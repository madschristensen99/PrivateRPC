"use strict";
(() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __typeError = (msg) => {
    throw TypeError(msg);
  };
  var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __esm = (fn, res) => function __init() {
    return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
  };
  var __commonJS = (cb, mod3) => function __require() {
    return mod3 || (0, cb[__getOwnPropNames(cb)[0]])((mod3 = { exports: {} }).exports, mod3), mod3.exports;
  };
  var __export = (target, all) => {
    for (var name in all)
      __defProp(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from5, except, desc) => {
    if (from5 && typeof from5 === "object" || typeof from5 === "function") {
      for (let key of __getOwnPropNames(from5))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from5[key], enumerable: !(desc = __getOwnPropDesc(from5, key)) || desc.enumerable });
    }
    return to;
  };
  var __toESM = (mod3, isNodeMode, target) => (target = mod3 != null ? __create(__getProtoOf(mod3)) : {}, __copyProps(
    // If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod3 || !mod3.__esModule ? __defProp(target, "default", { value: mod3, enumerable: true }) : target,
    mod3
  ));
  var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
  var __privateGet = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
  var __privateAdd = (obj, member, value) => member.has(obj) ? __typeError("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
  var __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
  var __privateMethod = (obj, member, method) => (__accessCheck(obj, member, "access private method"), method);
  var __privateWrapper = (obj, member, setter, getter) => ({
    set _(value) {
      __privateSet(obj, member, value, setter);
    },
    get _() {
      return __privateGet(obj, member, getter);
    }
  });

  // node_modules/scheduler/cjs/scheduler.production.js
  var require_scheduler_production = __commonJS({
    "node_modules/scheduler/cjs/scheduler.production.js"(exports) {
      "use strict";
      function push(heap, node) {
        var index2 = heap.length;
        heap.push(node);
        a: for (; 0 < index2; ) {
          var parentIndex = index2 - 1 >>> 1, parent = heap[parentIndex];
          if (0 < compare(parent, node))
            heap[parentIndex] = node, heap[index2] = parent, index2 = parentIndex;
          else break a;
        }
      }
      function peek(heap) {
        return 0 === heap.length ? null : heap[0];
      }
      function pop(heap) {
        if (0 === heap.length) return null;
        var first = heap[0], last = heap.pop();
        if (last !== first) {
          heap[0] = last;
          a: for (var index2 = 0, length = heap.length, halfLength = length >>> 1; index2 < halfLength; ) {
            var leftIndex = 2 * (index2 + 1) - 1, left = heap[leftIndex], rightIndex = leftIndex + 1, right = heap[rightIndex];
            if (0 > compare(left, last))
              rightIndex < length && 0 > compare(right, left) ? (heap[index2] = right, heap[rightIndex] = last, index2 = rightIndex) : (heap[index2] = left, heap[leftIndex] = last, index2 = leftIndex);
            else if (rightIndex < length && 0 > compare(right, last))
              heap[index2] = right, heap[rightIndex] = last, index2 = rightIndex;
            else break a;
          }
        }
        return first;
      }
      function compare(a, b2) {
        var diff = a.sortIndex - b2.sortIndex;
        return 0 !== diff ? diff : a.id - b2.id;
      }
      exports.unstable_now = void 0;
      if ("object" === typeof performance && "function" === typeof performance.now) {
        localPerformance = performance;
        exports.unstable_now = function() {
          return localPerformance.now();
        };
      } else {
        localDate = Date, initialTime = localDate.now();
        exports.unstable_now = function() {
          return localDate.now() - initialTime;
        };
      }
      var localPerformance;
      var localDate;
      var initialTime;
      var taskQueue = [];
      var timerQueue = [];
      var taskIdCounter = 1;
      var currentTask = null;
      var currentPriorityLevel = 3;
      var isPerformingWork = false;
      var isHostCallbackScheduled = false;
      var isHostTimeoutScheduled = false;
      var needsPaint = false;
      var localSetTimeout = "function" === typeof setTimeout ? setTimeout : null;
      var localClearTimeout = "function" === typeof clearTimeout ? clearTimeout : null;
      var localSetImmediate = "undefined" !== typeof setImmediate ? setImmediate : null;
      function advanceTimers(currentTime) {
        for (var timer = peek(timerQueue); null !== timer; ) {
          if (null === timer.callback) pop(timerQueue);
          else if (timer.startTime <= currentTime)
            pop(timerQueue), timer.sortIndex = timer.expirationTime, push(taskQueue, timer);
          else break;
          timer = peek(timerQueue);
        }
      }
      function handleTimeout(currentTime) {
        isHostTimeoutScheduled = false;
        advanceTimers(currentTime);
        if (!isHostCallbackScheduled)
          if (null !== peek(taskQueue))
            isHostCallbackScheduled = true, isMessageLoopRunning || (isMessageLoopRunning = true, schedulePerformWorkUntilDeadline());
          else {
            var firstTimer = peek(timerQueue);
            null !== firstTimer && requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);
          }
      }
      var isMessageLoopRunning = false;
      var taskTimeoutID = -1;
      var frameInterval = 5;
      var startTime = -1;
      function shouldYieldToHost() {
        return needsPaint ? true : exports.unstable_now() - startTime < frameInterval ? false : true;
      }
      function performWorkUntilDeadline() {
        needsPaint = false;
        if (isMessageLoopRunning) {
          var currentTime = exports.unstable_now();
          startTime = currentTime;
          var hasMoreWork = true;
          try {
            a: {
              isHostCallbackScheduled = false;
              isHostTimeoutScheduled && (isHostTimeoutScheduled = false, localClearTimeout(taskTimeoutID), taskTimeoutID = -1);
              isPerformingWork = true;
              var previousPriorityLevel = currentPriorityLevel;
              try {
                b: {
                  advanceTimers(currentTime);
                  for (currentTask = peek(taskQueue); null !== currentTask && !(currentTask.expirationTime > currentTime && shouldYieldToHost()); ) {
                    var callback = currentTask.callback;
                    if ("function" === typeof callback) {
                      currentTask.callback = null;
                      currentPriorityLevel = currentTask.priorityLevel;
                      var continuationCallback = callback(
                        currentTask.expirationTime <= currentTime
                      );
                      currentTime = exports.unstable_now();
                      if ("function" === typeof continuationCallback) {
                        currentTask.callback = continuationCallback;
                        advanceTimers(currentTime);
                        hasMoreWork = true;
                        break b;
                      }
                      currentTask === peek(taskQueue) && pop(taskQueue);
                      advanceTimers(currentTime);
                    } else pop(taskQueue);
                    currentTask = peek(taskQueue);
                  }
                  if (null !== currentTask) hasMoreWork = true;
                  else {
                    var firstTimer = peek(timerQueue);
                    null !== firstTimer && requestHostTimeout(
                      handleTimeout,
                      firstTimer.startTime - currentTime
                    );
                    hasMoreWork = false;
                  }
                }
                break a;
              } finally {
                currentTask = null, currentPriorityLevel = previousPriorityLevel, isPerformingWork = false;
              }
              hasMoreWork = void 0;
            }
          } finally {
            hasMoreWork ? schedulePerformWorkUntilDeadline() : isMessageLoopRunning = false;
          }
        }
      }
      var schedulePerformWorkUntilDeadline;
      if ("function" === typeof localSetImmediate)
        schedulePerformWorkUntilDeadline = function() {
          localSetImmediate(performWorkUntilDeadline);
        };
      else if ("undefined" !== typeof MessageChannel) {
        channel = new MessageChannel(), port = channel.port2;
        channel.port1.onmessage = performWorkUntilDeadline;
        schedulePerformWorkUntilDeadline = function() {
          port.postMessage(null);
        };
      } else
        schedulePerformWorkUntilDeadline = function() {
          localSetTimeout(performWorkUntilDeadline, 0);
        };
      var channel;
      var port;
      function requestHostTimeout(callback, ms) {
        taskTimeoutID = localSetTimeout(function() {
          callback(exports.unstable_now());
        }, ms);
      }
      exports.unstable_IdlePriority = 5;
      exports.unstable_ImmediatePriority = 1;
      exports.unstable_LowPriority = 4;
      exports.unstable_NormalPriority = 3;
      exports.unstable_Profiling = null;
      exports.unstable_UserBlockingPriority = 2;
      exports.unstable_cancelCallback = function(task) {
        task.callback = null;
      };
      exports.unstable_forceFrameRate = function(fps) {
        0 > fps || 125 < fps ? console.error(
          "forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"
        ) : frameInterval = 0 < fps ? Math.floor(1e3 / fps) : 5;
      };
      exports.unstable_getCurrentPriorityLevel = function() {
        return currentPriorityLevel;
      };
      exports.unstable_next = function(eventHandler) {
        switch (currentPriorityLevel) {
          case 1:
          case 2:
          case 3:
            var priorityLevel = 3;
            break;
          default:
            priorityLevel = currentPriorityLevel;
        }
        var previousPriorityLevel = currentPriorityLevel;
        currentPriorityLevel = priorityLevel;
        try {
          return eventHandler();
        } finally {
          currentPriorityLevel = previousPriorityLevel;
        }
      };
      exports.unstable_requestPaint = function() {
        needsPaint = true;
      };
      exports.unstable_runWithPriority = function(priorityLevel, eventHandler) {
        switch (priorityLevel) {
          case 1:
          case 2:
          case 3:
          case 4:
          case 5:
            break;
          default:
            priorityLevel = 3;
        }
        var previousPriorityLevel = currentPriorityLevel;
        currentPriorityLevel = priorityLevel;
        try {
          return eventHandler();
        } finally {
          currentPriorityLevel = previousPriorityLevel;
        }
      };
      exports.unstable_scheduleCallback = function(priorityLevel, callback, options) {
        var currentTime = exports.unstable_now();
        "object" === typeof options && null !== options ? (options = options.delay, options = "number" === typeof options && 0 < options ? currentTime + options : currentTime) : options = currentTime;
        switch (priorityLevel) {
          case 1:
            var timeout = -1;
            break;
          case 2:
            timeout = 250;
            break;
          case 5:
            timeout = 1073741823;
            break;
          case 4:
            timeout = 1e4;
            break;
          default:
            timeout = 5e3;
        }
        timeout = options + timeout;
        priorityLevel = {
          id: taskIdCounter++,
          callback,
          priorityLevel,
          startTime: options,
          expirationTime: timeout,
          sortIndex: -1
        };
        options > currentTime ? (priorityLevel.sortIndex = options, push(timerQueue, priorityLevel), null === peek(taskQueue) && priorityLevel === peek(timerQueue) && (isHostTimeoutScheduled ? (localClearTimeout(taskTimeoutID), taskTimeoutID = -1) : isHostTimeoutScheduled = true, requestHostTimeout(handleTimeout, options - currentTime))) : (priorityLevel.sortIndex = timeout, push(taskQueue, priorityLevel), isHostCallbackScheduled || isPerformingWork || (isHostCallbackScheduled = true, isMessageLoopRunning || (isMessageLoopRunning = true, schedulePerformWorkUntilDeadline())));
        return priorityLevel;
      };
      exports.unstable_shouldYield = shouldYieldToHost;
      exports.unstable_wrapCallback = function(callback) {
        var parentPriorityLevel = currentPriorityLevel;
        return function() {
          var previousPriorityLevel = currentPriorityLevel;
          currentPriorityLevel = parentPriorityLevel;
          try {
            return callback.apply(this, arguments);
          } finally {
            currentPriorityLevel = previousPriorityLevel;
          }
        };
      };
    }
  });

  // node_modules/scheduler/index.js
  var require_scheduler = __commonJS({
    "node_modules/scheduler/index.js"(exports, module) {
      "use strict";
      if (true) {
        module.exports = require_scheduler_production();
      } else {
        module.exports = null;
      }
    }
  });

  // node_modules/react/cjs/react.production.js
  var require_react_production = __commonJS({
    "node_modules/react/cjs/react.production.js"(exports) {
      "use strict";
      var REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element");
      var REACT_PORTAL_TYPE = Symbol.for("react.portal");
      var REACT_FRAGMENT_TYPE = Symbol.for("react.fragment");
      var REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode");
      var REACT_PROFILER_TYPE = Symbol.for("react.profiler");
      var REACT_CONSUMER_TYPE = Symbol.for("react.consumer");
      var REACT_CONTEXT_TYPE = Symbol.for("react.context");
      var REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref");
      var REACT_SUSPENSE_TYPE = Symbol.for("react.suspense");
      var REACT_MEMO_TYPE = Symbol.for("react.memo");
      var REACT_LAZY_TYPE = Symbol.for("react.lazy");
      var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
      function getIteratorFn(maybeIterable) {
        if (null === maybeIterable || "object" !== typeof maybeIterable) return null;
        maybeIterable = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable["@@iterator"];
        return "function" === typeof maybeIterable ? maybeIterable : null;
      }
      var ReactNoopUpdateQueue = {
        isMounted: function() {
          return false;
        },
        enqueueForceUpdate: function() {
        },
        enqueueReplaceState: function() {
        },
        enqueueSetState: function() {
        }
      };
      var assign = Object.assign;
      var emptyObject = {};
      function Component(props, context, updater) {
        this.props = props;
        this.context = context;
        this.refs = emptyObject;
        this.updater = updater || ReactNoopUpdateQueue;
      }
      Component.prototype.isReactComponent = {};
      Component.prototype.setState = function(partialState, callback) {
        if ("object" !== typeof partialState && "function" !== typeof partialState && null != partialState)
          throw Error(
            "takes an object of state variables to update or a function which returns an object of state variables."
          );
        this.updater.enqueueSetState(this, partialState, callback, "setState");
      };
      Component.prototype.forceUpdate = function(callback) {
        this.updater.enqueueForceUpdate(this, callback, "forceUpdate");
      };
      function ComponentDummy() {
      }
      ComponentDummy.prototype = Component.prototype;
      function PureComponent(props, context, updater) {
        this.props = props;
        this.context = context;
        this.refs = emptyObject;
        this.updater = updater || ReactNoopUpdateQueue;
      }
      var pureComponentPrototype = PureComponent.prototype = new ComponentDummy();
      pureComponentPrototype.constructor = PureComponent;
      assign(pureComponentPrototype, Component.prototype);
      pureComponentPrototype.isPureReactComponent = true;
      var isArrayImpl = Array.isArray;
      var ReactSharedInternals = { H: null, A: null, T: null, S: null, V: null };
      var hasOwnProperty = Object.prototype.hasOwnProperty;
      function ReactElement(type, key, self2, source, owner, props) {
        self2 = props.ref;
        return {
          $$typeof: REACT_ELEMENT_TYPE,
          type,
          key,
          ref: void 0 !== self2 ? self2 : null,
          props
        };
      }
      function cloneAndReplaceKey(oldElement, newKey) {
        return ReactElement(
          oldElement.type,
          newKey,
          void 0,
          void 0,
          void 0,
          oldElement.props
        );
      }
      function isValidElement(object2) {
        return "object" === typeof object2 && null !== object2 && object2.$$typeof === REACT_ELEMENT_TYPE;
      }
      function escape(key) {
        var escaperLookup = { "=": "=0", ":": "=2" };
        return "$" + key.replace(/[=:]/g, function(match) {
          return escaperLookup[match];
        });
      }
      var userProvidedKeyEscapeRegex = /\/+/g;
      function getElementKey(element, index2) {
        return "object" === typeof element && null !== element && null != element.key ? escape("" + element.key) : index2.toString(36);
      }
      function noop$1() {
      }
      function resolveThenable(thenable) {
        switch (thenable.status) {
          case "fulfilled":
            return thenable.value;
          case "rejected":
            throw thenable.reason;
          default:
            switch ("string" === typeof thenable.status ? thenable.then(noop$1, noop$1) : (thenable.status = "pending", thenable.then(
              function(fulfilledValue) {
                "pending" === thenable.status && (thenable.status = "fulfilled", thenable.value = fulfilledValue);
              },
              function(error) {
                "pending" === thenable.status && (thenable.status = "rejected", thenable.reason = error);
              }
            )), thenable.status) {
              case "fulfilled":
                return thenable.value;
              case "rejected":
                throw thenable.reason;
            }
        }
        throw thenable;
      }
      function mapIntoArray(children, array, escapedPrefix, nameSoFar, callback) {
        var type = typeof children;
        if ("undefined" === type || "boolean" === type) children = null;
        var invokeCallback = false;
        if (null === children) invokeCallback = true;
        else
          switch (type) {
            case "bigint":
            case "string":
            case "number":
              invokeCallback = true;
              break;
            case "object":
              switch (children.$$typeof) {
                case REACT_ELEMENT_TYPE:
                case REACT_PORTAL_TYPE:
                  invokeCallback = true;
                  break;
                case REACT_LAZY_TYPE:
                  return invokeCallback = children._init, mapIntoArray(
                    invokeCallback(children._payload),
                    array,
                    escapedPrefix,
                    nameSoFar,
                    callback
                  );
              }
          }
        if (invokeCallback)
          return callback = callback(children), invokeCallback = "" === nameSoFar ? "." + getElementKey(children, 0) : nameSoFar, isArrayImpl(callback) ? (escapedPrefix = "", null != invokeCallback && (escapedPrefix = invokeCallback.replace(userProvidedKeyEscapeRegex, "$&/") + "/"), mapIntoArray(callback, array, escapedPrefix, "", function(c) {
            return c;
          })) : null != callback && (isValidElement(callback) && (callback = cloneAndReplaceKey(
            callback,
            escapedPrefix + (null == callback.key || children && children.key === callback.key ? "" : ("" + callback.key).replace(
              userProvidedKeyEscapeRegex,
              "$&/"
            ) + "/") + invokeCallback
          )), array.push(callback)), 1;
        invokeCallback = 0;
        var nextNamePrefix = "" === nameSoFar ? "." : nameSoFar + ":";
        if (isArrayImpl(children))
          for (var i = 0; i < children.length; i++)
            nameSoFar = children[i], type = nextNamePrefix + getElementKey(nameSoFar, i), invokeCallback += mapIntoArray(
              nameSoFar,
              array,
              escapedPrefix,
              type,
              callback
            );
        else if (i = getIteratorFn(children), "function" === typeof i)
          for (children = i.call(children), i = 0; !(nameSoFar = children.next()).done; )
            nameSoFar = nameSoFar.value, type = nextNamePrefix + getElementKey(nameSoFar, i++), invokeCallback += mapIntoArray(
              nameSoFar,
              array,
              escapedPrefix,
              type,
              callback
            );
        else if ("object" === type) {
          if ("function" === typeof children.then)
            return mapIntoArray(
              resolveThenable(children),
              array,
              escapedPrefix,
              nameSoFar,
              callback
            );
          array = String(children);
          throw Error(
            "Objects are not valid as a React child (found: " + ("[object Object]" === array ? "object with keys {" + Object.keys(children).join(", ") + "}" : array) + "). If you meant to render a collection of children, use an array instead."
          );
        }
        return invokeCallback;
      }
      function mapChildren(children, func, context) {
        if (null == children) return children;
        var result = [], count = 0;
        mapIntoArray(children, result, "", "", function(child) {
          return func.call(context, child, count++);
        });
        return result;
      }
      function lazyInitializer(payload) {
        if (-1 === payload._status) {
          var ctor = payload._result;
          ctor = ctor();
          ctor.then(
            function(moduleObject) {
              if (0 === payload._status || -1 === payload._status)
                payload._status = 1, payload._result = moduleObject;
            },
            function(error) {
              if (0 === payload._status || -1 === payload._status)
                payload._status = 2, payload._result = error;
            }
          );
          -1 === payload._status && (payload._status = 0, payload._result = ctor);
        }
        if (1 === payload._status) return payload._result.default;
        throw payload._result;
      }
      var reportGlobalError = "function" === typeof reportError ? reportError : function(error) {
        if ("object" === typeof window && "function" === typeof window.ErrorEvent) {
          var event = new window.ErrorEvent("error", {
            bubbles: true,
            cancelable: true,
            message: "object" === typeof error && null !== error && "string" === typeof error.message ? String(error.message) : String(error),
            error
          });
          if (!window.dispatchEvent(event)) return;
        } else if ("object" === typeof process && "function" === typeof process.emit) {
          process.emit("uncaughtException", error);
          return;
        }
        console.error(error);
      };
      function noop() {
      }
      exports.Children = {
        map: mapChildren,
        forEach: function(children, forEachFunc, forEachContext) {
          mapChildren(
            children,
            function() {
              forEachFunc.apply(this, arguments);
            },
            forEachContext
          );
        },
        count: function(children) {
          var n2 = 0;
          mapChildren(children, function() {
            n2++;
          });
          return n2;
        },
        toArray: function(children) {
          return mapChildren(children, function(child) {
            return child;
          }) || [];
        },
        only: function(children) {
          if (!isValidElement(children))
            throw Error(
              "React.Children.only expected to receive a single React element child."
            );
          return children;
        }
      };
      exports.Component = Component;
      exports.Fragment = REACT_FRAGMENT_TYPE;
      exports.Profiler = REACT_PROFILER_TYPE;
      exports.PureComponent = PureComponent;
      exports.StrictMode = REACT_STRICT_MODE_TYPE;
      exports.Suspense = REACT_SUSPENSE_TYPE;
      exports.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = ReactSharedInternals;
      exports.__COMPILER_RUNTIME = {
        __proto__: null,
        c: function(size5) {
          return ReactSharedInternals.H.useMemoCache(size5);
        }
      };
      exports.cache = function(fn) {
        return function() {
          return fn.apply(null, arguments);
        };
      };
      exports.cloneElement = function(element, config, children) {
        if (null === element || void 0 === element)
          throw Error(
            "The argument must be a React element, but you passed " + element + "."
          );
        var props = assign({}, element.props), key = element.key, owner = void 0;
        if (null != config)
          for (propName in void 0 !== config.ref && (owner = void 0), void 0 !== config.key && (key = "" + config.key), config)
            !hasOwnProperty.call(config, propName) || "key" === propName || "__self" === propName || "__source" === propName || "ref" === propName && void 0 === config.ref || (props[propName] = config[propName]);
        var propName = arguments.length - 2;
        if (1 === propName) props.children = children;
        else if (1 < propName) {
          for (var childArray = Array(propName), i = 0; i < propName; i++)
            childArray[i] = arguments[i + 2];
          props.children = childArray;
        }
        return ReactElement(element.type, key, void 0, void 0, owner, props);
      };
      exports.createContext = function(defaultValue) {
        defaultValue = {
          $$typeof: REACT_CONTEXT_TYPE,
          _currentValue: defaultValue,
          _currentValue2: defaultValue,
          _threadCount: 0,
          Provider: null,
          Consumer: null
        };
        defaultValue.Provider = defaultValue;
        defaultValue.Consumer = {
          $$typeof: REACT_CONSUMER_TYPE,
          _context: defaultValue
        };
        return defaultValue;
      };
      exports.createElement = function(type, config, children) {
        var propName, props = {}, key = null;
        if (null != config)
          for (propName in void 0 !== config.key && (key = "" + config.key), config)
            hasOwnProperty.call(config, propName) && "key" !== propName && "__self" !== propName && "__source" !== propName && (props[propName] = config[propName]);
        var childrenLength = arguments.length - 2;
        if (1 === childrenLength) props.children = children;
        else if (1 < childrenLength) {
          for (var childArray = Array(childrenLength), i = 0; i < childrenLength; i++)
            childArray[i] = arguments[i + 2];
          props.children = childArray;
        }
        if (type && type.defaultProps)
          for (propName in childrenLength = type.defaultProps, childrenLength)
            void 0 === props[propName] && (props[propName] = childrenLength[propName]);
        return ReactElement(type, key, void 0, void 0, null, props);
      };
      exports.createRef = function() {
        return { current: null };
      };
      exports.forwardRef = function(render) {
        return { $$typeof: REACT_FORWARD_REF_TYPE, render };
      };
      exports.isValidElement = isValidElement;
      exports.lazy = function(ctor) {
        return {
          $$typeof: REACT_LAZY_TYPE,
          _payload: { _status: -1, _result: ctor },
          _init: lazyInitializer
        };
      };
      exports.memo = function(type, compare) {
        return {
          $$typeof: REACT_MEMO_TYPE,
          type,
          compare: void 0 === compare ? null : compare
        };
      };
      exports.startTransition = function(scope) {
        var prevTransition = ReactSharedInternals.T, currentTransition = {};
        ReactSharedInternals.T = currentTransition;
        try {
          var returnValue = scope(), onStartTransitionFinish = ReactSharedInternals.S;
          null !== onStartTransitionFinish && onStartTransitionFinish(currentTransition, returnValue);
          "object" === typeof returnValue && null !== returnValue && "function" === typeof returnValue.then && returnValue.then(noop, reportGlobalError);
        } catch (error) {
          reportGlobalError(error);
        } finally {
          ReactSharedInternals.T = prevTransition;
        }
      };
      exports.unstable_useCacheRefresh = function() {
        return ReactSharedInternals.H.useCacheRefresh();
      };
      exports.use = function(usable) {
        return ReactSharedInternals.H.use(usable);
      };
      exports.useActionState = function(action, initialState, permalink) {
        return ReactSharedInternals.H.useActionState(action, initialState, permalink);
      };
      exports.useCallback = function(callback, deps) {
        return ReactSharedInternals.H.useCallback(callback, deps);
      };
      exports.useContext = function(Context) {
        return ReactSharedInternals.H.useContext(Context);
      };
      exports.useDebugValue = function() {
      };
      exports.useDeferredValue = function(value, initialValue) {
        return ReactSharedInternals.H.useDeferredValue(value, initialValue);
      };
      exports.useEffect = function(create, createDeps, update) {
        var dispatcher = ReactSharedInternals.H;
        if ("function" === typeof update)
          throw Error(
            "useEffect CRUD overload is not enabled in this build of React."
          );
        return dispatcher.useEffect(create, createDeps);
      };
      exports.useId = function() {
        return ReactSharedInternals.H.useId();
      };
      exports.useImperativeHandle = function(ref, create, deps) {
        return ReactSharedInternals.H.useImperativeHandle(ref, create, deps);
      };
      exports.useInsertionEffect = function(create, deps) {
        return ReactSharedInternals.H.useInsertionEffect(create, deps);
      };
      exports.useLayoutEffect = function(create, deps) {
        return ReactSharedInternals.H.useLayoutEffect(create, deps);
      };
      exports.useMemo = function(create, deps) {
        return ReactSharedInternals.H.useMemo(create, deps);
      };
      exports.useOptimistic = function(passthrough, reducer) {
        return ReactSharedInternals.H.useOptimistic(passthrough, reducer);
      };
      exports.useReducer = function(reducer, initialArg, init2) {
        return ReactSharedInternals.H.useReducer(reducer, initialArg, init2);
      };
      exports.useRef = function(initialValue) {
        return ReactSharedInternals.H.useRef(initialValue);
      };
      exports.useState = function(initialState) {
        return ReactSharedInternals.H.useState(initialState);
      };
      exports.useSyncExternalStore = function(subscribe, getSnapshot, getServerSnapshot) {
        return ReactSharedInternals.H.useSyncExternalStore(
          subscribe,
          getSnapshot,
          getServerSnapshot
        );
      };
      exports.useTransition = function() {
        return ReactSharedInternals.H.useTransition();
      };
      exports.version = "19.1.0";
    }
  });

  // node_modules/react/index.js
  var require_react = __commonJS({
    "node_modules/react/index.js"(exports, module) {
      "use strict";
      if (true) {
        module.exports = require_react_production();
      } else {
        module.exports = null;
      }
    }
  });

  // node_modules/react-dom/cjs/react-dom.production.js
  var require_react_dom_production = __commonJS({
    "node_modules/react-dom/cjs/react-dom.production.js"(exports) {
      "use strict";
      var React = require_react();
      function formatProdErrorMessage(code) {
        var url = "https://react.dev/errors/" + code;
        if (1 < arguments.length) {
          url += "?args[]=" + encodeURIComponent(arguments[1]);
          for (var i = 2; i < arguments.length; i++)
            url += "&args[]=" + encodeURIComponent(arguments[i]);
        }
        return "Minified React error #" + code + "; visit " + url + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
      }
      function noop() {
      }
      var Internals = {
        d: {
          f: noop,
          r: function() {
            throw Error(formatProdErrorMessage(522));
          },
          D: noop,
          C: noop,
          L: noop,
          m: noop,
          X: noop,
          S: noop,
          M: noop
        },
        p: 0,
        findDOMNode: null
      };
      var REACT_PORTAL_TYPE = Symbol.for("react.portal");
      function createPortal$1(children, containerInfo, implementation) {
        var key = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null;
        return {
          $$typeof: REACT_PORTAL_TYPE,
          key: null == key ? null : "" + key,
          children,
          containerInfo,
          implementation
        };
      }
      var ReactSharedInternals = React.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;
      function getCrossOriginStringAs(as, input) {
        if ("font" === as) return "";
        if ("string" === typeof input)
          return "use-credentials" === input ? input : "";
      }
      exports.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = Internals;
      exports.createPortal = function(children, container) {
        var key = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null;
        if (!container || 1 !== container.nodeType && 9 !== container.nodeType && 11 !== container.nodeType)
          throw Error(formatProdErrorMessage(299));
        return createPortal$1(children, container, null, key);
      };
      exports.flushSync = function(fn) {
        var previousTransition = ReactSharedInternals.T, previousUpdatePriority = Internals.p;
        try {
          if (ReactSharedInternals.T = null, Internals.p = 2, fn) return fn();
        } finally {
          ReactSharedInternals.T = previousTransition, Internals.p = previousUpdatePriority, Internals.d.f();
        }
      };
      exports.preconnect = function(href, options) {
        "string" === typeof href && (options ? (options = options.crossOrigin, options = "string" === typeof options ? "use-credentials" === options ? options : "" : void 0) : options = null, Internals.d.C(href, options));
      };
      exports.prefetchDNS = function(href) {
        "string" === typeof href && Internals.d.D(href);
      };
      exports.preinit = function(href, options) {
        if ("string" === typeof href && options && "string" === typeof options.as) {
          var as = options.as, crossOrigin = getCrossOriginStringAs(as, options.crossOrigin), integrity = "string" === typeof options.integrity ? options.integrity : void 0, fetchPriority = "string" === typeof options.fetchPriority ? options.fetchPriority : void 0;
          "style" === as ? Internals.d.S(
            href,
            "string" === typeof options.precedence ? options.precedence : void 0,
            {
              crossOrigin,
              integrity,
              fetchPriority
            }
          ) : "script" === as && Internals.d.X(href, {
            crossOrigin,
            integrity,
            fetchPriority,
            nonce: "string" === typeof options.nonce ? options.nonce : void 0
          });
        }
      };
      exports.preinitModule = function(href, options) {
        if ("string" === typeof href)
          if ("object" === typeof options && null !== options) {
            if (null == options.as || "script" === options.as) {
              var crossOrigin = getCrossOriginStringAs(
                options.as,
                options.crossOrigin
              );
              Internals.d.M(href, {
                crossOrigin,
                integrity: "string" === typeof options.integrity ? options.integrity : void 0,
                nonce: "string" === typeof options.nonce ? options.nonce : void 0
              });
            }
          } else null == options && Internals.d.M(href);
      };
      exports.preload = function(href, options) {
        if ("string" === typeof href && "object" === typeof options && null !== options && "string" === typeof options.as) {
          var as = options.as, crossOrigin = getCrossOriginStringAs(as, options.crossOrigin);
          Internals.d.L(href, as, {
            crossOrigin,
            integrity: "string" === typeof options.integrity ? options.integrity : void 0,
            nonce: "string" === typeof options.nonce ? options.nonce : void 0,
            type: "string" === typeof options.type ? options.type : void 0,
            fetchPriority: "string" === typeof options.fetchPriority ? options.fetchPriority : void 0,
            referrerPolicy: "string" === typeof options.referrerPolicy ? options.referrerPolicy : void 0,
            imageSrcSet: "string" === typeof options.imageSrcSet ? options.imageSrcSet : void 0,
            imageSizes: "string" === typeof options.imageSizes ? options.imageSizes : void 0,
            media: "string" === typeof options.media ? options.media : void 0
          });
        }
      };
      exports.preloadModule = function(href, options) {
        if ("string" === typeof href)
          if (options) {
            var crossOrigin = getCrossOriginStringAs(options.as, options.crossOrigin);
            Internals.d.m(href, {
              as: "string" === typeof options.as && "script" !== options.as ? options.as : void 0,
              crossOrigin,
              integrity: "string" === typeof options.integrity ? options.integrity : void 0
            });
          } else Internals.d.m(href);
      };
      exports.requestFormReset = function(form) {
        Internals.d.r(form);
      };
      exports.unstable_batchedUpdates = function(fn, a) {
        return fn(a);
      };
      exports.useFormState = function(action, initialState, permalink) {
        return ReactSharedInternals.H.useFormState(action, initialState, permalink);
      };
      exports.useFormStatus = function() {
        return ReactSharedInternals.H.useHostTransitionStatus();
      };
      exports.version = "19.1.0";
    }
  });

  // node_modules/react-dom/index.js
  var require_react_dom = __commonJS({
    "node_modules/react-dom/index.js"(exports, module) {
      "use strict";
      function checkDCE() {
        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === "undefined" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== "function") {
          return;
        }
        if (false) {
          throw new Error("^_^");
        }
        try {
          __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
        } catch (err) {
          console.error(err);
        }
      }
      if (true) {
        checkDCE();
        module.exports = require_react_dom_production();
      } else {
        module.exports = null;
      }
    }
  });

  // node_modules/react-dom/cjs/react-dom-client.production.js
  var require_react_dom_client_production = __commonJS({
    "node_modules/react-dom/cjs/react-dom-client.production.js"(exports) {
      "use strict";
      var Scheduler = require_scheduler();
      var React = require_react();
      var ReactDOM = require_react_dom();
      function formatProdErrorMessage(code) {
        var url = "https://react.dev/errors/" + code;
        if (1 < arguments.length) {
          url += "?args[]=" + encodeURIComponent(arguments[1]);
          for (var i = 2; i < arguments.length; i++)
            url += "&args[]=" + encodeURIComponent(arguments[i]);
        }
        return "Minified React error #" + code + "; visit " + url + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
      }
      function isValidContainer(node) {
        return !(!node || 1 !== node.nodeType && 9 !== node.nodeType && 11 !== node.nodeType);
      }
      function getNearestMountedFiber(fiber) {
        var node = fiber, nearestMounted = fiber;
        if (fiber.alternate) for (; node.return; ) node = node.return;
        else {
          fiber = node;
          do
            node = fiber, 0 !== (node.flags & 4098) && (nearestMounted = node.return), fiber = node.return;
          while (fiber);
        }
        return 3 === node.tag ? nearestMounted : null;
      }
      function getSuspenseInstanceFromFiber(fiber) {
        if (13 === fiber.tag) {
          var suspenseState = fiber.memoizedState;
          null === suspenseState && (fiber = fiber.alternate, null !== fiber && (suspenseState = fiber.memoizedState));
          if (null !== suspenseState) return suspenseState.dehydrated;
        }
        return null;
      }
      function assertIsMounted(fiber) {
        if (getNearestMountedFiber(fiber) !== fiber)
          throw Error(formatProdErrorMessage(188));
      }
      function findCurrentFiberUsingSlowPath(fiber) {
        var alternate = fiber.alternate;
        if (!alternate) {
          alternate = getNearestMountedFiber(fiber);
          if (null === alternate) throw Error(formatProdErrorMessage(188));
          return alternate !== fiber ? null : fiber;
        }
        for (var a = fiber, b2 = alternate; ; ) {
          var parentA = a.return;
          if (null === parentA) break;
          var parentB = parentA.alternate;
          if (null === parentB) {
            b2 = parentA.return;
            if (null !== b2) {
              a = b2;
              continue;
            }
            break;
          }
          if (parentA.child === parentB.child) {
            for (parentB = parentA.child; parentB; ) {
              if (parentB === a) return assertIsMounted(parentA), fiber;
              if (parentB === b2) return assertIsMounted(parentA), alternate;
              parentB = parentB.sibling;
            }
            throw Error(formatProdErrorMessage(188));
          }
          if (a.return !== b2.return) a = parentA, b2 = parentB;
          else {
            for (var didFindChild = false, child$0 = parentA.child; child$0; ) {
              if (child$0 === a) {
                didFindChild = true;
                a = parentA;
                b2 = parentB;
                break;
              }
              if (child$0 === b2) {
                didFindChild = true;
                b2 = parentA;
                a = parentB;
                break;
              }
              child$0 = child$0.sibling;
            }
            if (!didFindChild) {
              for (child$0 = parentB.child; child$0; ) {
                if (child$0 === a) {
                  didFindChild = true;
                  a = parentB;
                  b2 = parentA;
                  break;
                }
                if (child$0 === b2) {
                  didFindChild = true;
                  b2 = parentB;
                  a = parentA;
                  break;
                }
                child$0 = child$0.sibling;
              }
              if (!didFindChild) throw Error(formatProdErrorMessage(189));
            }
          }
          if (a.alternate !== b2) throw Error(formatProdErrorMessage(190));
        }
        if (3 !== a.tag) throw Error(formatProdErrorMessage(188));
        return a.stateNode.current === a ? fiber : alternate;
      }
      function findCurrentHostFiberImpl(node) {
        var tag = node.tag;
        if (5 === tag || 26 === tag || 27 === tag || 6 === tag) return node;
        for (node = node.child; null !== node; ) {
          tag = findCurrentHostFiberImpl(node);
          if (null !== tag) return tag;
          node = node.sibling;
        }
        return null;
      }
      var assign = Object.assign;
      var REACT_LEGACY_ELEMENT_TYPE = Symbol.for("react.element");
      var REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element");
      var REACT_PORTAL_TYPE = Symbol.for("react.portal");
      var REACT_FRAGMENT_TYPE = Symbol.for("react.fragment");
      var REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode");
      var REACT_PROFILER_TYPE = Symbol.for("react.profiler");
      var REACT_PROVIDER_TYPE = Symbol.for("react.provider");
      var REACT_CONSUMER_TYPE = Symbol.for("react.consumer");
      var REACT_CONTEXT_TYPE = Symbol.for("react.context");
      var REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref");
      var REACT_SUSPENSE_TYPE = Symbol.for("react.suspense");
      var REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list");
      var REACT_MEMO_TYPE = Symbol.for("react.memo");
      var REACT_LAZY_TYPE = Symbol.for("react.lazy");
      Symbol.for("react.scope");
      var REACT_ACTIVITY_TYPE = Symbol.for("react.activity");
      Symbol.for("react.legacy_hidden");
      Symbol.for("react.tracing_marker");
      var REACT_MEMO_CACHE_SENTINEL = Symbol.for("react.memo_cache_sentinel");
      Symbol.for("react.view_transition");
      var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
      function getIteratorFn(maybeIterable) {
        if (null === maybeIterable || "object" !== typeof maybeIterable) return null;
        maybeIterable = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable["@@iterator"];
        return "function" === typeof maybeIterable ? maybeIterable : null;
      }
      var REACT_CLIENT_REFERENCE = Symbol.for("react.client.reference");
      function getComponentNameFromType(type) {
        if (null == type) return null;
        if ("function" === typeof type)
          return type.$$typeof === REACT_CLIENT_REFERENCE ? null : type.displayName || type.name || null;
        if ("string" === typeof type) return type;
        switch (type) {
          case REACT_FRAGMENT_TYPE:
            return "Fragment";
          case REACT_PROFILER_TYPE:
            return "Profiler";
          case REACT_STRICT_MODE_TYPE:
            return "StrictMode";
          case REACT_SUSPENSE_TYPE:
            return "Suspense";
          case REACT_SUSPENSE_LIST_TYPE:
            return "SuspenseList";
          case REACT_ACTIVITY_TYPE:
            return "Activity";
        }
        if ("object" === typeof type)
          switch (type.$$typeof) {
            case REACT_PORTAL_TYPE:
              return "Portal";
            case REACT_CONTEXT_TYPE:
              return (type.displayName || "Context") + ".Provider";
            case REACT_CONSUMER_TYPE:
              return (type._context.displayName || "Context") + ".Consumer";
            case REACT_FORWARD_REF_TYPE:
              var innerType = type.render;
              type = type.displayName;
              type || (type = innerType.displayName || innerType.name || "", type = "" !== type ? "ForwardRef(" + type + ")" : "ForwardRef");
              return type;
            case REACT_MEMO_TYPE:
              return innerType = type.displayName || null, null !== innerType ? innerType : getComponentNameFromType(type.type) || "Memo";
            case REACT_LAZY_TYPE:
              innerType = type._payload;
              type = type._init;
              try {
                return getComponentNameFromType(type(innerType));
              } catch (x) {
              }
          }
        return null;
      }
      var isArrayImpl = Array.isArray;
      var ReactSharedInternals = React.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;
      var ReactDOMSharedInternals = ReactDOM.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;
      var sharedNotPendingObject = {
        pending: false,
        data: null,
        method: null,
        action: null
      };
      var valueStack = [];
      var index2 = -1;
      function createCursor2(defaultValue) {
        return { current: defaultValue };
      }
      function pop(cursor) {
        0 > index2 || (cursor.current = valueStack[index2], valueStack[index2] = null, index2--);
      }
      function push(cursor, value) {
        index2++;
        valueStack[index2] = cursor.current;
        cursor.current = value;
      }
      var contextStackCursor = createCursor2(null);
      var contextFiberStackCursor = createCursor2(null);
      var rootInstanceStackCursor = createCursor2(null);
      var hostTransitionProviderCursor = createCursor2(null);
      function pushHostContainer(fiber, nextRootInstance) {
        push(rootInstanceStackCursor, nextRootInstance);
        push(contextFiberStackCursor, fiber);
        push(contextStackCursor, null);
        switch (nextRootInstance.nodeType) {
          case 9:
          case 11:
            fiber = (fiber = nextRootInstance.documentElement) ? (fiber = fiber.namespaceURI) ? getOwnHostContext(fiber) : 0 : 0;
            break;
          default:
            if (fiber = nextRootInstance.tagName, nextRootInstance = nextRootInstance.namespaceURI)
              nextRootInstance = getOwnHostContext(nextRootInstance), fiber = getChildHostContextProd(nextRootInstance, fiber);
            else
              switch (fiber) {
                case "svg":
                  fiber = 1;
                  break;
                case "math":
                  fiber = 2;
                  break;
                default:
                  fiber = 0;
              }
        }
        pop(contextStackCursor);
        push(contextStackCursor, fiber);
      }
      function popHostContainer() {
        pop(contextStackCursor);
        pop(contextFiberStackCursor);
        pop(rootInstanceStackCursor);
      }
      function pushHostContext(fiber) {
        null !== fiber.memoizedState && push(hostTransitionProviderCursor, fiber);
        var context = contextStackCursor.current;
        var JSCompiler_inline_result = getChildHostContextProd(context, fiber.type);
        context !== JSCompiler_inline_result && (push(contextFiberStackCursor, fiber), push(contextStackCursor, JSCompiler_inline_result));
      }
      function popHostContext(fiber) {
        contextFiberStackCursor.current === fiber && (pop(contextStackCursor), pop(contextFiberStackCursor));
        hostTransitionProviderCursor.current === fiber && (pop(hostTransitionProviderCursor), HostTransitionContext._currentValue = sharedNotPendingObject);
      }
      var hasOwnProperty = Object.prototype.hasOwnProperty;
      var scheduleCallback$3 = Scheduler.unstable_scheduleCallback;
      var cancelCallback$1 = Scheduler.unstable_cancelCallback;
      var shouldYield = Scheduler.unstable_shouldYield;
      var requestPaint = Scheduler.unstable_requestPaint;
      var now = Scheduler.unstable_now;
      var getCurrentPriorityLevel = Scheduler.unstable_getCurrentPriorityLevel;
      var ImmediatePriority = Scheduler.unstable_ImmediatePriority;
      var UserBlockingPriority = Scheduler.unstable_UserBlockingPriority;
      var NormalPriority$1 = Scheduler.unstable_NormalPriority;
      var LowPriority = Scheduler.unstable_LowPriority;
      var IdlePriority = Scheduler.unstable_IdlePriority;
      var log$1 = Scheduler.log;
      var unstable_setDisableYieldValue = Scheduler.unstable_setDisableYieldValue;
      var rendererID = null;
      var injectedHook = null;
      function setIsStrictModeForDevtools(newIsStrictMode) {
        "function" === typeof log$1 && unstable_setDisableYieldValue(newIsStrictMode);
        if (injectedHook && "function" === typeof injectedHook.setStrictMode)
          try {
            injectedHook.setStrictMode(rendererID, newIsStrictMode);
          } catch (err) {
          }
      }
      var clz32 = Math.clz32 ? Math.clz32 : clz32Fallback;
      var log = Math.log;
      var LN2 = Math.LN2;
      function clz32Fallback(x) {
        x >>>= 0;
        return 0 === x ? 32 : 31 - (log(x) / LN2 | 0) | 0;
      }
      var nextTransitionLane = 256;
      var nextRetryLane = 4194304;
      function getHighestPriorityLanes(lanes) {
        var pendingSyncLanes = lanes & 42;
        if (0 !== pendingSyncLanes) return pendingSyncLanes;
        switch (lanes & -lanes) {
          case 1:
            return 1;
          case 2:
            return 2;
          case 4:
            return 4;
          case 8:
            return 8;
          case 16:
            return 16;
          case 32:
            return 32;
          case 64:
            return 64;
          case 128:
            return 128;
          case 256:
          case 512:
          case 1024:
          case 2048:
          case 4096:
          case 8192:
          case 16384:
          case 32768:
          case 65536:
          case 131072:
          case 262144:
          case 524288:
          case 1048576:
          case 2097152:
            return lanes & 4194048;
          case 4194304:
          case 8388608:
          case 16777216:
          case 33554432:
            return lanes & 62914560;
          case 67108864:
            return 67108864;
          case 134217728:
            return 134217728;
          case 268435456:
            return 268435456;
          case 536870912:
            return 536870912;
          case 1073741824:
            return 0;
          default:
            return lanes;
        }
      }
      function getNextLanes(root2, wipLanes, rootHasPendingCommit) {
        var pendingLanes = root2.pendingLanes;
        if (0 === pendingLanes) return 0;
        var nextLanes = 0, suspendedLanes = root2.suspendedLanes, pingedLanes = root2.pingedLanes;
        root2 = root2.warmLanes;
        var nonIdlePendingLanes = pendingLanes & 134217727;
        0 !== nonIdlePendingLanes ? (pendingLanes = nonIdlePendingLanes & ~suspendedLanes, 0 !== pendingLanes ? nextLanes = getHighestPriorityLanes(pendingLanes) : (pingedLanes &= nonIdlePendingLanes, 0 !== pingedLanes ? nextLanes = getHighestPriorityLanes(pingedLanes) : rootHasPendingCommit || (rootHasPendingCommit = nonIdlePendingLanes & ~root2, 0 !== rootHasPendingCommit && (nextLanes = getHighestPriorityLanes(rootHasPendingCommit))))) : (nonIdlePendingLanes = pendingLanes & ~suspendedLanes, 0 !== nonIdlePendingLanes ? nextLanes = getHighestPriorityLanes(nonIdlePendingLanes) : 0 !== pingedLanes ? nextLanes = getHighestPriorityLanes(pingedLanes) : rootHasPendingCommit || (rootHasPendingCommit = pendingLanes & ~root2, 0 !== rootHasPendingCommit && (nextLanes = getHighestPriorityLanes(rootHasPendingCommit))));
        return 0 === nextLanes ? 0 : 0 !== wipLanes && wipLanes !== nextLanes && 0 === (wipLanes & suspendedLanes) && (suspendedLanes = nextLanes & -nextLanes, rootHasPendingCommit = wipLanes & -wipLanes, suspendedLanes >= rootHasPendingCommit || 32 === suspendedLanes && 0 !== (rootHasPendingCommit & 4194048)) ? wipLanes : nextLanes;
      }
      function checkIfRootIsPrerendering(root2, renderLanes2) {
        return 0 === (root2.pendingLanes & ~(root2.suspendedLanes & ~root2.pingedLanes) & renderLanes2);
      }
      function computeExpirationTime(lane, currentTime) {
        switch (lane) {
          case 1:
          case 2:
          case 4:
          case 8:
          case 64:
            return currentTime + 250;
          case 16:
          case 32:
          case 128:
          case 256:
          case 512:
          case 1024:
          case 2048:
          case 4096:
          case 8192:
          case 16384:
          case 32768:
          case 65536:
          case 131072:
          case 262144:
          case 524288:
          case 1048576:
          case 2097152:
            return currentTime + 5e3;
          case 4194304:
          case 8388608:
          case 16777216:
          case 33554432:
            return -1;
          case 67108864:
          case 134217728:
          case 268435456:
          case 536870912:
          case 1073741824:
            return -1;
          default:
            return -1;
        }
      }
      function claimNextTransitionLane() {
        var lane = nextTransitionLane;
        nextTransitionLane <<= 1;
        0 === (nextTransitionLane & 4194048) && (nextTransitionLane = 256);
        return lane;
      }
      function claimNextRetryLane() {
        var lane = nextRetryLane;
        nextRetryLane <<= 1;
        0 === (nextRetryLane & 62914560) && (nextRetryLane = 4194304);
        return lane;
      }
      function createLaneMap(initial) {
        for (var laneMap = [], i = 0; 31 > i; i++) laneMap.push(initial);
        return laneMap;
      }
      function markRootUpdated$1(root2, updateLane) {
        root2.pendingLanes |= updateLane;
        268435456 !== updateLane && (root2.suspendedLanes = 0, root2.pingedLanes = 0, root2.warmLanes = 0);
      }
      function markRootFinished(root2, finishedLanes, remainingLanes, spawnedLane, updatedLanes, suspendedRetryLanes) {
        var previouslyPendingLanes = root2.pendingLanes;
        root2.pendingLanes = remainingLanes;
        root2.suspendedLanes = 0;
        root2.pingedLanes = 0;
        root2.warmLanes = 0;
        root2.expiredLanes &= remainingLanes;
        root2.entangledLanes &= remainingLanes;
        root2.errorRecoveryDisabledLanes &= remainingLanes;
        root2.shellSuspendCounter = 0;
        var entanglements = root2.entanglements, expirationTimes = root2.expirationTimes, hiddenUpdates = root2.hiddenUpdates;
        for (remainingLanes = previouslyPendingLanes & ~remainingLanes; 0 < remainingLanes; ) {
          var index$5 = 31 - clz32(remainingLanes), lane = 1 << index$5;
          entanglements[index$5] = 0;
          expirationTimes[index$5] = -1;
          var hiddenUpdatesForLane = hiddenUpdates[index$5];
          if (null !== hiddenUpdatesForLane)
            for (hiddenUpdates[index$5] = null, index$5 = 0; index$5 < hiddenUpdatesForLane.length; index$5++) {
              var update = hiddenUpdatesForLane[index$5];
              null !== update && (update.lane &= -536870913);
            }
          remainingLanes &= ~lane;
        }
        0 !== spawnedLane && markSpawnedDeferredLane(root2, spawnedLane, 0);
        0 !== suspendedRetryLanes && 0 === updatedLanes && 0 !== root2.tag && (root2.suspendedLanes |= suspendedRetryLanes & ~(previouslyPendingLanes & ~finishedLanes));
      }
      function markSpawnedDeferredLane(root2, spawnedLane, entangledLanes) {
        root2.pendingLanes |= spawnedLane;
        root2.suspendedLanes &= ~spawnedLane;
        var spawnedLaneIndex = 31 - clz32(spawnedLane);
        root2.entangledLanes |= spawnedLane;
        root2.entanglements[spawnedLaneIndex] = root2.entanglements[spawnedLaneIndex] | 1073741824 | entangledLanes & 4194090;
      }
      function markRootEntangled(root2, entangledLanes) {
        var rootEntangledLanes = root2.entangledLanes |= entangledLanes;
        for (root2 = root2.entanglements; rootEntangledLanes; ) {
          var index$6 = 31 - clz32(rootEntangledLanes), lane = 1 << index$6;
          lane & entangledLanes | root2[index$6] & entangledLanes && (root2[index$6] |= entangledLanes);
          rootEntangledLanes &= ~lane;
        }
      }
      function getBumpedLaneForHydrationByLane(lane) {
        switch (lane) {
          case 2:
            lane = 1;
            break;
          case 8:
            lane = 4;
            break;
          case 32:
            lane = 16;
            break;
          case 256:
          case 512:
          case 1024:
          case 2048:
          case 4096:
          case 8192:
          case 16384:
          case 32768:
          case 65536:
          case 131072:
          case 262144:
          case 524288:
          case 1048576:
          case 2097152:
          case 4194304:
          case 8388608:
          case 16777216:
          case 33554432:
            lane = 128;
            break;
          case 268435456:
            lane = 134217728;
            break;
          default:
            lane = 0;
        }
        return lane;
      }
      function lanesToEventPriority(lanes) {
        lanes &= -lanes;
        return 2 < lanes ? 8 < lanes ? 0 !== (lanes & 134217727) ? 32 : 268435456 : 8 : 2;
      }
      function resolveUpdatePriority() {
        var updatePriority = ReactDOMSharedInternals.p;
        if (0 !== updatePriority) return updatePriority;
        updatePriority = window.event;
        return void 0 === updatePriority ? 32 : getEventPriority(updatePriority.type);
      }
      function runWithPriority(priority, fn) {
        var previousPriority = ReactDOMSharedInternals.p;
        try {
          return ReactDOMSharedInternals.p = priority, fn();
        } finally {
          ReactDOMSharedInternals.p = previousPriority;
        }
      }
      var randomKey = Math.random().toString(36).slice(2);
      var internalInstanceKey = "__reactFiber$" + randomKey;
      var internalPropsKey = "__reactProps$" + randomKey;
      var internalContainerInstanceKey = "__reactContainer$" + randomKey;
      var internalEventHandlersKey = "__reactEvents$" + randomKey;
      var internalEventHandlerListenersKey = "__reactListeners$" + randomKey;
      var internalEventHandlesSetKey = "__reactHandles$" + randomKey;
      var internalRootNodeResourcesKey = "__reactResources$" + randomKey;
      var internalHoistableMarker = "__reactMarker$" + randomKey;
      function detachDeletedInstance(node) {
        delete node[internalInstanceKey];
        delete node[internalPropsKey];
        delete node[internalEventHandlersKey];
        delete node[internalEventHandlerListenersKey];
        delete node[internalEventHandlesSetKey];
      }
      function getClosestInstanceFromNode(targetNode) {
        var targetInst = targetNode[internalInstanceKey];
        if (targetInst) return targetInst;
        for (var parentNode = targetNode.parentNode; parentNode; ) {
          if (targetInst = parentNode[internalContainerInstanceKey] || parentNode[internalInstanceKey]) {
            parentNode = targetInst.alternate;
            if (null !== targetInst.child || null !== parentNode && null !== parentNode.child)
              for (targetNode = getParentSuspenseInstance(targetNode); null !== targetNode; ) {
                if (parentNode = targetNode[internalInstanceKey]) return parentNode;
                targetNode = getParentSuspenseInstance(targetNode);
              }
            return targetInst;
          }
          targetNode = parentNode;
          parentNode = targetNode.parentNode;
        }
        return null;
      }
      function getInstanceFromNode(node) {
        if (node = node[internalInstanceKey] || node[internalContainerInstanceKey]) {
          var tag = node.tag;
          if (5 === tag || 6 === tag || 13 === tag || 26 === tag || 27 === tag || 3 === tag)
            return node;
        }
        return null;
      }
      function getNodeFromInstance(inst) {
        var tag = inst.tag;
        if (5 === tag || 26 === tag || 27 === tag || 6 === tag) return inst.stateNode;
        throw Error(formatProdErrorMessage(33));
      }
      function getResourcesFromRoot(root2) {
        var resources = root2[internalRootNodeResourcesKey];
        resources || (resources = root2[internalRootNodeResourcesKey] = { hoistableStyles: /* @__PURE__ */ new Map(), hoistableScripts: /* @__PURE__ */ new Map() });
        return resources;
      }
      function markNodeAsHoistable(node) {
        node[internalHoistableMarker] = true;
      }
      var allNativeEvents = /* @__PURE__ */ new Set();
      var registrationNameDependencies = {};
      function registerTwoPhaseEvent(registrationName, dependencies) {
        registerDirectEvent(registrationName, dependencies);
        registerDirectEvent(registrationName + "Capture", dependencies);
      }
      function registerDirectEvent(registrationName, dependencies) {
        registrationNameDependencies[registrationName] = dependencies;
        for (registrationName = 0; registrationName < dependencies.length; registrationName++)
          allNativeEvents.add(dependencies[registrationName]);
      }
      var VALID_ATTRIBUTE_NAME_REGEX = RegExp(
        "^[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"
      );
      var illegalAttributeNameCache = {};
      var validatedAttributeNameCache = {};
      function isAttributeNameSafe(attributeName) {
        if (hasOwnProperty.call(validatedAttributeNameCache, attributeName))
          return true;
        if (hasOwnProperty.call(illegalAttributeNameCache, attributeName)) return false;
        if (VALID_ATTRIBUTE_NAME_REGEX.test(attributeName))
          return validatedAttributeNameCache[attributeName] = true;
        illegalAttributeNameCache[attributeName] = true;
        return false;
      }
      function setValueForAttribute(node, name, value) {
        if (isAttributeNameSafe(name))
          if (null === value) node.removeAttribute(name);
          else {
            switch (typeof value) {
              case "undefined":
              case "function":
              case "symbol":
                node.removeAttribute(name);
                return;
              case "boolean":
                var prefix$8 = name.toLowerCase().slice(0, 5);
                if ("data-" !== prefix$8 && "aria-" !== prefix$8) {
                  node.removeAttribute(name);
                  return;
                }
            }
            node.setAttribute(name, "" + value);
          }
      }
      function setValueForKnownAttribute(node, name, value) {
        if (null === value) node.removeAttribute(name);
        else {
          switch (typeof value) {
            case "undefined":
            case "function":
            case "symbol":
            case "boolean":
              node.removeAttribute(name);
              return;
          }
          node.setAttribute(name, "" + value);
        }
      }
      function setValueForNamespacedAttribute(node, namespace, name, value) {
        if (null === value) node.removeAttribute(name);
        else {
          switch (typeof value) {
            case "undefined":
            case "function":
            case "symbol":
            case "boolean":
              node.removeAttribute(name);
              return;
          }
          node.setAttributeNS(namespace, name, "" + value);
        }
      }
      var prefix;
      var suffix;
      function describeBuiltInComponentFrame(name) {
        if (void 0 === prefix)
          try {
            throw Error();
          } catch (x) {
            var match = x.stack.trim().match(/\n( *(at )?)/);
            prefix = match && match[1] || "";
            suffix = -1 < x.stack.indexOf("\n    at") ? " (<anonymous>)" : -1 < x.stack.indexOf("@") ? "@unknown:0:0" : "";
          }
        return "\n" + prefix + name + suffix;
      }
      var reentry = false;
      function describeNativeComponentFrame(fn, construct) {
        if (!fn || reentry) return "";
        reentry = true;
        var previousPrepareStackTrace = Error.prepareStackTrace;
        Error.prepareStackTrace = void 0;
        try {
          var RunInRootFrame = {
            DetermineComponentFrameRoot: function() {
              try {
                if (construct) {
                  var Fake = function() {
                    throw Error();
                  };
                  Object.defineProperty(Fake.prototype, "props", {
                    set: function() {
                      throw Error();
                    }
                  });
                  if ("object" === typeof Reflect && Reflect.construct) {
                    try {
                      Reflect.construct(Fake, []);
                    } catch (x) {
                      var control = x;
                    }
                    Reflect.construct(fn, [], Fake);
                  } else {
                    try {
                      Fake.call();
                    } catch (x$9) {
                      control = x$9;
                    }
                    fn.call(Fake.prototype);
                  }
                } else {
                  try {
                    throw Error();
                  } catch (x$10) {
                    control = x$10;
                  }
                  (Fake = fn()) && "function" === typeof Fake.catch && Fake.catch(function() {
                  });
                }
              } catch (sample) {
                if (sample && control && "string" === typeof sample.stack)
                  return [sample.stack, control.stack];
              }
              return [null, null];
            }
          };
          RunInRootFrame.DetermineComponentFrameRoot.displayName = "DetermineComponentFrameRoot";
          var namePropDescriptor = Object.getOwnPropertyDescriptor(
            RunInRootFrame.DetermineComponentFrameRoot,
            "name"
          );
          namePropDescriptor && namePropDescriptor.configurable && Object.defineProperty(
            RunInRootFrame.DetermineComponentFrameRoot,
            "name",
            { value: "DetermineComponentFrameRoot" }
          );
          var _RunInRootFrame$Deter = RunInRootFrame.DetermineComponentFrameRoot(), sampleStack = _RunInRootFrame$Deter[0], controlStack = _RunInRootFrame$Deter[1];
          if (sampleStack && controlStack) {
            var sampleLines = sampleStack.split("\n"), controlLines = controlStack.split("\n");
            for (namePropDescriptor = RunInRootFrame = 0; RunInRootFrame < sampleLines.length && !sampleLines[RunInRootFrame].includes("DetermineComponentFrameRoot"); )
              RunInRootFrame++;
            for (; namePropDescriptor < controlLines.length && !controlLines[namePropDescriptor].includes(
              "DetermineComponentFrameRoot"
            ); )
              namePropDescriptor++;
            if (RunInRootFrame === sampleLines.length || namePropDescriptor === controlLines.length)
              for (RunInRootFrame = sampleLines.length - 1, namePropDescriptor = controlLines.length - 1; 1 <= RunInRootFrame && 0 <= namePropDescriptor && sampleLines[RunInRootFrame] !== controlLines[namePropDescriptor]; )
                namePropDescriptor--;
            for (; 1 <= RunInRootFrame && 0 <= namePropDescriptor; RunInRootFrame--, namePropDescriptor--)
              if (sampleLines[RunInRootFrame] !== controlLines[namePropDescriptor]) {
                if (1 !== RunInRootFrame || 1 !== namePropDescriptor) {
                  do
                    if (RunInRootFrame--, namePropDescriptor--, 0 > namePropDescriptor || sampleLines[RunInRootFrame] !== controlLines[namePropDescriptor]) {
                      var frame = "\n" + sampleLines[RunInRootFrame].replace(" at new ", " at ");
                      fn.displayName && frame.includes("<anonymous>") && (frame = frame.replace("<anonymous>", fn.displayName));
                      return frame;
                    }
                  while (1 <= RunInRootFrame && 0 <= namePropDescriptor);
                }
                break;
              }
          }
        } finally {
          reentry = false, Error.prepareStackTrace = previousPrepareStackTrace;
        }
        return (previousPrepareStackTrace = fn ? fn.displayName || fn.name : "") ? describeBuiltInComponentFrame(previousPrepareStackTrace) : "";
      }
      function describeFiber(fiber) {
        switch (fiber.tag) {
          case 26:
          case 27:
          case 5:
            return describeBuiltInComponentFrame(fiber.type);
          case 16:
            return describeBuiltInComponentFrame("Lazy");
          case 13:
            return describeBuiltInComponentFrame("Suspense");
          case 19:
            return describeBuiltInComponentFrame("SuspenseList");
          case 0:
          case 15:
            return describeNativeComponentFrame(fiber.type, false);
          case 11:
            return describeNativeComponentFrame(fiber.type.render, false);
          case 1:
            return describeNativeComponentFrame(fiber.type, true);
          case 31:
            return describeBuiltInComponentFrame("Activity");
          default:
            return "";
        }
      }
      function getStackByFiberInDevAndProd(workInProgress2) {
        try {
          var info = "";
          do
            info += describeFiber(workInProgress2), workInProgress2 = workInProgress2.return;
          while (workInProgress2);
          return info;
        } catch (x) {
          return "\nError generating stack: " + x.message + "\n" + x.stack;
        }
      }
      function getToStringValue(value) {
        switch (typeof value) {
          case "bigint":
          case "boolean":
          case "number":
          case "string":
          case "undefined":
            return value;
          case "object":
            return value;
          default:
            return "";
        }
      }
      function isCheckable(elem) {
        var type = elem.type;
        return (elem = elem.nodeName) && "input" === elem.toLowerCase() && ("checkbox" === type || "radio" === type);
      }
      function trackValueOnNode(node) {
        var valueField = isCheckable(node) ? "checked" : "value", descriptor = Object.getOwnPropertyDescriptor(
          node.constructor.prototype,
          valueField
        ), currentValue = "" + node[valueField];
        if (!node.hasOwnProperty(valueField) && "undefined" !== typeof descriptor && "function" === typeof descriptor.get && "function" === typeof descriptor.set) {
          var get = descriptor.get, set = descriptor.set;
          Object.defineProperty(node, valueField, {
            configurable: true,
            get: function() {
              return get.call(this);
            },
            set: function(value) {
              currentValue = "" + value;
              set.call(this, value);
            }
          });
          Object.defineProperty(node, valueField, {
            enumerable: descriptor.enumerable
          });
          return {
            getValue: function() {
              return currentValue;
            },
            setValue: function(value) {
              currentValue = "" + value;
            },
            stopTracking: function() {
              node._valueTracker = null;
              delete node[valueField];
            }
          };
        }
      }
      function track(node) {
        node._valueTracker || (node._valueTracker = trackValueOnNode(node));
      }
      function updateValueIfChanged(node) {
        if (!node) return false;
        var tracker = node._valueTracker;
        if (!tracker) return true;
        var lastValue = tracker.getValue();
        var value = "";
        node && (value = isCheckable(node) ? node.checked ? "true" : "false" : node.value);
        node = value;
        return node !== lastValue ? (tracker.setValue(node), true) : false;
      }
      function getActiveElement(doc) {
        doc = doc || ("undefined" !== typeof document ? document : void 0);
        if ("undefined" === typeof doc) return null;
        try {
          return doc.activeElement || doc.body;
        } catch (e) {
          return doc.body;
        }
      }
      var escapeSelectorAttributeValueInsideDoubleQuotesRegex = /[\n"\\]/g;
      function escapeSelectorAttributeValueInsideDoubleQuotes(value) {
        return value.replace(
          escapeSelectorAttributeValueInsideDoubleQuotesRegex,
          function(ch) {
            return "\\" + ch.charCodeAt(0).toString(16) + " ";
          }
        );
      }
      function updateInput(element, value, defaultValue, lastDefaultValue, checked, defaultChecked, type, name) {
        element.name = "";
        null != type && "function" !== typeof type && "symbol" !== typeof type && "boolean" !== typeof type ? element.type = type : element.removeAttribute("type");
        if (null != value)
          if ("number" === type) {
            if (0 === value && "" === element.value || element.value != value)
              element.value = "" + getToStringValue(value);
          } else
            element.value !== "" + getToStringValue(value) && (element.value = "" + getToStringValue(value));
        else
          "submit" !== type && "reset" !== type || element.removeAttribute("value");
        null != value ? setDefaultValue(element, type, getToStringValue(value)) : null != defaultValue ? setDefaultValue(element, type, getToStringValue(defaultValue)) : null != lastDefaultValue && element.removeAttribute("value");
        null == checked && null != defaultChecked && (element.defaultChecked = !!defaultChecked);
        null != checked && (element.checked = checked && "function" !== typeof checked && "symbol" !== typeof checked);
        null != name && "function" !== typeof name && "symbol" !== typeof name && "boolean" !== typeof name ? element.name = "" + getToStringValue(name) : element.removeAttribute("name");
      }
      function initInput(element, value, defaultValue, checked, defaultChecked, type, name, isHydrating2) {
        null != type && "function" !== typeof type && "symbol" !== typeof type && "boolean" !== typeof type && (element.type = type);
        if (null != value || null != defaultValue) {
          if (!("submit" !== type && "reset" !== type || void 0 !== value && null !== value))
            return;
          defaultValue = null != defaultValue ? "" + getToStringValue(defaultValue) : "";
          value = null != value ? "" + getToStringValue(value) : defaultValue;
          isHydrating2 || value === element.value || (element.value = value);
          element.defaultValue = value;
        }
        checked = null != checked ? checked : defaultChecked;
        checked = "function" !== typeof checked && "symbol" !== typeof checked && !!checked;
        element.checked = isHydrating2 ? element.checked : !!checked;
        element.defaultChecked = !!checked;
        null != name && "function" !== typeof name && "symbol" !== typeof name && "boolean" !== typeof name && (element.name = name);
      }
      function setDefaultValue(node, type, value) {
        "number" === type && getActiveElement(node.ownerDocument) === node || node.defaultValue === "" + value || (node.defaultValue = "" + value);
      }
      function updateOptions(node, multiple, propValue, setDefaultSelected) {
        node = node.options;
        if (multiple) {
          multiple = {};
          for (var i = 0; i < propValue.length; i++)
            multiple["$" + propValue[i]] = true;
          for (propValue = 0; propValue < node.length; propValue++)
            i = multiple.hasOwnProperty("$" + node[propValue].value), node[propValue].selected !== i && (node[propValue].selected = i), i && setDefaultSelected && (node[propValue].defaultSelected = true);
        } else {
          propValue = "" + getToStringValue(propValue);
          multiple = null;
          for (i = 0; i < node.length; i++) {
            if (node[i].value === propValue) {
              node[i].selected = true;
              setDefaultSelected && (node[i].defaultSelected = true);
              return;
            }
            null !== multiple || node[i].disabled || (multiple = node[i]);
          }
          null !== multiple && (multiple.selected = true);
        }
      }
      function updateTextarea(element, value, defaultValue) {
        if (null != value && (value = "" + getToStringValue(value), value !== element.value && (element.value = value), null == defaultValue)) {
          element.defaultValue !== value && (element.defaultValue = value);
          return;
        }
        element.defaultValue = null != defaultValue ? "" + getToStringValue(defaultValue) : "";
      }
      function initTextarea(element, value, defaultValue, children) {
        if (null == value) {
          if (null != children) {
            if (null != defaultValue) throw Error(formatProdErrorMessage(92));
            if (isArrayImpl(children)) {
              if (1 < children.length) throw Error(formatProdErrorMessage(93));
              children = children[0];
            }
            defaultValue = children;
          }
          null == defaultValue && (defaultValue = "");
          value = defaultValue;
        }
        defaultValue = getToStringValue(value);
        element.defaultValue = defaultValue;
        children = element.textContent;
        children === defaultValue && "" !== children && null !== children && (element.value = children);
      }
      function setTextContent(node, text) {
        if (text) {
          var firstChild = node.firstChild;
          if (firstChild && firstChild === node.lastChild && 3 === firstChild.nodeType) {
            firstChild.nodeValue = text;
            return;
          }
        }
        node.textContent = text;
      }
      var unitlessNumbers = new Set(
        "animationIterationCount aspectRatio borderImageOutset borderImageSlice borderImageWidth boxFlex boxFlexGroup boxOrdinalGroup columnCount columns flex flexGrow flexPositive flexShrink flexNegative flexOrder gridArea gridRow gridRowEnd gridRowSpan gridRowStart gridColumn gridColumnEnd gridColumnSpan gridColumnStart fontWeight lineClamp lineHeight opacity order orphans scale tabSize widows zIndex zoom fillOpacity floodOpacity stopOpacity strokeDasharray strokeDashoffset strokeMiterlimit strokeOpacity strokeWidth MozAnimationIterationCount MozBoxFlex MozBoxFlexGroup MozLineClamp msAnimationIterationCount msFlex msZoom msFlexGrow msFlexNegative msFlexOrder msFlexPositive msFlexShrink msGridColumn msGridColumnSpan msGridRow msGridRowSpan WebkitAnimationIterationCount WebkitBoxFlex WebKitBoxFlexGroup WebkitBoxOrdinalGroup WebkitColumnCount WebkitColumns WebkitFlex WebkitFlexGrow WebkitFlexPositive WebkitFlexShrink WebkitLineClamp".split(
          " "
        )
      );
      function setValueForStyle(style2, styleName, value) {
        var isCustomProperty = 0 === styleName.indexOf("--");
        null == value || "boolean" === typeof value || "" === value ? isCustomProperty ? style2.setProperty(styleName, "") : "float" === styleName ? style2.cssFloat = "" : style2[styleName] = "" : isCustomProperty ? style2.setProperty(styleName, value) : "number" !== typeof value || 0 === value || unitlessNumbers.has(styleName) ? "float" === styleName ? style2.cssFloat = value : style2[styleName] = ("" + value).trim() : style2[styleName] = value + "px";
      }
      function setValueForStyles(node, styles, prevStyles) {
        if (null != styles && "object" !== typeof styles)
          throw Error(formatProdErrorMessage(62));
        node = node.style;
        if (null != prevStyles) {
          for (var styleName in prevStyles)
            !prevStyles.hasOwnProperty(styleName) || null != styles && styles.hasOwnProperty(styleName) || (0 === styleName.indexOf("--") ? node.setProperty(styleName, "") : "float" === styleName ? node.cssFloat = "" : node[styleName] = "");
          for (var styleName$16 in styles)
            styleName = styles[styleName$16], styles.hasOwnProperty(styleName$16) && prevStyles[styleName$16] !== styleName && setValueForStyle(node, styleName$16, styleName);
        } else
          for (var styleName$17 in styles)
            styles.hasOwnProperty(styleName$17) && setValueForStyle(node, styleName$17, styles[styleName$17]);
      }
      function isCustomElement(tagName) {
        if (-1 === tagName.indexOf("-")) return false;
        switch (tagName) {
          case "annotation-xml":
          case "color-profile":
          case "font-face":
          case "font-face-src":
          case "font-face-uri":
          case "font-face-format":
          case "font-face-name":
          case "missing-glyph":
            return false;
          default:
            return true;
        }
      }
      var aliases = /* @__PURE__ */ new Map([
        ["acceptCharset", "accept-charset"],
        ["htmlFor", "for"],
        ["httpEquiv", "http-equiv"],
        ["crossOrigin", "crossorigin"],
        ["accentHeight", "accent-height"],
        ["alignmentBaseline", "alignment-baseline"],
        ["arabicForm", "arabic-form"],
        ["baselineShift", "baseline-shift"],
        ["capHeight", "cap-height"],
        ["clipPath", "clip-path"],
        ["clipRule", "clip-rule"],
        ["colorInterpolation", "color-interpolation"],
        ["colorInterpolationFilters", "color-interpolation-filters"],
        ["colorProfile", "color-profile"],
        ["colorRendering", "color-rendering"],
        ["dominantBaseline", "dominant-baseline"],
        ["enableBackground", "enable-background"],
        ["fillOpacity", "fill-opacity"],
        ["fillRule", "fill-rule"],
        ["floodColor", "flood-color"],
        ["floodOpacity", "flood-opacity"],
        ["fontFamily", "font-family"],
        ["fontSize", "font-size"],
        ["fontSizeAdjust", "font-size-adjust"],
        ["fontStretch", "font-stretch"],
        ["fontStyle", "font-style"],
        ["fontVariant", "font-variant"],
        ["fontWeight", "font-weight"],
        ["glyphName", "glyph-name"],
        ["glyphOrientationHorizontal", "glyph-orientation-horizontal"],
        ["glyphOrientationVertical", "glyph-orientation-vertical"],
        ["horizAdvX", "horiz-adv-x"],
        ["horizOriginX", "horiz-origin-x"],
        ["imageRendering", "image-rendering"],
        ["letterSpacing", "letter-spacing"],
        ["lightingColor", "lighting-color"],
        ["markerEnd", "marker-end"],
        ["markerMid", "marker-mid"],
        ["markerStart", "marker-start"],
        ["overlinePosition", "overline-position"],
        ["overlineThickness", "overline-thickness"],
        ["paintOrder", "paint-order"],
        ["panose-1", "panose-1"],
        ["pointerEvents", "pointer-events"],
        ["renderingIntent", "rendering-intent"],
        ["shapeRendering", "shape-rendering"],
        ["stopColor", "stop-color"],
        ["stopOpacity", "stop-opacity"],
        ["strikethroughPosition", "strikethrough-position"],
        ["strikethroughThickness", "strikethrough-thickness"],
        ["strokeDasharray", "stroke-dasharray"],
        ["strokeDashoffset", "stroke-dashoffset"],
        ["strokeLinecap", "stroke-linecap"],
        ["strokeLinejoin", "stroke-linejoin"],
        ["strokeMiterlimit", "stroke-miterlimit"],
        ["strokeOpacity", "stroke-opacity"],
        ["strokeWidth", "stroke-width"],
        ["textAnchor", "text-anchor"],
        ["textDecoration", "text-decoration"],
        ["textRendering", "text-rendering"],
        ["transformOrigin", "transform-origin"],
        ["underlinePosition", "underline-position"],
        ["underlineThickness", "underline-thickness"],
        ["unicodeBidi", "unicode-bidi"],
        ["unicodeRange", "unicode-range"],
        ["unitsPerEm", "units-per-em"],
        ["vAlphabetic", "v-alphabetic"],
        ["vHanging", "v-hanging"],
        ["vIdeographic", "v-ideographic"],
        ["vMathematical", "v-mathematical"],
        ["vectorEffect", "vector-effect"],
        ["vertAdvY", "vert-adv-y"],
        ["vertOriginX", "vert-origin-x"],
        ["vertOriginY", "vert-origin-y"],
        ["wordSpacing", "word-spacing"],
        ["writingMode", "writing-mode"],
        ["xmlnsXlink", "xmlns:xlink"],
        ["xHeight", "x-height"]
      ]);
      var isJavaScriptProtocol = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*:/i;
      function sanitizeURL(url) {
        return isJavaScriptProtocol.test("" + url) ? "javascript:throw new Error('React has blocked a javascript: URL as a security precaution.')" : url;
      }
      var currentReplayingEvent = null;
      function getEventTarget(nativeEvent) {
        nativeEvent = nativeEvent.target || nativeEvent.srcElement || window;
        nativeEvent.correspondingUseElement && (nativeEvent = nativeEvent.correspondingUseElement);
        return 3 === nativeEvent.nodeType ? nativeEvent.parentNode : nativeEvent;
      }
      var restoreTarget = null;
      var restoreQueue = null;
      function restoreStateOfTarget(target) {
        var internalInstance = getInstanceFromNode(target);
        if (internalInstance && (target = internalInstance.stateNode)) {
          var props = target[internalPropsKey] || null;
          a: switch (target = internalInstance.stateNode, internalInstance.type) {
            case "input":
              updateInput(
                target,
                props.value,
                props.defaultValue,
                props.defaultValue,
                props.checked,
                props.defaultChecked,
                props.type,
                props.name
              );
              internalInstance = props.name;
              if ("radio" === props.type && null != internalInstance) {
                for (props = target; props.parentNode; ) props = props.parentNode;
                props = props.querySelectorAll(
                  'input[name="' + escapeSelectorAttributeValueInsideDoubleQuotes(
                    "" + internalInstance
                  ) + '"][type="radio"]'
                );
                for (internalInstance = 0; internalInstance < props.length; internalInstance++) {
                  var otherNode = props[internalInstance];
                  if (otherNode !== target && otherNode.form === target.form) {
                    var otherProps = otherNode[internalPropsKey] || null;
                    if (!otherProps) throw Error(formatProdErrorMessage(90));
                    updateInput(
                      otherNode,
                      otherProps.value,
                      otherProps.defaultValue,
                      otherProps.defaultValue,
                      otherProps.checked,
                      otherProps.defaultChecked,
                      otherProps.type,
                      otherProps.name
                    );
                  }
                }
                for (internalInstance = 0; internalInstance < props.length; internalInstance++)
                  otherNode = props[internalInstance], otherNode.form === target.form && updateValueIfChanged(otherNode);
              }
              break a;
            case "textarea":
              updateTextarea(target, props.value, props.defaultValue);
              break a;
            case "select":
              internalInstance = props.value, null != internalInstance && updateOptions(target, !!props.multiple, internalInstance, false);
          }
        }
      }
      var isInsideEventHandler = false;
      function batchedUpdates$1(fn, a, b2) {
        if (isInsideEventHandler) return fn(a, b2);
        isInsideEventHandler = true;
        try {
          var JSCompiler_inline_result = fn(a);
          return JSCompiler_inline_result;
        } finally {
          if (isInsideEventHandler = false, null !== restoreTarget || null !== restoreQueue) {
            if (flushSyncWork$1(), restoreTarget && (a = restoreTarget, fn = restoreQueue, restoreQueue = restoreTarget = null, restoreStateOfTarget(a), fn))
              for (a = 0; a < fn.length; a++) restoreStateOfTarget(fn[a]);
          }
        }
      }
      function getListener(inst, registrationName) {
        var stateNode = inst.stateNode;
        if (null === stateNode) return null;
        var props = stateNode[internalPropsKey] || null;
        if (null === props) return null;
        stateNode = props[registrationName];
        a: switch (registrationName) {
          case "onClick":
          case "onClickCapture":
          case "onDoubleClick":
          case "onDoubleClickCapture":
          case "onMouseDown":
          case "onMouseDownCapture":
          case "onMouseMove":
          case "onMouseMoveCapture":
          case "onMouseUp":
          case "onMouseUpCapture":
          case "onMouseEnter":
            (props = !props.disabled) || (inst = inst.type, props = !("button" === inst || "input" === inst || "select" === inst || "textarea" === inst));
            inst = !props;
            break a;
          default:
            inst = false;
        }
        if (inst) return null;
        if (stateNode && "function" !== typeof stateNode)
          throw Error(
            formatProdErrorMessage(231, registrationName, typeof stateNode)
          );
        return stateNode;
      }
      var canUseDOM = !("undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement);
      var passiveBrowserEventsSupported = false;
      if (canUseDOM)
        try {
          options = {};
          Object.defineProperty(options, "passive", {
            get: function() {
              passiveBrowserEventsSupported = true;
            }
          });
          window.addEventListener("test", options, options);
          window.removeEventListener("test", options, options);
        } catch (e) {
          passiveBrowserEventsSupported = false;
        }
      var options;
      var root = null;
      var startText = null;
      var fallbackText = null;
      function getData() {
        if (fallbackText) return fallbackText;
        var start, startValue = startText, startLength = startValue.length, end, endValue = "value" in root ? root.value : root.textContent, endLength = endValue.length;
        for (start = 0; start < startLength && startValue[start] === endValue[start]; start++) ;
        var minEnd = startLength - start;
        for (end = 1; end <= minEnd && startValue[startLength - end] === endValue[endLength - end]; end++) ;
        return fallbackText = endValue.slice(start, 1 < end ? 1 - end : void 0);
      }
      function getEventCharCode(nativeEvent) {
        var keyCode = nativeEvent.keyCode;
        "charCode" in nativeEvent ? (nativeEvent = nativeEvent.charCode, 0 === nativeEvent && 13 === keyCode && (nativeEvent = 13)) : nativeEvent = keyCode;
        10 === nativeEvent && (nativeEvent = 13);
        return 32 <= nativeEvent || 13 === nativeEvent ? nativeEvent : 0;
      }
      function functionThatReturnsTrue() {
        return true;
      }
      function functionThatReturnsFalse() {
        return false;
      }
      function createSyntheticEvent(Interface2) {
        function SyntheticBaseEvent(reactName, reactEventType, targetInst, nativeEvent, nativeEventTarget) {
          this._reactName = reactName;
          this._targetInst = targetInst;
          this.type = reactEventType;
          this.nativeEvent = nativeEvent;
          this.target = nativeEventTarget;
          this.currentTarget = null;
          for (var propName in Interface2)
            Interface2.hasOwnProperty(propName) && (reactName = Interface2[propName], this[propName] = reactName ? reactName(nativeEvent) : nativeEvent[propName]);
          this.isDefaultPrevented = (null != nativeEvent.defaultPrevented ? nativeEvent.defaultPrevented : false === nativeEvent.returnValue) ? functionThatReturnsTrue : functionThatReturnsFalse;
          this.isPropagationStopped = functionThatReturnsFalse;
          return this;
        }
        assign(SyntheticBaseEvent.prototype, {
          preventDefault: function() {
            this.defaultPrevented = true;
            var event = this.nativeEvent;
            event && (event.preventDefault ? event.preventDefault() : "unknown" !== typeof event.returnValue && (event.returnValue = false), this.isDefaultPrevented = functionThatReturnsTrue);
          },
          stopPropagation: function() {
            var event = this.nativeEvent;
            event && (event.stopPropagation ? event.stopPropagation() : "unknown" !== typeof event.cancelBubble && (event.cancelBubble = true), this.isPropagationStopped = functionThatReturnsTrue);
          },
          persist: function() {
          },
          isPersistent: functionThatReturnsTrue
        });
        return SyntheticBaseEvent;
      }
      var EventInterface = {
        eventPhase: 0,
        bubbles: 0,
        cancelable: 0,
        timeStamp: function(event) {
          return event.timeStamp || Date.now();
        },
        defaultPrevented: 0,
        isTrusted: 0
      };
      var SyntheticEvent = createSyntheticEvent(EventInterface);
      var UIEventInterface = assign({}, EventInterface, { view: 0, detail: 0 });
      var SyntheticUIEvent = createSyntheticEvent(UIEventInterface);
      var lastMovementX;
      var lastMovementY;
      var lastMouseEvent;
      var MouseEventInterface = assign({}, UIEventInterface, {
        screenX: 0,
        screenY: 0,
        clientX: 0,
        clientY: 0,
        pageX: 0,
        pageY: 0,
        ctrlKey: 0,
        shiftKey: 0,
        altKey: 0,
        metaKey: 0,
        getModifierState: getEventModifierState,
        button: 0,
        buttons: 0,
        relatedTarget: function(event) {
          return void 0 === event.relatedTarget ? event.fromElement === event.srcElement ? event.toElement : event.fromElement : event.relatedTarget;
        },
        movementX: function(event) {
          if ("movementX" in event) return event.movementX;
          event !== lastMouseEvent && (lastMouseEvent && "mousemove" === event.type ? (lastMovementX = event.screenX - lastMouseEvent.screenX, lastMovementY = event.screenY - lastMouseEvent.screenY) : lastMovementY = lastMovementX = 0, lastMouseEvent = event);
          return lastMovementX;
        },
        movementY: function(event) {
          return "movementY" in event ? event.movementY : lastMovementY;
        }
      });
      var SyntheticMouseEvent = createSyntheticEvent(MouseEventInterface);
      var DragEventInterface = assign({}, MouseEventInterface, { dataTransfer: 0 });
      var SyntheticDragEvent = createSyntheticEvent(DragEventInterface);
      var FocusEventInterface = assign({}, UIEventInterface, { relatedTarget: 0 });
      var SyntheticFocusEvent = createSyntheticEvent(FocusEventInterface);
      var AnimationEventInterface = assign({}, EventInterface, {
        animationName: 0,
        elapsedTime: 0,
        pseudoElement: 0
      });
      var SyntheticAnimationEvent = createSyntheticEvent(AnimationEventInterface);
      var ClipboardEventInterface = assign({}, EventInterface, {
        clipboardData: function(event) {
          return "clipboardData" in event ? event.clipboardData : window.clipboardData;
        }
      });
      var SyntheticClipboardEvent = createSyntheticEvent(ClipboardEventInterface);
      var CompositionEventInterface = assign({}, EventInterface, { data: 0 });
      var SyntheticCompositionEvent = createSyntheticEvent(CompositionEventInterface);
      var normalizeKey = {
        Esc: "Escape",
        Spacebar: " ",
        Left: "ArrowLeft",
        Up: "ArrowUp",
        Right: "ArrowRight",
        Down: "ArrowDown",
        Del: "Delete",
        Win: "OS",
        Menu: "ContextMenu",
        Apps: "ContextMenu",
        Scroll: "ScrollLock",
        MozPrintableKey: "Unidentified"
      };
      var translateToKey = {
        8: "Backspace",
        9: "Tab",
        12: "Clear",
        13: "Enter",
        16: "Shift",
        17: "Control",
        18: "Alt",
        19: "Pause",
        20: "CapsLock",
        27: "Escape",
        32: " ",
        33: "PageUp",
        34: "PageDown",
        35: "End",
        36: "Home",
        37: "ArrowLeft",
        38: "ArrowUp",
        39: "ArrowRight",
        40: "ArrowDown",
        45: "Insert",
        46: "Delete",
        112: "F1",
        113: "F2",
        114: "F3",
        115: "F4",
        116: "F5",
        117: "F6",
        118: "F7",
        119: "F8",
        120: "F9",
        121: "F10",
        122: "F11",
        123: "F12",
        144: "NumLock",
        145: "ScrollLock",
        224: "Meta"
      };
      var modifierKeyToProp = {
        Alt: "altKey",
        Control: "ctrlKey",
        Meta: "metaKey",
        Shift: "shiftKey"
      };
      function modifierStateGetter(keyArg) {
        var nativeEvent = this.nativeEvent;
        return nativeEvent.getModifierState ? nativeEvent.getModifierState(keyArg) : (keyArg = modifierKeyToProp[keyArg]) ? !!nativeEvent[keyArg] : false;
      }
      function getEventModifierState() {
        return modifierStateGetter;
      }
      var KeyboardEventInterface = assign({}, UIEventInterface, {
        key: function(nativeEvent) {
          if (nativeEvent.key) {
            var key = normalizeKey[nativeEvent.key] || nativeEvent.key;
            if ("Unidentified" !== key) return key;
          }
          return "keypress" === nativeEvent.type ? (nativeEvent = getEventCharCode(nativeEvent), 13 === nativeEvent ? "Enter" : String.fromCharCode(nativeEvent)) : "keydown" === nativeEvent.type || "keyup" === nativeEvent.type ? translateToKey[nativeEvent.keyCode] || "Unidentified" : "";
        },
        code: 0,
        location: 0,
        ctrlKey: 0,
        shiftKey: 0,
        altKey: 0,
        metaKey: 0,
        repeat: 0,
        locale: 0,
        getModifierState: getEventModifierState,
        charCode: function(event) {
          return "keypress" === event.type ? getEventCharCode(event) : 0;
        },
        keyCode: function(event) {
          return "keydown" === event.type || "keyup" === event.type ? event.keyCode : 0;
        },
        which: function(event) {
          return "keypress" === event.type ? getEventCharCode(event) : "keydown" === event.type || "keyup" === event.type ? event.keyCode : 0;
        }
      });
      var SyntheticKeyboardEvent = createSyntheticEvent(KeyboardEventInterface);
      var PointerEventInterface = assign({}, MouseEventInterface, {
        pointerId: 0,
        width: 0,
        height: 0,
        pressure: 0,
        tangentialPressure: 0,
        tiltX: 0,
        tiltY: 0,
        twist: 0,
        pointerType: 0,
        isPrimary: 0
      });
      var SyntheticPointerEvent = createSyntheticEvent(PointerEventInterface);
      var TouchEventInterface = assign({}, UIEventInterface, {
        touches: 0,
        targetTouches: 0,
        changedTouches: 0,
        altKey: 0,
        metaKey: 0,
        ctrlKey: 0,
        shiftKey: 0,
        getModifierState: getEventModifierState
      });
      var SyntheticTouchEvent = createSyntheticEvent(TouchEventInterface);
      var TransitionEventInterface = assign({}, EventInterface, {
        propertyName: 0,
        elapsedTime: 0,
        pseudoElement: 0
      });
      var SyntheticTransitionEvent = createSyntheticEvent(TransitionEventInterface);
      var WheelEventInterface = assign({}, MouseEventInterface, {
        deltaX: function(event) {
          return "deltaX" in event ? event.deltaX : "wheelDeltaX" in event ? -event.wheelDeltaX : 0;
        },
        deltaY: function(event) {
          return "deltaY" in event ? event.deltaY : "wheelDeltaY" in event ? -event.wheelDeltaY : "wheelDelta" in event ? -event.wheelDelta : 0;
        },
        deltaZ: 0,
        deltaMode: 0
      });
      var SyntheticWheelEvent = createSyntheticEvent(WheelEventInterface);
      var ToggleEventInterface = assign({}, EventInterface, {
        newState: 0,
        oldState: 0
      });
      var SyntheticToggleEvent = createSyntheticEvent(ToggleEventInterface);
      var END_KEYCODES = [9, 13, 27, 32];
      var canUseCompositionEvent = canUseDOM && "CompositionEvent" in window;
      var documentMode = null;
      canUseDOM && "documentMode" in document && (documentMode = document.documentMode);
      var canUseTextInputEvent = canUseDOM && "TextEvent" in window && !documentMode;
      var useFallbackCompositionData = canUseDOM && (!canUseCompositionEvent || documentMode && 8 < documentMode && 11 >= documentMode);
      var SPACEBAR_CHAR = String.fromCharCode(32);
      var hasSpaceKeypress = false;
      function isFallbackCompositionEnd(domEventName, nativeEvent) {
        switch (domEventName) {
          case "keyup":
            return -1 !== END_KEYCODES.indexOf(nativeEvent.keyCode);
          case "keydown":
            return 229 !== nativeEvent.keyCode;
          case "keypress":
          case "mousedown":
          case "focusout":
            return true;
          default:
            return false;
        }
      }
      function getDataFromCustomEvent(nativeEvent) {
        nativeEvent = nativeEvent.detail;
        return "object" === typeof nativeEvent && "data" in nativeEvent ? nativeEvent.data : null;
      }
      var isComposing = false;
      function getNativeBeforeInputChars(domEventName, nativeEvent) {
        switch (domEventName) {
          case "compositionend":
            return getDataFromCustomEvent(nativeEvent);
          case "keypress":
            if (32 !== nativeEvent.which) return null;
            hasSpaceKeypress = true;
            return SPACEBAR_CHAR;
          case "textInput":
            return domEventName = nativeEvent.data, domEventName === SPACEBAR_CHAR && hasSpaceKeypress ? null : domEventName;
          default:
            return null;
        }
      }
      function getFallbackBeforeInputChars(domEventName, nativeEvent) {
        if (isComposing)
          return "compositionend" === domEventName || !canUseCompositionEvent && isFallbackCompositionEnd(domEventName, nativeEvent) ? (domEventName = getData(), fallbackText = startText = root = null, isComposing = false, domEventName) : null;
        switch (domEventName) {
          case "paste":
            return null;
          case "keypress":
            if (!(nativeEvent.ctrlKey || nativeEvent.altKey || nativeEvent.metaKey) || nativeEvent.ctrlKey && nativeEvent.altKey) {
              if (nativeEvent.char && 1 < nativeEvent.char.length)
                return nativeEvent.char;
              if (nativeEvent.which) return String.fromCharCode(nativeEvent.which);
            }
            return null;
          case "compositionend":
            return useFallbackCompositionData && "ko" !== nativeEvent.locale ? null : nativeEvent.data;
          default:
            return null;
        }
      }
      var supportedInputTypes = {
        color: true,
        date: true,
        datetime: true,
        "datetime-local": true,
        email: true,
        month: true,
        number: true,
        password: true,
        range: true,
        search: true,
        tel: true,
        text: true,
        time: true,
        url: true,
        week: true
      };
      function isTextInputElement(elem) {
        var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
        return "input" === nodeName ? !!supportedInputTypes[elem.type] : "textarea" === nodeName ? true : false;
      }
      function createAndAccumulateChangeEvent(dispatchQueue, inst, nativeEvent, target) {
        restoreTarget ? restoreQueue ? restoreQueue.push(target) : restoreQueue = [target] : restoreTarget = target;
        inst = accumulateTwoPhaseListeners(inst, "onChange");
        0 < inst.length && (nativeEvent = new SyntheticEvent(
          "onChange",
          "change",
          null,
          nativeEvent,
          target
        ), dispatchQueue.push({ event: nativeEvent, listeners: inst }));
      }
      var activeElement$1 = null;
      var activeElementInst$1 = null;
      function runEventInBatch(dispatchQueue) {
        processDispatchQueue(dispatchQueue, 0);
      }
      function getInstIfValueChanged(targetInst) {
        var targetNode = getNodeFromInstance(targetInst);
        if (updateValueIfChanged(targetNode)) return targetInst;
      }
      function getTargetInstForChangeEvent(domEventName, targetInst) {
        if ("change" === domEventName) return targetInst;
      }
      var isInputEventSupported = false;
      if (canUseDOM) {
        if (canUseDOM) {
          isSupported$jscomp$inline_417 = "oninput" in document;
          if (!isSupported$jscomp$inline_417) {
            element$jscomp$inline_418 = document.createElement("div");
            element$jscomp$inline_418.setAttribute("oninput", "return;");
            isSupported$jscomp$inline_417 = "function" === typeof element$jscomp$inline_418.oninput;
          }
          JSCompiler_inline_result$jscomp$282 = isSupported$jscomp$inline_417;
        } else JSCompiler_inline_result$jscomp$282 = false;
        isInputEventSupported = JSCompiler_inline_result$jscomp$282 && (!document.documentMode || 9 < document.documentMode);
      }
      var JSCompiler_inline_result$jscomp$282;
      var isSupported$jscomp$inline_417;
      var element$jscomp$inline_418;
      function stopWatchingForValueChange() {
        activeElement$1 && (activeElement$1.detachEvent("onpropertychange", handlePropertyChange), activeElementInst$1 = activeElement$1 = null);
      }
      function handlePropertyChange(nativeEvent) {
        if ("value" === nativeEvent.propertyName && getInstIfValueChanged(activeElementInst$1)) {
          var dispatchQueue = [];
          createAndAccumulateChangeEvent(
            dispatchQueue,
            activeElementInst$1,
            nativeEvent,
            getEventTarget(nativeEvent)
          );
          batchedUpdates$1(runEventInBatch, dispatchQueue);
        }
      }
      function handleEventsForInputEventPolyfill(domEventName, target, targetInst) {
        "focusin" === domEventName ? (stopWatchingForValueChange(), activeElement$1 = target, activeElementInst$1 = targetInst, activeElement$1.attachEvent("onpropertychange", handlePropertyChange)) : "focusout" === domEventName && stopWatchingForValueChange();
      }
      function getTargetInstForInputEventPolyfill(domEventName) {
        if ("selectionchange" === domEventName || "keyup" === domEventName || "keydown" === domEventName)
          return getInstIfValueChanged(activeElementInst$1);
      }
      function getTargetInstForClickEvent(domEventName, targetInst) {
        if ("click" === domEventName) return getInstIfValueChanged(targetInst);
      }
      function getTargetInstForInputOrChangeEvent(domEventName, targetInst) {
        if ("input" === domEventName || "change" === domEventName)
          return getInstIfValueChanged(targetInst);
      }
      function is(x, y) {
        return x === y && (0 !== x || 1 / x === 1 / y) || x !== x && y !== y;
      }
      var objectIs = "function" === typeof Object.is ? Object.is : is;
      function shallowEqual(objA, objB) {
        if (objectIs(objA, objB)) return true;
        if ("object" !== typeof objA || null === objA || "object" !== typeof objB || null === objB)
          return false;
        var keysA = Object.keys(objA), keysB = Object.keys(objB);
        if (keysA.length !== keysB.length) return false;
        for (keysB = 0; keysB < keysA.length; keysB++) {
          var currentKey = keysA[keysB];
          if (!hasOwnProperty.call(objB, currentKey) || !objectIs(objA[currentKey], objB[currentKey]))
            return false;
        }
        return true;
      }
      function getLeafNode(node) {
        for (; node && node.firstChild; ) node = node.firstChild;
        return node;
      }
      function getNodeForCharacterOffset(root2, offset) {
        var node = getLeafNode(root2);
        root2 = 0;
        for (var nodeEnd; node; ) {
          if (3 === node.nodeType) {
            nodeEnd = root2 + node.textContent.length;
            if (root2 <= offset && nodeEnd >= offset)
              return { node, offset: offset - root2 };
            root2 = nodeEnd;
          }
          a: {
            for (; node; ) {
              if (node.nextSibling) {
                node = node.nextSibling;
                break a;
              }
              node = node.parentNode;
            }
            node = void 0;
          }
          node = getLeafNode(node);
        }
      }
      function containsNode(outerNode, innerNode) {
        return outerNode && innerNode ? outerNode === innerNode ? true : outerNode && 3 === outerNode.nodeType ? false : innerNode && 3 === innerNode.nodeType ? containsNode(outerNode, innerNode.parentNode) : "contains" in outerNode ? outerNode.contains(innerNode) : outerNode.compareDocumentPosition ? !!(outerNode.compareDocumentPosition(innerNode) & 16) : false : false;
      }
      function getActiveElementDeep(containerInfo) {
        containerInfo = null != containerInfo && null != containerInfo.ownerDocument && null != containerInfo.ownerDocument.defaultView ? containerInfo.ownerDocument.defaultView : window;
        for (var element = getActiveElement(containerInfo.document); element instanceof containerInfo.HTMLIFrameElement; ) {
          try {
            var JSCompiler_inline_result = "string" === typeof element.contentWindow.location.href;
          } catch (err) {
            JSCompiler_inline_result = false;
          }
          if (JSCompiler_inline_result) containerInfo = element.contentWindow;
          else break;
          element = getActiveElement(containerInfo.document);
        }
        return element;
      }
      function hasSelectionCapabilities(elem) {
        var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
        return nodeName && ("input" === nodeName && ("text" === elem.type || "search" === elem.type || "tel" === elem.type || "url" === elem.type || "password" === elem.type) || "textarea" === nodeName || "true" === elem.contentEditable);
      }
      var skipSelectionChangeEvent = canUseDOM && "documentMode" in document && 11 >= document.documentMode;
      var activeElement = null;
      var activeElementInst = null;
      var lastSelection = null;
      var mouseDown = false;
      function constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget) {
        var doc = nativeEventTarget.window === nativeEventTarget ? nativeEventTarget.document : 9 === nativeEventTarget.nodeType ? nativeEventTarget : nativeEventTarget.ownerDocument;
        mouseDown || null == activeElement || activeElement !== getActiveElement(doc) || (doc = activeElement, "selectionStart" in doc && hasSelectionCapabilities(doc) ? doc = { start: doc.selectionStart, end: doc.selectionEnd } : (doc = (doc.ownerDocument && doc.ownerDocument.defaultView || window).getSelection(), doc = {
          anchorNode: doc.anchorNode,
          anchorOffset: doc.anchorOffset,
          focusNode: doc.focusNode,
          focusOffset: doc.focusOffset
        }), lastSelection && shallowEqual(lastSelection, doc) || (lastSelection = doc, doc = accumulateTwoPhaseListeners(activeElementInst, "onSelect"), 0 < doc.length && (nativeEvent = new SyntheticEvent(
          "onSelect",
          "select",
          null,
          nativeEvent,
          nativeEventTarget
        ), dispatchQueue.push({ event: nativeEvent, listeners: doc }), nativeEvent.target = activeElement)));
      }
      function makePrefixMap(styleProp, eventName) {
        var prefixes = {};
        prefixes[styleProp.toLowerCase()] = eventName.toLowerCase();
        prefixes["Webkit" + styleProp] = "webkit" + eventName;
        prefixes["Moz" + styleProp] = "moz" + eventName;
        return prefixes;
      }
      var vendorPrefixes = {
        animationend: makePrefixMap("Animation", "AnimationEnd"),
        animationiteration: makePrefixMap("Animation", "AnimationIteration"),
        animationstart: makePrefixMap("Animation", "AnimationStart"),
        transitionrun: makePrefixMap("Transition", "TransitionRun"),
        transitionstart: makePrefixMap("Transition", "TransitionStart"),
        transitioncancel: makePrefixMap("Transition", "TransitionCancel"),
        transitionend: makePrefixMap("Transition", "TransitionEnd")
      };
      var prefixedEventNames = {};
      var style = {};
      canUseDOM && (style = document.createElement("div").style, "AnimationEvent" in window || (delete vendorPrefixes.animationend.animation, delete vendorPrefixes.animationiteration.animation, delete vendorPrefixes.animationstart.animation), "TransitionEvent" in window || delete vendorPrefixes.transitionend.transition);
      function getVendorPrefixedEventName(eventName) {
        if (prefixedEventNames[eventName]) return prefixedEventNames[eventName];
        if (!vendorPrefixes[eventName]) return eventName;
        var prefixMap = vendorPrefixes[eventName], styleProp;
        for (styleProp in prefixMap)
          if (prefixMap.hasOwnProperty(styleProp) && styleProp in style)
            return prefixedEventNames[eventName] = prefixMap[styleProp];
        return eventName;
      }
      var ANIMATION_END = getVendorPrefixedEventName("animationend");
      var ANIMATION_ITERATION = getVendorPrefixedEventName("animationiteration");
      var ANIMATION_START = getVendorPrefixedEventName("animationstart");
      var TRANSITION_RUN = getVendorPrefixedEventName("transitionrun");
      var TRANSITION_START = getVendorPrefixedEventName("transitionstart");
      var TRANSITION_CANCEL = getVendorPrefixedEventName("transitioncancel");
      var TRANSITION_END = getVendorPrefixedEventName("transitionend");
      var topLevelEventsToReactNames = /* @__PURE__ */ new Map();
      var simpleEventPluginEvents = "abort auxClick beforeToggle cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(
        " "
      );
      simpleEventPluginEvents.push("scrollEnd");
      function registerSimpleEvent(domEventName, reactName) {
        topLevelEventsToReactNames.set(domEventName, reactName);
        registerTwoPhaseEvent(reactName, [domEventName]);
      }
      var CapturedStacks = /* @__PURE__ */ new WeakMap();
      function createCapturedValueAtFiber(value, source) {
        if ("object" === typeof value && null !== value) {
          var existing = CapturedStacks.get(value);
          if (void 0 !== existing) return existing;
          source = {
            value,
            source,
            stack: getStackByFiberInDevAndProd(source)
          };
          CapturedStacks.set(value, source);
          return source;
        }
        return {
          value,
          source,
          stack: getStackByFiberInDevAndProd(source)
        };
      }
      var concurrentQueues = [];
      var concurrentQueuesIndex = 0;
      var concurrentlyUpdatedLanes = 0;
      function finishQueueingConcurrentUpdates() {
        for (var endIndex = concurrentQueuesIndex, i = concurrentlyUpdatedLanes = concurrentQueuesIndex = 0; i < endIndex; ) {
          var fiber = concurrentQueues[i];
          concurrentQueues[i++] = null;
          var queue = concurrentQueues[i];
          concurrentQueues[i++] = null;
          var update = concurrentQueues[i];
          concurrentQueues[i++] = null;
          var lane = concurrentQueues[i];
          concurrentQueues[i++] = null;
          if (null !== queue && null !== update) {
            var pending = queue.pending;
            null === pending ? update.next = update : (update.next = pending.next, pending.next = update);
            queue.pending = update;
          }
          0 !== lane && markUpdateLaneFromFiberToRoot(fiber, update, lane);
        }
      }
      function enqueueUpdate$1(fiber, queue, update, lane) {
        concurrentQueues[concurrentQueuesIndex++] = fiber;
        concurrentQueues[concurrentQueuesIndex++] = queue;
        concurrentQueues[concurrentQueuesIndex++] = update;
        concurrentQueues[concurrentQueuesIndex++] = lane;
        concurrentlyUpdatedLanes |= lane;
        fiber.lanes |= lane;
        fiber = fiber.alternate;
        null !== fiber && (fiber.lanes |= lane);
      }
      function enqueueConcurrentHookUpdate(fiber, queue, update, lane) {
        enqueueUpdate$1(fiber, queue, update, lane);
        return getRootForUpdatedFiber(fiber);
      }
      function enqueueConcurrentRenderForLane(fiber, lane) {
        enqueueUpdate$1(fiber, null, null, lane);
        return getRootForUpdatedFiber(fiber);
      }
      function markUpdateLaneFromFiberToRoot(sourceFiber, update, lane) {
        sourceFiber.lanes |= lane;
        var alternate = sourceFiber.alternate;
        null !== alternate && (alternate.lanes |= lane);
        for (var isHidden = false, parent = sourceFiber.return; null !== parent; )
          parent.childLanes |= lane, alternate = parent.alternate, null !== alternate && (alternate.childLanes |= lane), 22 === parent.tag && (sourceFiber = parent.stateNode, null === sourceFiber || sourceFiber._visibility & 1 || (isHidden = true)), sourceFiber = parent, parent = parent.return;
        return 3 === sourceFiber.tag ? (parent = sourceFiber.stateNode, isHidden && null !== update && (isHidden = 31 - clz32(lane), sourceFiber = parent.hiddenUpdates, alternate = sourceFiber[isHidden], null === alternate ? sourceFiber[isHidden] = [update] : alternate.push(update), update.lane = lane | 536870912), parent) : null;
      }
      function getRootForUpdatedFiber(sourceFiber) {
        if (50 < nestedUpdateCount)
          throw nestedUpdateCount = 0, rootWithNestedUpdates = null, Error(formatProdErrorMessage(185));
        for (var parent = sourceFiber.return; null !== parent; )
          sourceFiber = parent, parent = sourceFiber.return;
        return 3 === sourceFiber.tag ? sourceFiber.stateNode : null;
      }
      var emptyContextObject = {};
      function FiberNode(tag, pendingProps, key, mode) {
        this.tag = tag;
        this.key = key;
        this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null;
        this.index = 0;
        this.refCleanup = this.ref = null;
        this.pendingProps = pendingProps;
        this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null;
        this.mode = mode;
        this.subtreeFlags = this.flags = 0;
        this.deletions = null;
        this.childLanes = this.lanes = 0;
        this.alternate = null;
      }
      function createFiberImplClass(tag, pendingProps, key, mode) {
        return new FiberNode(tag, pendingProps, key, mode);
      }
      function shouldConstruct(Component) {
        Component = Component.prototype;
        return !(!Component || !Component.isReactComponent);
      }
      function createWorkInProgress(current, pendingProps) {
        var workInProgress2 = current.alternate;
        null === workInProgress2 ? (workInProgress2 = createFiberImplClass(
          current.tag,
          pendingProps,
          current.key,
          current.mode
        ), workInProgress2.elementType = current.elementType, workInProgress2.type = current.type, workInProgress2.stateNode = current.stateNode, workInProgress2.alternate = current, current.alternate = workInProgress2) : (workInProgress2.pendingProps = pendingProps, workInProgress2.type = current.type, workInProgress2.flags = 0, workInProgress2.subtreeFlags = 0, workInProgress2.deletions = null);
        workInProgress2.flags = current.flags & 65011712;
        workInProgress2.childLanes = current.childLanes;
        workInProgress2.lanes = current.lanes;
        workInProgress2.child = current.child;
        workInProgress2.memoizedProps = current.memoizedProps;
        workInProgress2.memoizedState = current.memoizedState;
        workInProgress2.updateQueue = current.updateQueue;
        pendingProps = current.dependencies;
        workInProgress2.dependencies = null === pendingProps ? null : { lanes: pendingProps.lanes, firstContext: pendingProps.firstContext };
        workInProgress2.sibling = current.sibling;
        workInProgress2.index = current.index;
        workInProgress2.ref = current.ref;
        workInProgress2.refCleanup = current.refCleanup;
        return workInProgress2;
      }
      function resetWorkInProgress(workInProgress2, renderLanes2) {
        workInProgress2.flags &= 65011714;
        var current = workInProgress2.alternate;
        null === current ? (workInProgress2.childLanes = 0, workInProgress2.lanes = renderLanes2, workInProgress2.child = null, workInProgress2.subtreeFlags = 0, workInProgress2.memoizedProps = null, workInProgress2.memoizedState = null, workInProgress2.updateQueue = null, workInProgress2.dependencies = null, workInProgress2.stateNode = null) : (workInProgress2.childLanes = current.childLanes, workInProgress2.lanes = current.lanes, workInProgress2.child = current.child, workInProgress2.subtreeFlags = 0, workInProgress2.deletions = null, workInProgress2.memoizedProps = current.memoizedProps, workInProgress2.memoizedState = current.memoizedState, workInProgress2.updateQueue = current.updateQueue, workInProgress2.type = current.type, renderLanes2 = current.dependencies, workInProgress2.dependencies = null === renderLanes2 ? null : {
          lanes: renderLanes2.lanes,
          firstContext: renderLanes2.firstContext
        });
        return workInProgress2;
      }
      function createFiberFromTypeAndProps(type, key, pendingProps, owner, mode, lanes) {
        var fiberTag = 0;
        owner = type;
        if ("function" === typeof type) shouldConstruct(type) && (fiberTag = 1);
        else if ("string" === typeof type)
          fiberTag = isHostHoistableType(
            type,
            pendingProps,
            contextStackCursor.current
          ) ? 26 : "html" === type || "head" === type || "body" === type ? 27 : 5;
        else
          a: switch (type) {
            case REACT_ACTIVITY_TYPE:
              return type = createFiberImplClass(31, pendingProps, key, mode), type.elementType = REACT_ACTIVITY_TYPE, type.lanes = lanes, type;
            case REACT_FRAGMENT_TYPE:
              return createFiberFromFragment(pendingProps.children, mode, lanes, key);
            case REACT_STRICT_MODE_TYPE:
              fiberTag = 8;
              mode |= 24;
              break;
            case REACT_PROFILER_TYPE:
              return type = createFiberImplClass(12, pendingProps, key, mode | 2), type.elementType = REACT_PROFILER_TYPE, type.lanes = lanes, type;
            case REACT_SUSPENSE_TYPE:
              return type = createFiberImplClass(13, pendingProps, key, mode), type.elementType = REACT_SUSPENSE_TYPE, type.lanes = lanes, type;
            case REACT_SUSPENSE_LIST_TYPE:
              return type = createFiberImplClass(19, pendingProps, key, mode), type.elementType = REACT_SUSPENSE_LIST_TYPE, type.lanes = lanes, type;
            default:
              if ("object" === typeof type && null !== type)
                switch (type.$$typeof) {
                  case REACT_PROVIDER_TYPE:
                  case REACT_CONTEXT_TYPE:
                    fiberTag = 10;
                    break a;
                  case REACT_CONSUMER_TYPE:
                    fiberTag = 9;
                    break a;
                  case REACT_FORWARD_REF_TYPE:
                    fiberTag = 11;
                    break a;
                  case REACT_MEMO_TYPE:
                    fiberTag = 14;
                    break a;
                  case REACT_LAZY_TYPE:
                    fiberTag = 16;
                    owner = null;
                    break a;
                }
              fiberTag = 29;
              pendingProps = Error(
                formatProdErrorMessage(130, null === type ? "null" : typeof type, "")
              );
              owner = null;
          }
        key = createFiberImplClass(fiberTag, pendingProps, key, mode);
        key.elementType = type;
        key.type = owner;
        key.lanes = lanes;
        return key;
      }
      function createFiberFromFragment(elements, mode, lanes, key) {
        elements = createFiberImplClass(7, elements, key, mode);
        elements.lanes = lanes;
        return elements;
      }
      function createFiberFromText(content, mode, lanes) {
        content = createFiberImplClass(6, content, null, mode);
        content.lanes = lanes;
        return content;
      }
      function createFiberFromPortal(portal, mode, lanes) {
        mode = createFiberImplClass(
          4,
          null !== portal.children ? portal.children : [],
          portal.key,
          mode
        );
        mode.lanes = lanes;
        mode.stateNode = {
          containerInfo: portal.containerInfo,
          pendingChildren: null,
          implementation: portal.implementation
        };
        return mode;
      }
      var forkStack = [];
      var forkStackIndex = 0;
      var treeForkProvider = null;
      var treeForkCount = 0;
      var idStack = [];
      var idStackIndex = 0;
      var treeContextProvider = null;
      var treeContextId = 1;
      var treeContextOverflow = "";
      function pushTreeFork(workInProgress2, totalChildren) {
        forkStack[forkStackIndex++] = treeForkCount;
        forkStack[forkStackIndex++] = treeForkProvider;
        treeForkProvider = workInProgress2;
        treeForkCount = totalChildren;
      }
      function pushTreeId(workInProgress2, totalChildren, index3) {
        idStack[idStackIndex++] = treeContextId;
        idStack[idStackIndex++] = treeContextOverflow;
        idStack[idStackIndex++] = treeContextProvider;
        treeContextProvider = workInProgress2;
        var baseIdWithLeadingBit = treeContextId;
        workInProgress2 = treeContextOverflow;
        var baseLength = 32 - clz32(baseIdWithLeadingBit) - 1;
        baseIdWithLeadingBit &= ~(1 << baseLength);
        index3 += 1;
        var length = 32 - clz32(totalChildren) + baseLength;
        if (30 < length) {
          var numberOfOverflowBits = baseLength - baseLength % 5;
          length = (baseIdWithLeadingBit & (1 << numberOfOverflowBits) - 1).toString(32);
          baseIdWithLeadingBit >>= numberOfOverflowBits;
          baseLength -= numberOfOverflowBits;
          treeContextId = 1 << 32 - clz32(totalChildren) + baseLength | index3 << baseLength | baseIdWithLeadingBit;
          treeContextOverflow = length + workInProgress2;
        } else
          treeContextId = 1 << length | index3 << baseLength | baseIdWithLeadingBit, treeContextOverflow = workInProgress2;
      }
      function pushMaterializedTreeId(workInProgress2) {
        null !== workInProgress2.return && (pushTreeFork(workInProgress2, 1), pushTreeId(workInProgress2, 1, 0));
      }
      function popTreeContext(workInProgress2) {
        for (; workInProgress2 === treeForkProvider; )
          treeForkProvider = forkStack[--forkStackIndex], forkStack[forkStackIndex] = null, treeForkCount = forkStack[--forkStackIndex], forkStack[forkStackIndex] = null;
        for (; workInProgress2 === treeContextProvider; )
          treeContextProvider = idStack[--idStackIndex], idStack[idStackIndex] = null, treeContextOverflow = idStack[--idStackIndex], idStack[idStackIndex] = null, treeContextId = idStack[--idStackIndex], idStack[idStackIndex] = null;
      }
      var hydrationParentFiber = null;
      var nextHydratableInstance = null;
      var isHydrating = false;
      var hydrationErrors = null;
      var rootOrSingletonContext = false;
      var HydrationMismatchException = Error(formatProdErrorMessage(519));
      function throwOnHydrationMismatch(fiber) {
        var error = Error(formatProdErrorMessage(418, ""));
        queueHydrationError(createCapturedValueAtFiber(error, fiber));
        throw HydrationMismatchException;
      }
      function prepareToHydrateHostInstance(fiber) {
        var instance = fiber.stateNode, type = fiber.type, props = fiber.memoizedProps;
        instance[internalInstanceKey] = fiber;
        instance[internalPropsKey] = props;
        switch (type) {
          case "dialog":
            listenToNonDelegatedEvent("cancel", instance);
            listenToNonDelegatedEvent("close", instance);
            break;
          case "iframe":
          case "object":
          case "embed":
            listenToNonDelegatedEvent("load", instance);
            break;
          case "video":
          case "audio":
            for (type = 0; type < mediaEventTypes.length; type++)
              listenToNonDelegatedEvent(mediaEventTypes[type], instance);
            break;
          case "source":
            listenToNonDelegatedEvent("error", instance);
            break;
          case "img":
          case "image":
          case "link":
            listenToNonDelegatedEvent("error", instance);
            listenToNonDelegatedEvent("load", instance);
            break;
          case "details":
            listenToNonDelegatedEvent("toggle", instance);
            break;
          case "input":
            listenToNonDelegatedEvent("invalid", instance);
            initInput(
              instance,
              props.value,
              props.defaultValue,
              props.checked,
              props.defaultChecked,
              props.type,
              props.name,
              true
            );
            track(instance);
            break;
          case "select":
            listenToNonDelegatedEvent("invalid", instance);
            break;
          case "textarea":
            listenToNonDelegatedEvent("invalid", instance), initTextarea(instance, props.value, props.defaultValue, props.children), track(instance);
        }
        type = props.children;
        "string" !== typeof type && "number" !== typeof type && "bigint" !== typeof type || instance.textContent === "" + type || true === props.suppressHydrationWarning || checkForUnmatchedText(instance.textContent, type) ? (null != props.popover && (listenToNonDelegatedEvent("beforetoggle", instance), listenToNonDelegatedEvent("toggle", instance)), null != props.onScroll && listenToNonDelegatedEvent("scroll", instance), null != props.onScrollEnd && listenToNonDelegatedEvent("scrollend", instance), null != props.onClick && (instance.onclick = noop$1), instance = true) : instance = false;
        instance || throwOnHydrationMismatch(fiber);
      }
      function popToNextHostParent(fiber) {
        for (hydrationParentFiber = fiber.return; hydrationParentFiber; )
          switch (hydrationParentFiber.tag) {
            case 5:
            case 13:
              rootOrSingletonContext = false;
              return;
            case 27:
            case 3:
              rootOrSingletonContext = true;
              return;
            default:
              hydrationParentFiber = hydrationParentFiber.return;
          }
      }
      function popHydrationState(fiber) {
        if (fiber !== hydrationParentFiber) return false;
        if (!isHydrating) return popToNextHostParent(fiber), isHydrating = true, false;
        var tag = fiber.tag, JSCompiler_temp;
        if (JSCompiler_temp = 3 !== tag && 27 !== tag) {
          if (JSCompiler_temp = 5 === tag)
            JSCompiler_temp = fiber.type, JSCompiler_temp = !("form" !== JSCompiler_temp && "button" !== JSCompiler_temp) || shouldSetTextContent(fiber.type, fiber.memoizedProps);
          JSCompiler_temp = !JSCompiler_temp;
        }
        JSCompiler_temp && nextHydratableInstance && throwOnHydrationMismatch(fiber);
        popToNextHostParent(fiber);
        if (13 === tag) {
          fiber = fiber.memoizedState;
          fiber = null !== fiber ? fiber.dehydrated : null;
          if (!fiber) throw Error(formatProdErrorMessage(317));
          a: {
            fiber = fiber.nextSibling;
            for (tag = 0; fiber; ) {
              if (8 === fiber.nodeType)
                if (JSCompiler_temp = fiber.data, "/$" === JSCompiler_temp) {
                  if (0 === tag) {
                    nextHydratableInstance = getNextHydratable(fiber.nextSibling);
                    break a;
                  }
                  tag--;
                } else
                  "$" !== JSCompiler_temp && "$!" !== JSCompiler_temp && "$?" !== JSCompiler_temp || tag++;
              fiber = fiber.nextSibling;
            }
            nextHydratableInstance = null;
          }
        } else
          27 === tag ? (tag = nextHydratableInstance, isSingletonScope(fiber.type) ? (fiber = previousHydratableOnEnteringScopedSingleton, previousHydratableOnEnteringScopedSingleton = null, nextHydratableInstance = fiber) : nextHydratableInstance = tag) : nextHydratableInstance = hydrationParentFiber ? getNextHydratable(fiber.stateNode.nextSibling) : null;
        return true;
      }
      function resetHydrationState() {
        nextHydratableInstance = hydrationParentFiber = null;
        isHydrating = false;
      }
      function upgradeHydrationErrorsToRecoverable() {
        var queuedErrors = hydrationErrors;
        null !== queuedErrors && (null === workInProgressRootRecoverableErrors ? workInProgressRootRecoverableErrors = queuedErrors : workInProgressRootRecoverableErrors.push.apply(
          workInProgressRootRecoverableErrors,
          queuedErrors
        ), hydrationErrors = null);
        return queuedErrors;
      }
      function queueHydrationError(error) {
        null === hydrationErrors ? hydrationErrors = [error] : hydrationErrors.push(error);
      }
      var valueCursor = createCursor2(null);
      var currentlyRenderingFiber$1 = null;
      var lastContextDependency = null;
      function pushProvider(providerFiber, context, nextValue) {
        push(valueCursor, context._currentValue);
        context._currentValue = nextValue;
      }
      function popProvider(context) {
        context._currentValue = valueCursor.current;
        pop(valueCursor);
      }
      function scheduleContextWorkOnParentPath(parent, renderLanes2, propagationRoot) {
        for (; null !== parent; ) {
          var alternate = parent.alternate;
          (parent.childLanes & renderLanes2) !== renderLanes2 ? (parent.childLanes |= renderLanes2, null !== alternate && (alternate.childLanes |= renderLanes2)) : null !== alternate && (alternate.childLanes & renderLanes2) !== renderLanes2 && (alternate.childLanes |= renderLanes2);
          if (parent === propagationRoot) break;
          parent = parent.return;
        }
      }
      function propagateContextChanges(workInProgress2, contexts, renderLanes2, forcePropagateEntireTree) {
        var fiber = workInProgress2.child;
        null !== fiber && (fiber.return = workInProgress2);
        for (; null !== fiber; ) {
          var list = fiber.dependencies;
          if (null !== list) {
            var nextFiber = fiber.child;
            list = list.firstContext;
            a: for (; null !== list; ) {
              var dependency = list;
              list = fiber;
              for (var i = 0; i < contexts.length; i++)
                if (dependency.context === contexts[i]) {
                  list.lanes |= renderLanes2;
                  dependency = list.alternate;
                  null !== dependency && (dependency.lanes |= renderLanes2);
                  scheduleContextWorkOnParentPath(
                    list.return,
                    renderLanes2,
                    workInProgress2
                  );
                  forcePropagateEntireTree || (nextFiber = null);
                  break a;
                }
              list = dependency.next;
            }
          } else if (18 === fiber.tag) {
            nextFiber = fiber.return;
            if (null === nextFiber) throw Error(formatProdErrorMessage(341));
            nextFiber.lanes |= renderLanes2;
            list = nextFiber.alternate;
            null !== list && (list.lanes |= renderLanes2);
            scheduleContextWorkOnParentPath(nextFiber, renderLanes2, workInProgress2);
            nextFiber = null;
          } else nextFiber = fiber.child;
          if (null !== nextFiber) nextFiber.return = fiber;
          else
            for (nextFiber = fiber; null !== nextFiber; ) {
              if (nextFiber === workInProgress2) {
                nextFiber = null;
                break;
              }
              fiber = nextFiber.sibling;
              if (null !== fiber) {
                fiber.return = nextFiber.return;
                nextFiber = fiber;
                break;
              }
              nextFiber = nextFiber.return;
            }
          fiber = nextFiber;
        }
      }
      function propagateParentContextChanges(current, workInProgress2, renderLanes2, forcePropagateEntireTree) {
        current = null;
        for (var parent = workInProgress2, isInsidePropagationBailout = false; null !== parent; ) {
          if (!isInsidePropagationBailout) {
            if (0 !== (parent.flags & 524288)) isInsidePropagationBailout = true;
            else if (0 !== (parent.flags & 262144)) break;
          }
          if (10 === parent.tag) {
            var currentParent = parent.alternate;
            if (null === currentParent) throw Error(formatProdErrorMessage(387));
            currentParent = currentParent.memoizedProps;
            if (null !== currentParent) {
              var context = parent.type;
              objectIs(parent.pendingProps.value, currentParent.value) || (null !== current ? current.push(context) : current = [context]);
            }
          } else if (parent === hostTransitionProviderCursor.current) {
            currentParent = parent.alternate;
            if (null === currentParent) throw Error(formatProdErrorMessage(387));
            currentParent.memoizedState.memoizedState !== parent.memoizedState.memoizedState && (null !== current ? current.push(HostTransitionContext) : current = [HostTransitionContext]);
          }
          parent = parent.return;
        }
        null !== current && propagateContextChanges(
          workInProgress2,
          current,
          renderLanes2,
          forcePropagateEntireTree
        );
        workInProgress2.flags |= 262144;
      }
      function checkIfContextChanged(currentDependencies) {
        for (currentDependencies = currentDependencies.firstContext; null !== currentDependencies; ) {
          if (!objectIs(
            currentDependencies.context._currentValue,
            currentDependencies.memoizedValue
          ))
            return true;
          currentDependencies = currentDependencies.next;
        }
        return false;
      }
      function prepareToReadContext(workInProgress2) {
        currentlyRenderingFiber$1 = workInProgress2;
        lastContextDependency = null;
        workInProgress2 = workInProgress2.dependencies;
        null !== workInProgress2 && (workInProgress2.firstContext = null);
      }
      function readContext(context) {
        return readContextForConsumer(currentlyRenderingFiber$1, context);
      }
      function readContextDuringReconciliation(consumer, context) {
        null === currentlyRenderingFiber$1 && prepareToReadContext(consumer);
        return readContextForConsumer(consumer, context);
      }
      function readContextForConsumer(consumer, context) {
        var value = context._currentValue;
        context = { context, memoizedValue: value, next: null };
        if (null === lastContextDependency) {
          if (null === consumer) throw Error(formatProdErrorMessage(308));
          lastContextDependency = context;
          consumer.dependencies = { lanes: 0, firstContext: context };
          consumer.flags |= 524288;
        } else lastContextDependency = lastContextDependency.next = context;
        return value;
      }
      var AbortControllerLocal = "undefined" !== typeof AbortController ? AbortController : function() {
        var listeners = [], signal = this.signal = {
          aborted: false,
          addEventListener: function(type, listener) {
            listeners.push(listener);
          }
        };
        this.abort = function() {
          signal.aborted = true;
          listeners.forEach(function(listener) {
            return listener();
          });
        };
      };
      var scheduleCallback$2 = Scheduler.unstable_scheduleCallback;
      var NormalPriority = Scheduler.unstable_NormalPriority;
      var CacheContext = {
        $$typeof: REACT_CONTEXT_TYPE,
        Consumer: null,
        Provider: null,
        _currentValue: null,
        _currentValue2: null,
        _threadCount: 0
      };
      function createCache() {
        return {
          controller: new AbortControllerLocal(),
          data: /* @__PURE__ */ new Map(),
          refCount: 0
        };
      }
      function releaseCache(cache) {
        cache.refCount--;
        0 === cache.refCount && scheduleCallback$2(NormalPriority, function() {
          cache.controller.abort();
        });
      }
      var currentEntangledListeners = null;
      var currentEntangledPendingCount = 0;
      var currentEntangledLane = 0;
      var currentEntangledActionThenable = null;
      function entangleAsyncAction(transition, thenable) {
        if (null === currentEntangledListeners) {
          var entangledListeners = currentEntangledListeners = [];
          currentEntangledPendingCount = 0;
          currentEntangledLane = requestTransitionLane();
          currentEntangledActionThenable = {
            status: "pending",
            value: void 0,
            then: function(resolve) {
              entangledListeners.push(resolve);
            }
          };
        }
        currentEntangledPendingCount++;
        thenable.then(pingEngtangledActionScope, pingEngtangledActionScope);
        return thenable;
      }
      function pingEngtangledActionScope() {
        if (0 === --currentEntangledPendingCount && null !== currentEntangledListeners) {
          null !== currentEntangledActionThenable && (currentEntangledActionThenable.status = "fulfilled");
          var listeners = currentEntangledListeners;
          currentEntangledListeners = null;
          currentEntangledLane = 0;
          currentEntangledActionThenable = null;
          for (var i = 0; i < listeners.length; i++) (0, listeners[i])();
        }
      }
      function chainThenableValue(thenable, result) {
        var listeners = [], thenableWithOverride = {
          status: "pending",
          value: null,
          reason: null,
          then: function(resolve) {
            listeners.push(resolve);
          }
        };
        thenable.then(
          function() {
            thenableWithOverride.status = "fulfilled";
            thenableWithOverride.value = result;
            for (var i = 0; i < listeners.length; i++) (0, listeners[i])(result);
          },
          function(error) {
            thenableWithOverride.status = "rejected";
            thenableWithOverride.reason = error;
            for (error = 0; error < listeners.length; error++)
              (0, listeners[error])(void 0);
          }
        );
        return thenableWithOverride;
      }
      var prevOnStartTransitionFinish = ReactSharedInternals.S;
      ReactSharedInternals.S = function(transition, returnValue) {
        "object" === typeof returnValue && null !== returnValue && "function" === typeof returnValue.then && entangleAsyncAction(transition, returnValue);
        null !== prevOnStartTransitionFinish && prevOnStartTransitionFinish(transition, returnValue);
      };
      var resumedCache = createCursor2(null);
      function peekCacheFromPool() {
        var cacheResumedFromPreviousRender = resumedCache.current;
        return null !== cacheResumedFromPreviousRender ? cacheResumedFromPreviousRender : workInProgressRoot.pooledCache;
      }
      function pushTransition(offscreenWorkInProgress, prevCachePool) {
        null === prevCachePool ? push(resumedCache, resumedCache.current) : push(resumedCache, prevCachePool.pool);
      }
      function getSuspendedCache() {
        var cacheFromPool = peekCacheFromPool();
        return null === cacheFromPool ? null : { parent: CacheContext._currentValue, pool: cacheFromPool };
      }
      var SuspenseException = Error(formatProdErrorMessage(460));
      var SuspenseyCommitException = Error(formatProdErrorMessage(474));
      var SuspenseActionException = Error(formatProdErrorMessage(542));
      var noopSuspenseyCommitThenable = { then: function() {
      } };
      function isThenableResolved(thenable) {
        thenable = thenable.status;
        return "fulfilled" === thenable || "rejected" === thenable;
      }
      function noop$3() {
      }
      function trackUsedThenable(thenableState2, thenable, index3) {
        index3 = thenableState2[index3];
        void 0 === index3 ? thenableState2.push(thenable) : index3 !== thenable && (thenable.then(noop$3, noop$3), thenable = index3);
        switch (thenable.status) {
          case "fulfilled":
            return thenable.value;
          case "rejected":
            throw thenableState2 = thenable.reason, checkIfUseWrappedInAsyncCatch(thenableState2), thenableState2;
          default:
            if ("string" === typeof thenable.status) thenable.then(noop$3, noop$3);
            else {
              thenableState2 = workInProgressRoot;
              if (null !== thenableState2 && 100 < thenableState2.shellSuspendCounter)
                throw Error(formatProdErrorMessage(482));
              thenableState2 = thenable;
              thenableState2.status = "pending";
              thenableState2.then(
                function(fulfilledValue) {
                  if ("pending" === thenable.status) {
                    var fulfilledThenable = thenable;
                    fulfilledThenable.status = "fulfilled";
                    fulfilledThenable.value = fulfilledValue;
                  }
                },
                function(error) {
                  if ("pending" === thenable.status) {
                    var rejectedThenable = thenable;
                    rejectedThenable.status = "rejected";
                    rejectedThenable.reason = error;
                  }
                }
              );
            }
            switch (thenable.status) {
              case "fulfilled":
                return thenable.value;
              case "rejected":
                throw thenableState2 = thenable.reason, checkIfUseWrappedInAsyncCatch(thenableState2), thenableState2;
            }
            suspendedThenable = thenable;
            throw SuspenseException;
        }
      }
      var suspendedThenable = null;
      function getSuspendedThenable() {
        if (null === suspendedThenable) throw Error(formatProdErrorMessage(459));
        var thenable = suspendedThenable;
        suspendedThenable = null;
        return thenable;
      }
      function checkIfUseWrappedInAsyncCatch(rejectedReason) {
        if (rejectedReason === SuspenseException || rejectedReason === SuspenseActionException)
          throw Error(formatProdErrorMessage(483));
      }
      var hasForceUpdate = false;
      function initializeUpdateQueue(fiber) {
        fiber.updateQueue = {
          baseState: fiber.memoizedState,
          firstBaseUpdate: null,
          lastBaseUpdate: null,
          shared: { pending: null, lanes: 0, hiddenCallbacks: null },
          callbacks: null
        };
      }
      function cloneUpdateQueue(current, workInProgress2) {
        current = current.updateQueue;
        workInProgress2.updateQueue === current && (workInProgress2.updateQueue = {
          baseState: current.baseState,
          firstBaseUpdate: current.firstBaseUpdate,
          lastBaseUpdate: current.lastBaseUpdate,
          shared: current.shared,
          callbacks: null
        });
      }
      function createUpdate(lane) {
        return { lane, tag: 0, payload: null, callback: null, next: null };
      }
      function enqueueUpdate(fiber, update, lane) {
        var updateQueue = fiber.updateQueue;
        if (null === updateQueue) return null;
        updateQueue = updateQueue.shared;
        if (0 !== (executionContext & 2)) {
          var pending = updateQueue.pending;
          null === pending ? update.next = update : (update.next = pending.next, pending.next = update);
          updateQueue.pending = update;
          update = getRootForUpdatedFiber(fiber);
          markUpdateLaneFromFiberToRoot(fiber, null, lane);
          return update;
        }
        enqueueUpdate$1(fiber, updateQueue, update, lane);
        return getRootForUpdatedFiber(fiber);
      }
      function entangleTransitions(root2, fiber, lane) {
        fiber = fiber.updateQueue;
        if (null !== fiber && (fiber = fiber.shared, 0 !== (lane & 4194048))) {
          var queueLanes = fiber.lanes;
          queueLanes &= root2.pendingLanes;
          lane |= queueLanes;
          fiber.lanes = lane;
          markRootEntangled(root2, lane);
        }
      }
      function enqueueCapturedUpdate(workInProgress2, capturedUpdate) {
        var queue = workInProgress2.updateQueue, current = workInProgress2.alternate;
        if (null !== current && (current = current.updateQueue, queue === current)) {
          var newFirst = null, newLast = null;
          queue = queue.firstBaseUpdate;
          if (null !== queue) {
            do {
              var clone = {
                lane: queue.lane,
                tag: queue.tag,
                payload: queue.payload,
                callback: null,
                next: null
              };
              null === newLast ? newFirst = newLast = clone : newLast = newLast.next = clone;
              queue = queue.next;
            } while (null !== queue);
            null === newLast ? newFirst = newLast = capturedUpdate : newLast = newLast.next = capturedUpdate;
          } else newFirst = newLast = capturedUpdate;
          queue = {
            baseState: current.baseState,
            firstBaseUpdate: newFirst,
            lastBaseUpdate: newLast,
            shared: current.shared,
            callbacks: current.callbacks
          };
          workInProgress2.updateQueue = queue;
          return;
        }
        workInProgress2 = queue.lastBaseUpdate;
        null === workInProgress2 ? queue.firstBaseUpdate = capturedUpdate : workInProgress2.next = capturedUpdate;
        queue.lastBaseUpdate = capturedUpdate;
      }
      var didReadFromEntangledAsyncAction = false;
      function suspendIfUpdateReadFromEntangledAsyncAction() {
        if (didReadFromEntangledAsyncAction) {
          var entangledActionThenable = currentEntangledActionThenable;
          if (null !== entangledActionThenable) throw entangledActionThenable;
        }
      }
      function processUpdateQueue(workInProgress$jscomp$0, props, instance$jscomp$0, renderLanes2) {
        didReadFromEntangledAsyncAction = false;
        var queue = workInProgress$jscomp$0.updateQueue;
        hasForceUpdate = false;
        var firstBaseUpdate = queue.firstBaseUpdate, lastBaseUpdate = queue.lastBaseUpdate, pendingQueue = queue.shared.pending;
        if (null !== pendingQueue) {
          queue.shared.pending = null;
          var lastPendingUpdate = pendingQueue, firstPendingUpdate = lastPendingUpdate.next;
          lastPendingUpdate.next = null;
          null === lastBaseUpdate ? firstBaseUpdate = firstPendingUpdate : lastBaseUpdate.next = firstPendingUpdate;
          lastBaseUpdate = lastPendingUpdate;
          var current = workInProgress$jscomp$0.alternate;
          null !== current && (current = current.updateQueue, pendingQueue = current.lastBaseUpdate, pendingQueue !== lastBaseUpdate && (null === pendingQueue ? current.firstBaseUpdate = firstPendingUpdate : pendingQueue.next = firstPendingUpdate, current.lastBaseUpdate = lastPendingUpdate));
        }
        if (null !== firstBaseUpdate) {
          var newState = queue.baseState;
          lastBaseUpdate = 0;
          current = firstPendingUpdate = lastPendingUpdate = null;
          pendingQueue = firstBaseUpdate;
          do {
            var updateLane = pendingQueue.lane & -536870913, isHiddenUpdate = updateLane !== pendingQueue.lane;
            if (isHiddenUpdate ? (workInProgressRootRenderLanes & updateLane) === updateLane : (renderLanes2 & updateLane) === updateLane) {
              0 !== updateLane && updateLane === currentEntangledLane && (didReadFromEntangledAsyncAction = true);
              null !== current && (current = current.next = {
                lane: 0,
                tag: pendingQueue.tag,
                payload: pendingQueue.payload,
                callback: null,
                next: null
              });
              a: {
                var workInProgress2 = workInProgress$jscomp$0, update = pendingQueue;
                updateLane = props;
                var instance = instance$jscomp$0;
                switch (update.tag) {
                  case 1:
                    workInProgress2 = update.payload;
                    if ("function" === typeof workInProgress2) {
                      newState = workInProgress2.call(instance, newState, updateLane);
                      break a;
                    }
                    newState = workInProgress2;
                    break a;
                  case 3:
                    workInProgress2.flags = workInProgress2.flags & -65537 | 128;
                  case 0:
                    workInProgress2 = update.payload;
                    updateLane = "function" === typeof workInProgress2 ? workInProgress2.call(instance, newState, updateLane) : workInProgress2;
                    if (null === updateLane || void 0 === updateLane) break a;
                    newState = assign({}, newState, updateLane);
                    break a;
                  case 2:
                    hasForceUpdate = true;
                }
              }
              updateLane = pendingQueue.callback;
              null !== updateLane && (workInProgress$jscomp$0.flags |= 64, isHiddenUpdate && (workInProgress$jscomp$0.flags |= 8192), isHiddenUpdate = queue.callbacks, null === isHiddenUpdate ? queue.callbacks = [updateLane] : isHiddenUpdate.push(updateLane));
            } else
              isHiddenUpdate = {
                lane: updateLane,
                tag: pendingQueue.tag,
                payload: pendingQueue.payload,
                callback: pendingQueue.callback,
                next: null
              }, null === current ? (firstPendingUpdate = current = isHiddenUpdate, lastPendingUpdate = newState) : current = current.next = isHiddenUpdate, lastBaseUpdate |= updateLane;
            pendingQueue = pendingQueue.next;
            if (null === pendingQueue)
              if (pendingQueue = queue.shared.pending, null === pendingQueue)
                break;
              else
                isHiddenUpdate = pendingQueue, pendingQueue = isHiddenUpdate.next, isHiddenUpdate.next = null, queue.lastBaseUpdate = isHiddenUpdate, queue.shared.pending = null;
          } while (1);
          null === current && (lastPendingUpdate = newState);
          queue.baseState = lastPendingUpdate;
          queue.firstBaseUpdate = firstPendingUpdate;
          queue.lastBaseUpdate = current;
          null === firstBaseUpdate && (queue.shared.lanes = 0);
          workInProgressRootSkippedLanes |= lastBaseUpdate;
          workInProgress$jscomp$0.lanes = lastBaseUpdate;
          workInProgress$jscomp$0.memoizedState = newState;
        }
      }
      function callCallback(callback, context) {
        if ("function" !== typeof callback)
          throw Error(formatProdErrorMessage(191, callback));
        callback.call(context);
      }
      function commitCallbacks(updateQueue, context) {
        var callbacks = updateQueue.callbacks;
        if (null !== callbacks)
          for (updateQueue.callbacks = null, updateQueue = 0; updateQueue < callbacks.length; updateQueue++)
            callCallback(callbacks[updateQueue], context);
      }
      var currentTreeHiddenStackCursor = createCursor2(null);
      var prevEntangledRenderLanesCursor = createCursor2(0);
      function pushHiddenContext(fiber, context) {
        fiber = entangledRenderLanes;
        push(prevEntangledRenderLanesCursor, fiber);
        push(currentTreeHiddenStackCursor, context);
        entangledRenderLanes = fiber | context.baseLanes;
      }
      function reuseHiddenContextOnStack() {
        push(prevEntangledRenderLanesCursor, entangledRenderLanes);
        push(currentTreeHiddenStackCursor, currentTreeHiddenStackCursor.current);
      }
      function popHiddenContext() {
        entangledRenderLanes = prevEntangledRenderLanesCursor.current;
        pop(currentTreeHiddenStackCursor);
        pop(prevEntangledRenderLanesCursor);
      }
      var renderLanes = 0;
      var currentlyRenderingFiber = null;
      var currentHook = null;
      var workInProgressHook = null;
      var didScheduleRenderPhaseUpdate = false;
      var didScheduleRenderPhaseUpdateDuringThisPass = false;
      var shouldDoubleInvokeUserFnsInHooksDEV = false;
      var localIdCounter = 0;
      var thenableIndexCounter$1 = 0;
      var thenableState$1 = null;
      var globalClientIdCounter = 0;
      function throwInvalidHookError() {
        throw Error(formatProdErrorMessage(321));
      }
      function areHookInputsEqual(nextDeps, prevDeps) {
        if (null === prevDeps) return false;
        for (var i = 0; i < prevDeps.length && i < nextDeps.length; i++)
          if (!objectIs(nextDeps[i], prevDeps[i])) return false;
        return true;
      }
      function renderWithHooks(current, workInProgress2, Component, props, secondArg, nextRenderLanes) {
        renderLanes = nextRenderLanes;
        currentlyRenderingFiber = workInProgress2;
        workInProgress2.memoizedState = null;
        workInProgress2.updateQueue = null;
        workInProgress2.lanes = 0;
        ReactSharedInternals.H = null === current || null === current.memoizedState ? HooksDispatcherOnMount : HooksDispatcherOnUpdate;
        shouldDoubleInvokeUserFnsInHooksDEV = false;
        nextRenderLanes = Component(props, secondArg);
        shouldDoubleInvokeUserFnsInHooksDEV = false;
        didScheduleRenderPhaseUpdateDuringThisPass && (nextRenderLanes = renderWithHooksAgain(
          workInProgress2,
          Component,
          props,
          secondArg
        ));
        finishRenderingHooks(current);
        return nextRenderLanes;
      }
      function finishRenderingHooks(current) {
        ReactSharedInternals.H = ContextOnlyDispatcher;
        var didRenderTooFewHooks = null !== currentHook && null !== currentHook.next;
        renderLanes = 0;
        workInProgressHook = currentHook = currentlyRenderingFiber = null;
        didScheduleRenderPhaseUpdate = false;
        thenableIndexCounter$1 = 0;
        thenableState$1 = null;
        if (didRenderTooFewHooks) throw Error(formatProdErrorMessage(300));
        null === current || didReceiveUpdate || (current = current.dependencies, null !== current && checkIfContextChanged(current) && (didReceiveUpdate = true));
      }
      function renderWithHooksAgain(workInProgress2, Component, props, secondArg) {
        currentlyRenderingFiber = workInProgress2;
        var numberOfReRenders = 0;
        do {
          didScheduleRenderPhaseUpdateDuringThisPass && (thenableState$1 = null);
          thenableIndexCounter$1 = 0;
          didScheduleRenderPhaseUpdateDuringThisPass = false;
          if (25 <= numberOfReRenders) throw Error(formatProdErrorMessage(301));
          numberOfReRenders += 1;
          workInProgressHook = currentHook = null;
          if (null != workInProgress2.updateQueue) {
            var children = workInProgress2.updateQueue;
            children.lastEffect = null;
            children.events = null;
            children.stores = null;
            null != children.memoCache && (children.memoCache.index = 0);
          }
          ReactSharedInternals.H = HooksDispatcherOnRerender;
          children = Component(props, secondArg);
        } while (didScheduleRenderPhaseUpdateDuringThisPass);
        return children;
      }
      function TransitionAwareHostComponent() {
        var dispatcher = ReactSharedInternals.H, maybeThenable = dispatcher.useState()[0];
        maybeThenable = "function" === typeof maybeThenable.then ? useThenable(maybeThenable) : maybeThenable;
        dispatcher = dispatcher.useState()[0];
        (null !== currentHook ? currentHook.memoizedState : null) !== dispatcher && (currentlyRenderingFiber.flags |= 1024);
        return maybeThenable;
      }
      function checkDidRenderIdHook() {
        var didRenderIdHook = 0 !== localIdCounter;
        localIdCounter = 0;
        return didRenderIdHook;
      }
      function bailoutHooks(current, workInProgress2, lanes) {
        workInProgress2.updateQueue = current.updateQueue;
        workInProgress2.flags &= -2053;
        current.lanes &= ~lanes;
      }
      function resetHooksOnUnwind(workInProgress2) {
        if (didScheduleRenderPhaseUpdate) {
          for (workInProgress2 = workInProgress2.memoizedState; null !== workInProgress2; ) {
            var queue = workInProgress2.queue;
            null !== queue && (queue.pending = null);
            workInProgress2 = workInProgress2.next;
          }
          didScheduleRenderPhaseUpdate = false;
        }
        renderLanes = 0;
        workInProgressHook = currentHook = currentlyRenderingFiber = null;
        didScheduleRenderPhaseUpdateDuringThisPass = false;
        thenableIndexCounter$1 = localIdCounter = 0;
        thenableState$1 = null;
      }
      function mountWorkInProgressHook() {
        var hook = {
          memoizedState: null,
          baseState: null,
          baseQueue: null,
          queue: null,
          next: null
        };
        null === workInProgressHook ? currentlyRenderingFiber.memoizedState = workInProgressHook = hook : workInProgressHook = workInProgressHook.next = hook;
        return workInProgressHook;
      }
      function updateWorkInProgressHook() {
        if (null === currentHook) {
          var nextCurrentHook = currentlyRenderingFiber.alternate;
          nextCurrentHook = null !== nextCurrentHook ? nextCurrentHook.memoizedState : null;
        } else nextCurrentHook = currentHook.next;
        var nextWorkInProgressHook = null === workInProgressHook ? currentlyRenderingFiber.memoizedState : workInProgressHook.next;
        if (null !== nextWorkInProgressHook)
          workInProgressHook = nextWorkInProgressHook, currentHook = nextCurrentHook;
        else {
          if (null === nextCurrentHook) {
            if (null === currentlyRenderingFiber.alternate)
              throw Error(formatProdErrorMessage(467));
            throw Error(formatProdErrorMessage(310));
          }
          currentHook = nextCurrentHook;
          nextCurrentHook = {
            memoizedState: currentHook.memoizedState,
            baseState: currentHook.baseState,
            baseQueue: currentHook.baseQueue,
            queue: currentHook.queue,
            next: null
          };
          null === workInProgressHook ? currentlyRenderingFiber.memoizedState = workInProgressHook = nextCurrentHook : workInProgressHook = workInProgressHook.next = nextCurrentHook;
        }
        return workInProgressHook;
      }
      function createFunctionComponentUpdateQueue() {
        return { lastEffect: null, events: null, stores: null, memoCache: null };
      }
      function useThenable(thenable) {
        var index3 = thenableIndexCounter$1;
        thenableIndexCounter$1 += 1;
        null === thenableState$1 && (thenableState$1 = []);
        thenable = trackUsedThenable(thenableState$1, thenable, index3);
        index3 = currentlyRenderingFiber;
        null === (null === workInProgressHook ? index3.memoizedState : workInProgressHook.next) && (index3 = index3.alternate, ReactSharedInternals.H = null === index3 || null === index3.memoizedState ? HooksDispatcherOnMount : HooksDispatcherOnUpdate);
        return thenable;
      }
      function use(usable) {
        if (null !== usable && "object" === typeof usable) {
          if ("function" === typeof usable.then) return useThenable(usable);
          if (usable.$$typeof === REACT_CONTEXT_TYPE) return readContext(usable);
        }
        throw Error(formatProdErrorMessage(438, String(usable)));
      }
      function useMemoCache(size5) {
        var memoCache = null, updateQueue = currentlyRenderingFiber.updateQueue;
        null !== updateQueue && (memoCache = updateQueue.memoCache);
        if (null == memoCache) {
          var current = currentlyRenderingFiber.alternate;
          null !== current && (current = current.updateQueue, null !== current && (current = current.memoCache, null != current && (memoCache = {
            data: current.data.map(function(array) {
              return array.slice();
            }),
            index: 0
          })));
        }
        null == memoCache && (memoCache = { data: [], index: 0 });
        null === updateQueue && (updateQueue = createFunctionComponentUpdateQueue(), currentlyRenderingFiber.updateQueue = updateQueue);
        updateQueue.memoCache = memoCache;
        updateQueue = memoCache.data[memoCache.index];
        if (void 0 === updateQueue)
          for (updateQueue = memoCache.data[memoCache.index] = Array(size5), current = 0; current < size5; current++)
            updateQueue[current] = REACT_MEMO_CACHE_SENTINEL;
        memoCache.index++;
        return updateQueue;
      }
      function basicStateReducer(state, action) {
        return "function" === typeof action ? action(state) : action;
      }
      function updateReducer(reducer) {
        var hook = updateWorkInProgressHook();
        return updateReducerImpl(hook, currentHook, reducer);
      }
      function updateReducerImpl(hook, current, reducer) {
        var queue = hook.queue;
        if (null === queue) throw Error(formatProdErrorMessage(311));
        queue.lastRenderedReducer = reducer;
        var baseQueue = hook.baseQueue, pendingQueue = queue.pending;
        if (null !== pendingQueue) {
          if (null !== baseQueue) {
            var baseFirst = baseQueue.next;
            baseQueue.next = pendingQueue.next;
            pendingQueue.next = baseFirst;
          }
          current.baseQueue = baseQueue = pendingQueue;
          queue.pending = null;
        }
        pendingQueue = hook.baseState;
        if (null === baseQueue) hook.memoizedState = pendingQueue;
        else {
          current = baseQueue.next;
          var newBaseQueueFirst = baseFirst = null, newBaseQueueLast = null, update = current, didReadFromEntangledAsyncAction$32 = false;
          do {
            var updateLane = update.lane & -536870913;
            if (updateLane !== update.lane ? (workInProgressRootRenderLanes & updateLane) === updateLane : (renderLanes & updateLane) === updateLane) {
              var revertLane = update.revertLane;
              if (0 === revertLane)
                null !== newBaseQueueLast && (newBaseQueueLast = newBaseQueueLast.next = {
                  lane: 0,
                  revertLane: 0,
                  action: update.action,
                  hasEagerState: update.hasEagerState,
                  eagerState: update.eagerState,
                  next: null
                }), updateLane === currentEntangledLane && (didReadFromEntangledAsyncAction$32 = true);
              else if ((renderLanes & revertLane) === revertLane) {
                update = update.next;
                revertLane === currentEntangledLane && (didReadFromEntangledAsyncAction$32 = true);
                continue;
              } else
                updateLane = {
                  lane: 0,
                  revertLane: update.revertLane,
                  action: update.action,
                  hasEagerState: update.hasEagerState,
                  eagerState: update.eagerState,
                  next: null
                }, null === newBaseQueueLast ? (newBaseQueueFirst = newBaseQueueLast = updateLane, baseFirst = pendingQueue) : newBaseQueueLast = newBaseQueueLast.next = updateLane, currentlyRenderingFiber.lanes |= revertLane, workInProgressRootSkippedLanes |= revertLane;
              updateLane = update.action;
              shouldDoubleInvokeUserFnsInHooksDEV && reducer(pendingQueue, updateLane);
              pendingQueue = update.hasEagerState ? update.eagerState : reducer(pendingQueue, updateLane);
            } else
              revertLane = {
                lane: updateLane,
                revertLane: update.revertLane,
                action: update.action,
                hasEagerState: update.hasEagerState,
                eagerState: update.eagerState,
                next: null
              }, null === newBaseQueueLast ? (newBaseQueueFirst = newBaseQueueLast = revertLane, baseFirst = pendingQueue) : newBaseQueueLast = newBaseQueueLast.next = revertLane, currentlyRenderingFiber.lanes |= updateLane, workInProgressRootSkippedLanes |= updateLane;
            update = update.next;
          } while (null !== update && update !== current);
          null === newBaseQueueLast ? baseFirst = pendingQueue : newBaseQueueLast.next = newBaseQueueFirst;
          if (!objectIs(pendingQueue, hook.memoizedState) && (didReceiveUpdate = true, didReadFromEntangledAsyncAction$32 && (reducer = currentEntangledActionThenable, null !== reducer)))
            throw reducer;
          hook.memoizedState = pendingQueue;
          hook.baseState = baseFirst;
          hook.baseQueue = newBaseQueueLast;
          queue.lastRenderedState = pendingQueue;
        }
        null === baseQueue && (queue.lanes = 0);
        return [hook.memoizedState, queue.dispatch];
      }
      function rerenderReducer(reducer) {
        var hook = updateWorkInProgressHook(), queue = hook.queue;
        if (null === queue) throw Error(formatProdErrorMessage(311));
        queue.lastRenderedReducer = reducer;
        var dispatch = queue.dispatch, lastRenderPhaseUpdate = queue.pending, newState = hook.memoizedState;
        if (null !== lastRenderPhaseUpdate) {
          queue.pending = null;
          var update = lastRenderPhaseUpdate = lastRenderPhaseUpdate.next;
          do
            newState = reducer(newState, update.action), update = update.next;
          while (update !== lastRenderPhaseUpdate);
          objectIs(newState, hook.memoizedState) || (didReceiveUpdate = true);
          hook.memoizedState = newState;
          null === hook.baseQueue && (hook.baseState = newState);
          queue.lastRenderedState = newState;
        }
        return [newState, dispatch];
      }
      function updateSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {
        var fiber = currentlyRenderingFiber, hook = updateWorkInProgressHook(), isHydrating$jscomp$0 = isHydrating;
        if (isHydrating$jscomp$0) {
          if (void 0 === getServerSnapshot) throw Error(formatProdErrorMessage(407));
          getServerSnapshot = getServerSnapshot();
        } else getServerSnapshot = getSnapshot();
        var snapshotChanged = !objectIs(
          (currentHook || hook).memoizedState,
          getServerSnapshot
        );
        snapshotChanged && (hook.memoizedState = getServerSnapshot, didReceiveUpdate = true);
        hook = hook.queue;
        var create = subscribeToStore.bind(null, fiber, hook, subscribe);
        updateEffectImpl(2048, 8, create, [subscribe]);
        if (hook.getSnapshot !== getSnapshot || snapshotChanged || null !== workInProgressHook && workInProgressHook.memoizedState.tag & 1) {
          fiber.flags |= 2048;
          pushSimpleEffect(
            9,
            createEffectInstance(),
            updateStoreInstance.bind(
              null,
              fiber,
              hook,
              getServerSnapshot,
              getSnapshot
            ),
            null
          );
          if (null === workInProgressRoot) throw Error(formatProdErrorMessage(349));
          isHydrating$jscomp$0 || 0 !== (renderLanes & 124) || pushStoreConsistencyCheck(fiber, getSnapshot, getServerSnapshot);
        }
        return getServerSnapshot;
      }
      function pushStoreConsistencyCheck(fiber, getSnapshot, renderedSnapshot) {
        fiber.flags |= 16384;
        fiber = { getSnapshot, value: renderedSnapshot };
        getSnapshot = currentlyRenderingFiber.updateQueue;
        null === getSnapshot ? (getSnapshot = createFunctionComponentUpdateQueue(), currentlyRenderingFiber.updateQueue = getSnapshot, getSnapshot.stores = [fiber]) : (renderedSnapshot = getSnapshot.stores, null === renderedSnapshot ? getSnapshot.stores = [fiber] : renderedSnapshot.push(fiber));
      }
      function updateStoreInstance(fiber, inst, nextSnapshot, getSnapshot) {
        inst.value = nextSnapshot;
        inst.getSnapshot = getSnapshot;
        checkIfSnapshotChanged(inst) && forceStoreRerender(fiber);
      }
      function subscribeToStore(fiber, inst, subscribe) {
        return subscribe(function() {
          checkIfSnapshotChanged(inst) && forceStoreRerender(fiber);
        });
      }
      function checkIfSnapshotChanged(inst) {
        var latestGetSnapshot = inst.getSnapshot;
        inst = inst.value;
        try {
          var nextValue = latestGetSnapshot();
          return !objectIs(inst, nextValue);
        } catch (error) {
          return true;
        }
      }
      function forceStoreRerender(fiber) {
        var root2 = enqueueConcurrentRenderForLane(fiber, 2);
        null !== root2 && scheduleUpdateOnFiber(root2, fiber, 2);
      }
      function mountStateImpl(initialState) {
        var hook = mountWorkInProgressHook();
        if ("function" === typeof initialState) {
          var initialStateInitializer = initialState;
          initialState = initialStateInitializer();
          if (shouldDoubleInvokeUserFnsInHooksDEV) {
            setIsStrictModeForDevtools(true);
            try {
              initialStateInitializer();
            } finally {
              setIsStrictModeForDevtools(false);
            }
          }
        }
        hook.memoizedState = hook.baseState = initialState;
        hook.queue = {
          pending: null,
          lanes: 0,
          dispatch: null,
          lastRenderedReducer: basicStateReducer,
          lastRenderedState: initialState
        };
        return hook;
      }
      function updateOptimisticImpl(hook, current, passthrough, reducer) {
        hook.baseState = passthrough;
        return updateReducerImpl(
          hook,
          currentHook,
          "function" === typeof reducer ? reducer : basicStateReducer
        );
      }
      function dispatchActionState(fiber, actionQueue, setPendingState, setState, payload) {
        if (isRenderPhaseUpdate(fiber)) throw Error(formatProdErrorMessage(485));
        fiber = actionQueue.action;
        if (null !== fiber) {
          var actionNode = {
            payload,
            action: fiber,
            next: null,
            isTransition: true,
            status: "pending",
            value: null,
            reason: null,
            listeners: [],
            then: function(listener) {
              actionNode.listeners.push(listener);
            }
          };
          null !== ReactSharedInternals.T ? setPendingState(true) : actionNode.isTransition = false;
          setState(actionNode);
          setPendingState = actionQueue.pending;
          null === setPendingState ? (actionNode.next = actionQueue.pending = actionNode, runActionStateAction(actionQueue, actionNode)) : (actionNode.next = setPendingState.next, actionQueue.pending = setPendingState.next = actionNode);
        }
      }
      function runActionStateAction(actionQueue, node) {
        var action = node.action, payload = node.payload, prevState = actionQueue.state;
        if (node.isTransition) {
          var prevTransition = ReactSharedInternals.T, currentTransition = {};
          ReactSharedInternals.T = currentTransition;
          try {
            var returnValue = action(prevState, payload), onStartTransitionFinish = ReactSharedInternals.S;
            null !== onStartTransitionFinish && onStartTransitionFinish(currentTransition, returnValue);
            handleActionReturnValue(actionQueue, node, returnValue);
          } catch (error) {
            onActionError(actionQueue, node, error);
          } finally {
            ReactSharedInternals.T = prevTransition;
          }
        } else
          try {
            prevTransition = action(prevState, payload), handleActionReturnValue(actionQueue, node, prevTransition);
          } catch (error$38) {
            onActionError(actionQueue, node, error$38);
          }
      }
      function handleActionReturnValue(actionQueue, node, returnValue) {
        null !== returnValue && "object" === typeof returnValue && "function" === typeof returnValue.then ? returnValue.then(
          function(nextState) {
            onActionSuccess(actionQueue, node, nextState);
          },
          function(error) {
            return onActionError(actionQueue, node, error);
          }
        ) : onActionSuccess(actionQueue, node, returnValue);
      }
      function onActionSuccess(actionQueue, actionNode, nextState) {
        actionNode.status = "fulfilled";
        actionNode.value = nextState;
        notifyActionListeners(actionNode);
        actionQueue.state = nextState;
        actionNode = actionQueue.pending;
        null !== actionNode && (nextState = actionNode.next, nextState === actionNode ? actionQueue.pending = null : (nextState = nextState.next, actionNode.next = nextState, runActionStateAction(actionQueue, nextState)));
      }
      function onActionError(actionQueue, actionNode, error) {
        var last = actionQueue.pending;
        actionQueue.pending = null;
        if (null !== last) {
          last = last.next;
          do
            actionNode.status = "rejected", actionNode.reason = error, notifyActionListeners(actionNode), actionNode = actionNode.next;
          while (actionNode !== last);
        }
        actionQueue.action = null;
      }
      function notifyActionListeners(actionNode) {
        actionNode = actionNode.listeners;
        for (var i = 0; i < actionNode.length; i++) (0, actionNode[i])();
      }
      function actionStateReducer(oldState, newState) {
        return newState;
      }
      function mountActionState(action, initialStateProp) {
        if (isHydrating) {
          var ssrFormState = workInProgressRoot.formState;
          if (null !== ssrFormState) {
            a: {
              var JSCompiler_inline_result = currentlyRenderingFiber;
              if (isHydrating) {
                if (nextHydratableInstance) {
                  b: {
                    var JSCompiler_inline_result$jscomp$0 = nextHydratableInstance;
                    for (var inRootOrSingleton = rootOrSingletonContext; 8 !== JSCompiler_inline_result$jscomp$0.nodeType; ) {
                      if (!inRootOrSingleton) {
                        JSCompiler_inline_result$jscomp$0 = null;
                        break b;
                      }
                      JSCompiler_inline_result$jscomp$0 = getNextHydratable(
                        JSCompiler_inline_result$jscomp$0.nextSibling
                      );
                      if (null === JSCompiler_inline_result$jscomp$0) {
                        JSCompiler_inline_result$jscomp$0 = null;
                        break b;
                      }
                    }
                    inRootOrSingleton = JSCompiler_inline_result$jscomp$0.data;
                    JSCompiler_inline_result$jscomp$0 = "F!" === inRootOrSingleton || "F" === inRootOrSingleton ? JSCompiler_inline_result$jscomp$0 : null;
                  }
                  if (JSCompiler_inline_result$jscomp$0) {
                    nextHydratableInstance = getNextHydratable(
                      JSCompiler_inline_result$jscomp$0.nextSibling
                    );
                    JSCompiler_inline_result = "F!" === JSCompiler_inline_result$jscomp$0.data;
                    break a;
                  }
                }
                throwOnHydrationMismatch(JSCompiler_inline_result);
              }
              JSCompiler_inline_result = false;
            }
            JSCompiler_inline_result && (initialStateProp = ssrFormState[0]);
          }
        }
        ssrFormState = mountWorkInProgressHook();
        ssrFormState.memoizedState = ssrFormState.baseState = initialStateProp;
        JSCompiler_inline_result = {
          pending: null,
          lanes: 0,
          dispatch: null,
          lastRenderedReducer: actionStateReducer,
          lastRenderedState: initialStateProp
        };
        ssrFormState.queue = JSCompiler_inline_result;
        ssrFormState = dispatchSetState.bind(
          null,
          currentlyRenderingFiber,
          JSCompiler_inline_result
        );
        JSCompiler_inline_result.dispatch = ssrFormState;
        JSCompiler_inline_result = mountStateImpl(false);
        inRootOrSingleton = dispatchOptimisticSetState.bind(
          null,
          currentlyRenderingFiber,
          false,
          JSCompiler_inline_result.queue
        );
        JSCompiler_inline_result = mountWorkInProgressHook();
        JSCompiler_inline_result$jscomp$0 = {
          state: initialStateProp,
          dispatch: null,
          action,
          pending: null
        };
        JSCompiler_inline_result.queue = JSCompiler_inline_result$jscomp$0;
        ssrFormState = dispatchActionState.bind(
          null,
          currentlyRenderingFiber,
          JSCompiler_inline_result$jscomp$0,
          inRootOrSingleton,
          ssrFormState
        );
        JSCompiler_inline_result$jscomp$0.dispatch = ssrFormState;
        JSCompiler_inline_result.memoizedState = action;
        return [initialStateProp, ssrFormState, false];
      }
      function updateActionState(action) {
        var stateHook = updateWorkInProgressHook();
        return updateActionStateImpl(stateHook, currentHook, action);
      }
      function updateActionStateImpl(stateHook, currentStateHook, action) {
        currentStateHook = updateReducerImpl(
          stateHook,
          currentStateHook,
          actionStateReducer
        )[0];
        stateHook = updateReducer(basicStateReducer)[0];
        if ("object" === typeof currentStateHook && null !== currentStateHook && "function" === typeof currentStateHook.then)
          try {
            var state = useThenable(currentStateHook);
          } catch (x) {
            if (x === SuspenseException) throw SuspenseActionException;
            throw x;
          }
        else state = currentStateHook;
        currentStateHook = updateWorkInProgressHook();
        var actionQueue = currentStateHook.queue, dispatch = actionQueue.dispatch;
        action !== currentStateHook.memoizedState && (currentlyRenderingFiber.flags |= 2048, pushSimpleEffect(
          9,
          createEffectInstance(),
          actionStateActionEffect.bind(null, actionQueue, action),
          null
        ));
        return [state, dispatch, stateHook];
      }
      function actionStateActionEffect(actionQueue, action) {
        actionQueue.action = action;
      }
      function rerenderActionState(action) {
        var stateHook = updateWorkInProgressHook(), currentStateHook = currentHook;
        if (null !== currentStateHook)
          return updateActionStateImpl(stateHook, currentStateHook, action);
        updateWorkInProgressHook();
        stateHook = stateHook.memoizedState;
        currentStateHook = updateWorkInProgressHook();
        var dispatch = currentStateHook.queue.dispatch;
        currentStateHook.memoizedState = action;
        return [stateHook, dispatch, false];
      }
      function pushSimpleEffect(tag, inst, create, createDeps) {
        tag = { tag, create, deps: createDeps, inst, next: null };
        inst = currentlyRenderingFiber.updateQueue;
        null === inst && (inst = createFunctionComponentUpdateQueue(), currentlyRenderingFiber.updateQueue = inst);
        create = inst.lastEffect;
        null === create ? inst.lastEffect = tag.next = tag : (createDeps = create.next, create.next = tag, tag.next = createDeps, inst.lastEffect = tag);
        return tag;
      }
      function createEffectInstance() {
        return { destroy: void 0, resource: void 0 };
      }
      function updateRef() {
        return updateWorkInProgressHook().memoizedState;
      }
      function mountEffectImpl(fiberFlags, hookFlags, create, createDeps) {
        var hook = mountWorkInProgressHook();
        createDeps = void 0 === createDeps ? null : createDeps;
        currentlyRenderingFiber.flags |= fiberFlags;
        hook.memoizedState = pushSimpleEffect(
          1 | hookFlags,
          createEffectInstance(),
          create,
          createDeps
        );
      }
      function updateEffectImpl(fiberFlags, hookFlags, create, deps) {
        var hook = updateWorkInProgressHook();
        deps = void 0 === deps ? null : deps;
        var inst = hook.memoizedState.inst;
        null !== currentHook && null !== deps && areHookInputsEqual(deps, currentHook.memoizedState.deps) ? hook.memoizedState = pushSimpleEffect(hookFlags, inst, create, deps) : (currentlyRenderingFiber.flags |= fiberFlags, hook.memoizedState = pushSimpleEffect(
          1 | hookFlags,
          inst,
          create,
          deps
        ));
      }
      function mountEffect(create, createDeps) {
        mountEffectImpl(8390656, 8, create, createDeps);
      }
      function updateEffect(create, createDeps) {
        updateEffectImpl(2048, 8, create, createDeps);
      }
      function updateInsertionEffect(create, deps) {
        return updateEffectImpl(4, 2, create, deps);
      }
      function updateLayoutEffect(create, deps) {
        return updateEffectImpl(4, 4, create, deps);
      }
      function imperativeHandleEffect(create, ref) {
        if ("function" === typeof ref) {
          create = create();
          var refCleanup = ref(create);
          return function() {
            "function" === typeof refCleanup ? refCleanup() : ref(null);
          };
        }
        if (null !== ref && void 0 !== ref)
          return create = create(), ref.current = create, function() {
            ref.current = null;
          };
      }
      function updateImperativeHandle(ref, create, deps) {
        deps = null !== deps && void 0 !== deps ? deps.concat([ref]) : null;
        updateEffectImpl(4, 4, imperativeHandleEffect.bind(null, create, ref), deps);
      }
      function mountDebugValue() {
      }
      function updateCallback(callback, deps) {
        var hook = updateWorkInProgressHook();
        deps = void 0 === deps ? null : deps;
        var prevState = hook.memoizedState;
        if (null !== deps && areHookInputsEqual(deps, prevState[1]))
          return prevState[0];
        hook.memoizedState = [callback, deps];
        return callback;
      }
      function updateMemo(nextCreate, deps) {
        var hook = updateWorkInProgressHook();
        deps = void 0 === deps ? null : deps;
        var prevState = hook.memoizedState;
        if (null !== deps && areHookInputsEqual(deps, prevState[1]))
          return prevState[0];
        prevState = nextCreate();
        if (shouldDoubleInvokeUserFnsInHooksDEV) {
          setIsStrictModeForDevtools(true);
          try {
            nextCreate();
          } finally {
            setIsStrictModeForDevtools(false);
          }
        }
        hook.memoizedState = [prevState, deps];
        return prevState;
      }
      function mountDeferredValueImpl(hook, value, initialValue) {
        if (void 0 === initialValue || 0 !== (renderLanes & 1073741824))
          return hook.memoizedState = value;
        hook.memoizedState = initialValue;
        hook = requestDeferredLane();
        currentlyRenderingFiber.lanes |= hook;
        workInProgressRootSkippedLanes |= hook;
        return initialValue;
      }
      function updateDeferredValueImpl(hook, prevValue, value, initialValue) {
        if (objectIs(value, prevValue)) return value;
        if (null !== currentTreeHiddenStackCursor.current)
          return hook = mountDeferredValueImpl(hook, value, initialValue), objectIs(hook, prevValue) || (didReceiveUpdate = true), hook;
        if (0 === (renderLanes & 42))
          return didReceiveUpdate = true, hook.memoizedState = value;
        hook = requestDeferredLane();
        currentlyRenderingFiber.lanes |= hook;
        workInProgressRootSkippedLanes |= hook;
        return prevValue;
      }
      function startTransition(fiber, queue, pendingState, finishedState, callback) {
        var previousPriority = ReactDOMSharedInternals.p;
        ReactDOMSharedInternals.p = 0 !== previousPriority && 8 > previousPriority ? previousPriority : 8;
        var prevTransition = ReactSharedInternals.T, currentTransition = {};
        ReactSharedInternals.T = currentTransition;
        dispatchOptimisticSetState(fiber, false, queue, pendingState);
        try {
          var returnValue = callback(), onStartTransitionFinish = ReactSharedInternals.S;
          null !== onStartTransitionFinish && onStartTransitionFinish(currentTransition, returnValue);
          if (null !== returnValue && "object" === typeof returnValue && "function" === typeof returnValue.then) {
            var thenableForFinishedState = chainThenableValue(
              returnValue,
              finishedState
            );
            dispatchSetStateInternal(
              fiber,
              queue,
              thenableForFinishedState,
              requestUpdateLane(fiber)
            );
          } else
            dispatchSetStateInternal(
              fiber,
              queue,
              finishedState,
              requestUpdateLane(fiber)
            );
        } catch (error) {
          dispatchSetStateInternal(
            fiber,
            queue,
            { then: function() {
            }, status: "rejected", reason: error },
            requestUpdateLane()
          );
        } finally {
          ReactDOMSharedInternals.p = previousPriority, ReactSharedInternals.T = prevTransition;
        }
      }
      function noop$2() {
      }
      function startHostTransition(formFiber, pendingState, action, formData) {
        if (5 !== formFiber.tag) throw Error(formatProdErrorMessage(476));
        var queue = ensureFormComponentIsStateful(formFiber).queue;
        startTransition(
          formFiber,
          queue,
          pendingState,
          sharedNotPendingObject,
          null === action ? noop$2 : function() {
            requestFormReset$1(formFiber);
            return action(formData);
          }
        );
      }
      function ensureFormComponentIsStateful(formFiber) {
        var existingStateHook = formFiber.memoizedState;
        if (null !== existingStateHook) return existingStateHook;
        existingStateHook = {
          memoizedState: sharedNotPendingObject,
          baseState: sharedNotPendingObject,
          baseQueue: null,
          queue: {
            pending: null,
            lanes: 0,
            dispatch: null,
            lastRenderedReducer: basicStateReducer,
            lastRenderedState: sharedNotPendingObject
          },
          next: null
        };
        var initialResetState = {};
        existingStateHook.next = {
          memoizedState: initialResetState,
          baseState: initialResetState,
          baseQueue: null,
          queue: {
            pending: null,
            lanes: 0,
            dispatch: null,
            lastRenderedReducer: basicStateReducer,
            lastRenderedState: initialResetState
          },
          next: null
        };
        formFiber.memoizedState = existingStateHook;
        formFiber = formFiber.alternate;
        null !== formFiber && (formFiber.memoizedState = existingStateHook);
        return existingStateHook;
      }
      function requestFormReset$1(formFiber) {
        var resetStateQueue = ensureFormComponentIsStateful(formFiber).next.queue;
        dispatchSetStateInternal(formFiber, resetStateQueue, {}, requestUpdateLane());
      }
      function useHostTransitionStatus() {
        return readContext(HostTransitionContext);
      }
      function updateId() {
        return updateWorkInProgressHook().memoizedState;
      }
      function updateRefresh() {
        return updateWorkInProgressHook().memoizedState;
      }
      function refreshCache(fiber) {
        for (var provider = fiber.return; null !== provider; ) {
          switch (provider.tag) {
            case 24:
            case 3:
              var lane = requestUpdateLane();
              fiber = createUpdate(lane);
              var root$41 = enqueueUpdate(provider, fiber, lane);
              null !== root$41 && (scheduleUpdateOnFiber(root$41, provider, lane), entangleTransitions(root$41, provider, lane));
              provider = { cache: createCache() };
              fiber.payload = provider;
              return;
          }
          provider = provider.return;
        }
      }
      function dispatchReducerAction(fiber, queue, action) {
        var lane = requestUpdateLane();
        action = {
          lane,
          revertLane: 0,
          action,
          hasEagerState: false,
          eagerState: null,
          next: null
        };
        isRenderPhaseUpdate(fiber) ? enqueueRenderPhaseUpdate(queue, action) : (action = enqueueConcurrentHookUpdate(fiber, queue, action, lane), null !== action && (scheduleUpdateOnFiber(action, fiber, lane), entangleTransitionUpdate(action, queue, lane)));
      }
      function dispatchSetState(fiber, queue, action) {
        var lane = requestUpdateLane();
        dispatchSetStateInternal(fiber, queue, action, lane);
      }
      function dispatchSetStateInternal(fiber, queue, action, lane) {
        var update = {
          lane,
          revertLane: 0,
          action,
          hasEagerState: false,
          eagerState: null,
          next: null
        };
        if (isRenderPhaseUpdate(fiber)) enqueueRenderPhaseUpdate(queue, update);
        else {
          var alternate = fiber.alternate;
          if (0 === fiber.lanes && (null === alternate || 0 === alternate.lanes) && (alternate = queue.lastRenderedReducer, null !== alternate))
            try {
              var currentState = queue.lastRenderedState, eagerState = alternate(currentState, action);
              update.hasEagerState = true;
              update.eagerState = eagerState;
              if (objectIs(eagerState, currentState))
                return enqueueUpdate$1(fiber, queue, update, 0), null === workInProgressRoot && finishQueueingConcurrentUpdates(), false;
            } catch (error) {
            } finally {
            }
          action = enqueueConcurrentHookUpdate(fiber, queue, update, lane);
          if (null !== action)
            return scheduleUpdateOnFiber(action, fiber, lane), entangleTransitionUpdate(action, queue, lane), true;
        }
        return false;
      }
      function dispatchOptimisticSetState(fiber, throwIfDuringRender, queue, action) {
        action = {
          lane: 2,
          revertLane: requestTransitionLane(),
          action,
          hasEagerState: false,
          eagerState: null,
          next: null
        };
        if (isRenderPhaseUpdate(fiber)) {
          if (throwIfDuringRender) throw Error(formatProdErrorMessage(479));
        } else
          throwIfDuringRender = enqueueConcurrentHookUpdate(
            fiber,
            queue,
            action,
            2
          ), null !== throwIfDuringRender && scheduleUpdateOnFiber(throwIfDuringRender, fiber, 2);
      }
      function isRenderPhaseUpdate(fiber) {
        var alternate = fiber.alternate;
        return fiber === currentlyRenderingFiber || null !== alternate && alternate === currentlyRenderingFiber;
      }
      function enqueueRenderPhaseUpdate(queue, update) {
        didScheduleRenderPhaseUpdateDuringThisPass = didScheduleRenderPhaseUpdate = true;
        var pending = queue.pending;
        null === pending ? update.next = update : (update.next = pending.next, pending.next = update);
        queue.pending = update;
      }
      function entangleTransitionUpdate(root2, queue, lane) {
        if (0 !== (lane & 4194048)) {
          var queueLanes = queue.lanes;
          queueLanes &= root2.pendingLanes;
          lane |= queueLanes;
          queue.lanes = lane;
          markRootEntangled(root2, lane);
        }
      }
      var ContextOnlyDispatcher = {
        readContext,
        use,
        useCallback: throwInvalidHookError,
        useContext: throwInvalidHookError,
        useEffect: throwInvalidHookError,
        useImperativeHandle: throwInvalidHookError,
        useLayoutEffect: throwInvalidHookError,
        useInsertionEffect: throwInvalidHookError,
        useMemo: throwInvalidHookError,
        useReducer: throwInvalidHookError,
        useRef: throwInvalidHookError,
        useState: throwInvalidHookError,
        useDebugValue: throwInvalidHookError,
        useDeferredValue: throwInvalidHookError,
        useTransition: throwInvalidHookError,
        useSyncExternalStore: throwInvalidHookError,
        useId: throwInvalidHookError,
        useHostTransitionStatus: throwInvalidHookError,
        useFormState: throwInvalidHookError,
        useActionState: throwInvalidHookError,
        useOptimistic: throwInvalidHookError,
        useMemoCache: throwInvalidHookError,
        useCacheRefresh: throwInvalidHookError
      };
      var HooksDispatcherOnMount = {
        readContext,
        use,
        useCallback: function(callback, deps) {
          mountWorkInProgressHook().memoizedState = [
            callback,
            void 0 === deps ? null : deps
          ];
          return callback;
        },
        useContext: readContext,
        useEffect: mountEffect,
        useImperativeHandle: function(ref, create, deps) {
          deps = null !== deps && void 0 !== deps ? deps.concat([ref]) : null;
          mountEffectImpl(
            4194308,
            4,
            imperativeHandleEffect.bind(null, create, ref),
            deps
          );
        },
        useLayoutEffect: function(create, deps) {
          return mountEffectImpl(4194308, 4, create, deps);
        },
        useInsertionEffect: function(create, deps) {
          mountEffectImpl(4, 2, create, deps);
        },
        useMemo: function(nextCreate, deps) {
          var hook = mountWorkInProgressHook();
          deps = void 0 === deps ? null : deps;
          var nextValue = nextCreate();
          if (shouldDoubleInvokeUserFnsInHooksDEV) {
            setIsStrictModeForDevtools(true);
            try {
              nextCreate();
            } finally {
              setIsStrictModeForDevtools(false);
            }
          }
          hook.memoizedState = [nextValue, deps];
          return nextValue;
        },
        useReducer: function(reducer, initialArg, init2) {
          var hook = mountWorkInProgressHook();
          if (void 0 !== init2) {
            var initialState = init2(initialArg);
            if (shouldDoubleInvokeUserFnsInHooksDEV) {
              setIsStrictModeForDevtools(true);
              try {
                init2(initialArg);
              } finally {
                setIsStrictModeForDevtools(false);
              }
            }
          } else initialState = initialArg;
          hook.memoizedState = hook.baseState = initialState;
          reducer = {
            pending: null,
            lanes: 0,
            dispatch: null,
            lastRenderedReducer: reducer,
            lastRenderedState: initialState
          };
          hook.queue = reducer;
          reducer = reducer.dispatch = dispatchReducerAction.bind(
            null,
            currentlyRenderingFiber,
            reducer
          );
          return [hook.memoizedState, reducer];
        },
        useRef: function(initialValue) {
          var hook = mountWorkInProgressHook();
          initialValue = { current: initialValue };
          return hook.memoizedState = initialValue;
        },
        useState: function(initialState) {
          initialState = mountStateImpl(initialState);
          var queue = initialState.queue, dispatch = dispatchSetState.bind(null, currentlyRenderingFiber, queue);
          queue.dispatch = dispatch;
          return [initialState.memoizedState, dispatch];
        },
        useDebugValue: mountDebugValue,
        useDeferredValue: function(value, initialValue) {
          var hook = mountWorkInProgressHook();
          return mountDeferredValueImpl(hook, value, initialValue);
        },
        useTransition: function() {
          var stateHook = mountStateImpl(false);
          stateHook = startTransition.bind(
            null,
            currentlyRenderingFiber,
            stateHook.queue,
            true,
            false
          );
          mountWorkInProgressHook().memoizedState = stateHook;
          return [false, stateHook];
        },
        useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
          var fiber = currentlyRenderingFiber, hook = mountWorkInProgressHook();
          if (isHydrating) {
            if (void 0 === getServerSnapshot)
              throw Error(formatProdErrorMessage(407));
            getServerSnapshot = getServerSnapshot();
          } else {
            getServerSnapshot = getSnapshot();
            if (null === workInProgressRoot)
              throw Error(formatProdErrorMessage(349));
            0 !== (workInProgressRootRenderLanes & 124) || pushStoreConsistencyCheck(fiber, getSnapshot, getServerSnapshot);
          }
          hook.memoizedState = getServerSnapshot;
          var inst = { value: getServerSnapshot, getSnapshot };
          hook.queue = inst;
          mountEffect(subscribeToStore.bind(null, fiber, inst, subscribe), [
            subscribe
          ]);
          fiber.flags |= 2048;
          pushSimpleEffect(
            9,
            createEffectInstance(),
            updateStoreInstance.bind(
              null,
              fiber,
              inst,
              getServerSnapshot,
              getSnapshot
            ),
            null
          );
          return getServerSnapshot;
        },
        useId: function() {
          var hook = mountWorkInProgressHook(), identifierPrefix = workInProgressRoot.identifierPrefix;
          if (isHydrating) {
            var JSCompiler_inline_result = treeContextOverflow;
            var idWithLeadingBit = treeContextId;
            JSCompiler_inline_result = (idWithLeadingBit & ~(1 << 32 - clz32(idWithLeadingBit) - 1)).toString(32) + JSCompiler_inline_result;
            identifierPrefix = "\xAB" + identifierPrefix + "R" + JSCompiler_inline_result;
            JSCompiler_inline_result = localIdCounter++;
            0 < JSCompiler_inline_result && (identifierPrefix += "H" + JSCompiler_inline_result.toString(32));
            identifierPrefix += "\xBB";
          } else
            JSCompiler_inline_result = globalClientIdCounter++, identifierPrefix = "\xAB" + identifierPrefix + "r" + JSCompiler_inline_result.toString(32) + "\xBB";
          return hook.memoizedState = identifierPrefix;
        },
        useHostTransitionStatus,
        useFormState: mountActionState,
        useActionState: mountActionState,
        useOptimistic: function(passthrough) {
          var hook = mountWorkInProgressHook();
          hook.memoizedState = hook.baseState = passthrough;
          var queue = {
            pending: null,
            lanes: 0,
            dispatch: null,
            lastRenderedReducer: null,
            lastRenderedState: null
          };
          hook.queue = queue;
          hook = dispatchOptimisticSetState.bind(
            null,
            currentlyRenderingFiber,
            true,
            queue
          );
          queue.dispatch = hook;
          return [passthrough, hook];
        },
        useMemoCache,
        useCacheRefresh: function() {
          return mountWorkInProgressHook().memoizedState = refreshCache.bind(
            null,
            currentlyRenderingFiber
          );
        }
      };
      var HooksDispatcherOnUpdate = {
        readContext,
        use,
        useCallback: updateCallback,
        useContext: readContext,
        useEffect: updateEffect,
        useImperativeHandle: updateImperativeHandle,
        useInsertionEffect: updateInsertionEffect,
        useLayoutEffect: updateLayoutEffect,
        useMemo: updateMemo,
        useReducer: updateReducer,
        useRef: updateRef,
        useState: function() {
          return updateReducer(basicStateReducer);
        },
        useDebugValue: mountDebugValue,
        useDeferredValue: function(value, initialValue) {
          var hook = updateWorkInProgressHook();
          return updateDeferredValueImpl(
            hook,
            currentHook.memoizedState,
            value,
            initialValue
          );
        },
        useTransition: function() {
          var booleanOrThenable = updateReducer(basicStateReducer)[0], start = updateWorkInProgressHook().memoizedState;
          return [
            "boolean" === typeof booleanOrThenable ? booleanOrThenable : useThenable(booleanOrThenable),
            start
          ];
        },
        useSyncExternalStore: updateSyncExternalStore,
        useId: updateId,
        useHostTransitionStatus,
        useFormState: updateActionState,
        useActionState: updateActionState,
        useOptimistic: function(passthrough, reducer) {
          var hook = updateWorkInProgressHook();
          return updateOptimisticImpl(hook, currentHook, passthrough, reducer);
        },
        useMemoCache,
        useCacheRefresh: updateRefresh
      };
      var HooksDispatcherOnRerender = {
        readContext,
        use,
        useCallback: updateCallback,
        useContext: readContext,
        useEffect: updateEffect,
        useImperativeHandle: updateImperativeHandle,
        useInsertionEffect: updateInsertionEffect,
        useLayoutEffect: updateLayoutEffect,
        useMemo: updateMemo,
        useReducer: rerenderReducer,
        useRef: updateRef,
        useState: function() {
          return rerenderReducer(basicStateReducer);
        },
        useDebugValue: mountDebugValue,
        useDeferredValue: function(value, initialValue) {
          var hook = updateWorkInProgressHook();
          return null === currentHook ? mountDeferredValueImpl(hook, value, initialValue) : updateDeferredValueImpl(
            hook,
            currentHook.memoizedState,
            value,
            initialValue
          );
        },
        useTransition: function() {
          var booleanOrThenable = rerenderReducer(basicStateReducer)[0], start = updateWorkInProgressHook().memoizedState;
          return [
            "boolean" === typeof booleanOrThenable ? booleanOrThenable : useThenable(booleanOrThenable),
            start
          ];
        },
        useSyncExternalStore: updateSyncExternalStore,
        useId: updateId,
        useHostTransitionStatus,
        useFormState: rerenderActionState,
        useActionState: rerenderActionState,
        useOptimistic: function(passthrough, reducer) {
          var hook = updateWorkInProgressHook();
          if (null !== currentHook)
            return updateOptimisticImpl(hook, currentHook, passthrough, reducer);
          hook.baseState = passthrough;
          return [passthrough, hook.queue.dispatch];
        },
        useMemoCache,
        useCacheRefresh: updateRefresh
      };
      var thenableState = null;
      var thenableIndexCounter = 0;
      function unwrapThenable(thenable) {
        var index3 = thenableIndexCounter;
        thenableIndexCounter += 1;
        null === thenableState && (thenableState = []);
        return trackUsedThenable(thenableState, thenable, index3);
      }
      function coerceRef(workInProgress2, element) {
        element = element.props.ref;
        workInProgress2.ref = void 0 !== element ? element : null;
      }
      function throwOnInvalidObjectType(returnFiber, newChild) {
        if (newChild.$$typeof === REACT_LEGACY_ELEMENT_TYPE)
          throw Error(formatProdErrorMessage(525));
        returnFiber = Object.prototype.toString.call(newChild);
        throw Error(
          formatProdErrorMessage(
            31,
            "[object Object]" === returnFiber ? "object with keys {" + Object.keys(newChild).join(", ") + "}" : returnFiber
          )
        );
      }
      function resolveLazy(lazyType) {
        var init2 = lazyType._init;
        return init2(lazyType._payload);
      }
      function createChildReconciler(shouldTrackSideEffects) {
        function deleteChild(returnFiber, childToDelete) {
          if (shouldTrackSideEffects) {
            var deletions = returnFiber.deletions;
            null === deletions ? (returnFiber.deletions = [childToDelete], returnFiber.flags |= 16) : deletions.push(childToDelete);
          }
        }
        function deleteRemainingChildren(returnFiber, currentFirstChild) {
          if (!shouldTrackSideEffects) return null;
          for (; null !== currentFirstChild; )
            deleteChild(returnFiber, currentFirstChild), currentFirstChild = currentFirstChild.sibling;
          return null;
        }
        function mapRemainingChildren(currentFirstChild) {
          for (var existingChildren = /* @__PURE__ */ new Map(); null !== currentFirstChild; )
            null !== currentFirstChild.key ? existingChildren.set(currentFirstChild.key, currentFirstChild) : existingChildren.set(currentFirstChild.index, currentFirstChild), currentFirstChild = currentFirstChild.sibling;
          return existingChildren;
        }
        function useFiber(fiber, pendingProps) {
          fiber = createWorkInProgress(fiber, pendingProps);
          fiber.index = 0;
          fiber.sibling = null;
          return fiber;
        }
        function placeChild(newFiber, lastPlacedIndex, newIndex) {
          newFiber.index = newIndex;
          if (!shouldTrackSideEffects)
            return newFiber.flags |= 1048576, lastPlacedIndex;
          newIndex = newFiber.alternate;
          if (null !== newIndex)
            return newIndex = newIndex.index, newIndex < lastPlacedIndex ? (newFiber.flags |= 67108866, lastPlacedIndex) : newIndex;
          newFiber.flags |= 67108866;
          return lastPlacedIndex;
        }
        function placeSingleChild(newFiber) {
          shouldTrackSideEffects && null === newFiber.alternate && (newFiber.flags |= 67108866);
          return newFiber;
        }
        function updateTextNode(returnFiber, current, textContent, lanes) {
          if (null === current || 6 !== current.tag)
            return current = createFiberFromText(textContent, returnFiber.mode, lanes), current.return = returnFiber, current;
          current = useFiber(current, textContent);
          current.return = returnFiber;
          return current;
        }
        function updateElement(returnFiber, current, element, lanes) {
          var elementType = element.type;
          if (elementType === REACT_FRAGMENT_TYPE)
            return updateFragment(
              returnFiber,
              current,
              element.props.children,
              lanes,
              element.key
            );
          if (null !== current && (current.elementType === elementType || "object" === typeof elementType && null !== elementType && elementType.$$typeof === REACT_LAZY_TYPE && resolveLazy(elementType) === current.type))
            return current = useFiber(current, element.props), coerceRef(current, element), current.return = returnFiber, current;
          current = createFiberFromTypeAndProps(
            element.type,
            element.key,
            element.props,
            null,
            returnFiber.mode,
            lanes
          );
          coerceRef(current, element);
          current.return = returnFiber;
          return current;
        }
        function updatePortal(returnFiber, current, portal, lanes) {
          if (null === current || 4 !== current.tag || current.stateNode.containerInfo !== portal.containerInfo || current.stateNode.implementation !== portal.implementation)
            return current = createFiberFromPortal(portal, returnFiber.mode, lanes), current.return = returnFiber, current;
          current = useFiber(current, portal.children || []);
          current.return = returnFiber;
          return current;
        }
        function updateFragment(returnFiber, current, fragment, lanes, key) {
          if (null === current || 7 !== current.tag)
            return current = createFiberFromFragment(
              fragment,
              returnFiber.mode,
              lanes,
              key
            ), current.return = returnFiber, current;
          current = useFiber(current, fragment);
          current.return = returnFiber;
          return current;
        }
        function createChild(returnFiber, newChild, lanes) {
          if ("string" === typeof newChild && "" !== newChild || "number" === typeof newChild || "bigint" === typeof newChild)
            return newChild = createFiberFromText(
              "" + newChild,
              returnFiber.mode,
              lanes
            ), newChild.return = returnFiber, newChild;
          if ("object" === typeof newChild && null !== newChild) {
            switch (newChild.$$typeof) {
              case REACT_ELEMENT_TYPE:
                return lanes = createFiberFromTypeAndProps(
                  newChild.type,
                  newChild.key,
                  newChild.props,
                  null,
                  returnFiber.mode,
                  lanes
                ), coerceRef(lanes, newChild), lanes.return = returnFiber, lanes;
              case REACT_PORTAL_TYPE:
                return newChild = createFiberFromPortal(
                  newChild,
                  returnFiber.mode,
                  lanes
                ), newChild.return = returnFiber, newChild;
              case REACT_LAZY_TYPE:
                var init2 = newChild._init;
                newChild = init2(newChild._payload);
                return createChild(returnFiber, newChild, lanes);
            }
            if (isArrayImpl(newChild) || getIteratorFn(newChild))
              return newChild = createFiberFromFragment(
                newChild,
                returnFiber.mode,
                lanes,
                null
              ), newChild.return = returnFiber, newChild;
            if ("function" === typeof newChild.then)
              return createChild(returnFiber, unwrapThenable(newChild), lanes);
            if (newChild.$$typeof === REACT_CONTEXT_TYPE)
              return createChild(
                returnFiber,
                readContextDuringReconciliation(returnFiber, newChild),
                lanes
              );
            throwOnInvalidObjectType(returnFiber, newChild);
          }
          return null;
        }
        function updateSlot(returnFiber, oldFiber, newChild, lanes) {
          var key = null !== oldFiber ? oldFiber.key : null;
          if ("string" === typeof newChild && "" !== newChild || "number" === typeof newChild || "bigint" === typeof newChild)
            return null !== key ? null : updateTextNode(returnFiber, oldFiber, "" + newChild, lanes);
          if ("object" === typeof newChild && null !== newChild) {
            switch (newChild.$$typeof) {
              case REACT_ELEMENT_TYPE:
                return newChild.key === key ? updateElement(returnFiber, oldFiber, newChild, lanes) : null;
              case REACT_PORTAL_TYPE:
                return newChild.key === key ? updatePortal(returnFiber, oldFiber, newChild, lanes) : null;
              case REACT_LAZY_TYPE:
                return key = newChild._init, newChild = key(newChild._payload), updateSlot(returnFiber, oldFiber, newChild, lanes);
            }
            if (isArrayImpl(newChild) || getIteratorFn(newChild))
              return null !== key ? null : updateFragment(returnFiber, oldFiber, newChild, lanes, null);
            if ("function" === typeof newChild.then)
              return updateSlot(
                returnFiber,
                oldFiber,
                unwrapThenable(newChild),
                lanes
              );
            if (newChild.$$typeof === REACT_CONTEXT_TYPE)
              return updateSlot(
                returnFiber,
                oldFiber,
                readContextDuringReconciliation(returnFiber, newChild),
                lanes
              );
            throwOnInvalidObjectType(returnFiber, newChild);
          }
          return null;
        }
        function updateFromMap(existingChildren, returnFiber, newIdx, newChild, lanes) {
          if ("string" === typeof newChild && "" !== newChild || "number" === typeof newChild || "bigint" === typeof newChild)
            return existingChildren = existingChildren.get(newIdx) || null, updateTextNode(returnFiber, existingChildren, "" + newChild, lanes);
          if ("object" === typeof newChild && null !== newChild) {
            switch (newChild.$$typeof) {
              case REACT_ELEMENT_TYPE:
                return existingChildren = existingChildren.get(
                  null === newChild.key ? newIdx : newChild.key
                ) || null, updateElement(returnFiber, existingChildren, newChild, lanes);
              case REACT_PORTAL_TYPE:
                return existingChildren = existingChildren.get(
                  null === newChild.key ? newIdx : newChild.key
                ) || null, updatePortal(returnFiber, existingChildren, newChild, lanes);
              case REACT_LAZY_TYPE:
                var init2 = newChild._init;
                newChild = init2(newChild._payload);
                return updateFromMap(
                  existingChildren,
                  returnFiber,
                  newIdx,
                  newChild,
                  lanes
                );
            }
            if (isArrayImpl(newChild) || getIteratorFn(newChild))
              return existingChildren = existingChildren.get(newIdx) || null, updateFragment(returnFiber, existingChildren, newChild, lanes, null);
            if ("function" === typeof newChild.then)
              return updateFromMap(
                existingChildren,
                returnFiber,
                newIdx,
                unwrapThenable(newChild),
                lanes
              );
            if (newChild.$$typeof === REACT_CONTEXT_TYPE)
              return updateFromMap(
                existingChildren,
                returnFiber,
                newIdx,
                readContextDuringReconciliation(returnFiber, newChild),
                lanes
              );
            throwOnInvalidObjectType(returnFiber, newChild);
          }
          return null;
        }
        function reconcileChildrenArray(returnFiber, currentFirstChild, newChildren, lanes) {
          for (var resultingFirstChild = null, previousNewFiber = null, oldFiber = currentFirstChild, newIdx = currentFirstChild = 0, nextOldFiber = null; null !== oldFiber && newIdx < newChildren.length; newIdx++) {
            oldFiber.index > newIdx ? (nextOldFiber = oldFiber, oldFiber = null) : nextOldFiber = oldFiber.sibling;
            var newFiber = updateSlot(
              returnFiber,
              oldFiber,
              newChildren[newIdx],
              lanes
            );
            if (null === newFiber) {
              null === oldFiber && (oldFiber = nextOldFiber);
              break;
            }
            shouldTrackSideEffects && oldFiber && null === newFiber.alternate && deleteChild(returnFiber, oldFiber);
            currentFirstChild = placeChild(newFiber, currentFirstChild, newIdx);
            null === previousNewFiber ? resultingFirstChild = newFiber : previousNewFiber.sibling = newFiber;
            previousNewFiber = newFiber;
            oldFiber = nextOldFiber;
          }
          if (newIdx === newChildren.length)
            return deleteRemainingChildren(returnFiber, oldFiber), isHydrating && pushTreeFork(returnFiber, newIdx), resultingFirstChild;
          if (null === oldFiber) {
            for (; newIdx < newChildren.length; newIdx++)
              oldFiber = createChild(returnFiber, newChildren[newIdx], lanes), null !== oldFiber && (currentFirstChild = placeChild(
                oldFiber,
                currentFirstChild,
                newIdx
              ), null === previousNewFiber ? resultingFirstChild = oldFiber : previousNewFiber.sibling = oldFiber, previousNewFiber = oldFiber);
            isHydrating && pushTreeFork(returnFiber, newIdx);
            return resultingFirstChild;
          }
          for (oldFiber = mapRemainingChildren(oldFiber); newIdx < newChildren.length; newIdx++)
            nextOldFiber = updateFromMap(
              oldFiber,
              returnFiber,
              newIdx,
              newChildren[newIdx],
              lanes
            ), null !== nextOldFiber && (shouldTrackSideEffects && null !== nextOldFiber.alternate && oldFiber.delete(
              null === nextOldFiber.key ? newIdx : nextOldFiber.key
            ), currentFirstChild = placeChild(
              nextOldFiber,
              currentFirstChild,
              newIdx
            ), null === previousNewFiber ? resultingFirstChild = nextOldFiber : previousNewFiber.sibling = nextOldFiber, previousNewFiber = nextOldFiber);
          shouldTrackSideEffects && oldFiber.forEach(function(child) {
            return deleteChild(returnFiber, child);
          });
          isHydrating && pushTreeFork(returnFiber, newIdx);
          return resultingFirstChild;
        }
        function reconcileChildrenIterator(returnFiber, currentFirstChild, newChildren, lanes) {
          if (null == newChildren) throw Error(formatProdErrorMessage(151));
          for (var resultingFirstChild = null, previousNewFiber = null, oldFiber = currentFirstChild, newIdx = currentFirstChild = 0, nextOldFiber = null, step = newChildren.next(); null !== oldFiber && !step.done; newIdx++, step = newChildren.next()) {
            oldFiber.index > newIdx ? (nextOldFiber = oldFiber, oldFiber = null) : nextOldFiber = oldFiber.sibling;
            var newFiber = updateSlot(returnFiber, oldFiber, step.value, lanes);
            if (null === newFiber) {
              null === oldFiber && (oldFiber = nextOldFiber);
              break;
            }
            shouldTrackSideEffects && oldFiber && null === newFiber.alternate && deleteChild(returnFiber, oldFiber);
            currentFirstChild = placeChild(newFiber, currentFirstChild, newIdx);
            null === previousNewFiber ? resultingFirstChild = newFiber : previousNewFiber.sibling = newFiber;
            previousNewFiber = newFiber;
            oldFiber = nextOldFiber;
          }
          if (step.done)
            return deleteRemainingChildren(returnFiber, oldFiber), isHydrating && pushTreeFork(returnFiber, newIdx), resultingFirstChild;
          if (null === oldFiber) {
            for (; !step.done; newIdx++, step = newChildren.next())
              step = createChild(returnFiber, step.value, lanes), null !== step && (currentFirstChild = placeChild(step, currentFirstChild, newIdx), null === previousNewFiber ? resultingFirstChild = step : previousNewFiber.sibling = step, previousNewFiber = step);
            isHydrating && pushTreeFork(returnFiber, newIdx);
            return resultingFirstChild;
          }
          for (oldFiber = mapRemainingChildren(oldFiber); !step.done; newIdx++, step = newChildren.next())
            step = updateFromMap(oldFiber, returnFiber, newIdx, step.value, lanes), null !== step && (shouldTrackSideEffects && null !== step.alternate && oldFiber.delete(null === step.key ? newIdx : step.key), currentFirstChild = placeChild(step, currentFirstChild, newIdx), null === previousNewFiber ? resultingFirstChild = step : previousNewFiber.sibling = step, previousNewFiber = step);
          shouldTrackSideEffects && oldFiber.forEach(function(child) {
            return deleteChild(returnFiber, child);
          });
          isHydrating && pushTreeFork(returnFiber, newIdx);
          return resultingFirstChild;
        }
        function reconcileChildFibersImpl(returnFiber, currentFirstChild, newChild, lanes) {
          "object" === typeof newChild && null !== newChild && newChild.type === REACT_FRAGMENT_TYPE && null === newChild.key && (newChild = newChild.props.children);
          if ("object" === typeof newChild && null !== newChild) {
            switch (newChild.$$typeof) {
              case REACT_ELEMENT_TYPE:
                a: {
                  for (var key = newChild.key; null !== currentFirstChild; ) {
                    if (currentFirstChild.key === key) {
                      key = newChild.type;
                      if (key === REACT_FRAGMENT_TYPE) {
                        if (7 === currentFirstChild.tag) {
                          deleteRemainingChildren(
                            returnFiber,
                            currentFirstChild.sibling
                          );
                          lanes = useFiber(
                            currentFirstChild,
                            newChild.props.children
                          );
                          lanes.return = returnFiber;
                          returnFiber = lanes;
                          break a;
                        }
                      } else if (currentFirstChild.elementType === key || "object" === typeof key && null !== key && key.$$typeof === REACT_LAZY_TYPE && resolveLazy(key) === currentFirstChild.type) {
                        deleteRemainingChildren(
                          returnFiber,
                          currentFirstChild.sibling
                        );
                        lanes = useFiber(currentFirstChild, newChild.props);
                        coerceRef(lanes, newChild);
                        lanes.return = returnFiber;
                        returnFiber = lanes;
                        break a;
                      }
                      deleteRemainingChildren(returnFiber, currentFirstChild);
                      break;
                    } else deleteChild(returnFiber, currentFirstChild);
                    currentFirstChild = currentFirstChild.sibling;
                  }
                  newChild.type === REACT_FRAGMENT_TYPE ? (lanes = createFiberFromFragment(
                    newChild.props.children,
                    returnFiber.mode,
                    lanes,
                    newChild.key
                  ), lanes.return = returnFiber, returnFiber = lanes) : (lanes = createFiberFromTypeAndProps(
                    newChild.type,
                    newChild.key,
                    newChild.props,
                    null,
                    returnFiber.mode,
                    lanes
                  ), coerceRef(lanes, newChild), lanes.return = returnFiber, returnFiber = lanes);
                }
                return placeSingleChild(returnFiber);
              case REACT_PORTAL_TYPE:
                a: {
                  for (key = newChild.key; null !== currentFirstChild; ) {
                    if (currentFirstChild.key === key)
                      if (4 === currentFirstChild.tag && currentFirstChild.stateNode.containerInfo === newChild.containerInfo && currentFirstChild.stateNode.implementation === newChild.implementation) {
                        deleteRemainingChildren(
                          returnFiber,
                          currentFirstChild.sibling
                        );
                        lanes = useFiber(currentFirstChild, newChild.children || []);
                        lanes.return = returnFiber;
                        returnFiber = lanes;
                        break a;
                      } else {
                        deleteRemainingChildren(returnFiber, currentFirstChild);
                        break;
                      }
                    else deleteChild(returnFiber, currentFirstChild);
                    currentFirstChild = currentFirstChild.sibling;
                  }
                  lanes = createFiberFromPortal(newChild, returnFiber.mode, lanes);
                  lanes.return = returnFiber;
                  returnFiber = lanes;
                }
                return placeSingleChild(returnFiber);
              case REACT_LAZY_TYPE:
                return key = newChild._init, newChild = key(newChild._payload), reconcileChildFibersImpl(
                  returnFiber,
                  currentFirstChild,
                  newChild,
                  lanes
                );
            }
            if (isArrayImpl(newChild))
              return reconcileChildrenArray(
                returnFiber,
                currentFirstChild,
                newChild,
                lanes
              );
            if (getIteratorFn(newChild)) {
              key = getIteratorFn(newChild);
              if ("function" !== typeof key) throw Error(formatProdErrorMessage(150));
              newChild = key.call(newChild);
              return reconcileChildrenIterator(
                returnFiber,
                currentFirstChild,
                newChild,
                lanes
              );
            }
            if ("function" === typeof newChild.then)
              return reconcileChildFibersImpl(
                returnFiber,
                currentFirstChild,
                unwrapThenable(newChild),
                lanes
              );
            if (newChild.$$typeof === REACT_CONTEXT_TYPE)
              return reconcileChildFibersImpl(
                returnFiber,
                currentFirstChild,
                readContextDuringReconciliation(returnFiber, newChild),
                lanes
              );
            throwOnInvalidObjectType(returnFiber, newChild);
          }
          return "string" === typeof newChild && "" !== newChild || "number" === typeof newChild || "bigint" === typeof newChild ? (newChild = "" + newChild, null !== currentFirstChild && 6 === currentFirstChild.tag ? (deleteRemainingChildren(returnFiber, currentFirstChild.sibling), lanes = useFiber(currentFirstChild, newChild), lanes.return = returnFiber, returnFiber = lanes) : (deleteRemainingChildren(returnFiber, currentFirstChild), lanes = createFiberFromText(newChild, returnFiber.mode, lanes), lanes.return = returnFiber, returnFiber = lanes), placeSingleChild(returnFiber)) : deleteRemainingChildren(returnFiber, currentFirstChild);
        }
        return function(returnFiber, currentFirstChild, newChild, lanes) {
          try {
            thenableIndexCounter = 0;
            var firstChildFiber = reconcileChildFibersImpl(
              returnFiber,
              currentFirstChild,
              newChild,
              lanes
            );
            thenableState = null;
            return firstChildFiber;
          } catch (x) {
            if (x === SuspenseException || x === SuspenseActionException) throw x;
            var fiber = createFiberImplClass(29, x, null, returnFiber.mode);
            fiber.lanes = lanes;
            fiber.return = returnFiber;
            return fiber;
          } finally {
          }
        };
      }
      var reconcileChildFibers = createChildReconciler(true);
      var mountChildFibers = createChildReconciler(false);
      var suspenseHandlerStackCursor = createCursor2(null);
      var shellBoundary = null;
      function pushPrimaryTreeSuspenseHandler(handler) {
        var current = handler.alternate;
        push(suspenseStackCursor, suspenseStackCursor.current & 1);
        push(suspenseHandlerStackCursor, handler);
        null === shellBoundary && (null === current || null !== currentTreeHiddenStackCursor.current ? shellBoundary = handler : null !== current.memoizedState && (shellBoundary = handler));
      }
      function pushOffscreenSuspenseHandler(fiber) {
        if (22 === fiber.tag) {
          if (push(suspenseStackCursor, suspenseStackCursor.current), push(suspenseHandlerStackCursor, fiber), null === shellBoundary) {
            var current = fiber.alternate;
            null !== current && null !== current.memoizedState && (shellBoundary = fiber);
          }
        } else reuseSuspenseHandlerOnStack(fiber);
      }
      function reuseSuspenseHandlerOnStack() {
        push(suspenseStackCursor, suspenseStackCursor.current);
        push(suspenseHandlerStackCursor, suspenseHandlerStackCursor.current);
      }
      function popSuspenseHandler(fiber) {
        pop(suspenseHandlerStackCursor);
        shellBoundary === fiber && (shellBoundary = null);
        pop(suspenseStackCursor);
      }
      var suspenseStackCursor = createCursor2(0);
      function findFirstSuspended(row) {
        for (var node = row; null !== node; ) {
          if (13 === node.tag) {
            var state = node.memoizedState;
            if (null !== state && (state = state.dehydrated, null === state || "$?" === state.data || isSuspenseInstanceFallback(state)))
              return node;
          } else if (19 === node.tag && void 0 !== node.memoizedProps.revealOrder) {
            if (0 !== (node.flags & 128)) return node;
          } else if (null !== node.child) {
            node.child.return = node;
            node = node.child;
            continue;
          }
          if (node === row) break;
          for (; null === node.sibling; ) {
            if (null === node.return || node.return === row) return null;
            node = node.return;
          }
          node.sibling.return = node.return;
          node = node.sibling;
        }
        return null;
      }
      function applyDerivedStateFromProps(workInProgress2, ctor, getDerivedStateFromProps, nextProps) {
        ctor = workInProgress2.memoizedState;
        getDerivedStateFromProps = getDerivedStateFromProps(nextProps, ctor);
        getDerivedStateFromProps = null === getDerivedStateFromProps || void 0 === getDerivedStateFromProps ? ctor : assign({}, ctor, getDerivedStateFromProps);
        workInProgress2.memoizedState = getDerivedStateFromProps;
        0 === workInProgress2.lanes && (workInProgress2.updateQueue.baseState = getDerivedStateFromProps);
      }
      var classComponentUpdater = {
        enqueueSetState: function(inst, payload, callback) {
          inst = inst._reactInternals;
          var lane = requestUpdateLane(), update = createUpdate(lane);
          update.payload = payload;
          void 0 !== callback && null !== callback && (update.callback = callback);
          payload = enqueueUpdate(inst, update, lane);
          null !== payload && (scheduleUpdateOnFiber(payload, inst, lane), entangleTransitions(payload, inst, lane));
        },
        enqueueReplaceState: function(inst, payload, callback) {
          inst = inst._reactInternals;
          var lane = requestUpdateLane(), update = createUpdate(lane);
          update.tag = 1;
          update.payload = payload;
          void 0 !== callback && null !== callback && (update.callback = callback);
          payload = enqueueUpdate(inst, update, lane);
          null !== payload && (scheduleUpdateOnFiber(payload, inst, lane), entangleTransitions(payload, inst, lane));
        },
        enqueueForceUpdate: function(inst, callback) {
          inst = inst._reactInternals;
          var lane = requestUpdateLane(), update = createUpdate(lane);
          update.tag = 2;
          void 0 !== callback && null !== callback && (update.callback = callback);
          callback = enqueueUpdate(inst, update, lane);
          null !== callback && (scheduleUpdateOnFiber(callback, inst, lane), entangleTransitions(callback, inst, lane));
        }
      };
      function checkShouldComponentUpdate(workInProgress2, ctor, oldProps, newProps, oldState, newState, nextContext) {
        workInProgress2 = workInProgress2.stateNode;
        return "function" === typeof workInProgress2.shouldComponentUpdate ? workInProgress2.shouldComponentUpdate(newProps, newState, nextContext) : ctor.prototype && ctor.prototype.isPureReactComponent ? !shallowEqual(oldProps, newProps) || !shallowEqual(oldState, newState) : true;
      }
      function callComponentWillReceiveProps(workInProgress2, instance, newProps, nextContext) {
        workInProgress2 = instance.state;
        "function" === typeof instance.componentWillReceiveProps && instance.componentWillReceiveProps(newProps, nextContext);
        "function" === typeof instance.UNSAFE_componentWillReceiveProps && instance.UNSAFE_componentWillReceiveProps(newProps, nextContext);
        instance.state !== workInProgress2 && classComponentUpdater.enqueueReplaceState(instance, instance.state, null);
      }
      function resolveClassComponentProps(Component, baseProps) {
        var newProps = baseProps;
        if ("ref" in baseProps) {
          newProps = {};
          for (var propName in baseProps)
            "ref" !== propName && (newProps[propName] = baseProps[propName]);
        }
        if (Component = Component.defaultProps) {
          newProps === baseProps && (newProps = assign({}, newProps));
          for (var propName$73 in Component)
            void 0 === newProps[propName$73] && (newProps[propName$73] = Component[propName$73]);
        }
        return newProps;
      }
      var reportGlobalError = "function" === typeof reportError ? reportError : function(error) {
        if ("object" === typeof window && "function" === typeof window.ErrorEvent) {
          var event = new window.ErrorEvent("error", {
            bubbles: true,
            cancelable: true,
            message: "object" === typeof error && null !== error && "string" === typeof error.message ? String(error.message) : String(error),
            error
          });
          if (!window.dispatchEvent(event)) return;
        } else if ("object" === typeof process && "function" === typeof process.emit) {
          process.emit("uncaughtException", error);
          return;
        }
        console.error(error);
      };
      function defaultOnUncaughtError(error) {
        reportGlobalError(error);
      }
      function defaultOnCaughtError(error) {
        console.error(error);
      }
      function defaultOnRecoverableError(error) {
        reportGlobalError(error);
      }
      function logUncaughtError(root2, errorInfo) {
        try {
          var onUncaughtError = root2.onUncaughtError;
          onUncaughtError(errorInfo.value, { componentStack: errorInfo.stack });
        } catch (e$74) {
          setTimeout(function() {
            throw e$74;
          });
        }
      }
      function logCaughtError(root2, boundary, errorInfo) {
        try {
          var onCaughtError = root2.onCaughtError;
          onCaughtError(errorInfo.value, {
            componentStack: errorInfo.stack,
            errorBoundary: 1 === boundary.tag ? boundary.stateNode : null
          });
        } catch (e$75) {
          setTimeout(function() {
            throw e$75;
          });
        }
      }
      function createRootErrorUpdate(root2, errorInfo, lane) {
        lane = createUpdate(lane);
        lane.tag = 3;
        lane.payload = { element: null };
        lane.callback = function() {
          logUncaughtError(root2, errorInfo);
        };
        return lane;
      }
      function createClassErrorUpdate(lane) {
        lane = createUpdate(lane);
        lane.tag = 3;
        return lane;
      }
      function initializeClassErrorUpdate(update, root2, fiber, errorInfo) {
        var getDerivedStateFromError = fiber.type.getDerivedStateFromError;
        if ("function" === typeof getDerivedStateFromError) {
          var error = errorInfo.value;
          update.payload = function() {
            return getDerivedStateFromError(error);
          };
          update.callback = function() {
            logCaughtError(root2, fiber, errorInfo);
          };
        }
        var inst = fiber.stateNode;
        null !== inst && "function" === typeof inst.componentDidCatch && (update.callback = function() {
          logCaughtError(root2, fiber, errorInfo);
          "function" !== typeof getDerivedStateFromError && (null === legacyErrorBoundariesThatAlreadyFailed ? legacyErrorBoundariesThatAlreadyFailed = /* @__PURE__ */ new Set([this]) : legacyErrorBoundariesThatAlreadyFailed.add(this));
          var stack = errorInfo.stack;
          this.componentDidCatch(errorInfo.value, {
            componentStack: null !== stack ? stack : ""
          });
        });
      }
      function throwException(root2, returnFiber, sourceFiber, value, rootRenderLanes) {
        sourceFiber.flags |= 32768;
        if (null !== value && "object" === typeof value && "function" === typeof value.then) {
          returnFiber = sourceFiber.alternate;
          null !== returnFiber && propagateParentContextChanges(
            returnFiber,
            sourceFiber,
            rootRenderLanes,
            true
          );
          sourceFiber = suspenseHandlerStackCursor.current;
          if (null !== sourceFiber) {
            switch (sourceFiber.tag) {
              case 13:
                return null === shellBoundary ? renderDidSuspendDelayIfPossible() : null === sourceFiber.alternate && 0 === workInProgressRootExitStatus && (workInProgressRootExitStatus = 3), sourceFiber.flags &= -257, sourceFiber.flags |= 65536, sourceFiber.lanes = rootRenderLanes, value === noopSuspenseyCommitThenable ? sourceFiber.flags |= 16384 : (returnFiber = sourceFiber.updateQueue, null === returnFiber ? sourceFiber.updateQueue = /* @__PURE__ */ new Set([value]) : returnFiber.add(value), attachPingListener(root2, value, rootRenderLanes)), false;
              case 22:
                return sourceFiber.flags |= 65536, value === noopSuspenseyCommitThenable ? sourceFiber.flags |= 16384 : (returnFiber = sourceFiber.updateQueue, null === returnFiber ? (returnFiber = {
                  transitions: null,
                  markerInstances: null,
                  retryQueue: /* @__PURE__ */ new Set([value])
                }, sourceFiber.updateQueue = returnFiber) : (sourceFiber = returnFiber.retryQueue, null === sourceFiber ? returnFiber.retryQueue = /* @__PURE__ */ new Set([value]) : sourceFiber.add(value)), attachPingListener(root2, value, rootRenderLanes)), false;
            }
            throw Error(formatProdErrorMessage(435, sourceFiber.tag));
          }
          attachPingListener(root2, value, rootRenderLanes);
          renderDidSuspendDelayIfPossible();
          return false;
        }
        if (isHydrating)
          return returnFiber = suspenseHandlerStackCursor.current, null !== returnFiber ? (0 === (returnFiber.flags & 65536) && (returnFiber.flags |= 256), returnFiber.flags |= 65536, returnFiber.lanes = rootRenderLanes, value !== HydrationMismatchException && (root2 = Error(formatProdErrorMessage(422), { cause: value }), queueHydrationError(createCapturedValueAtFiber(root2, sourceFiber)))) : (value !== HydrationMismatchException && (returnFiber = Error(formatProdErrorMessage(423), {
            cause: value
          }), queueHydrationError(
            createCapturedValueAtFiber(returnFiber, sourceFiber)
          )), root2 = root2.current.alternate, root2.flags |= 65536, rootRenderLanes &= -rootRenderLanes, root2.lanes |= rootRenderLanes, value = createCapturedValueAtFiber(value, sourceFiber), rootRenderLanes = createRootErrorUpdate(
            root2.stateNode,
            value,
            rootRenderLanes
          ), enqueueCapturedUpdate(root2, rootRenderLanes), 4 !== workInProgressRootExitStatus && (workInProgressRootExitStatus = 2)), false;
        var wrapperError = Error(formatProdErrorMessage(520), { cause: value });
        wrapperError = createCapturedValueAtFiber(wrapperError, sourceFiber);
        null === workInProgressRootConcurrentErrors ? workInProgressRootConcurrentErrors = [wrapperError] : workInProgressRootConcurrentErrors.push(wrapperError);
        4 !== workInProgressRootExitStatus && (workInProgressRootExitStatus = 2);
        if (null === returnFiber) return true;
        value = createCapturedValueAtFiber(value, sourceFiber);
        sourceFiber = returnFiber;
        do {
          switch (sourceFiber.tag) {
            case 3:
              return sourceFiber.flags |= 65536, root2 = rootRenderLanes & -rootRenderLanes, sourceFiber.lanes |= root2, root2 = createRootErrorUpdate(sourceFiber.stateNode, value, root2), enqueueCapturedUpdate(sourceFiber, root2), false;
            case 1:
              if (returnFiber = sourceFiber.type, wrapperError = sourceFiber.stateNode, 0 === (sourceFiber.flags & 128) && ("function" === typeof returnFiber.getDerivedStateFromError || null !== wrapperError && "function" === typeof wrapperError.componentDidCatch && (null === legacyErrorBoundariesThatAlreadyFailed || !legacyErrorBoundariesThatAlreadyFailed.has(wrapperError))))
                return sourceFiber.flags |= 65536, rootRenderLanes &= -rootRenderLanes, sourceFiber.lanes |= rootRenderLanes, rootRenderLanes = createClassErrorUpdate(rootRenderLanes), initializeClassErrorUpdate(
                  rootRenderLanes,
                  root2,
                  sourceFiber,
                  value
                ), enqueueCapturedUpdate(sourceFiber, rootRenderLanes), false;
          }
          sourceFiber = sourceFiber.return;
        } while (null !== sourceFiber);
        return false;
      }
      var SelectiveHydrationException = Error(formatProdErrorMessage(461));
      var didReceiveUpdate = false;
      function reconcileChildren(current, workInProgress2, nextChildren, renderLanes2) {
        workInProgress2.child = null === current ? mountChildFibers(workInProgress2, null, nextChildren, renderLanes2) : reconcileChildFibers(
          workInProgress2,
          current.child,
          nextChildren,
          renderLanes2
        );
      }
      function updateForwardRef(current, workInProgress2, Component, nextProps, renderLanes2) {
        Component = Component.render;
        var ref = workInProgress2.ref;
        if ("ref" in nextProps) {
          var propsWithoutRef = {};
          for (var key in nextProps)
            "ref" !== key && (propsWithoutRef[key] = nextProps[key]);
        } else propsWithoutRef = nextProps;
        prepareToReadContext(workInProgress2);
        nextProps = renderWithHooks(
          current,
          workInProgress2,
          Component,
          propsWithoutRef,
          ref,
          renderLanes2
        );
        key = checkDidRenderIdHook();
        if (null !== current && !didReceiveUpdate)
          return bailoutHooks(current, workInProgress2, renderLanes2), bailoutOnAlreadyFinishedWork(current, workInProgress2, renderLanes2);
        isHydrating && key && pushMaterializedTreeId(workInProgress2);
        workInProgress2.flags |= 1;
        reconcileChildren(current, workInProgress2, nextProps, renderLanes2);
        return workInProgress2.child;
      }
      function updateMemoComponent(current, workInProgress2, Component, nextProps, renderLanes2) {
        if (null === current) {
          var type = Component.type;
          if ("function" === typeof type && !shouldConstruct(type) && void 0 === type.defaultProps && null === Component.compare)
            return workInProgress2.tag = 15, workInProgress2.type = type, updateSimpleMemoComponent(
              current,
              workInProgress2,
              type,
              nextProps,
              renderLanes2
            );
          current = createFiberFromTypeAndProps(
            Component.type,
            null,
            nextProps,
            workInProgress2,
            workInProgress2.mode,
            renderLanes2
          );
          current.ref = workInProgress2.ref;
          current.return = workInProgress2;
          return workInProgress2.child = current;
        }
        type = current.child;
        if (!checkScheduledUpdateOrContext(current, renderLanes2)) {
          var prevProps = type.memoizedProps;
          Component = Component.compare;
          Component = null !== Component ? Component : shallowEqual;
          if (Component(prevProps, nextProps) && current.ref === workInProgress2.ref)
            return bailoutOnAlreadyFinishedWork(current, workInProgress2, renderLanes2);
        }
        workInProgress2.flags |= 1;
        current = createWorkInProgress(type, nextProps);
        current.ref = workInProgress2.ref;
        current.return = workInProgress2;
        return workInProgress2.child = current;
      }
      function updateSimpleMemoComponent(current, workInProgress2, Component, nextProps, renderLanes2) {
        if (null !== current) {
          var prevProps = current.memoizedProps;
          if (shallowEqual(prevProps, nextProps) && current.ref === workInProgress2.ref)
            if (didReceiveUpdate = false, workInProgress2.pendingProps = nextProps = prevProps, checkScheduledUpdateOrContext(current, renderLanes2))
              0 !== (current.flags & 131072) && (didReceiveUpdate = true);
            else
              return workInProgress2.lanes = current.lanes, bailoutOnAlreadyFinishedWork(current, workInProgress2, renderLanes2);
        }
        return updateFunctionComponent(
          current,
          workInProgress2,
          Component,
          nextProps,
          renderLanes2
        );
      }
      function updateOffscreenComponent(current, workInProgress2, renderLanes2) {
        var nextProps = workInProgress2.pendingProps, nextChildren = nextProps.children, prevState = null !== current ? current.memoizedState : null;
        if ("hidden" === nextProps.mode) {
          if (0 !== (workInProgress2.flags & 128)) {
            nextProps = null !== prevState ? prevState.baseLanes | renderLanes2 : renderLanes2;
            if (null !== current) {
              nextChildren = workInProgress2.child = current.child;
              for (prevState = 0; null !== nextChildren; )
                prevState = prevState | nextChildren.lanes | nextChildren.childLanes, nextChildren = nextChildren.sibling;
              workInProgress2.childLanes = prevState & ~nextProps;
            } else workInProgress2.childLanes = 0, workInProgress2.child = null;
            return deferHiddenOffscreenComponent(
              current,
              workInProgress2,
              nextProps,
              renderLanes2
            );
          }
          if (0 !== (renderLanes2 & 536870912))
            workInProgress2.memoizedState = { baseLanes: 0, cachePool: null }, null !== current && pushTransition(
              workInProgress2,
              null !== prevState ? prevState.cachePool : null
            ), null !== prevState ? pushHiddenContext(workInProgress2, prevState) : reuseHiddenContextOnStack(), pushOffscreenSuspenseHandler(workInProgress2);
          else
            return workInProgress2.lanes = workInProgress2.childLanes = 536870912, deferHiddenOffscreenComponent(
              current,
              workInProgress2,
              null !== prevState ? prevState.baseLanes | renderLanes2 : renderLanes2,
              renderLanes2
            );
        } else
          null !== prevState ? (pushTransition(workInProgress2, prevState.cachePool), pushHiddenContext(workInProgress2, prevState), reuseSuspenseHandlerOnStack(workInProgress2), workInProgress2.memoizedState = null) : (null !== current && pushTransition(workInProgress2, null), reuseHiddenContextOnStack(), reuseSuspenseHandlerOnStack(workInProgress2));
        reconcileChildren(current, workInProgress2, nextChildren, renderLanes2);
        return workInProgress2.child;
      }
      function deferHiddenOffscreenComponent(current, workInProgress2, nextBaseLanes, renderLanes2) {
        var JSCompiler_inline_result = peekCacheFromPool();
        JSCompiler_inline_result = null === JSCompiler_inline_result ? null : { parent: CacheContext._currentValue, pool: JSCompiler_inline_result };
        workInProgress2.memoizedState = {
          baseLanes: nextBaseLanes,
          cachePool: JSCompiler_inline_result
        };
        null !== current && pushTransition(workInProgress2, null);
        reuseHiddenContextOnStack();
        pushOffscreenSuspenseHandler(workInProgress2);
        null !== current && propagateParentContextChanges(current, workInProgress2, renderLanes2, true);
        return null;
      }
      function markRef(current, workInProgress2) {
        var ref = workInProgress2.ref;
        if (null === ref)
          null !== current && null !== current.ref && (workInProgress2.flags |= 4194816);
        else {
          if ("function" !== typeof ref && "object" !== typeof ref)
            throw Error(formatProdErrorMessage(284));
          if (null === current || current.ref !== ref)
            workInProgress2.flags |= 4194816;
        }
      }
      function updateFunctionComponent(current, workInProgress2, Component, nextProps, renderLanes2) {
        prepareToReadContext(workInProgress2);
        Component = renderWithHooks(
          current,
          workInProgress2,
          Component,
          nextProps,
          void 0,
          renderLanes2
        );
        nextProps = checkDidRenderIdHook();
        if (null !== current && !didReceiveUpdate)
          return bailoutHooks(current, workInProgress2, renderLanes2), bailoutOnAlreadyFinishedWork(current, workInProgress2, renderLanes2);
        isHydrating && nextProps && pushMaterializedTreeId(workInProgress2);
        workInProgress2.flags |= 1;
        reconcileChildren(current, workInProgress2, Component, renderLanes2);
        return workInProgress2.child;
      }
      function replayFunctionComponent(current, workInProgress2, nextProps, Component, secondArg, renderLanes2) {
        prepareToReadContext(workInProgress2);
        workInProgress2.updateQueue = null;
        nextProps = renderWithHooksAgain(
          workInProgress2,
          Component,
          nextProps,
          secondArg
        );
        finishRenderingHooks(current);
        Component = checkDidRenderIdHook();
        if (null !== current && !didReceiveUpdate)
          return bailoutHooks(current, workInProgress2, renderLanes2), bailoutOnAlreadyFinishedWork(current, workInProgress2, renderLanes2);
        isHydrating && Component && pushMaterializedTreeId(workInProgress2);
        workInProgress2.flags |= 1;
        reconcileChildren(current, workInProgress2, nextProps, renderLanes2);
        return workInProgress2.child;
      }
      function updateClassComponent(current, workInProgress2, Component, nextProps, renderLanes2) {
        prepareToReadContext(workInProgress2);
        if (null === workInProgress2.stateNode) {
          var context = emptyContextObject, contextType = Component.contextType;
          "object" === typeof contextType && null !== contextType && (context = readContext(contextType));
          context = new Component(nextProps, context);
          workInProgress2.memoizedState = null !== context.state && void 0 !== context.state ? context.state : null;
          context.updater = classComponentUpdater;
          workInProgress2.stateNode = context;
          context._reactInternals = workInProgress2;
          context = workInProgress2.stateNode;
          context.props = nextProps;
          context.state = workInProgress2.memoizedState;
          context.refs = {};
          initializeUpdateQueue(workInProgress2);
          contextType = Component.contextType;
          context.context = "object" === typeof contextType && null !== contextType ? readContext(contextType) : emptyContextObject;
          context.state = workInProgress2.memoizedState;
          contextType = Component.getDerivedStateFromProps;
          "function" === typeof contextType && (applyDerivedStateFromProps(
            workInProgress2,
            Component,
            contextType,
            nextProps
          ), context.state = workInProgress2.memoizedState);
          "function" === typeof Component.getDerivedStateFromProps || "function" === typeof context.getSnapshotBeforeUpdate || "function" !== typeof context.UNSAFE_componentWillMount && "function" !== typeof context.componentWillMount || (contextType = context.state, "function" === typeof context.componentWillMount && context.componentWillMount(), "function" === typeof context.UNSAFE_componentWillMount && context.UNSAFE_componentWillMount(), contextType !== context.state && classComponentUpdater.enqueueReplaceState(context, context.state, null), processUpdateQueue(workInProgress2, nextProps, context, renderLanes2), suspendIfUpdateReadFromEntangledAsyncAction(), context.state = workInProgress2.memoizedState);
          "function" === typeof context.componentDidMount && (workInProgress2.flags |= 4194308);
          nextProps = true;
        } else if (null === current) {
          context = workInProgress2.stateNode;
          var unresolvedOldProps = workInProgress2.memoizedProps, oldProps = resolveClassComponentProps(Component, unresolvedOldProps);
          context.props = oldProps;
          var oldContext = context.context, contextType$jscomp$0 = Component.contextType;
          contextType = emptyContextObject;
          "object" === typeof contextType$jscomp$0 && null !== contextType$jscomp$0 && (contextType = readContext(contextType$jscomp$0));
          var getDerivedStateFromProps = Component.getDerivedStateFromProps;
          contextType$jscomp$0 = "function" === typeof getDerivedStateFromProps || "function" === typeof context.getSnapshotBeforeUpdate;
          unresolvedOldProps = workInProgress2.pendingProps !== unresolvedOldProps;
          contextType$jscomp$0 || "function" !== typeof context.UNSAFE_componentWillReceiveProps && "function" !== typeof context.componentWillReceiveProps || (unresolvedOldProps || oldContext !== contextType) && callComponentWillReceiveProps(
            workInProgress2,
            context,
            nextProps,
            contextType
          );
          hasForceUpdate = false;
          var oldState = workInProgress2.memoizedState;
          context.state = oldState;
          processUpdateQueue(workInProgress2, nextProps, context, renderLanes2);
          suspendIfUpdateReadFromEntangledAsyncAction();
          oldContext = workInProgress2.memoizedState;
          unresolvedOldProps || oldState !== oldContext || hasForceUpdate ? ("function" === typeof getDerivedStateFromProps && (applyDerivedStateFromProps(
            workInProgress2,
            Component,
            getDerivedStateFromProps,
            nextProps
          ), oldContext = workInProgress2.memoizedState), (oldProps = hasForceUpdate || checkShouldComponentUpdate(
            workInProgress2,
            Component,
            oldProps,
            nextProps,
            oldState,
            oldContext,
            contextType
          )) ? (contextType$jscomp$0 || "function" !== typeof context.UNSAFE_componentWillMount && "function" !== typeof context.componentWillMount || ("function" === typeof context.componentWillMount && context.componentWillMount(), "function" === typeof context.UNSAFE_componentWillMount && context.UNSAFE_componentWillMount()), "function" === typeof context.componentDidMount && (workInProgress2.flags |= 4194308)) : ("function" === typeof context.componentDidMount && (workInProgress2.flags |= 4194308), workInProgress2.memoizedProps = nextProps, workInProgress2.memoizedState = oldContext), context.props = nextProps, context.state = oldContext, context.context = contextType, nextProps = oldProps) : ("function" === typeof context.componentDidMount && (workInProgress2.flags |= 4194308), nextProps = false);
        } else {
          context = workInProgress2.stateNode;
          cloneUpdateQueue(current, workInProgress2);
          contextType = workInProgress2.memoizedProps;
          contextType$jscomp$0 = resolveClassComponentProps(Component, contextType);
          context.props = contextType$jscomp$0;
          getDerivedStateFromProps = workInProgress2.pendingProps;
          oldState = context.context;
          oldContext = Component.contextType;
          oldProps = emptyContextObject;
          "object" === typeof oldContext && null !== oldContext && (oldProps = readContext(oldContext));
          unresolvedOldProps = Component.getDerivedStateFromProps;
          (oldContext = "function" === typeof unresolvedOldProps || "function" === typeof context.getSnapshotBeforeUpdate) || "function" !== typeof context.UNSAFE_componentWillReceiveProps && "function" !== typeof context.componentWillReceiveProps || (contextType !== getDerivedStateFromProps || oldState !== oldProps) && callComponentWillReceiveProps(
            workInProgress2,
            context,
            nextProps,
            oldProps
          );
          hasForceUpdate = false;
          oldState = workInProgress2.memoizedState;
          context.state = oldState;
          processUpdateQueue(workInProgress2, nextProps, context, renderLanes2);
          suspendIfUpdateReadFromEntangledAsyncAction();
          var newState = workInProgress2.memoizedState;
          contextType !== getDerivedStateFromProps || oldState !== newState || hasForceUpdate || null !== current && null !== current.dependencies && checkIfContextChanged(current.dependencies) ? ("function" === typeof unresolvedOldProps && (applyDerivedStateFromProps(
            workInProgress2,
            Component,
            unresolvedOldProps,
            nextProps
          ), newState = workInProgress2.memoizedState), (contextType$jscomp$0 = hasForceUpdate || checkShouldComponentUpdate(
            workInProgress2,
            Component,
            contextType$jscomp$0,
            nextProps,
            oldState,
            newState,
            oldProps
          ) || null !== current && null !== current.dependencies && checkIfContextChanged(current.dependencies)) ? (oldContext || "function" !== typeof context.UNSAFE_componentWillUpdate && "function" !== typeof context.componentWillUpdate || ("function" === typeof context.componentWillUpdate && context.componentWillUpdate(nextProps, newState, oldProps), "function" === typeof context.UNSAFE_componentWillUpdate && context.UNSAFE_componentWillUpdate(
            nextProps,
            newState,
            oldProps
          )), "function" === typeof context.componentDidUpdate && (workInProgress2.flags |= 4), "function" === typeof context.getSnapshotBeforeUpdate && (workInProgress2.flags |= 1024)) : ("function" !== typeof context.componentDidUpdate || contextType === current.memoizedProps && oldState === current.memoizedState || (workInProgress2.flags |= 4), "function" !== typeof context.getSnapshotBeforeUpdate || contextType === current.memoizedProps && oldState === current.memoizedState || (workInProgress2.flags |= 1024), workInProgress2.memoizedProps = nextProps, workInProgress2.memoizedState = newState), context.props = nextProps, context.state = newState, context.context = oldProps, nextProps = contextType$jscomp$0) : ("function" !== typeof context.componentDidUpdate || contextType === current.memoizedProps && oldState === current.memoizedState || (workInProgress2.flags |= 4), "function" !== typeof context.getSnapshotBeforeUpdate || contextType === current.memoizedProps && oldState === current.memoizedState || (workInProgress2.flags |= 1024), nextProps = false);
        }
        context = nextProps;
        markRef(current, workInProgress2);
        nextProps = 0 !== (workInProgress2.flags & 128);
        context || nextProps ? (context = workInProgress2.stateNode, Component = nextProps && "function" !== typeof Component.getDerivedStateFromError ? null : context.render(), workInProgress2.flags |= 1, null !== current && nextProps ? (workInProgress2.child = reconcileChildFibers(
          workInProgress2,
          current.child,
          null,
          renderLanes2
        ), workInProgress2.child = reconcileChildFibers(
          workInProgress2,
          null,
          Component,
          renderLanes2
        )) : reconcileChildren(current, workInProgress2, Component, renderLanes2), workInProgress2.memoizedState = context.state, current = workInProgress2.child) : current = bailoutOnAlreadyFinishedWork(
          current,
          workInProgress2,
          renderLanes2
        );
        return current;
      }
      function mountHostRootWithoutHydrating(current, workInProgress2, nextChildren, renderLanes2) {
        resetHydrationState();
        workInProgress2.flags |= 256;
        reconcileChildren(current, workInProgress2, nextChildren, renderLanes2);
        return workInProgress2.child;
      }
      var SUSPENDED_MARKER = {
        dehydrated: null,
        treeContext: null,
        retryLane: 0,
        hydrationErrors: null
      };
      function mountSuspenseOffscreenState(renderLanes2) {
        return { baseLanes: renderLanes2, cachePool: getSuspendedCache() };
      }
      function getRemainingWorkInPrimaryTree(current, primaryTreeDidDefer, renderLanes2) {
        current = null !== current ? current.childLanes & ~renderLanes2 : 0;
        primaryTreeDidDefer && (current |= workInProgressDeferredLane);
        return current;
      }
      function updateSuspenseComponent(current, workInProgress2, renderLanes2) {
        var nextProps = workInProgress2.pendingProps, showFallback = false, didSuspend = 0 !== (workInProgress2.flags & 128), JSCompiler_temp;
        (JSCompiler_temp = didSuspend) || (JSCompiler_temp = null !== current && null === current.memoizedState ? false : 0 !== (suspenseStackCursor.current & 2));
        JSCompiler_temp && (showFallback = true, workInProgress2.flags &= -129);
        JSCompiler_temp = 0 !== (workInProgress2.flags & 32);
        workInProgress2.flags &= -33;
        if (null === current) {
          if (isHydrating) {
            showFallback ? pushPrimaryTreeSuspenseHandler(workInProgress2) : reuseSuspenseHandlerOnStack(workInProgress2);
            if (isHydrating) {
              var nextInstance = nextHydratableInstance, JSCompiler_temp$jscomp$0;
              if (JSCompiler_temp$jscomp$0 = nextInstance) {
                c: {
                  JSCompiler_temp$jscomp$0 = nextInstance;
                  for (nextInstance = rootOrSingletonContext; 8 !== JSCompiler_temp$jscomp$0.nodeType; ) {
                    if (!nextInstance) {
                      nextInstance = null;
                      break c;
                    }
                    JSCompiler_temp$jscomp$0 = getNextHydratable(
                      JSCompiler_temp$jscomp$0.nextSibling
                    );
                    if (null === JSCompiler_temp$jscomp$0) {
                      nextInstance = null;
                      break c;
                    }
                  }
                  nextInstance = JSCompiler_temp$jscomp$0;
                }
                null !== nextInstance ? (workInProgress2.memoizedState = {
                  dehydrated: nextInstance,
                  treeContext: null !== treeContextProvider ? { id: treeContextId, overflow: treeContextOverflow } : null,
                  retryLane: 536870912,
                  hydrationErrors: null
                }, JSCompiler_temp$jscomp$0 = createFiberImplClass(
                  18,
                  null,
                  null,
                  0
                ), JSCompiler_temp$jscomp$0.stateNode = nextInstance, JSCompiler_temp$jscomp$0.return = workInProgress2, workInProgress2.child = JSCompiler_temp$jscomp$0, hydrationParentFiber = workInProgress2, nextHydratableInstance = null, JSCompiler_temp$jscomp$0 = true) : JSCompiler_temp$jscomp$0 = false;
              }
              JSCompiler_temp$jscomp$0 || throwOnHydrationMismatch(workInProgress2);
            }
            nextInstance = workInProgress2.memoizedState;
            if (null !== nextInstance && (nextInstance = nextInstance.dehydrated, null !== nextInstance))
              return isSuspenseInstanceFallback(nextInstance) ? workInProgress2.lanes = 32 : workInProgress2.lanes = 536870912, null;
            popSuspenseHandler(workInProgress2);
          }
          nextInstance = nextProps.children;
          nextProps = nextProps.fallback;
          if (showFallback)
            return reuseSuspenseHandlerOnStack(workInProgress2), showFallback = workInProgress2.mode, nextInstance = mountWorkInProgressOffscreenFiber(
              { mode: "hidden", children: nextInstance },
              showFallback
            ), nextProps = createFiberFromFragment(
              nextProps,
              showFallback,
              renderLanes2,
              null
            ), nextInstance.return = workInProgress2, nextProps.return = workInProgress2, nextInstance.sibling = nextProps, workInProgress2.child = nextInstance, showFallback = workInProgress2.child, showFallback.memoizedState = mountSuspenseOffscreenState(renderLanes2), showFallback.childLanes = getRemainingWorkInPrimaryTree(
              current,
              JSCompiler_temp,
              renderLanes2
            ), workInProgress2.memoizedState = SUSPENDED_MARKER, nextProps;
          pushPrimaryTreeSuspenseHandler(workInProgress2);
          return mountSuspensePrimaryChildren(workInProgress2, nextInstance);
        }
        JSCompiler_temp$jscomp$0 = current.memoizedState;
        if (null !== JSCompiler_temp$jscomp$0 && (nextInstance = JSCompiler_temp$jscomp$0.dehydrated, null !== nextInstance)) {
          if (didSuspend)
            workInProgress2.flags & 256 ? (pushPrimaryTreeSuspenseHandler(workInProgress2), workInProgress2.flags &= -257, workInProgress2 = retrySuspenseComponentWithoutHydrating(
              current,
              workInProgress2,
              renderLanes2
            )) : null !== workInProgress2.memoizedState ? (reuseSuspenseHandlerOnStack(workInProgress2), workInProgress2.child = current.child, workInProgress2.flags |= 128, workInProgress2 = null) : (reuseSuspenseHandlerOnStack(workInProgress2), showFallback = nextProps.fallback, nextInstance = workInProgress2.mode, nextProps = mountWorkInProgressOffscreenFiber(
              { mode: "visible", children: nextProps.children },
              nextInstance
            ), showFallback = createFiberFromFragment(
              showFallback,
              nextInstance,
              renderLanes2,
              null
            ), showFallback.flags |= 2, nextProps.return = workInProgress2, showFallback.return = workInProgress2, nextProps.sibling = showFallback, workInProgress2.child = nextProps, reconcileChildFibers(
              workInProgress2,
              current.child,
              null,
              renderLanes2
            ), nextProps = workInProgress2.child, nextProps.memoizedState = mountSuspenseOffscreenState(renderLanes2), nextProps.childLanes = getRemainingWorkInPrimaryTree(
              current,
              JSCompiler_temp,
              renderLanes2
            ), workInProgress2.memoizedState = SUSPENDED_MARKER, workInProgress2 = showFallback);
          else if (pushPrimaryTreeSuspenseHandler(workInProgress2), isSuspenseInstanceFallback(nextInstance)) {
            JSCompiler_temp = nextInstance.nextSibling && nextInstance.nextSibling.dataset;
            if (JSCompiler_temp) var digest = JSCompiler_temp.dgst;
            JSCompiler_temp = digest;
            nextProps = Error(formatProdErrorMessage(419));
            nextProps.stack = "";
            nextProps.digest = JSCompiler_temp;
            queueHydrationError({ value: nextProps, source: null, stack: null });
            workInProgress2 = retrySuspenseComponentWithoutHydrating(
              current,
              workInProgress2,
              renderLanes2
            );
          } else if (didReceiveUpdate || propagateParentContextChanges(current, workInProgress2, renderLanes2, false), JSCompiler_temp = 0 !== (renderLanes2 & current.childLanes), didReceiveUpdate || JSCompiler_temp) {
            JSCompiler_temp = workInProgressRoot;
            if (null !== JSCompiler_temp && (nextProps = renderLanes2 & -renderLanes2, nextProps = 0 !== (nextProps & 42) ? 1 : getBumpedLaneForHydrationByLane(nextProps), nextProps = 0 !== (nextProps & (JSCompiler_temp.suspendedLanes | renderLanes2)) ? 0 : nextProps, 0 !== nextProps && nextProps !== JSCompiler_temp$jscomp$0.retryLane))
              throw JSCompiler_temp$jscomp$0.retryLane = nextProps, enqueueConcurrentRenderForLane(current, nextProps), scheduleUpdateOnFiber(JSCompiler_temp, current, nextProps), SelectiveHydrationException;
            "$?" === nextInstance.data || renderDidSuspendDelayIfPossible();
            workInProgress2 = retrySuspenseComponentWithoutHydrating(
              current,
              workInProgress2,
              renderLanes2
            );
          } else
            "$?" === nextInstance.data ? (workInProgress2.flags |= 192, workInProgress2.child = current.child, workInProgress2 = null) : (current = JSCompiler_temp$jscomp$0.treeContext, nextHydratableInstance = getNextHydratable(
              nextInstance.nextSibling
            ), hydrationParentFiber = workInProgress2, isHydrating = true, hydrationErrors = null, rootOrSingletonContext = false, null !== current && (idStack[idStackIndex++] = treeContextId, idStack[idStackIndex++] = treeContextOverflow, idStack[idStackIndex++] = treeContextProvider, treeContextId = current.id, treeContextOverflow = current.overflow, treeContextProvider = workInProgress2), workInProgress2 = mountSuspensePrimaryChildren(
              workInProgress2,
              nextProps.children
            ), workInProgress2.flags |= 4096);
          return workInProgress2;
        }
        if (showFallback)
          return reuseSuspenseHandlerOnStack(workInProgress2), showFallback = nextProps.fallback, nextInstance = workInProgress2.mode, JSCompiler_temp$jscomp$0 = current.child, digest = JSCompiler_temp$jscomp$0.sibling, nextProps = createWorkInProgress(JSCompiler_temp$jscomp$0, {
            mode: "hidden",
            children: nextProps.children
          }), nextProps.subtreeFlags = JSCompiler_temp$jscomp$0.subtreeFlags & 65011712, null !== digest ? showFallback = createWorkInProgress(digest, showFallback) : (showFallback = createFiberFromFragment(
            showFallback,
            nextInstance,
            renderLanes2,
            null
          ), showFallback.flags |= 2), showFallback.return = workInProgress2, nextProps.return = workInProgress2, nextProps.sibling = showFallback, workInProgress2.child = nextProps, nextProps = showFallback, showFallback = workInProgress2.child, nextInstance = current.child.memoizedState, null === nextInstance ? nextInstance = mountSuspenseOffscreenState(renderLanes2) : (JSCompiler_temp$jscomp$0 = nextInstance.cachePool, null !== JSCompiler_temp$jscomp$0 ? (digest = CacheContext._currentValue, JSCompiler_temp$jscomp$0 = JSCompiler_temp$jscomp$0.parent !== digest ? { parent: digest, pool: digest } : JSCompiler_temp$jscomp$0) : JSCompiler_temp$jscomp$0 = getSuspendedCache(), nextInstance = {
            baseLanes: nextInstance.baseLanes | renderLanes2,
            cachePool: JSCompiler_temp$jscomp$0
          }), showFallback.memoizedState = nextInstance, showFallback.childLanes = getRemainingWorkInPrimaryTree(
            current,
            JSCompiler_temp,
            renderLanes2
          ), workInProgress2.memoizedState = SUSPENDED_MARKER, nextProps;
        pushPrimaryTreeSuspenseHandler(workInProgress2);
        renderLanes2 = current.child;
        current = renderLanes2.sibling;
        renderLanes2 = createWorkInProgress(renderLanes2, {
          mode: "visible",
          children: nextProps.children
        });
        renderLanes2.return = workInProgress2;
        renderLanes2.sibling = null;
        null !== current && (JSCompiler_temp = workInProgress2.deletions, null === JSCompiler_temp ? (workInProgress2.deletions = [current], workInProgress2.flags |= 16) : JSCompiler_temp.push(current));
        workInProgress2.child = renderLanes2;
        workInProgress2.memoizedState = null;
        return renderLanes2;
      }
      function mountSuspensePrimaryChildren(workInProgress2, primaryChildren) {
        primaryChildren = mountWorkInProgressOffscreenFiber(
          { mode: "visible", children: primaryChildren },
          workInProgress2.mode
        );
        primaryChildren.return = workInProgress2;
        return workInProgress2.child = primaryChildren;
      }
      function mountWorkInProgressOffscreenFiber(offscreenProps, mode) {
        offscreenProps = createFiberImplClass(22, offscreenProps, null, mode);
        offscreenProps.lanes = 0;
        offscreenProps.stateNode = {
          _visibility: 1,
          _pendingMarkers: null,
          _retryCache: null,
          _transitions: null
        };
        return offscreenProps;
      }
      function retrySuspenseComponentWithoutHydrating(current, workInProgress2, renderLanes2) {
        reconcileChildFibers(workInProgress2, current.child, null, renderLanes2);
        current = mountSuspensePrimaryChildren(
          workInProgress2,
          workInProgress2.pendingProps.children
        );
        current.flags |= 2;
        workInProgress2.memoizedState = null;
        return current;
      }
      function scheduleSuspenseWorkOnFiber(fiber, renderLanes2, propagationRoot) {
        fiber.lanes |= renderLanes2;
        var alternate = fiber.alternate;
        null !== alternate && (alternate.lanes |= renderLanes2);
        scheduleContextWorkOnParentPath(fiber.return, renderLanes2, propagationRoot);
      }
      function initSuspenseListRenderState(workInProgress2, isBackwards, tail, lastContentRow, tailMode) {
        var renderState = workInProgress2.memoizedState;
        null === renderState ? workInProgress2.memoizedState = {
          isBackwards,
          rendering: null,
          renderingStartTime: 0,
          last: lastContentRow,
          tail,
          tailMode
        } : (renderState.isBackwards = isBackwards, renderState.rendering = null, renderState.renderingStartTime = 0, renderState.last = lastContentRow, renderState.tail = tail, renderState.tailMode = tailMode);
      }
      function updateSuspenseListComponent(current, workInProgress2, renderLanes2) {
        var nextProps = workInProgress2.pendingProps, revealOrder = nextProps.revealOrder, tailMode = nextProps.tail;
        reconcileChildren(current, workInProgress2, nextProps.children, renderLanes2);
        nextProps = suspenseStackCursor.current;
        if (0 !== (nextProps & 2))
          nextProps = nextProps & 1 | 2, workInProgress2.flags |= 128;
        else {
          if (null !== current && 0 !== (current.flags & 128))
            a: for (current = workInProgress2.child; null !== current; ) {
              if (13 === current.tag)
                null !== current.memoizedState && scheduleSuspenseWorkOnFiber(current, renderLanes2, workInProgress2);
              else if (19 === current.tag)
                scheduleSuspenseWorkOnFiber(current, renderLanes2, workInProgress2);
              else if (null !== current.child) {
                current.child.return = current;
                current = current.child;
                continue;
              }
              if (current === workInProgress2) break a;
              for (; null === current.sibling; ) {
                if (null === current.return || current.return === workInProgress2)
                  break a;
                current = current.return;
              }
              current.sibling.return = current.return;
              current = current.sibling;
            }
          nextProps &= 1;
        }
        push(suspenseStackCursor, nextProps);
        switch (revealOrder) {
          case "forwards":
            renderLanes2 = workInProgress2.child;
            for (revealOrder = null; null !== renderLanes2; )
              current = renderLanes2.alternate, null !== current && null === findFirstSuspended(current) && (revealOrder = renderLanes2), renderLanes2 = renderLanes2.sibling;
            renderLanes2 = revealOrder;
            null === renderLanes2 ? (revealOrder = workInProgress2.child, workInProgress2.child = null) : (revealOrder = renderLanes2.sibling, renderLanes2.sibling = null);
            initSuspenseListRenderState(
              workInProgress2,
              false,
              revealOrder,
              renderLanes2,
              tailMode
            );
            break;
          case "backwards":
            renderLanes2 = null;
            revealOrder = workInProgress2.child;
            for (workInProgress2.child = null; null !== revealOrder; ) {
              current = revealOrder.alternate;
              if (null !== current && null === findFirstSuspended(current)) {
                workInProgress2.child = revealOrder;
                break;
              }
              current = revealOrder.sibling;
              revealOrder.sibling = renderLanes2;
              renderLanes2 = revealOrder;
              revealOrder = current;
            }
            initSuspenseListRenderState(
              workInProgress2,
              true,
              renderLanes2,
              null,
              tailMode
            );
            break;
          case "together":
            initSuspenseListRenderState(workInProgress2, false, null, null, void 0);
            break;
          default:
            workInProgress2.memoizedState = null;
        }
        return workInProgress2.child;
      }
      function bailoutOnAlreadyFinishedWork(current, workInProgress2, renderLanes2) {
        null !== current && (workInProgress2.dependencies = current.dependencies);
        workInProgressRootSkippedLanes |= workInProgress2.lanes;
        if (0 === (renderLanes2 & workInProgress2.childLanes))
          if (null !== current) {
            if (propagateParentContextChanges(
              current,
              workInProgress2,
              renderLanes2,
              false
            ), 0 === (renderLanes2 & workInProgress2.childLanes))
              return null;
          } else return null;
        if (null !== current && workInProgress2.child !== current.child)
          throw Error(formatProdErrorMessage(153));
        if (null !== workInProgress2.child) {
          current = workInProgress2.child;
          renderLanes2 = createWorkInProgress(current, current.pendingProps);
          workInProgress2.child = renderLanes2;
          for (renderLanes2.return = workInProgress2; null !== current.sibling; )
            current = current.sibling, renderLanes2 = renderLanes2.sibling = createWorkInProgress(current, current.pendingProps), renderLanes2.return = workInProgress2;
          renderLanes2.sibling = null;
        }
        return workInProgress2.child;
      }
      function checkScheduledUpdateOrContext(current, renderLanes2) {
        if (0 !== (current.lanes & renderLanes2)) return true;
        current = current.dependencies;
        return null !== current && checkIfContextChanged(current) ? true : false;
      }
      function attemptEarlyBailoutIfNoScheduledUpdate(current, workInProgress2, renderLanes2) {
        switch (workInProgress2.tag) {
          case 3:
            pushHostContainer(workInProgress2, workInProgress2.stateNode.containerInfo);
            pushProvider(workInProgress2, CacheContext, current.memoizedState.cache);
            resetHydrationState();
            break;
          case 27:
          case 5:
            pushHostContext(workInProgress2);
            break;
          case 4:
            pushHostContainer(workInProgress2, workInProgress2.stateNode.containerInfo);
            break;
          case 10:
            pushProvider(
              workInProgress2,
              workInProgress2.type,
              workInProgress2.memoizedProps.value
            );
            break;
          case 13:
            var state = workInProgress2.memoizedState;
            if (null !== state) {
              if (null !== state.dehydrated)
                return pushPrimaryTreeSuspenseHandler(workInProgress2), workInProgress2.flags |= 128, null;
              if (0 !== (renderLanes2 & workInProgress2.child.childLanes))
                return updateSuspenseComponent(current, workInProgress2, renderLanes2);
              pushPrimaryTreeSuspenseHandler(workInProgress2);
              current = bailoutOnAlreadyFinishedWork(
                current,
                workInProgress2,
                renderLanes2
              );
              return null !== current ? current.sibling : null;
            }
            pushPrimaryTreeSuspenseHandler(workInProgress2);
            break;
          case 19:
            var didSuspendBefore = 0 !== (current.flags & 128);
            state = 0 !== (renderLanes2 & workInProgress2.childLanes);
            state || (propagateParentContextChanges(
              current,
              workInProgress2,
              renderLanes2,
              false
            ), state = 0 !== (renderLanes2 & workInProgress2.childLanes));
            if (didSuspendBefore) {
              if (state)
                return updateSuspenseListComponent(
                  current,
                  workInProgress2,
                  renderLanes2
                );
              workInProgress2.flags |= 128;
            }
            didSuspendBefore = workInProgress2.memoizedState;
            null !== didSuspendBefore && (didSuspendBefore.rendering = null, didSuspendBefore.tail = null, didSuspendBefore.lastEffect = null);
            push(suspenseStackCursor, suspenseStackCursor.current);
            if (state) break;
            else return null;
          case 22:
          case 23:
            return workInProgress2.lanes = 0, updateOffscreenComponent(current, workInProgress2, renderLanes2);
          case 24:
            pushProvider(workInProgress2, CacheContext, current.memoizedState.cache);
        }
        return bailoutOnAlreadyFinishedWork(current, workInProgress2, renderLanes2);
      }
      function beginWork(current, workInProgress2, renderLanes2) {
        if (null !== current)
          if (current.memoizedProps !== workInProgress2.pendingProps)
            didReceiveUpdate = true;
          else {
            if (!checkScheduledUpdateOrContext(current, renderLanes2) && 0 === (workInProgress2.flags & 128))
              return didReceiveUpdate = false, attemptEarlyBailoutIfNoScheduledUpdate(
                current,
                workInProgress2,
                renderLanes2
              );
            didReceiveUpdate = 0 !== (current.flags & 131072) ? true : false;
          }
        else
          didReceiveUpdate = false, isHydrating && 0 !== (workInProgress2.flags & 1048576) && pushTreeId(workInProgress2, treeForkCount, workInProgress2.index);
        workInProgress2.lanes = 0;
        switch (workInProgress2.tag) {
          case 16:
            a: {
              current = workInProgress2.pendingProps;
              var lazyComponent = workInProgress2.elementType, init2 = lazyComponent._init;
              lazyComponent = init2(lazyComponent._payload);
              workInProgress2.type = lazyComponent;
              if ("function" === typeof lazyComponent)
                shouldConstruct(lazyComponent) ? (current = resolveClassComponentProps(lazyComponent, current), workInProgress2.tag = 1, workInProgress2 = updateClassComponent(
                  null,
                  workInProgress2,
                  lazyComponent,
                  current,
                  renderLanes2
                )) : (workInProgress2.tag = 0, workInProgress2 = updateFunctionComponent(
                  null,
                  workInProgress2,
                  lazyComponent,
                  current,
                  renderLanes2
                ));
              else {
                if (void 0 !== lazyComponent && null !== lazyComponent) {
                  if (init2 = lazyComponent.$$typeof, init2 === REACT_FORWARD_REF_TYPE) {
                    workInProgress2.tag = 11;
                    workInProgress2 = updateForwardRef(
                      null,
                      workInProgress2,
                      lazyComponent,
                      current,
                      renderLanes2
                    );
                    break a;
                  } else if (init2 === REACT_MEMO_TYPE) {
                    workInProgress2.tag = 14;
                    workInProgress2 = updateMemoComponent(
                      null,
                      workInProgress2,
                      lazyComponent,
                      current,
                      renderLanes2
                    );
                    break a;
                  }
                }
                workInProgress2 = getComponentNameFromType(lazyComponent) || lazyComponent;
                throw Error(formatProdErrorMessage(306, workInProgress2, ""));
              }
            }
            return workInProgress2;
          case 0:
            return updateFunctionComponent(
              current,
              workInProgress2,
              workInProgress2.type,
              workInProgress2.pendingProps,
              renderLanes2
            );
          case 1:
            return lazyComponent = workInProgress2.type, init2 = resolveClassComponentProps(
              lazyComponent,
              workInProgress2.pendingProps
            ), updateClassComponent(
              current,
              workInProgress2,
              lazyComponent,
              init2,
              renderLanes2
            );
          case 3:
            a: {
              pushHostContainer(
                workInProgress2,
                workInProgress2.stateNode.containerInfo
              );
              if (null === current) throw Error(formatProdErrorMessage(387));
              lazyComponent = workInProgress2.pendingProps;
              var prevState = workInProgress2.memoizedState;
              init2 = prevState.element;
              cloneUpdateQueue(current, workInProgress2);
              processUpdateQueue(workInProgress2, lazyComponent, null, renderLanes2);
              var nextState = workInProgress2.memoizedState;
              lazyComponent = nextState.cache;
              pushProvider(workInProgress2, CacheContext, lazyComponent);
              lazyComponent !== prevState.cache && propagateContextChanges(
                workInProgress2,
                [CacheContext],
                renderLanes2,
                true
              );
              suspendIfUpdateReadFromEntangledAsyncAction();
              lazyComponent = nextState.element;
              if (prevState.isDehydrated)
                if (prevState = {
                  element: lazyComponent,
                  isDehydrated: false,
                  cache: nextState.cache
                }, workInProgress2.updateQueue.baseState = prevState, workInProgress2.memoizedState = prevState, workInProgress2.flags & 256) {
                  workInProgress2 = mountHostRootWithoutHydrating(
                    current,
                    workInProgress2,
                    lazyComponent,
                    renderLanes2
                  );
                  break a;
                } else if (lazyComponent !== init2) {
                  init2 = createCapturedValueAtFiber(
                    Error(formatProdErrorMessage(424)),
                    workInProgress2
                  );
                  queueHydrationError(init2);
                  workInProgress2 = mountHostRootWithoutHydrating(
                    current,
                    workInProgress2,
                    lazyComponent,
                    renderLanes2
                  );
                  break a;
                } else {
                  current = workInProgress2.stateNode.containerInfo;
                  switch (current.nodeType) {
                    case 9:
                      current = current.body;
                      break;
                    default:
                      current = "HTML" === current.nodeName ? current.ownerDocument.body : current;
                  }
                  nextHydratableInstance = getNextHydratable(current.firstChild);
                  hydrationParentFiber = workInProgress2;
                  isHydrating = true;
                  hydrationErrors = null;
                  rootOrSingletonContext = true;
                  renderLanes2 = mountChildFibers(
                    workInProgress2,
                    null,
                    lazyComponent,
                    renderLanes2
                  );
                  for (workInProgress2.child = renderLanes2; renderLanes2; )
                    renderLanes2.flags = renderLanes2.flags & -3 | 4096, renderLanes2 = renderLanes2.sibling;
                }
              else {
                resetHydrationState();
                if (lazyComponent === init2) {
                  workInProgress2 = bailoutOnAlreadyFinishedWork(
                    current,
                    workInProgress2,
                    renderLanes2
                  );
                  break a;
                }
                reconcileChildren(
                  current,
                  workInProgress2,
                  lazyComponent,
                  renderLanes2
                );
              }
              workInProgress2 = workInProgress2.child;
            }
            return workInProgress2;
          case 26:
            return markRef(current, workInProgress2), null === current ? (renderLanes2 = getResource(
              workInProgress2.type,
              null,
              workInProgress2.pendingProps,
              null
            )) ? workInProgress2.memoizedState = renderLanes2 : isHydrating || (renderLanes2 = workInProgress2.type, current = workInProgress2.pendingProps, lazyComponent = getOwnerDocumentFromRootContainer(
              rootInstanceStackCursor.current
            ).createElement(renderLanes2), lazyComponent[internalInstanceKey] = workInProgress2, lazyComponent[internalPropsKey] = current, setInitialProperties(lazyComponent, renderLanes2, current), markNodeAsHoistable(lazyComponent), workInProgress2.stateNode = lazyComponent) : workInProgress2.memoizedState = getResource(
              workInProgress2.type,
              current.memoizedProps,
              workInProgress2.pendingProps,
              current.memoizedState
            ), null;
          case 27:
            return pushHostContext(workInProgress2), null === current && isHydrating && (lazyComponent = workInProgress2.stateNode = resolveSingletonInstance(
              workInProgress2.type,
              workInProgress2.pendingProps,
              rootInstanceStackCursor.current
            ), hydrationParentFiber = workInProgress2, rootOrSingletonContext = true, init2 = nextHydratableInstance, isSingletonScope(workInProgress2.type) ? (previousHydratableOnEnteringScopedSingleton = init2, nextHydratableInstance = getNextHydratable(
              lazyComponent.firstChild
            )) : nextHydratableInstance = init2), reconcileChildren(
              current,
              workInProgress2,
              workInProgress2.pendingProps.children,
              renderLanes2
            ), markRef(current, workInProgress2), null === current && (workInProgress2.flags |= 4194304), workInProgress2.child;
          case 5:
            if (null === current && isHydrating) {
              if (init2 = lazyComponent = nextHydratableInstance)
                lazyComponent = canHydrateInstance(
                  lazyComponent,
                  workInProgress2.type,
                  workInProgress2.pendingProps,
                  rootOrSingletonContext
                ), null !== lazyComponent ? (workInProgress2.stateNode = lazyComponent, hydrationParentFiber = workInProgress2, nextHydratableInstance = getNextHydratable(
                  lazyComponent.firstChild
                ), rootOrSingletonContext = false, init2 = true) : init2 = false;
              init2 || throwOnHydrationMismatch(workInProgress2);
            }
            pushHostContext(workInProgress2);
            init2 = workInProgress2.type;
            prevState = workInProgress2.pendingProps;
            nextState = null !== current ? current.memoizedProps : null;
            lazyComponent = prevState.children;
            shouldSetTextContent(init2, prevState) ? lazyComponent = null : null !== nextState && shouldSetTextContent(init2, nextState) && (workInProgress2.flags |= 32);
            null !== workInProgress2.memoizedState && (init2 = renderWithHooks(
              current,
              workInProgress2,
              TransitionAwareHostComponent,
              null,
              null,
              renderLanes2
            ), HostTransitionContext._currentValue = init2);
            markRef(current, workInProgress2);
            reconcileChildren(current, workInProgress2, lazyComponent, renderLanes2);
            return workInProgress2.child;
          case 6:
            if (null === current && isHydrating) {
              if (current = renderLanes2 = nextHydratableInstance)
                renderLanes2 = canHydrateTextInstance(
                  renderLanes2,
                  workInProgress2.pendingProps,
                  rootOrSingletonContext
                ), null !== renderLanes2 ? (workInProgress2.stateNode = renderLanes2, hydrationParentFiber = workInProgress2, nextHydratableInstance = null, current = true) : current = false;
              current || throwOnHydrationMismatch(workInProgress2);
            }
            return null;
          case 13:
            return updateSuspenseComponent(current, workInProgress2, renderLanes2);
          case 4:
            return pushHostContainer(
              workInProgress2,
              workInProgress2.stateNode.containerInfo
            ), lazyComponent = workInProgress2.pendingProps, null === current ? workInProgress2.child = reconcileChildFibers(
              workInProgress2,
              null,
              lazyComponent,
              renderLanes2
            ) : reconcileChildren(
              current,
              workInProgress2,
              lazyComponent,
              renderLanes2
            ), workInProgress2.child;
          case 11:
            return updateForwardRef(
              current,
              workInProgress2,
              workInProgress2.type,
              workInProgress2.pendingProps,
              renderLanes2
            );
          case 7:
            return reconcileChildren(
              current,
              workInProgress2,
              workInProgress2.pendingProps,
              renderLanes2
            ), workInProgress2.child;
          case 8:
            return reconcileChildren(
              current,
              workInProgress2,
              workInProgress2.pendingProps.children,
              renderLanes2
            ), workInProgress2.child;
          case 12:
            return reconcileChildren(
              current,
              workInProgress2,
              workInProgress2.pendingProps.children,
              renderLanes2
            ), workInProgress2.child;
          case 10:
            return lazyComponent = workInProgress2.pendingProps, pushProvider(workInProgress2, workInProgress2.type, lazyComponent.value), reconcileChildren(
              current,
              workInProgress2,
              lazyComponent.children,
              renderLanes2
            ), workInProgress2.child;
          case 9:
            return init2 = workInProgress2.type._context, lazyComponent = workInProgress2.pendingProps.children, prepareToReadContext(workInProgress2), init2 = readContext(init2), lazyComponent = lazyComponent(init2), workInProgress2.flags |= 1, reconcileChildren(current, workInProgress2, lazyComponent, renderLanes2), workInProgress2.child;
          case 14:
            return updateMemoComponent(
              current,
              workInProgress2,
              workInProgress2.type,
              workInProgress2.pendingProps,
              renderLanes2
            );
          case 15:
            return updateSimpleMemoComponent(
              current,
              workInProgress2,
              workInProgress2.type,
              workInProgress2.pendingProps,
              renderLanes2
            );
          case 19:
            return updateSuspenseListComponent(current, workInProgress2, renderLanes2);
          case 31:
            return lazyComponent = workInProgress2.pendingProps, renderLanes2 = workInProgress2.mode, lazyComponent = {
              mode: lazyComponent.mode,
              children: lazyComponent.children
            }, null === current ? (renderLanes2 = mountWorkInProgressOffscreenFiber(
              lazyComponent,
              renderLanes2
            ), renderLanes2.ref = workInProgress2.ref, workInProgress2.child = renderLanes2, renderLanes2.return = workInProgress2, workInProgress2 = renderLanes2) : (renderLanes2 = createWorkInProgress(current.child, lazyComponent), renderLanes2.ref = workInProgress2.ref, workInProgress2.child = renderLanes2, renderLanes2.return = workInProgress2, workInProgress2 = renderLanes2), workInProgress2;
          case 22:
            return updateOffscreenComponent(current, workInProgress2, renderLanes2);
          case 24:
            return prepareToReadContext(workInProgress2), lazyComponent = readContext(CacheContext), null === current ? (init2 = peekCacheFromPool(), null === init2 && (init2 = workInProgressRoot, prevState = createCache(), init2.pooledCache = prevState, prevState.refCount++, null !== prevState && (init2.pooledCacheLanes |= renderLanes2), init2 = prevState), workInProgress2.memoizedState = {
              parent: lazyComponent,
              cache: init2
            }, initializeUpdateQueue(workInProgress2), pushProvider(workInProgress2, CacheContext, init2)) : (0 !== (current.lanes & renderLanes2) && (cloneUpdateQueue(current, workInProgress2), processUpdateQueue(workInProgress2, null, null, renderLanes2), suspendIfUpdateReadFromEntangledAsyncAction()), init2 = current.memoizedState, prevState = workInProgress2.memoizedState, init2.parent !== lazyComponent ? (init2 = { parent: lazyComponent, cache: lazyComponent }, workInProgress2.memoizedState = init2, 0 === workInProgress2.lanes && (workInProgress2.memoizedState = workInProgress2.updateQueue.baseState = init2), pushProvider(workInProgress2, CacheContext, lazyComponent)) : (lazyComponent = prevState.cache, pushProvider(workInProgress2, CacheContext, lazyComponent), lazyComponent !== init2.cache && propagateContextChanges(
              workInProgress2,
              [CacheContext],
              renderLanes2,
              true
            ))), reconcileChildren(
              current,
              workInProgress2,
              workInProgress2.pendingProps.children,
              renderLanes2
            ), workInProgress2.child;
          case 29:
            throw workInProgress2.pendingProps;
        }
        throw Error(formatProdErrorMessage(156, workInProgress2.tag));
      }
      function markUpdate(workInProgress2) {
        workInProgress2.flags |= 4;
      }
      function preloadResourceAndSuspendIfNeeded(workInProgress2, resource) {
        if ("stylesheet" !== resource.type || 0 !== (resource.state.loading & 4))
          workInProgress2.flags &= -16777217;
        else if (workInProgress2.flags |= 16777216, !preloadResource(resource)) {
          resource = suspenseHandlerStackCursor.current;
          if (null !== resource && ((workInProgressRootRenderLanes & 4194048) === workInProgressRootRenderLanes ? null !== shellBoundary : (workInProgressRootRenderLanes & 62914560) !== workInProgressRootRenderLanes && 0 === (workInProgressRootRenderLanes & 536870912) || resource !== shellBoundary))
            throw suspendedThenable = noopSuspenseyCommitThenable, SuspenseyCommitException;
          workInProgress2.flags |= 8192;
        }
      }
      function scheduleRetryEffect(workInProgress2, retryQueue) {
        null !== retryQueue && (workInProgress2.flags |= 4);
        workInProgress2.flags & 16384 && (retryQueue = 22 !== workInProgress2.tag ? claimNextRetryLane() : 536870912, workInProgress2.lanes |= retryQueue, workInProgressSuspendedRetryLanes |= retryQueue);
      }
      function cutOffTailIfNeeded(renderState, hasRenderedATailFallback) {
        if (!isHydrating)
          switch (renderState.tailMode) {
            case "hidden":
              hasRenderedATailFallback = renderState.tail;
              for (var lastTailNode = null; null !== hasRenderedATailFallback; )
                null !== hasRenderedATailFallback.alternate && (lastTailNode = hasRenderedATailFallback), hasRenderedATailFallback = hasRenderedATailFallback.sibling;
              null === lastTailNode ? renderState.tail = null : lastTailNode.sibling = null;
              break;
            case "collapsed":
              lastTailNode = renderState.tail;
              for (var lastTailNode$113 = null; null !== lastTailNode; )
                null !== lastTailNode.alternate && (lastTailNode$113 = lastTailNode), lastTailNode = lastTailNode.sibling;
              null === lastTailNode$113 ? hasRenderedATailFallback || null === renderState.tail ? renderState.tail = null : renderState.tail.sibling = null : lastTailNode$113.sibling = null;
          }
      }
      function bubbleProperties(completedWork) {
        var didBailout = null !== completedWork.alternate && completedWork.alternate.child === completedWork.child, newChildLanes = 0, subtreeFlags = 0;
        if (didBailout)
          for (var child$114 = completedWork.child; null !== child$114; )
            newChildLanes |= child$114.lanes | child$114.childLanes, subtreeFlags |= child$114.subtreeFlags & 65011712, subtreeFlags |= child$114.flags & 65011712, child$114.return = completedWork, child$114 = child$114.sibling;
        else
          for (child$114 = completedWork.child; null !== child$114; )
            newChildLanes |= child$114.lanes | child$114.childLanes, subtreeFlags |= child$114.subtreeFlags, subtreeFlags |= child$114.flags, child$114.return = completedWork, child$114 = child$114.sibling;
        completedWork.subtreeFlags |= subtreeFlags;
        completedWork.childLanes = newChildLanes;
        return didBailout;
      }
      function completeWork(current, workInProgress2, renderLanes2) {
        var newProps = workInProgress2.pendingProps;
        popTreeContext(workInProgress2);
        switch (workInProgress2.tag) {
          case 31:
          case 16:
          case 15:
          case 0:
          case 11:
          case 7:
          case 8:
          case 12:
          case 9:
          case 14:
            return bubbleProperties(workInProgress2), null;
          case 1:
            return bubbleProperties(workInProgress2), null;
          case 3:
            renderLanes2 = workInProgress2.stateNode;
            newProps = null;
            null !== current && (newProps = current.memoizedState.cache);
            workInProgress2.memoizedState.cache !== newProps && (workInProgress2.flags |= 2048);
            popProvider(CacheContext);
            popHostContainer();
            renderLanes2.pendingContext && (renderLanes2.context = renderLanes2.pendingContext, renderLanes2.pendingContext = null);
            if (null === current || null === current.child)
              popHydrationState(workInProgress2) ? markUpdate(workInProgress2) : null === current || current.memoizedState.isDehydrated && 0 === (workInProgress2.flags & 256) || (workInProgress2.flags |= 1024, upgradeHydrationErrorsToRecoverable());
            bubbleProperties(workInProgress2);
            return null;
          case 26:
            return renderLanes2 = workInProgress2.memoizedState, null === current ? (markUpdate(workInProgress2), null !== renderLanes2 ? (bubbleProperties(workInProgress2), preloadResourceAndSuspendIfNeeded(workInProgress2, renderLanes2)) : (bubbleProperties(workInProgress2), workInProgress2.flags &= -16777217)) : renderLanes2 ? renderLanes2 !== current.memoizedState ? (markUpdate(workInProgress2), bubbleProperties(workInProgress2), preloadResourceAndSuspendIfNeeded(workInProgress2, renderLanes2)) : (bubbleProperties(workInProgress2), workInProgress2.flags &= -16777217) : (current.memoizedProps !== newProps && markUpdate(workInProgress2), bubbleProperties(workInProgress2), workInProgress2.flags &= -16777217), null;
          case 27:
            popHostContext(workInProgress2);
            renderLanes2 = rootInstanceStackCursor.current;
            var type = workInProgress2.type;
            if (null !== current && null != workInProgress2.stateNode)
              current.memoizedProps !== newProps && markUpdate(workInProgress2);
            else {
              if (!newProps) {
                if (null === workInProgress2.stateNode)
                  throw Error(formatProdErrorMessage(166));
                bubbleProperties(workInProgress2);
                return null;
              }
              current = contextStackCursor.current;
              popHydrationState(workInProgress2) ? prepareToHydrateHostInstance(workInProgress2, current) : (current = resolveSingletonInstance(type, newProps, renderLanes2), workInProgress2.stateNode = current, markUpdate(workInProgress2));
            }
            bubbleProperties(workInProgress2);
            return null;
          case 5:
            popHostContext(workInProgress2);
            renderLanes2 = workInProgress2.type;
            if (null !== current && null != workInProgress2.stateNode)
              current.memoizedProps !== newProps && markUpdate(workInProgress2);
            else {
              if (!newProps) {
                if (null === workInProgress2.stateNode)
                  throw Error(formatProdErrorMessage(166));
                bubbleProperties(workInProgress2);
                return null;
              }
              current = contextStackCursor.current;
              if (popHydrationState(workInProgress2))
                prepareToHydrateHostInstance(workInProgress2, current);
              else {
                type = getOwnerDocumentFromRootContainer(
                  rootInstanceStackCursor.current
                );
                switch (current) {
                  case 1:
                    current = type.createElementNS(
                      "http://www.w3.org/2000/svg",
                      renderLanes2
                    );
                    break;
                  case 2:
                    current = type.createElementNS(
                      "http://www.w3.org/1998/Math/MathML",
                      renderLanes2
                    );
                    break;
                  default:
                    switch (renderLanes2) {
                      case "svg":
                        current = type.createElementNS(
                          "http://www.w3.org/2000/svg",
                          renderLanes2
                        );
                        break;
                      case "math":
                        current = type.createElementNS(
                          "http://www.w3.org/1998/Math/MathML",
                          renderLanes2
                        );
                        break;
                      case "script":
                        current = type.createElement("div");
                        current.innerHTML = "<script><\/script>";
                        current = current.removeChild(current.firstChild);
                        break;
                      case "select":
                        current = "string" === typeof newProps.is ? type.createElement("select", { is: newProps.is }) : type.createElement("select");
                        newProps.multiple ? current.multiple = true : newProps.size && (current.size = newProps.size);
                        break;
                      default:
                        current = "string" === typeof newProps.is ? type.createElement(renderLanes2, { is: newProps.is }) : type.createElement(renderLanes2);
                    }
                }
                current[internalInstanceKey] = workInProgress2;
                current[internalPropsKey] = newProps;
                a: for (type = workInProgress2.child; null !== type; ) {
                  if (5 === type.tag || 6 === type.tag)
                    current.appendChild(type.stateNode);
                  else if (4 !== type.tag && 27 !== type.tag && null !== type.child) {
                    type.child.return = type;
                    type = type.child;
                    continue;
                  }
                  if (type === workInProgress2) break a;
                  for (; null === type.sibling; ) {
                    if (null === type.return || type.return === workInProgress2)
                      break a;
                    type = type.return;
                  }
                  type.sibling.return = type.return;
                  type = type.sibling;
                }
                workInProgress2.stateNode = current;
                a: switch (setInitialProperties(current, renderLanes2, newProps), renderLanes2) {
                  case "button":
                  case "input":
                  case "select":
                  case "textarea":
                    current = !!newProps.autoFocus;
                    break a;
                  case "img":
                    current = true;
                    break a;
                  default:
                    current = false;
                }
                current && markUpdate(workInProgress2);
              }
            }
            bubbleProperties(workInProgress2);
            workInProgress2.flags &= -16777217;
            return null;
          case 6:
            if (current && null != workInProgress2.stateNode)
              current.memoizedProps !== newProps && markUpdate(workInProgress2);
            else {
              if ("string" !== typeof newProps && null === workInProgress2.stateNode)
                throw Error(formatProdErrorMessage(166));
              current = rootInstanceStackCursor.current;
              if (popHydrationState(workInProgress2)) {
                current = workInProgress2.stateNode;
                renderLanes2 = workInProgress2.memoizedProps;
                newProps = null;
                type = hydrationParentFiber;
                if (null !== type)
                  switch (type.tag) {
                    case 27:
                    case 5:
                      newProps = type.memoizedProps;
                  }
                current[internalInstanceKey] = workInProgress2;
                current = current.nodeValue === renderLanes2 || null !== newProps && true === newProps.suppressHydrationWarning || checkForUnmatchedText(current.nodeValue, renderLanes2) ? true : false;
                current || throwOnHydrationMismatch(workInProgress2);
              } else
                current = getOwnerDocumentFromRootContainer(current).createTextNode(
                  newProps
                ), current[internalInstanceKey] = workInProgress2, workInProgress2.stateNode = current;
            }
            bubbleProperties(workInProgress2);
            return null;
          case 13:
            newProps = workInProgress2.memoizedState;
            if (null === current || null !== current.memoizedState && null !== current.memoizedState.dehydrated) {
              type = popHydrationState(workInProgress2);
              if (null !== newProps && null !== newProps.dehydrated) {
                if (null === current) {
                  if (!type) throw Error(formatProdErrorMessage(318));
                  type = workInProgress2.memoizedState;
                  type = null !== type ? type.dehydrated : null;
                  if (!type) throw Error(formatProdErrorMessage(317));
                  type[internalInstanceKey] = workInProgress2;
                } else
                  resetHydrationState(), 0 === (workInProgress2.flags & 128) && (workInProgress2.memoizedState = null), workInProgress2.flags |= 4;
                bubbleProperties(workInProgress2);
                type = false;
              } else
                type = upgradeHydrationErrorsToRecoverable(), null !== current && null !== current.memoizedState && (current.memoizedState.hydrationErrors = type), type = true;
              if (!type) {
                if (workInProgress2.flags & 256)
                  return popSuspenseHandler(workInProgress2), workInProgress2;
                popSuspenseHandler(workInProgress2);
                return null;
              }
            }
            popSuspenseHandler(workInProgress2);
            if (0 !== (workInProgress2.flags & 128))
              return workInProgress2.lanes = renderLanes2, workInProgress2;
            renderLanes2 = null !== newProps;
            current = null !== current && null !== current.memoizedState;
            if (renderLanes2) {
              newProps = workInProgress2.child;
              type = null;
              null !== newProps.alternate && null !== newProps.alternate.memoizedState && null !== newProps.alternate.memoizedState.cachePool && (type = newProps.alternate.memoizedState.cachePool.pool);
              var cache$127 = null;
              null !== newProps.memoizedState && null !== newProps.memoizedState.cachePool && (cache$127 = newProps.memoizedState.cachePool.pool);
              cache$127 !== type && (newProps.flags |= 2048);
            }
            renderLanes2 !== current && renderLanes2 && (workInProgress2.child.flags |= 8192);
            scheduleRetryEffect(workInProgress2, workInProgress2.updateQueue);
            bubbleProperties(workInProgress2);
            return null;
          case 4:
            return popHostContainer(), null === current && listenToAllSupportedEvents(workInProgress2.stateNode.containerInfo), bubbleProperties(workInProgress2), null;
          case 10:
            return popProvider(workInProgress2.type), bubbleProperties(workInProgress2), null;
          case 19:
            pop(suspenseStackCursor);
            type = workInProgress2.memoizedState;
            if (null === type) return bubbleProperties(workInProgress2), null;
            newProps = 0 !== (workInProgress2.flags & 128);
            cache$127 = type.rendering;
            if (null === cache$127)
              if (newProps) cutOffTailIfNeeded(type, false);
              else {
                if (0 !== workInProgressRootExitStatus || null !== current && 0 !== (current.flags & 128))
                  for (current = workInProgress2.child; null !== current; ) {
                    cache$127 = findFirstSuspended(current);
                    if (null !== cache$127) {
                      workInProgress2.flags |= 128;
                      cutOffTailIfNeeded(type, false);
                      current = cache$127.updateQueue;
                      workInProgress2.updateQueue = current;
                      scheduleRetryEffect(workInProgress2, current);
                      workInProgress2.subtreeFlags = 0;
                      current = renderLanes2;
                      for (renderLanes2 = workInProgress2.child; null !== renderLanes2; )
                        resetWorkInProgress(renderLanes2, current), renderLanes2 = renderLanes2.sibling;
                      push(
                        suspenseStackCursor,
                        suspenseStackCursor.current & 1 | 2
                      );
                      return workInProgress2.child;
                    }
                    current = current.sibling;
                  }
                null !== type.tail && now() > workInProgressRootRenderTargetTime && (workInProgress2.flags |= 128, newProps = true, cutOffTailIfNeeded(type, false), workInProgress2.lanes = 4194304);
              }
            else {
              if (!newProps)
                if (current = findFirstSuspended(cache$127), null !== current) {
                  if (workInProgress2.flags |= 128, newProps = true, current = current.updateQueue, workInProgress2.updateQueue = current, scheduleRetryEffect(workInProgress2, current), cutOffTailIfNeeded(type, true), null === type.tail && "hidden" === type.tailMode && !cache$127.alternate && !isHydrating)
                    return bubbleProperties(workInProgress2), null;
                } else
                  2 * now() - type.renderingStartTime > workInProgressRootRenderTargetTime && 536870912 !== renderLanes2 && (workInProgress2.flags |= 128, newProps = true, cutOffTailIfNeeded(type, false), workInProgress2.lanes = 4194304);
              type.isBackwards ? (cache$127.sibling = workInProgress2.child, workInProgress2.child = cache$127) : (current = type.last, null !== current ? current.sibling = cache$127 : workInProgress2.child = cache$127, type.last = cache$127);
            }
            if (null !== type.tail)
              return workInProgress2 = type.tail, type.rendering = workInProgress2, type.tail = workInProgress2.sibling, type.renderingStartTime = now(), workInProgress2.sibling = null, current = suspenseStackCursor.current, push(suspenseStackCursor, newProps ? current & 1 | 2 : current & 1), workInProgress2;
            bubbleProperties(workInProgress2);
            return null;
          case 22:
          case 23:
            return popSuspenseHandler(workInProgress2), popHiddenContext(), newProps = null !== workInProgress2.memoizedState, null !== current ? null !== current.memoizedState !== newProps && (workInProgress2.flags |= 8192) : newProps && (workInProgress2.flags |= 8192), newProps ? 0 !== (renderLanes2 & 536870912) && 0 === (workInProgress2.flags & 128) && (bubbleProperties(workInProgress2), workInProgress2.subtreeFlags & 6 && (workInProgress2.flags |= 8192)) : bubbleProperties(workInProgress2), renderLanes2 = workInProgress2.updateQueue, null !== renderLanes2 && scheduleRetryEffect(workInProgress2, renderLanes2.retryQueue), renderLanes2 = null, null !== current && null !== current.memoizedState && null !== current.memoizedState.cachePool && (renderLanes2 = current.memoizedState.cachePool.pool), newProps = null, null !== workInProgress2.memoizedState && null !== workInProgress2.memoizedState.cachePool && (newProps = workInProgress2.memoizedState.cachePool.pool), newProps !== renderLanes2 && (workInProgress2.flags |= 2048), null !== current && pop(resumedCache), null;
          case 24:
            return renderLanes2 = null, null !== current && (renderLanes2 = current.memoizedState.cache), workInProgress2.memoizedState.cache !== renderLanes2 && (workInProgress2.flags |= 2048), popProvider(CacheContext), bubbleProperties(workInProgress2), null;
          case 25:
            return null;
          case 30:
            return null;
        }
        throw Error(formatProdErrorMessage(156, workInProgress2.tag));
      }
      function unwindWork(current, workInProgress2) {
        popTreeContext(workInProgress2);
        switch (workInProgress2.tag) {
          case 1:
            return current = workInProgress2.flags, current & 65536 ? (workInProgress2.flags = current & -65537 | 128, workInProgress2) : null;
          case 3:
            return popProvider(CacheContext), popHostContainer(), current = workInProgress2.flags, 0 !== (current & 65536) && 0 === (current & 128) ? (workInProgress2.flags = current & -65537 | 128, workInProgress2) : null;
          case 26:
          case 27:
          case 5:
            return popHostContext(workInProgress2), null;
          case 13:
            popSuspenseHandler(workInProgress2);
            current = workInProgress2.memoizedState;
            if (null !== current && null !== current.dehydrated) {
              if (null === workInProgress2.alternate)
                throw Error(formatProdErrorMessage(340));
              resetHydrationState();
            }
            current = workInProgress2.flags;
            return current & 65536 ? (workInProgress2.flags = current & -65537 | 128, workInProgress2) : null;
          case 19:
            return pop(suspenseStackCursor), null;
          case 4:
            return popHostContainer(), null;
          case 10:
            return popProvider(workInProgress2.type), null;
          case 22:
          case 23:
            return popSuspenseHandler(workInProgress2), popHiddenContext(), null !== current && pop(resumedCache), current = workInProgress2.flags, current & 65536 ? (workInProgress2.flags = current & -65537 | 128, workInProgress2) : null;
          case 24:
            return popProvider(CacheContext), null;
          case 25:
            return null;
          default:
            return null;
        }
      }
      function unwindInterruptedWork(current, interruptedWork) {
        popTreeContext(interruptedWork);
        switch (interruptedWork.tag) {
          case 3:
            popProvider(CacheContext);
            popHostContainer();
            break;
          case 26:
          case 27:
          case 5:
            popHostContext(interruptedWork);
            break;
          case 4:
            popHostContainer();
            break;
          case 13:
            popSuspenseHandler(interruptedWork);
            break;
          case 19:
            pop(suspenseStackCursor);
            break;
          case 10:
            popProvider(interruptedWork.type);
            break;
          case 22:
          case 23:
            popSuspenseHandler(interruptedWork);
            popHiddenContext();
            null !== current && pop(resumedCache);
            break;
          case 24:
            popProvider(CacheContext);
        }
      }
      function commitHookEffectListMount(flags, finishedWork) {
        try {
          var updateQueue = finishedWork.updateQueue, lastEffect = null !== updateQueue ? updateQueue.lastEffect : null;
          if (null !== lastEffect) {
            var firstEffect = lastEffect.next;
            updateQueue = firstEffect;
            do {
              if ((updateQueue.tag & flags) === flags) {
                lastEffect = void 0;
                var create = updateQueue.create, inst = updateQueue.inst;
                lastEffect = create();
                inst.destroy = lastEffect;
              }
              updateQueue = updateQueue.next;
            } while (updateQueue !== firstEffect);
          }
        } catch (error) {
          captureCommitPhaseError(finishedWork, finishedWork.return, error);
        }
      }
      function commitHookEffectListUnmount(flags, finishedWork, nearestMountedAncestor$jscomp$0) {
        try {
          var updateQueue = finishedWork.updateQueue, lastEffect = null !== updateQueue ? updateQueue.lastEffect : null;
          if (null !== lastEffect) {
            var firstEffect = lastEffect.next;
            updateQueue = firstEffect;
            do {
              if ((updateQueue.tag & flags) === flags) {
                var inst = updateQueue.inst, destroy = inst.destroy;
                if (void 0 !== destroy) {
                  inst.destroy = void 0;
                  lastEffect = finishedWork;
                  var nearestMountedAncestor = nearestMountedAncestor$jscomp$0, destroy_ = destroy;
                  try {
                    destroy_();
                  } catch (error) {
                    captureCommitPhaseError(
                      lastEffect,
                      nearestMountedAncestor,
                      error
                    );
                  }
                }
              }
              updateQueue = updateQueue.next;
            } while (updateQueue !== firstEffect);
          }
        } catch (error) {
          captureCommitPhaseError(finishedWork, finishedWork.return, error);
        }
      }
      function commitClassCallbacks(finishedWork) {
        var updateQueue = finishedWork.updateQueue;
        if (null !== updateQueue) {
          var instance = finishedWork.stateNode;
          try {
            commitCallbacks(updateQueue, instance);
          } catch (error) {
            captureCommitPhaseError(finishedWork, finishedWork.return, error);
          }
        }
      }
      function safelyCallComponentWillUnmount(current, nearestMountedAncestor, instance) {
        instance.props = resolveClassComponentProps(
          current.type,
          current.memoizedProps
        );
        instance.state = current.memoizedState;
        try {
          instance.componentWillUnmount();
        } catch (error) {
          captureCommitPhaseError(current, nearestMountedAncestor, error);
        }
      }
      function safelyAttachRef(current, nearestMountedAncestor) {
        try {
          var ref = current.ref;
          if (null !== ref) {
            switch (current.tag) {
              case 26:
              case 27:
              case 5:
                var instanceToUse = current.stateNode;
                break;
              case 30:
                instanceToUse = current.stateNode;
                break;
              default:
                instanceToUse = current.stateNode;
            }
            "function" === typeof ref ? current.refCleanup = ref(instanceToUse) : ref.current = instanceToUse;
          }
        } catch (error) {
          captureCommitPhaseError(current, nearestMountedAncestor, error);
        }
      }
      function safelyDetachRef(current, nearestMountedAncestor) {
        var ref = current.ref, refCleanup = current.refCleanup;
        if (null !== ref)
          if ("function" === typeof refCleanup)
            try {
              refCleanup();
            } catch (error) {
              captureCommitPhaseError(current, nearestMountedAncestor, error);
            } finally {
              current.refCleanup = null, current = current.alternate, null != current && (current.refCleanup = null);
            }
          else if ("function" === typeof ref)
            try {
              ref(null);
            } catch (error$143) {
              captureCommitPhaseError(current, nearestMountedAncestor, error$143);
            }
          else ref.current = null;
      }
      function commitHostMount(finishedWork) {
        var type = finishedWork.type, props = finishedWork.memoizedProps, instance = finishedWork.stateNode;
        try {
          a: switch (type) {
            case "button":
            case "input":
            case "select":
            case "textarea":
              props.autoFocus && instance.focus();
              break a;
            case "img":
              props.src ? instance.src = props.src : props.srcSet && (instance.srcset = props.srcSet);
          }
        } catch (error) {
          captureCommitPhaseError(finishedWork, finishedWork.return, error);
        }
      }
      function commitHostUpdate(finishedWork, newProps, oldProps) {
        try {
          var domElement = finishedWork.stateNode;
          updateProperties(domElement, finishedWork.type, oldProps, newProps);
          domElement[internalPropsKey] = newProps;
        } catch (error) {
          captureCommitPhaseError(finishedWork, finishedWork.return, error);
        }
      }
      function isHostParent(fiber) {
        return 5 === fiber.tag || 3 === fiber.tag || 26 === fiber.tag || 27 === fiber.tag && isSingletonScope(fiber.type) || 4 === fiber.tag;
      }
      function getHostSibling(fiber) {
        a: for (; ; ) {
          for (; null === fiber.sibling; ) {
            if (null === fiber.return || isHostParent(fiber.return)) return null;
            fiber = fiber.return;
          }
          fiber.sibling.return = fiber.return;
          for (fiber = fiber.sibling; 5 !== fiber.tag && 6 !== fiber.tag && 18 !== fiber.tag; ) {
            if (27 === fiber.tag && isSingletonScope(fiber.type)) continue a;
            if (fiber.flags & 2) continue a;
            if (null === fiber.child || 4 === fiber.tag) continue a;
            else fiber.child.return = fiber, fiber = fiber.child;
          }
          if (!(fiber.flags & 2)) return fiber.stateNode;
        }
      }
      function insertOrAppendPlacementNodeIntoContainer(node, before, parent) {
        var tag = node.tag;
        if (5 === tag || 6 === tag)
          node = node.stateNode, before ? (9 === parent.nodeType ? parent.body : "HTML" === parent.nodeName ? parent.ownerDocument.body : parent).insertBefore(node, before) : (before = 9 === parent.nodeType ? parent.body : "HTML" === parent.nodeName ? parent.ownerDocument.body : parent, before.appendChild(node), parent = parent._reactRootContainer, null !== parent && void 0 !== parent || null !== before.onclick || (before.onclick = noop$1));
        else if (4 !== tag && (27 === tag && isSingletonScope(node.type) && (parent = node.stateNode, before = null), node = node.child, null !== node))
          for (insertOrAppendPlacementNodeIntoContainer(node, before, parent), node = node.sibling; null !== node; )
            insertOrAppendPlacementNodeIntoContainer(node, before, parent), node = node.sibling;
      }
      function insertOrAppendPlacementNode(node, before, parent) {
        var tag = node.tag;
        if (5 === tag || 6 === tag)
          node = node.stateNode, before ? parent.insertBefore(node, before) : parent.appendChild(node);
        else if (4 !== tag && (27 === tag && isSingletonScope(node.type) && (parent = node.stateNode), node = node.child, null !== node))
          for (insertOrAppendPlacementNode(node, before, parent), node = node.sibling; null !== node; )
            insertOrAppendPlacementNode(node, before, parent), node = node.sibling;
      }
      function commitHostSingletonAcquisition(finishedWork) {
        var singleton = finishedWork.stateNode, props = finishedWork.memoizedProps;
        try {
          for (var type = finishedWork.type, attributes = singleton.attributes; attributes.length; )
            singleton.removeAttributeNode(attributes[0]);
          setInitialProperties(singleton, type, props);
          singleton[internalInstanceKey] = finishedWork;
          singleton[internalPropsKey] = props;
        } catch (error) {
          captureCommitPhaseError(finishedWork, finishedWork.return, error);
        }
      }
      var offscreenSubtreeIsHidden = false;
      var offscreenSubtreeWasHidden = false;
      var needsFormReset = false;
      var PossiblyWeakSet = "function" === typeof WeakSet ? WeakSet : Set;
      var nextEffect = null;
      function commitBeforeMutationEffects(root2, firstChild) {
        root2 = root2.containerInfo;
        eventsEnabled = _enabled;
        root2 = getActiveElementDeep(root2);
        if (hasSelectionCapabilities(root2)) {
          if ("selectionStart" in root2)
            var JSCompiler_temp = {
              start: root2.selectionStart,
              end: root2.selectionEnd
            };
          else
            a: {
              JSCompiler_temp = (JSCompiler_temp = root2.ownerDocument) && JSCompiler_temp.defaultView || window;
              var selection = JSCompiler_temp.getSelection && JSCompiler_temp.getSelection();
              if (selection && 0 !== selection.rangeCount) {
                JSCompiler_temp = selection.anchorNode;
                var anchorOffset = selection.anchorOffset, focusNode = selection.focusNode;
                selection = selection.focusOffset;
                try {
                  JSCompiler_temp.nodeType, focusNode.nodeType;
                } catch (e$20) {
                  JSCompiler_temp = null;
                  break a;
                }
                var length = 0, start = -1, end = -1, indexWithinAnchor = 0, indexWithinFocus = 0, node = root2, parentNode = null;
                b: for (; ; ) {
                  for (var next; ; ) {
                    node !== JSCompiler_temp || 0 !== anchorOffset && 3 !== node.nodeType || (start = length + anchorOffset);
                    node !== focusNode || 0 !== selection && 3 !== node.nodeType || (end = length + selection);
                    3 === node.nodeType && (length += node.nodeValue.length);
                    if (null === (next = node.firstChild)) break;
                    parentNode = node;
                    node = next;
                  }
                  for (; ; ) {
                    if (node === root2) break b;
                    parentNode === JSCompiler_temp && ++indexWithinAnchor === anchorOffset && (start = length);
                    parentNode === focusNode && ++indexWithinFocus === selection && (end = length);
                    if (null !== (next = node.nextSibling)) break;
                    node = parentNode;
                    parentNode = node.parentNode;
                  }
                  node = next;
                }
                JSCompiler_temp = -1 === start || -1 === end ? null : { start, end };
              } else JSCompiler_temp = null;
            }
          JSCompiler_temp = JSCompiler_temp || { start: 0, end: 0 };
        } else JSCompiler_temp = null;
        selectionInformation = { focusedElem: root2, selectionRange: JSCompiler_temp };
        _enabled = false;
        for (nextEffect = firstChild; null !== nextEffect; )
          if (firstChild = nextEffect, root2 = firstChild.child, 0 !== (firstChild.subtreeFlags & 1024) && null !== root2)
            root2.return = firstChild, nextEffect = root2;
          else
            for (; null !== nextEffect; ) {
              firstChild = nextEffect;
              focusNode = firstChild.alternate;
              root2 = firstChild.flags;
              switch (firstChild.tag) {
                case 0:
                  break;
                case 11:
                case 15:
                  break;
                case 1:
                  if (0 !== (root2 & 1024) && null !== focusNode) {
                    root2 = void 0;
                    JSCompiler_temp = firstChild;
                    anchorOffset = focusNode.memoizedProps;
                    focusNode = focusNode.memoizedState;
                    selection = JSCompiler_temp.stateNode;
                    try {
                      var resolvedPrevProps = resolveClassComponentProps(
                        JSCompiler_temp.type,
                        anchorOffset,
                        JSCompiler_temp.elementType === JSCompiler_temp.type
                      );
                      root2 = selection.getSnapshotBeforeUpdate(
                        resolvedPrevProps,
                        focusNode
                      );
                      selection.__reactInternalSnapshotBeforeUpdate = root2;
                    } catch (error) {
                      captureCommitPhaseError(
                        JSCompiler_temp,
                        JSCompiler_temp.return,
                        error
                      );
                    }
                  }
                  break;
                case 3:
                  if (0 !== (root2 & 1024)) {
                    if (root2 = firstChild.stateNode.containerInfo, JSCompiler_temp = root2.nodeType, 9 === JSCompiler_temp)
                      clearContainerSparingly(root2);
                    else if (1 === JSCompiler_temp)
                      switch (root2.nodeName) {
                        case "HEAD":
                        case "HTML":
                        case "BODY":
                          clearContainerSparingly(root2);
                          break;
                        default:
                          root2.textContent = "";
                      }
                  }
                  break;
                case 5:
                case 26:
                case 27:
                case 6:
                case 4:
                case 17:
                  break;
                default:
                  if (0 !== (root2 & 1024)) throw Error(formatProdErrorMessage(163));
              }
              root2 = firstChild.sibling;
              if (null !== root2) {
                root2.return = firstChild.return;
                nextEffect = root2;
                break;
              }
              nextEffect = firstChild.return;
            }
      }
      function commitLayoutEffectOnFiber(finishedRoot, current, finishedWork) {
        var flags = finishedWork.flags;
        switch (finishedWork.tag) {
          case 0:
          case 11:
          case 15:
            recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
            flags & 4 && commitHookEffectListMount(5, finishedWork);
            break;
          case 1:
            recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
            if (flags & 4)
              if (finishedRoot = finishedWork.stateNode, null === current)
                try {
                  finishedRoot.componentDidMount();
                } catch (error) {
                  captureCommitPhaseError(finishedWork, finishedWork.return, error);
                }
              else {
                var prevProps = resolveClassComponentProps(
                  finishedWork.type,
                  current.memoizedProps
                );
                current = current.memoizedState;
                try {
                  finishedRoot.componentDidUpdate(
                    prevProps,
                    current,
                    finishedRoot.__reactInternalSnapshotBeforeUpdate
                  );
                } catch (error$142) {
                  captureCommitPhaseError(
                    finishedWork,
                    finishedWork.return,
                    error$142
                  );
                }
              }
            flags & 64 && commitClassCallbacks(finishedWork);
            flags & 512 && safelyAttachRef(finishedWork, finishedWork.return);
            break;
          case 3:
            recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
            if (flags & 64 && (finishedRoot = finishedWork.updateQueue, null !== finishedRoot)) {
              current = null;
              if (null !== finishedWork.child)
                switch (finishedWork.child.tag) {
                  case 27:
                  case 5:
                    current = finishedWork.child.stateNode;
                    break;
                  case 1:
                    current = finishedWork.child.stateNode;
                }
              try {
                commitCallbacks(finishedRoot, current);
              } catch (error) {
                captureCommitPhaseError(finishedWork, finishedWork.return, error);
              }
            }
            break;
          case 27:
            null === current && flags & 4 && commitHostSingletonAcquisition(finishedWork);
          case 26:
          case 5:
            recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
            null === current && flags & 4 && commitHostMount(finishedWork);
            flags & 512 && safelyAttachRef(finishedWork, finishedWork.return);
            break;
          case 12:
            recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
            break;
          case 13:
            recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
            flags & 4 && commitSuspenseHydrationCallbacks(finishedRoot, finishedWork);
            flags & 64 && (finishedRoot = finishedWork.memoizedState, null !== finishedRoot && (finishedRoot = finishedRoot.dehydrated, null !== finishedRoot && (finishedWork = retryDehydratedSuspenseBoundary.bind(
              null,
              finishedWork
            ), registerSuspenseInstanceRetry(finishedRoot, finishedWork))));
            break;
          case 22:
            flags = null !== finishedWork.memoizedState || offscreenSubtreeIsHidden;
            if (!flags) {
              current = null !== current && null !== current.memoizedState || offscreenSubtreeWasHidden;
              prevProps = offscreenSubtreeIsHidden;
              var prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;
              offscreenSubtreeIsHidden = flags;
              (offscreenSubtreeWasHidden = current) && !prevOffscreenSubtreeWasHidden ? recursivelyTraverseReappearLayoutEffects(
                finishedRoot,
                finishedWork,
                0 !== (finishedWork.subtreeFlags & 8772)
              ) : recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
              offscreenSubtreeIsHidden = prevProps;
              offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;
            }
            break;
          case 30:
            break;
          default:
            recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
        }
      }
      function detachFiberAfterEffects(fiber) {
        var alternate = fiber.alternate;
        null !== alternate && (fiber.alternate = null, detachFiberAfterEffects(alternate));
        fiber.child = null;
        fiber.deletions = null;
        fiber.sibling = null;
        5 === fiber.tag && (alternate = fiber.stateNode, null !== alternate && detachDeletedInstance(alternate));
        fiber.stateNode = null;
        fiber.return = null;
        fiber.dependencies = null;
        fiber.memoizedProps = null;
        fiber.memoizedState = null;
        fiber.pendingProps = null;
        fiber.stateNode = null;
        fiber.updateQueue = null;
      }
      var hostParent = null;
      var hostParentIsContainer = false;
      function recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, parent) {
        for (parent = parent.child; null !== parent; )
          commitDeletionEffectsOnFiber(finishedRoot, nearestMountedAncestor, parent), parent = parent.sibling;
      }
      function commitDeletionEffectsOnFiber(finishedRoot, nearestMountedAncestor, deletedFiber) {
        if (injectedHook && "function" === typeof injectedHook.onCommitFiberUnmount)
          try {
            injectedHook.onCommitFiberUnmount(rendererID, deletedFiber);
          } catch (err) {
          }
        switch (deletedFiber.tag) {
          case 26:
            offscreenSubtreeWasHidden || safelyDetachRef(deletedFiber, nearestMountedAncestor);
            recursivelyTraverseDeletionEffects(
              finishedRoot,
              nearestMountedAncestor,
              deletedFiber
            );
            deletedFiber.memoizedState ? deletedFiber.memoizedState.count-- : deletedFiber.stateNode && (deletedFiber = deletedFiber.stateNode, deletedFiber.parentNode.removeChild(deletedFiber));
            break;
          case 27:
            offscreenSubtreeWasHidden || safelyDetachRef(deletedFiber, nearestMountedAncestor);
            var prevHostParent = hostParent, prevHostParentIsContainer = hostParentIsContainer;
            isSingletonScope(deletedFiber.type) && (hostParent = deletedFiber.stateNode, hostParentIsContainer = false);
            recursivelyTraverseDeletionEffects(
              finishedRoot,
              nearestMountedAncestor,
              deletedFiber
            );
            releaseSingletonInstance(deletedFiber.stateNode);
            hostParent = prevHostParent;
            hostParentIsContainer = prevHostParentIsContainer;
            break;
          case 5:
            offscreenSubtreeWasHidden || safelyDetachRef(deletedFiber, nearestMountedAncestor);
          case 6:
            prevHostParent = hostParent;
            prevHostParentIsContainer = hostParentIsContainer;
            hostParent = null;
            recursivelyTraverseDeletionEffects(
              finishedRoot,
              nearestMountedAncestor,
              deletedFiber
            );
            hostParent = prevHostParent;
            hostParentIsContainer = prevHostParentIsContainer;
            if (null !== hostParent)
              if (hostParentIsContainer)
                try {
                  (9 === hostParent.nodeType ? hostParent.body : "HTML" === hostParent.nodeName ? hostParent.ownerDocument.body : hostParent).removeChild(deletedFiber.stateNode);
                } catch (error) {
                  captureCommitPhaseError(
                    deletedFiber,
                    nearestMountedAncestor,
                    error
                  );
                }
              else
                try {
                  hostParent.removeChild(deletedFiber.stateNode);
                } catch (error) {
                  captureCommitPhaseError(
                    deletedFiber,
                    nearestMountedAncestor,
                    error
                  );
                }
            break;
          case 18:
            null !== hostParent && (hostParentIsContainer ? (finishedRoot = hostParent, clearSuspenseBoundary(
              9 === finishedRoot.nodeType ? finishedRoot.body : "HTML" === finishedRoot.nodeName ? finishedRoot.ownerDocument.body : finishedRoot,
              deletedFiber.stateNode
            ), retryIfBlockedOn(finishedRoot)) : clearSuspenseBoundary(hostParent, deletedFiber.stateNode));
            break;
          case 4:
            prevHostParent = hostParent;
            prevHostParentIsContainer = hostParentIsContainer;
            hostParent = deletedFiber.stateNode.containerInfo;
            hostParentIsContainer = true;
            recursivelyTraverseDeletionEffects(
              finishedRoot,
              nearestMountedAncestor,
              deletedFiber
            );
            hostParent = prevHostParent;
            hostParentIsContainer = prevHostParentIsContainer;
            break;
          case 0:
          case 11:
          case 14:
          case 15:
            offscreenSubtreeWasHidden || commitHookEffectListUnmount(2, deletedFiber, nearestMountedAncestor);
            offscreenSubtreeWasHidden || commitHookEffectListUnmount(4, deletedFiber, nearestMountedAncestor);
            recursivelyTraverseDeletionEffects(
              finishedRoot,
              nearestMountedAncestor,
              deletedFiber
            );
            break;
          case 1:
            offscreenSubtreeWasHidden || (safelyDetachRef(deletedFiber, nearestMountedAncestor), prevHostParent = deletedFiber.stateNode, "function" === typeof prevHostParent.componentWillUnmount && safelyCallComponentWillUnmount(
              deletedFiber,
              nearestMountedAncestor,
              prevHostParent
            ));
            recursivelyTraverseDeletionEffects(
              finishedRoot,
              nearestMountedAncestor,
              deletedFiber
            );
            break;
          case 21:
            recursivelyTraverseDeletionEffects(
              finishedRoot,
              nearestMountedAncestor,
              deletedFiber
            );
            break;
          case 22:
            offscreenSubtreeWasHidden = (prevHostParent = offscreenSubtreeWasHidden) || null !== deletedFiber.memoizedState;
            recursivelyTraverseDeletionEffects(
              finishedRoot,
              nearestMountedAncestor,
              deletedFiber
            );
            offscreenSubtreeWasHidden = prevHostParent;
            break;
          default:
            recursivelyTraverseDeletionEffects(
              finishedRoot,
              nearestMountedAncestor,
              deletedFiber
            );
        }
      }
      function commitSuspenseHydrationCallbacks(finishedRoot, finishedWork) {
        if (null === finishedWork.memoizedState && (finishedRoot = finishedWork.alternate, null !== finishedRoot && (finishedRoot = finishedRoot.memoizedState, null !== finishedRoot && (finishedRoot = finishedRoot.dehydrated, null !== finishedRoot))))
          try {
            retryIfBlockedOn(finishedRoot);
          } catch (error) {
            captureCommitPhaseError(finishedWork, finishedWork.return, error);
          }
      }
      function getRetryCache(finishedWork) {
        switch (finishedWork.tag) {
          case 13:
          case 19:
            var retryCache = finishedWork.stateNode;
            null === retryCache && (retryCache = finishedWork.stateNode = new PossiblyWeakSet());
            return retryCache;
          case 22:
            return finishedWork = finishedWork.stateNode, retryCache = finishedWork._retryCache, null === retryCache && (retryCache = finishedWork._retryCache = new PossiblyWeakSet()), retryCache;
          default:
            throw Error(formatProdErrorMessage(435, finishedWork.tag));
        }
      }
      function attachSuspenseRetryListeners(finishedWork, wakeables) {
        var retryCache = getRetryCache(finishedWork);
        wakeables.forEach(function(wakeable) {
          var retry = resolveRetryWakeable.bind(null, finishedWork, wakeable);
          retryCache.has(wakeable) || (retryCache.add(wakeable), wakeable.then(retry, retry));
        });
      }
      function recursivelyTraverseMutationEffects(root$jscomp$0, parentFiber) {
        var deletions = parentFiber.deletions;
        if (null !== deletions)
          for (var i = 0; i < deletions.length; i++) {
            var childToDelete = deletions[i], root2 = root$jscomp$0, returnFiber = parentFiber, parent = returnFiber;
            a: for (; null !== parent; ) {
              switch (parent.tag) {
                case 27:
                  if (isSingletonScope(parent.type)) {
                    hostParent = parent.stateNode;
                    hostParentIsContainer = false;
                    break a;
                  }
                  break;
                case 5:
                  hostParent = parent.stateNode;
                  hostParentIsContainer = false;
                  break a;
                case 3:
                case 4:
                  hostParent = parent.stateNode.containerInfo;
                  hostParentIsContainer = true;
                  break a;
              }
              parent = parent.return;
            }
            if (null === hostParent) throw Error(formatProdErrorMessage(160));
            commitDeletionEffectsOnFiber(root2, returnFiber, childToDelete);
            hostParent = null;
            hostParentIsContainer = false;
            root2 = childToDelete.alternate;
            null !== root2 && (root2.return = null);
            childToDelete.return = null;
          }
        if (parentFiber.subtreeFlags & 13878)
          for (parentFiber = parentFiber.child; null !== parentFiber; )
            commitMutationEffectsOnFiber(parentFiber, root$jscomp$0), parentFiber = parentFiber.sibling;
      }
      var currentHoistableRoot = null;
      function commitMutationEffectsOnFiber(finishedWork, root2) {
        var current = finishedWork.alternate, flags = finishedWork.flags;
        switch (finishedWork.tag) {
          case 0:
          case 11:
          case 14:
          case 15:
            recursivelyTraverseMutationEffects(root2, finishedWork);
            commitReconciliationEffects(finishedWork);
            flags & 4 && (commitHookEffectListUnmount(3, finishedWork, finishedWork.return), commitHookEffectListMount(3, finishedWork), commitHookEffectListUnmount(5, finishedWork, finishedWork.return));
            break;
          case 1:
            recursivelyTraverseMutationEffects(root2, finishedWork);
            commitReconciliationEffects(finishedWork);
            flags & 512 && (offscreenSubtreeWasHidden || null === current || safelyDetachRef(current, current.return));
            flags & 64 && offscreenSubtreeIsHidden && (finishedWork = finishedWork.updateQueue, null !== finishedWork && (flags = finishedWork.callbacks, null !== flags && (current = finishedWork.shared.hiddenCallbacks, finishedWork.shared.hiddenCallbacks = null === current ? flags : current.concat(flags))));
            break;
          case 26:
            var hoistableRoot = currentHoistableRoot;
            recursivelyTraverseMutationEffects(root2, finishedWork);
            commitReconciliationEffects(finishedWork);
            flags & 512 && (offscreenSubtreeWasHidden || null === current || safelyDetachRef(current, current.return));
            if (flags & 4) {
              var currentResource = null !== current ? current.memoizedState : null;
              flags = finishedWork.memoizedState;
              if (null === current)
                if (null === flags)
                  if (null === finishedWork.stateNode) {
                    a: {
                      flags = finishedWork.type;
                      current = finishedWork.memoizedProps;
                      hoistableRoot = hoistableRoot.ownerDocument || hoistableRoot;
                      b: switch (flags) {
                        case "title":
                          currentResource = hoistableRoot.getElementsByTagName("title")[0];
                          if (!currentResource || currentResource[internalHoistableMarker] || currentResource[internalInstanceKey] || "http://www.w3.org/2000/svg" === currentResource.namespaceURI || currentResource.hasAttribute("itemprop"))
                            currentResource = hoistableRoot.createElement(flags), hoistableRoot.head.insertBefore(
                              currentResource,
                              hoistableRoot.querySelector("head > title")
                            );
                          setInitialProperties(currentResource, flags, current);
                          currentResource[internalInstanceKey] = finishedWork;
                          markNodeAsHoistable(currentResource);
                          flags = currentResource;
                          break a;
                        case "link":
                          var maybeNodes = getHydratableHoistableCache(
                            "link",
                            "href",
                            hoistableRoot
                          ).get(flags + (current.href || ""));
                          if (maybeNodes) {
                            for (var i = 0; i < maybeNodes.length; i++)
                              if (currentResource = maybeNodes[i], currentResource.getAttribute("href") === (null == current.href || "" === current.href ? null : current.href) && currentResource.getAttribute("rel") === (null == current.rel ? null : current.rel) && currentResource.getAttribute("title") === (null == current.title ? null : current.title) && currentResource.getAttribute("crossorigin") === (null == current.crossOrigin ? null : current.crossOrigin)) {
                                maybeNodes.splice(i, 1);
                                break b;
                              }
                          }
                          currentResource = hoistableRoot.createElement(flags);
                          setInitialProperties(currentResource, flags, current);
                          hoistableRoot.head.appendChild(currentResource);
                          break;
                        case "meta":
                          if (maybeNodes = getHydratableHoistableCache(
                            "meta",
                            "content",
                            hoistableRoot
                          ).get(flags + (current.content || ""))) {
                            for (i = 0; i < maybeNodes.length; i++)
                              if (currentResource = maybeNodes[i], currentResource.getAttribute("content") === (null == current.content ? null : "" + current.content) && currentResource.getAttribute("name") === (null == current.name ? null : current.name) && currentResource.getAttribute("property") === (null == current.property ? null : current.property) && currentResource.getAttribute("http-equiv") === (null == current.httpEquiv ? null : current.httpEquiv) && currentResource.getAttribute("charset") === (null == current.charSet ? null : current.charSet)) {
                                maybeNodes.splice(i, 1);
                                break b;
                              }
                          }
                          currentResource = hoistableRoot.createElement(flags);
                          setInitialProperties(currentResource, flags, current);
                          hoistableRoot.head.appendChild(currentResource);
                          break;
                        default:
                          throw Error(formatProdErrorMessage(468, flags));
                      }
                      currentResource[internalInstanceKey] = finishedWork;
                      markNodeAsHoistable(currentResource);
                      flags = currentResource;
                    }
                    finishedWork.stateNode = flags;
                  } else
                    mountHoistable(
                      hoistableRoot,
                      finishedWork.type,
                      finishedWork.stateNode
                    );
                else
                  finishedWork.stateNode = acquireResource(
                    hoistableRoot,
                    flags,
                    finishedWork.memoizedProps
                  );
              else
                currentResource !== flags ? (null === currentResource ? null !== current.stateNode && (current = current.stateNode, current.parentNode.removeChild(current)) : currentResource.count--, null === flags ? mountHoistable(
                  hoistableRoot,
                  finishedWork.type,
                  finishedWork.stateNode
                ) : acquireResource(
                  hoistableRoot,
                  flags,
                  finishedWork.memoizedProps
                )) : null === flags && null !== finishedWork.stateNode && commitHostUpdate(
                  finishedWork,
                  finishedWork.memoizedProps,
                  current.memoizedProps
                );
            }
            break;
          case 27:
            recursivelyTraverseMutationEffects(root2, finishedWork);
            commitReconciliationEffects(finishedWork);
            flags & 512 && (offscreenSubtreeWasHidden || null === current || safelyDetachRef(current, current.return));
            null !== current && flags & 4 && commitHostUpdate(
              finishedWork,
              finishedWork.memoizedProps,
              current.memoizedProps
            );
            break;
          case 5:
            recursivelyTraverseMutationEffects(root2, finishedWork);
            commitReconciliationEffects(finishedWork);
            flags & 512 && (offscreenSubtreeWasHidden || null === current || safelyDetachRef(current, current.return));
            if (finishedWork.flags & 32) {
              hoistableRoot = finishedWork.stateNode;
              try {
                setTextContent(hoistableRoot, "");
              } catch (error) {
                captureCommitPhaseError(finishedWork, finishedWork.return, error);
              }
            }
            flags & 4 && null != finishedWork.stateNode && (hoistableRoot = finishedWork.memoizedProps, commitHostUpdate(
              finishedWork,
              hoistableRoot,
              null !== current ? current.memoizedProps : hoistableRoot
            ));
            flags & 1024 && (needsFormReset = true);
            break;
          case 6:
            recursivelyTraverseMutationEffects(root2, finishedWork);
            commitReconciliationEffects(finishedWork);
            if (flags & 4) {
              if (null === finishedWork.stateNode)
                throw Error(formatProdErrorMessage(162));
              flags = finishedWork.memoizedProps;
              current = finishedWork.stateNode;
              try {
                current.nodeValue = flags;
              } catch (error) {
                captureCommitPhaseError(finishedWork, finishedWork.return, error);
              }
            }
            break;
          case 3:
            tagCaches = null;
            hoistableRoot = currentHoistableRoot;
            currentHoistableRoot = getHoistableRoot(root2.containerInfo);
            recursivelyTraverseMutationEffects(root2, finishedWork);
            currentHoistableRoot = hoistableRoot;
            commitReconciliationEffects(finishedWork);
            if (flags & 4 && null !== current && current.memoizedState.isDehydrated)
              try {
                retryIfBlockedOn(root2.containerInfo);
              } catch (error) {
                captureCommitPhaseError(finishedWork, finishedWork.return, error);
              }
            needsFormReset && (needsFormReset = false, recursivelyResetForms(finishedWork));
            break;
          case 4:
            flags = currentHoistableRoot;
            currentHoistableRoot = getHoistableRoot(
              finishedWork.stateNode.containerInfo
            );
            recursivelyTraverseMutationEffects(root2, finishedWork);
            commitReconciliationEffects(finishedWork);
            currentHoistableRoot = flags;
            break;
          case 12:
            recursivelyTraverseMutationEffects(root2, finishedWork);
            commitReconciliationEffects(finishedWork);
            break;
          case 13:
            recursivelyTraverseMutationEffects(root2, finishedWork);
            commitReconciliationEffects(finishedWork);
            finishedWork.child.flags & 8192 && null !== finishedWork.memoizedState !== (null !== current && null !== current.memoizedState) && (globalMostRecentFallbackTime = now());
            flags & 4 && (flags = finishedWork.updateQueue, null !== flags && (finishedWork.updateQueue = null, attachSuspenseRetryListeners(finishedWork, flags)));
            break;
          case 22:
            hoistableRoot = null !== finishedWork.memoizedState;
            var wasHidden = null !== current && null !== current.memoizedState, prevOffscreenSubtreeIsHidden = offscreenSubtreeIsHidden, prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;
            offscreenSubtreeIsHidden = prevOffscreenSubtreeIsHidden || hoistableRoot;
            offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden || wasHidden;
            recursivelyTraverseMutationEffects(root2, finishedWork);
            offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;
            offscreenSubtreeIsHidden = prevOffscreenSubtreeIsHidden;
            commitReconciliationEffects(finishedWork);
            if (flags & 8192)
              a: for (root2 = finishedWork.stateNode, root2._visibility = hoistableRoot ? root2._visibility & -2 : root2._visibility | 1, hoistableRoot && (null === current || wasHidden || offscreenSubtreeIsHidden || offscreenSubtreeWasHidden || recursivelyTraverseDisappearLayoutEffects(finishedWork)), current = null, root2 = finishedWork; ; ) {
                if (5 === root2.tag || 26 === root2.tag) {
                  if (null === current) {
                    wasHidden = current = root2;
                    try {
                      if (currentResource = wasHidden.stateNode, hoistableRoot)
                        maybeNodes = currentResource.style, "function" === typeof maybeNodes.setProperty ? maybeNodes.setProperty("display", "none", "important") : maybeNodes.display = "none";
                      else {
                        i = wasHidden.stateNode;
                        var styleProp = wasHidden.memoizedProps.style, display = void 0 !== styleProp && null !== styleProp && styleProp.hasOwnProperty("display") ? styleProp.display : null;
                        i.style.display = null == display || "boolean" === typeof display ? "" : ("" + display).trim();
                      }
                    } catch (error) {
                      captureCommitPhaseError(wasHidden, wasHidden.return, error);
                    }
                  }
                } else if (6 === root2.tag) {
                  if (null === current) {
                    wasHidden = root2;
                    try {
                      wasHidden.stateNode.nodeValue = hoistableRoot ? "" : wasHidden.memoizedProps;
                    } catch (error) {
                      captureCommitPhaseError(wasHidden, wasHidden.return, error);
                    }
                  }
                } else if ((22 !== root2.tag && 23 !== root2.tag || null === root2.memoizedState || root2 === finishedWork) && null !== root2.child) {
                  root2.child.return = root2;
                  root2 = root2.child;
                  continue;
                }
                if (root2 === finishedWork) break a;
                for (; null === root2.sibling; ) {
                  if (null === root2.return || root2.return === finishedWork) break a;
                  current === root2 && (current = null);
                  root2 = root2.return;
                }
                current === root2 && (current = null);
                root2.sibling.return = root2.return;
                root2 = root2.sibling;
              }
            flags & 4 && (flags = finishedWork.updateQueue, null !== flags && (current = flags.retryQueue, null !== current && (flags.retryQueue = null, attachSuspenseRetryListeners(finishedWork, current))));
            break;
          case 19:
            recursivelyTraverseMutationEffects(root2, finishedWork);
            commitReconciliationEffects(finishedWork);
            flags & 4 && (flags = finishedWork.updateQueue, null !== flags && (finishedWork.updateQueue = null, attachSuspenseRetryListeners(finishedWork, flags)));
            break;
          case 30:
            break;
          case 21:
            break;
          default:
            recursivelyTraverseMutationEffects(root2, finishedWork), commitReconciliationEffects(finishedWork);
        }
      }
      function commitReconciliationEffects(finishedWork) {
        var flags = finishedWork.flags;
        if (flags & 2) {
          try {
            for (var hostParentFiber, parentFiber = finishedWork.return; null !== parentFiber; ) {
              if (isHostParent(parentFiber)) {
                hostParentFiber = parentFiber;
                break;
              }
              parentFiber = parentFiber.return;
            }
            if (null == hostParentFiber) throw Error(formatProdErrorMessage(160));
            switch (hostParentFiber.tag) {
              case 27:
                var parent = hostParentFiber.stateNode, before = getHostSibling(finishedWork);
                insertOrAppendPlacementNode(finishedWork, before, parent);
                break;
              case 5:
                var parent$144 = hostParentFiber.stateNode;
                hostParentFiber.flags & 32 && (setTextContent(parent$144, ""), hostParentFiber.flags &= -33);
                var before$145 = getHostSibling(finishedWork);
                insertOrAppendPlacementNode(finishedWork, before$145, parent$144);
                break;
              case 3:
              case 4:
                var parent$146 = hostParentFiber.stateNode.containerInfo, before$147 = getHostSibling(finishedWork);
                insertOrAppendPlacementNodeIntoContainer(
                  finishedWork,
                  before$147,
                  parent$146
                );
                break;
              default:
                throw Error(formatProdErrorMessage(161));
            }
          } catch (error) {
            captureCommitPhaseError(finishedWork, finishedWork.return, error);
          }
          finishedWork.flags &= -3;
        }
        flags & 4096 && (finishedWork.flags &= -4097);
      }
      function recursivelyResetForms(parentFiber) {
        if (parentFiber.subtreeFlags & 1024)
          for (parentFiber = parentFiber.child; null !== parentFiber; ) {
            var fiber = parentFiber;
            recursivelyResetForms(fiber);
            5 === fiber.tag && fiber.flags & 1024 && fiber.stateNode.reset();
            parentFiber = parentFiber.sibling;
          }
      }
      function recursivelyTraverseLayoutEffects(root2, parentFiber) {
        if (parentFiber.subtreeFlags & 8772)
          for (parentFiber = parentFiber.child; null !== parentFiber; )
            commitLayoutEffectOnFiber(root2, parentFiber.alternate, parentFiber), parentFiber = parentFiber.sibling;
      }
      function recursivelyTraverseDisappearLayoutEffects(parentFiber) {
        for (parentFiber = parentFiber.child; null !== parentFiber; ) {
          var finishedWork = parentFiber;
          switch (finishedWork.tag) {
            case 0:
            case 11:
            case 14:
            case 15:
              commitHookEffectListUnmount(4, finishedWork, finishedWork.return);
              recursivelyTraverseDisappearLayoutEffects(finishedWork);
              break;
            case 1:
              safelyDetachRef(finishedWork, finishedWork.return);
              var instance = finishedWork.stateNode;
              "function" === typeof instance.componentWillUnmount && safelyCallComponentWillUnmount(
                finishedWork,
                finishedWork.return,
                instance
              );
              recursivelyTraverseDisappearLayoutEffects(finishedWork);
              break;
            case 27:
              releaseSingletonInstance(finishedWork.stateNode);
            case 26:
            case 5:
              safelyDetachRef(finishedWork, finishedWork.return);
              recursivelyTraverseDisappearLayoutEffects(finishedWork);
              break;
            case 22:
              null === finishedWork.memoizedState && recursivelyTraverseDisappearLayoutEffects(finishedWork);
              break;
            case 30:
              recursivelyTraverseDisappearLayoutEffects(finishedWork);
              break;
            default:
              recursivelyTraverseDisappearLayoutEffects(finishedWork);
          }
          parentFiber = parentFiber.sibling;
        }
      }
      function recursivelyTraverseReappearLayoutEffects(finishedRoot$jscomp$0, parentFiber, includeWorkInProgressEffects) {
        includeWorkInProgressEffects = includeWorkInProgressEffects && 0 !== (parentFiber.subtreeFlags & 8772);
        for (parentFiber = parentFiber.child; null !== parentFiber; ) {
          var current = parentFiber.alternate, finishedRoot = finishedRoot$jscomp$0, finishedWork = parentFiber, flags = finishedWork.flags;
          switch (finishedWork.tag) {
            case 0:
            case 11:
            case 15:
              recursivelyTraverseReappearLayoutEffects(
                finishedRoot,
                finishedWork,
                includeWorkInProgressEffects
              );
              commitHookEffectListMount(4, finishedWork);
              break;
            case 1:
              recursivelyTraverseReappearLayoutEffects(
                finishedRoot,
                finishedWork,
                includeWorkInProgressEffects
              );
              current = finishedWork;
              finishedRoot = current.stateNode;
              if ("function" === typeof finishedRoot.componentDidMount)
                try {
                  finishedRoot.componentDidMount();
                } catch (error) {
                  captureCommitPhaseError(current, current.return, error);
                }
              current = finishedWork;
              finishedRoot = current.updateQueue;
              if (null !== finishedRoot) {
                var instance = current.stateNode;
                try {
                  var hiddenCallbacks = finishedRoot.shared.hiddenCallbacks;
                  if (null !== hiddenCallbacks)
                    for (finishedRoot.shared.hiddenCallbacks = null, finishedRoot = 0; finishedRoot < hiddenCallbacks.length; finishedRoot++)
                      callCallback(hiddenCallbacks[finishedRoot], instance);
                } catch (error) {
                  captureCommitPhaseError(current, current.return, error);
                }
              }
              includeWorkInProgressEffects && flags & 64 && commitClassCallbacks(finishedWork);
              safelyAttachRef(finishedWork, finishedWork.return);
              break;
            case 27:
              commitHostSingletonAcquisition(finishedWork);
            case 26:
            case 5:
              recursivelyTraverseReappearLayoutEffects(
                finishedRoot,
                finishedWork,
                includeWorkInProgressEffects
              );
              includeWorkInProgressEffects && null === current && flags & 4 && commitHostMount(finishedWork);
              safelyAttachRef(finishedWork, finishedWork.return);
              break;
            case 12:
              recursivelyTraverseReappearLayoutEffects(
                finishedRoot,
                finishedWork,
                includeWorkInProgressEffects
              );
              break;
            case 13:
              recursivelyTraverseReappearLayoutEffects(
                finishedRoot,
                finishedWork,
                includeWorkInProgressEffects
              );
              includeWorkInProgressEffects && flags & 4 && commitSuspenseHydrationCallbacks(finishedRoot, finishedWork);
              break;
            case 22:
              null === finishedWork.memoizedState && recursivelyTraverseReappearLayoutEffects(
                finishedRoot,
                finishedWork,
                includeWorkInProgressEffects
              );
              safelyAttachRef(finishedWork, finishedWork.return);
              break;
            case 30:
              break;
            default:
              recursivelyTraverseReappearLayoutEffects(
                finishedRoot,
                finishedWork,
                includeWorkInProgressEffects
              );
          }
          parentFiber = parentFiber.sibling;
        }
      }
      function commitOffscreenPassiveMountEffects(current, finishedWork) {
        var previousCache = null;
        null !== current && null !== current.memoizedState && null !== current.memoizedState.cachePool && (previousCache = current.memoizedState.cachePool.pool);
        current = null;
        null !== finishedWork.memoizedState && null !== finishedWork.memoizedState.cachePool && (current = finishedWork.memoizedState.cachePool.pool);
        current !== previousCache && (null != current && current.refCount++, null != previousCache && releaseCache(previousCache));
      }
      function commitCachePassiveMountEffect(current, finishedWork) {
        current = null;
        null !== finishedWork.alternate && (current = finishedWork.alternate.memoizedState.cache);
        finishedWork = finishedWork.memoizedState.cache;
        finishedWork !== current && (finishedWork.refCount++, null != current && releaseCache(current));
      }
      function recursivelyTraversePassiveMountEffects(root2, parentFiber, committedLanes, committedTransitions) {
        if (parentFiber.subtreeFlags & 10256)
          for (parentFiber = parentFiber.child; null !== parentFiber; )
            commitPassiveMountOnFiber(
              root2,
              parentFiber,
              committedLanes,
              committedTransitions
            ), parentFiber = parentFiber.sibling;
      }
      function commitPassiveMountOnFiber(finishedRoot, finishedWork, committedLanes, committedTransitions) {
        var flags = finishedWork.flags;
        switch (finishedWork.tag) {
          case 0:
          case 11:
          case 15:
            recursivelyTraversePassiveMountEffects(
              finishedRoot,
              finishedWork,
              committedLanes,
              committedTransitions
            );
            flags & 2048 && commitHookEffectListMount(9, finishedWork);
            break;
          case 1:
            recursivelyTraversePassiveMountEffects(
              finishedRoot,
              finishedWork,
              committedLanes,
              committedTransitions
            );
            break;
          case 3:
            recursivelyTraversePassiveMountEffects(
              finishedRoot,
              finishedWork,
              committedLanes,
              committedTransitions
            );
            flags & 2048 && (finishedRoot = null, null !== finishedWork.alternate && (finishedRoot = finishedWork.alternate.memoizedState.cache), finishedWork = finishedWork.memoizedState.cache, finishedWork !== finishedRoot && (finishedWork.refCount++, null != finishedRoot && releaseCache(finishedRoot)));
            break;
          case 12:
            if (flags & 2048) {
              recursivelyTraversePassiveMountEffects(
                finishedRoot,
                finishedWork,
                committedLanes,
                committedTransitions
              );
              finishedRoot = finishedWork.stateNode;
              try {
                var _finishedWork$memoize2 = finishedWork.memoizedProps, id2 = _finishedWork$memoize2.id, onPostCommit = _finishedWork$memoize2.onPostCommit;
                "function" === typeof onPostCommit && onPostCommit(
                  id2,
                  null === finishedWork.alternate ? "mount" : "update",
                  finishedRoot.passiveEffectDuration,
                  -0
                );
              } catch (error) {
                captureCommitPhaseError(finishedWork, finishedWork.return, error);
              }
            } else
              recursivelyTraversePassiveMountEffects(
                finishedRoot,
                finishedWork,
                committedLanes,
                committedTransitions
              );
            break;
          case 13:
            recursivelyTraversePassiveMountEffects(
              finishedRoot,
              finishedWork,
              committedLanes,
              committedTransitions
            );
            break;
          case 23:
            break;
          case 22:
            _finishedWork$memoize2 = finishedWork.stateNode;
            id2 = finishedWork.alternate;
            null !== finishedWork.memoizedState ? _finishedWork$memoize2._visibility & 2 ? recursivelyTraversePassiveMountEffects(
              finishedRoot,
              finishedWork,
              committedLanes,
              committedTransitions
            ) : recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork) : _finishedWork$memoize2._visibility & 2 ? recursivelyTraversePassiveMountEffects(
              finishedRoot,
              finishedWork,
              committedLanes,
              committedTransitions
            ) : (_finishedWork$memoize2._visibility |= 2, recursivelyTraverseReconnectPassiveEffects(
              finishedRoot,
              finishedWork,
              committedLanes,
              committedTransitions,
              0 !== (finishedWork.subtreeFlags & 10256)
            ));
            flags & 2048 && commitOffscreenPassiveMountEffects(id2, finishedWork);
            break;
          case 24:
            recursivelyTraversePassiveMountEffects(
              finishedRoot,
              finishedWork,
              committedLanes,
              committedTransitions
            );
            flags & 2048 && commitCachePassiveMountEffect(finishedWork.alternate, finishedWork);
            break;
          default:
            recursivelyTraversePassiveMountEffects(
              finishedRoot,
              finishedWork,
              committedLanes,
              committedTransitions
            );
        }
      }
      function recursivelyTraverseReconnectPassiveEffects(finishedRoot$jscomp$0, parentFiber, committedLanes$jscomp$0, committedTransitions$jscomp$0, includeWorkInProgressEffects) {
        includeWorkInProgressEffects = includeWorkInProgressEffects && 0 !== (parentFiber.subtreeFlags & 10256);
        for (parentFiber = parentFiber.child; null !== parentFiber; ) {
          var finishedRoot = finishedRoot$jscomp$0, finishedWork = parentFiber, committedLanes = committedLanes$jscomp$0, committedTransitions = committedTransitions$jscomp$0, flags = finishedWork.flags;
          switch (finishedWork.tag) {
            case 0:
            case 11:
            case 15:
              recursivelyTraverseReconnectPassiveEffects(
                finishedRoot,
                finishedWork,
                committedLanes,
                committedTransitions,
                includeWorkInProgressEffects
              );
              commitHookEffectListMount(8, finishedWork);
              break;
            case 23:
              break;
            case 22:
              var instance = finishedWork.stateNode;
              null !== finishedWork.memoizedState ? instance._visibility & 2 ? recursivelyTraverseReconnectPassiveEffects(
                finishedRoot,
                finishedWork,
                committedLanes,
                committedTransitions,
                includeWorkInProgressEffects
              ) : recursivelyTraverseAtomicPassiveEffects(
                finishedRoot,
                finishedWork
              ) : (instance._visibility |= 2, recursivelyTraverseReconnectPassiveEffects(
                finishedRoot,
                finishedWork,
                committedLanes,
                committedTransitions,
                includeWorkInProgressEffects
              ));
              includeWorkInProgressEffects && flags & 2048 && commitOffscreenPassiveMountEffects(
                finishedWork.alternate,
                finishedWork
              );
              break;
            case 24:
              recursivelyTraverseReconnectPassiveEffects(
                finishedRoot,
                finishedWork,
                committedLanes,
                committedTransitions,
                includeWorkInProgressEffects
              );
              includeWorkInProgressEffects && flags & 2048 && commitCachePassiveMountEffect(finishedWork.alternate, finishedWork);
              break;
            default:
              recursivelyTraverseReconnectPassiveEffects(
                finishedRoot,
                finishedWork,
                committedLanes,
                committedTransitions,
                includeWorkInProgressEffects
              );
          }
          parentFiber = parentFiber.sibling;
        }
      }
      function recursivelyTraverseAtomicPassiveEffects(finishedRoot$jscomp$0, parentFiber) {
        if (parentFiber.subtreeFlags & 10256)
          for (parentFiber = parentFiber.child; null !== parentFiber; ) {
            var finishedRoot = finishedRoot$jscomp$0, finishedWork = parentFiber, flags = finishedWork.flags;
            switch (finishedWork.tag) {
              case 22:
                recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork);
                flags & 2048 && commitOffscreenPassiveMountEffects(
                  finishedWork.alternate,
                  finishedWork
                );
                break;
              case 24:
                recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork);
                flags & 2048 && commitCachePassiveMountEffect(finishedWork.alternate, finishedWork);
                break;
              default:
                recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork);
            }
            parentFiber = parentFiber.sibling;
          }
      }
      var suspenseyCommitFlag = 8192;
      function recursivelyAccumulateSuspenseyCommit(parentFiber) {
        if (parentFiber.subtreeFlags & suspenseyCommitFlag)
          for (parentFiber = parentFiber.child; null !== parentFiber; )
            accumulateSuspenseyCommitOnFiber(parentFiber), parentFiber = parentFiber.sibling;
      }
      function accumulateSuspenseyCommitOnFiber(fiber) {
        switch (fiber.tag) {
          case 26:
            recursivelyAccumulateSuspenseyCommit(fiber);
            fiber.flags & suspenseyCommitFlag && null !== fiber.memoizedState && suspendResource(
              currentHoistableRoot,
              fiber.memoizedState,
              fiber.memoizedProps
            );
            break;
          case 5:
            recursivelyAccumulateSuspenseyCommit(fiber);
            break;
          case 3:
          case 4:
            var previousHoistableRoot = currentHoistableRoot;
            currentHoistableRoot = getHoistableRoot(fiber.stateNode.containerInfo);
            recursivelyAccumulateSuspenseyCommit(fiber);
            currentHoistableRoot = previousHoistableRoot;
            break;
          case 22:
            null === fiber.memoizedState && (previousHoistableRoot = fiber.alternate, null !== previousHoistableRoot && null !== previousHoistableRoot.memoizedState ? (previousHoistableRoot = suspenseyCommitFlag, suspenseyCommitFlag = 16777216, recursivelyAccumulateSuspenseyCommit(fiber), suspenseyCommitFlag = previousHoistableRoot) : recursivelyAccumulateSuspenseyCommit(fiber));
            break;
          default:
            recursivelyAccumulateSuspenseyCommit(fiber);
        }
      }
      function detachAlternateSiblings(parentFiber) {
        var previousFiber = parentFiber.alternate;
        if (null !== previousFiber && (parentFiber = previousFiber.child, null !== parentFiber)) {
          previousFiber.child = null;
          do
            previousFiber = parentFiber.sibling, parentFiber.sibling = null, parentFiber = previousFiber;
          while (null !== parentFiber);
        }
      }
      function recursivelyTraversePassiveUnmountEffects(parentFiber) {
        var deletions = parentFiber.deletions;
        if (0 !== (parentFiber.flags & 16)) {
          if (null !== deletions)
            for (var i = 0; i < deletions.length; i++) {
              var childToDelete = deletions[i];
              nextEffect = childToDelete;
              commitPassiveUnmountEffectsInsideOfDeletedTree_begin(
                childToDelete,
                parentFiber
              );
            }
          detachAlternateSiblings(parentFiber);
        }
        if (parentFiber.subtreeFlags & 10256)
          for (parentFiber = parentFiber.child; null !== parentFiber; )
            commitPassiveUnmountOnFiber(parentFiber), parentFiber = parentFiber.sibling;
      }
      function commitPassiveUnmountOnFiber(finishedWork) {
        switch (finishedWork.tag) {
          case 0:
          case 11:
          case 15:
            recursivelyTraversePassiveUnmountEffects(finishedWork);
            finishedWork.flags & 2048 && commitHookEffectListUnmount(9, finishedWork, finishedWork.return);
            break;
          case 3:
            recursivelyTraversePassiveUnmountEffects(finishedWork);
            break;
          case 12:
            recursivelyTraversePassiveUnmountEffects(finishedWork);
            break;
          case 22:
            var instance = finishedWork.stateNode;
            null !== finishedWork.memoizedState && instance._visibility & 2 && (null === finishedWork.return || 13 !== finishedWork.return.tag) ? (instance._visibility &= -3, recursivelyTraverseDisconnectPassiveEffects(finishedWork)) : recursivelyTraversePassiveUnmountEffects(finishedWork);
            break;
          default:
            recursivelyTraversePassiveUnmountEffects(finishedWork);
        }
      }
      function recursivelyTraverseDisconnectPassiveEffects(parentFiber) {
        var deletions = parentFiber.deletions;
        if (0 !== (parentFiber.flags & 16)) {
          if (null !== deletions)
            for (var i = 0; i < deletions.length; i++) {
              var childToDelete = deletions[i];
              nextEffect = childToDelete;
              commitPassiveUnmountEffectsInsideOfDeletedTree_begin(
                childToDelete,
                parentFiber
              );
            }
          detachAlternateSiblings(parentFiber);
        }
        for (parentFiber = parentFiber.child; null !== parentFiber; ) {
          deletions = parentFiber;
          switch (deletions.tag) {
            case 0:
            case 11:
            case 15:
              commitHookEffectListUnmount(8, deletions, deletions.return);
              recursivelyTraverseDisconnectPassiveEffects(deletions);
              break;
            case 22:
              i = deletions.stateNode;
              i._visibility & 2 && (i._visibility &= -3, recursivelyTraverseDisconnectPassiveEffects(deletions));
              break;
            default:
              recursivelyTraverseDisconnectPassiveEffects(deletions);
          }
          parentFiber = parentFiber.sibling;
        }
      }
      function commitPassiveUnmountEffectsInsideOfDeletedTree_begin(deletedSubtreeRoot, nearestMountedAncestor) {
        for (; null !== nextEffect; ) {
          var fiber = nextEffect;
          switch (fiber.tag) {
            case 0:
            case 11:
            case 15:
              commitHookEffectListUnmount(8, fiber, nearestMountedAncestor);
              break;
            case 23:
            case 22:
              if (null !== fiber.memoizedState && null !== fiber.memoizedState.cachePool) {
                var cache = fiber.memoizedState.cachePool.pool;
                null != cache && cache.refCount++;
              }
              break;
            case 24:
              releaseCache(fiber.memoizedState.cache);
          }
          cache = fiber.child;
          if (null !== cache) cache.return = fiber, nextEffect = cache;
          else
            a: for (fiber = deletedSubtreeRoot; null !== nextEffect; ) {
              cache = nextEffect;
              var sibling = cache.sibling, returnFiber = cache.return;
              detachFiberAfterEffects(cache);
              if (cache === fiber) {
                nextEffect = null;
                break a;
              }
              if (null !== sibling) {
                sibling.return = returnFiber;
                nextEffect = sibling;
                break a;
              }
              nextEffect = returnFiber;
            }
        }
      }
      var DefaultAsyncDispatcher = {
        getCacheForType: function(resourceType) {
          var cache = readContext(CacheContext), cacheForType = cache.data.get(resourceType);
          void 0 === cacheForType && (cacheForType = resourceType(), cache.data.set(resourceType, cacheForType));
          return cacheForType;
        }
      };
      var PossiblyWeakMap = "function" === typeof WeakMap ? WeakMap : Map;
      var executionContext = 0;
      var workInProgressRoot = null;
      var workInProgress = null;
      var workInProgressRootRenderLanes = 0;
      var workInProgressSuspendedReason = 0;
      var workInProgressThrownValue = null;
      var workInProgressRootDidSkipSuspendedSiblings = false;
      var workInProgressRootIsPrerendering = false;
      var workInProgressRootDidAttachPingListener = false;
      var entangledRenderLanes = 0;
      var workInProgressRootExitStatus = 0;
      var workInProgressRootSkippedLanes = 0;
      var workInProgressRootInterleavedUpdatedLanes = 0;
      var workInProgressRootPingedLanes = 0;
      var workInProgressDeferredLane = 0;
      var workInProgressSuspendedRetryLanes = 0;
      var workInProgressRootConcurrentErrors = null;
      var workInProgressRootRecoverableErrors = null;
      var workInProgressRootDidIncludeRecursiveRenderUpdate = false;
      var globalMostRecentFallbackTime = 0;
      var workInProgressRootRenderTargetTime = Infinity;
      var workInProgressTransitions = null;
      var legacyErrorBoundariesThatAlreadyFailed = null;
      var pendingEffectsStatus = 0;
      var pendingEffectsRoot = null;
      var pendingFinishedWork = null;
      var pendingEffectsLanes = 0;
      var pendingEffectsRemainingLanes = 0;
      var pendingPassiveTransitions = null;
      var pendingRecoverableErrors = null;
      var nestedUpdateCount = 0;
      var rootWithNestedUpdates = null;
      function requestUpdateLane() {
        if (0 !== (executionContext & 2) && 0 !== workInProgressRootRenderLanes)
          return workInProgressRootRenderLanes & -workInProgressRootRenderLanes;
        if (null !== ReactSharedInternals.T) {
          var actionScopeLane = currentEntangledLane;
          return 0 !== actionScopeLane ? actionScopeLane : requestTransitionLane();
        }
        return resolveUpdatePriority();
      }
      function requestDeferredLane() {
        0 === workInProgressDeferredLane && (workInProgressDeferredLane = 0 === (workInProgressRootRenderLanes & 536870912) || isHydrating ? claimNextTransitionLane() : 536870912);
        var suspenseHandler = suspenseHandlerStackCursor.current;
        null !== suspenseHandler && (suspenseHandler.flags |= 32);
        return workInProgressDeferredLane;
      }
      function scheduleUpdateOnFiber(root2, fiber, lane) {
        if (root2 === workInProgressRoot && (2 === workInProgressSuspendedReason || 9 === workInProgressSuspendedReason) || null !== root2.cancelPendingCommit)
          prepareFreshStack(root2, 0), markRootSuspended(
            root2,
            workInProgressRootRenderLanes,
            workInProgressDeferredLane,
            false
          );
        markRootUpdated$1(root2, lane);
        if (0 === (executionContext & 2) || root2 !== workInProgressRoot)
          root2 === workInProgressRoot && (0 === (executionContext & 2) && (workInProgressRootInterleavedUpdatedLanes |= lane), 4 === workInProgressRootExitStatus && markRootSuspended(
            root2,
            workInProgressRootRenderLanes,
            workInProgressDeferredLane,
            false
          )), ensureRootIsScheduled(root2);
      }
      function performWorkOnRoot(root$jscomp$0, lanes, forceSync) {
        if (0 !== (executionContext & 6)) throw Error(formatProdErrorMessage(327));
        var shouldTimeSlice = !forceSync && 0 === (lanes & 124) && 0 === (lanes & root$jscomp$0.expiredLanes) || checkIfRootIsPrerendering(root$jscomp$0, lanes), exitStatus = shouldTimeSlice ? renderRootConcurrent(root$jscomp$0, lanes) : renderRootSync(root$jscomp$0, lanes, true), renderWasConcurrent = shouldTimeSlice;
        do {
          if (0 === exitStatus) {
            workInProgressRootIsPrerendering && !shouldTimeSlice && markRootSuspended(root$jscomp$0, lanes, 0, false);
            break;
          } else {
            forceSync = root$jscomp$0.current.alternate;
            if (renderWasConcurrent && !isRenderConsistentWithExternalStores(forceSync)) {
              exitStatus = renderRootSync(root$jscomp$0, lanes, false);
              renderWasConcurrent = false;
              continue;
            }
            if (2 === exitStatus) {
              renderWasConcurrent = lanes;
              if (root$jscomp$0.errorRecoveryDisabledLanes & renderWasConcurrent)
                var JSCompiler_inline_result = 0;
              else
                JSCompiler_inline_result = root$jscomp$0.pendingLanes & -536870913, JSCompiler_inline_result = 0 !== JSCompiler_inline_result ? JSCompiler_inline_result : JSCompiler_inline_result & 536870912 ? 536870912 : 0;
              if (0 !== JSCompiler_inline_result) {
                lanes = JSCompiler_inline_result;
                a: {
                  var root2 = root$jscomp$0;
                  exitStatus = workInProgressRootConcurrentErrors;
                  var wasRootDehydrated = root2.current.memoizedState.isDehydrated;
                  wasRootDehydrated && (prepareFreshStack(root2, JSCompiler_inline_result).flags |= 256);
                  JSCompiler_inline_result = renderRootSync(
                    root2,
                    JSCompiler_inline_result,
                    false
                  );
                  if (2 !== JSCompiler_inline_result) {
                    if (workInProgressRootDidAttachPingListener && !wasRootDehydrated) {
                      root2.errorRecoveryDisabledLanes |= renderWasConcurrent;
                      workInProgressRootInterleavedUpdatedLanes |= renderWasConcurrent;
                      exitStatus = 4;
                      break a;
                    }
                    renderWasConcurrent = workInProgressRootRecoverableErrors;
                    workInProgressRootRecoverableErrors = exitStatus;
                    null !== renderWasConcurrent && (null === workInProgressRootRecoverableErrors ? workInProgressRootRecoverableErrors = renderWasConcurrent : workInProgressRootRecoverableErrors.push.apply(
                      workInProgressRootRecoverableErrors,
                      renderWasConcurrent
                    ));
                  }
                  exitStatus = JSCompiler_inline_result;
                }
                renderWasConcurrent = false;
                if (2 !== exitStatus) continue;
              }
            }
            if (1 === exitStatus) {
              prepareFreshStack(root$jscomp$0, 0);
              markRootSuspended(root$jscomp$0, lanes, 0, true);
              break;
            }
            a: {
              shouldTimeSlice = root$jscomp$0;
              renderWasConcurrent = exitStatus;
              switch (renderWasConcurrent) {
                case 0:
                case 1:
                  throw Error(formatProdErrorMessage(345));
                case 4:
                  if ((lanes & 4194048) !== lanes) break;
                case 6:
                  markRootSuspended(
                    shouldTimeSlice,
                    lanes,
                    workInProgressDeferredLane,
                    !workInProgressRootDidSkipSuspendedSiblings
                  );
                  break a;
                case 2:
                  workInProgressRootRecoverableErrors = null;
                  break;
                case 3:
                case 5:
                  break;
                default:
                  throw Error(formatProdErrorMessage(329));
              }
              if ((lanes & 62914560) === lanes && (exitStatus = globalMostRecentFallbackTime + 300 - now(), 10 < exitStatus)) {
                markRootSuspended(
                  shouldTimeSlice,
                  lanes,
                  workInProgressDeferredLane,
                  !workInProgressRootDidSkipSuspendedSiblings
                );
                if (0 !== getNextLanes(shouldTimeSlice, 0, true)) break a;
                shouldTimeSlice.timeoutHandle = scheduleTimeout(
                  commitRootWhenReady.bind(
                    null,
                    shouldTimeSlice,
                    forceSync,
                    workInProgressRootRecoverableErrors,
                    workInProgressTransitions,
                    workInProgressRootDidIncludeRecursiveRenderUpdate,
                    lanes,
                    workInProgressDeferredLane,
                    workInProgressRootInterleavedUpdatedLanes,
                    workInProgressSuspendedRetryLanes,
                    workInProgressRootDidSkipSuspendedSiblings,
                    renderWasConcurrent,
                    2,
                    -0,
                    0
                  ),
                  exitStatus
                );
                break a;
              }
              commitRootWhenReady(
                shouldTimeSlice,
                forceSync,
                workInProgressRootRecoverableErrors,
                workInProgressTransitions,
                workInProgressRootDidIncludeRecursiveRenderUpdate,
                lanes,
                workInProgressDeferredLane,
                workInProgressRootInterleavedUpdatedLanes,
                workInProgressSuspendedRetryLanes,
                workInProgressRootDidSkipSuspendedSiblings,
                renderWasConcurrent,
                0,
                -0,
                0
              );
            }
          }
          break;
        } while (1);
        ensureRootIsScheduled(root$jscomp$0);
      }
      function commitRootWhenReady(root2, finishedWork, recoverableErrors, transitions, didIncludeRenderPhaseUpdate, lanes, spawnedLane, updatedLanes, suspendedRetryLanes, didSkipSuspendedSiblings, exitStatus, suspendedCommitReason, completedRenderStartTime, completedRenderEndTime) {
        root2.timeoutHandle = -1;
        suspendedCommitReason = finishedWork.subtreeFlags;
        if (suspendedCommitReason & 8192 || 16785408 === (suspendedCommitReason & 16785408)) {
          if (suspendedState = { stylesheets: null, count: 0, unsuspend: noop }, accumulateSuspenseyCommitOnFiber(finishedWork), suspendedCommitReason = waitForCommitToBeReady(), null !== suspendedCommitReason) {
            root2.cancelPendingCommit = suspendedCommitReason(
              commitRoot.bind(
                null,
                root2,
                finishedWork,
                lanes,
                recoverableErrors,
                transitions,
                didIncludeRenderPhaseUpdate,
                spawnedLane,
                updatedLanes,
                suspendedRetryLanes,
                exitStatus,
                1,
                completedRenderStartTime,
                completedRenderEndTime
              )
            );
            markRootSuspended(root2, lanes, spawnedLane, !didSkipSuspendedSiblings);
            return;
          }
        }
        commitRoot(
          root2,
          finishedWork,
          lanes,
          recoverableErrors,
          transitions,
          didIncludeRenderPhaseUpdate,
          spawnedLane,
          updatedLanes,
          suspendedRetryLanes
        );
      }
      function isRenderConsistentWithExternalStores(finishedWork) {
        for (var node = finishedWork; ; ) {
          var tag = node.tag;
          if ((0 === tag || 11 === tag || 15 === tag) && node.flags & 16384 && (tag = node.updateQueue, null !== tag && (tag = tag.stores, null !== tag)))
            for (var i = 0; i < tag.length; i++) {
              var check = tag[i], getSnapshot = check.getSnapshot;
              check = check.value;
              try {
                if (!objectIs(getSnapshot(), check)) return false;
              } catch (error) {
                return false;
              }
            }
          tag = node.child;
          if (node.subtreeFlags & 16384 && null !== tag)
            tag.return = node, node = tag;
          else {
            if (node === finishedWork) break;
            for (; null === node.sibling; ) {
              if (null === node.return || node.return === finishedWork) return true;
              node = node.return;
            }
            node.sibling.return = node.return;
            node = node.sibling;
          }
        }
        return true;
      }
      function markRootSuspended(root2, suspendedLanes, spawnedLane, didAttemptEntireTree) {
        suspendedLanes &= ~workInProgressRootPingedLanes;
        suspendedLanes &= ~workInProgressRootInterleavedUpdatedLanes;
        root2.suspendedLanes |= suspendedLanes;
        root2.pingedLanes &= ~suspendedLanes;
        didAttemptEntireTree && (root2.warmLanes |= suspendedLanes);
        didAttemptEntireTree = root2.expirationTimes;
        for (var lanes = suspendedLanes; 0 < lanes; ) {
          var index$4 = 31 - clz32(lanes), lane = 1 << index$4;
          didAttemptEntireTree[index$4] = -1;
          lanes &= ~lane;
        }
        0 !== spawnedLane && markSpawnedDeferredLane(root2, spawnedLane, suspendedLanes);
      }
      function flushSyncWork$1() {
        return 0 === (executionContext & 6) ? (flushSyncWorkAcrossRoots_impl(0, false), false) : true;
      }
      function resetWorkInProgressStack() {
        if (null !== workInProgress) {
          if (0 === workInProgressSuspendedReason)
            var interruptedWork = workInProgress.return;
          else
            interruptedWork = workInProgress, lastContextDependency = currentlyRenderingFiber$1 = null, resetHooksOnUnwind(interruptedWork), thenableState = null, thenableIndexCounter = 0, interruptedWork = workInProgress;
          for (; null !== interruptedWork; )
            unwindInterruptedWork(interruptedWork.alternate, interruptedWork), interruptedWork = interruptedWork.return;
          workInProgress = null;
        }
      }
      function prepareFreshStack(root2, lanes) {
        var timeoutHandle = root2.timeoutHandle;
        -1 !== timeoutHandle && (root2.timeoutHandle = -1, cancelTimeout(timeoutHandle));
        timeoutHandle = root2.cancelPendingCommit;
        null !== timeoutHandle && (root2.cancelPendingCommit = null, timeoutHandle());
        resetWorkInProgressStack();
        workInProgressRoot = root2;
        workInProgress = timeoutHandle = createWorkInProgress(root2.current, null);
        workInProgressRootRenderLanes = lanes;
        workInProgressSuspendedReason = 0;
        workInProgressThrownValue = null;
        workInProgressRootDidSkipSuspendedSiblings = false;
        workInProgressRootIsPrerendering = checkIfRootIsPrerendering(root2, lanes);
        workInProgressRootDidAttachPingListener = false;
        workInProgressSuspendedRetryLanes = workInProgressDeferredLane = workInProgressRootPingedLanes = workInProgressRootInterleavedUpdatedLanes = workInProgressRootSkippedLanes = workInProgressRootExitStatus = 0;
        workInProgressRootRecoverableErrors = workInProgressRootConcurrentErrors = null;
        workInProgressRootDidIncludeRecursiveRenderUpdate = false;
        0 !== (lanes & 8) && (lanes |= lanes & 32);
        var allEntangledLanes = root2.entangledLanes;
        if (0 !== allEntangledLanes)
          for (root2 = root2.entanglements, allEntangledLanes &= lanes; 0 < allEntangledLanes; ) {
            var index$2 = 31 - clz32(allEntangledLanes), lane = 1 << index$2;
            lanes |= root2[index$2];
            allEntangledLanes &= ~lane;
          }
        entangledRenderLanes = lanes;
        finishQueueingConcurrentUpdates();
        return timeoutHandle;
      }
      function handleThrow(root2, thrownValue) {
        currentlyRenderingFiber = null;
        ReactSharedInternals.H = ContextOnlyDispatcher;
        thrownValue === SuspenseException || thrownValue === SuspenseActionException ? (thrownValue = getSuspendedThenable(), workInProgressSuspendedReason = 3) : thrownValue === SuspenseyCommitException ? (thrownValue = getSuspendedThenable(), workInProgressSuspendedReason = 4) : workInProgressSuspendedReason = thrownValue === SelectiveHydrationException ? 8 : null !== thrownValue && "object" === typeof thrownValue && "function" === typeof thrownValue.then ? 6 : 1;
        workInProgressThrownValue = thrownValue;
        null === workInProgress && (workInProgressRootExitStatus = 1, logUncaughtError(
          root2,
          createCapturedValueAtFiber(thrownValue, root2.current)
        ));
      }
      function pushDispatcher() {
        var prevDispatcher = ReactSharedInternals.H;
        ReactSharedInternals.H = ContextOnlyDispatcher;
        return null === prevDispatcher ? ContextOnlyDispatcher : prevDispatcher;
      }
      function pushAsyncDispatcher() {
        var prevAsyncDispatcher = ReactSharedInternals.A;
        ReactSharedInternals.A = DefaultAsyncDispatcher;
        return prevAsyncDispatcher;
      }
      function renderDidSuspendDelayIfPossible() {
        workInProgressRootExitStatus = 4;
        workInProgressRootDidSkipSuspendedSiblings || (workInProgressRootRenderLanes & 4194048) !== workInProgressRootRenderLanes && null !== suspenseHandlerStackCursor.current || (workInProgressRootIsPrerendering = true);
        0 === (workInProgressRootSkippedLanes & 134217727) && 0 === (workInProgressRootInterleavedUpdatedLanes & 134217727) || null === workInProgressRoot || markRootSuspended(
          workInProgressRoot,
          workInProgressRootRenderLanes,
          workInProgressDeferredLane,
          false
        );
      }
      function renderRootSync(root2, lanes, shouldYieldForPrerendering) {
        var prevExecutionContext = executionContext;
        executionContext |= 2;
        var prevDispatcher = pushDispatcher(), prevAsyncDispatcher = pushAsyncDispatcher();
        if (workInProgressRoot !== root2 || workInProgressRootRenderLanes !== lanes)
          workInProgressTransitions = null, prepareFreshStack(root2, lanes);
        lanes = false;
        var exitStatus = workInProgressRootExitStatus;
        a: do
          try {
            if (0 !== workInProgressSuspendedReason && null !== workInProgress) {
              var unitOfWork = workInProgress, thrownValue = workInProgressThrownValue;
              switch (workInProgressSuspendedReason) {
                case 8:
                  resetWorkInProgressStack();
                  exitStatus = 6;
                  break a;
                case 3:
                case 2:
                case 9:
                case 6:
                  null === suspenseHandlerStackCursor.current && (lanes = true);
                  var reason = workInProgressSuspendedReason;
                  workInProgressSuspendedReason = 0;
                  workInProgressThrownValue = null;
                  throwAndUnwindWorkLoop(root2, unitOfWork, thrownValue, reason);
                  if (shouldYieldForPrerendering && workInProgressRootIsPrerendering) {
                    exitStatus = 0;
                    break a;
                  }
                  break;
                default:
                  reason = workInProgressSuspendedReason, workInProgressSuspendedReason = 0, workInProgressThrownValue = null, throwAndUnwindWorkLoop(root2, unitOfWork, thrownValue, reason);
              }
            }
            workLoopSync();
            exitStatus = workInProgressRootExitStatus;
            break;
          } catch (thrownValue$167) {
            handleThrow(root2, thrownValue$167);
          }
        while (1);
        lanes && root2.shellSuspendCounter++;
        lastContextDependency = currentlyRenderingFiber$1 = null;
        executionContext = prevExecutionContext;
        ReactSharedInternals.H = prevDispatcher;
        ReactSharedInternals.A = prevAsyncDispatcher;
        null === workInProgress && (workInProgressRoot = null, workInProgressRootRenderLanes = 0, finishQueueingConcurrentUpdates());
        return exitStatus;
      }
      function workLoopSync() {
        for (; null !== workInProgress; ) performUnitOfWork(workInProgress);
      }
      function renderRootConcurrent(root2, lanes) {
        var prevExecutionContext = executionContext;
        executionContext |= 2;
        var prevDispatcher = pushDispatcher(), prevAsyncDispatcher = pushAsyncDispatcher();
        workInProgressRoot !== root2 || workInProgressRootRenderLanes !== lanes ? (workInProgressTransitions = null, workInProgressRootRenderTargetTime = now() + 500, prepareFreshStack(root2, lanes)) : workInProgressRootIsPrerendering = checkIfRootIsPrerendering(
          root2,
          lanes
        );
        a: do
          try {
            if (0 !== workInProgressSuspendedReason && null !== workInProgress) {
              lanes = workInProgress;
              var thrownValue = workInProgressThrownValue;
              b: switch (workInProgressSuspendedReason) {
                case 1:
                  workInProgressSuspendedReason = 0;
                  workInProgressThrownValue = null;
                  throwAndUnwindWorkLoop(root2, lanes, thrownValue, 1);
                  break;
                case 2:
                case 9:
                  if (isThenableResolved(thrownValue)) {
                    workInProgressSuspendedReason = 0;
                    workInProgressThrownValue = null;
                    replaySuspendedUnitOfWork(lanes);
                    break;
                  }
                  lanes = function() {
                    2 !== workInProgressSuspendedReason && 9 !== workInProgressSuspendedReason || workInProgressRoot !== root2 || (workInProgressSuspendedReason = 7);
                    ensureRootIsScheduled(root2);
                  };
                  thrownValue.then(lanes, lanes);
                  break a;
                case 3:
                  workInProgressSuspendedReason = 7;
                  break a;
                case 4:
                  workInProgressSuspendedReason = 5;
                  break a;
                case 7:
                  isThenableResolved(thrownValue) ? (workInProgressSuspendedReason = 0, workInProgressThrownValue = null, replaySuspendedUnitOfWork(lanes)) : (workInProgressSuspendedReason = 0, workInProgressThrownValue = null, throwAndUnwindWorkLoop(root2, lanes, thrownValue, 7));
                  break;
                case 5:
                  var resource = null;
                  switch (workInProgress.tag) {
                    case 26:
                      resource = workInProgress.memoizedState;
                    case 5:
                    case 27:
                      var hostFiber = workInProgress;
                      if (resource ? preloadResource(resource) : 1) {
                        workInProgressSuspendedReason = 0;
                        workInProgressThrownValue = null;
                        var sibling = hostFiber.sibling;
                        if (null !== sibling) workInProgress = sibling;
                        else {
                          var returnFiber = hostFiber.return;
                          null !== returnFiber ? (workInProgress = returnFiber, completeUnitOfWork(returnFiber)) : workInProgress = null;
                        }
                        break b;
                      }
                  }
                  workInProgressSuspendedReason = 0;
                  workInProgressThrownValue = null;
                  throwAndUnwindWorkLoop(root2, lanes, thrownValue, 5);
                  break;
                case 6:
                  workInProgressSuspendedReason = 0;
                  workInProgressThrownValue = null;
                  throwAndUnwindWorkLoop(root2, lanes, thrownValue, 6);
                  break;
                case 8:
                  resetWorkInProgressStack();
                  workInProgressRootExitStatus = 6;
                  break a;
                default:
                  throw Error(formatProdErrorMessage(462));
              }
            }
            workLoopConcurrentByScheduler();
            break;
          } catch (thrownValue$169) {
            handleThrow(root2, thrownValue$169);
          }
        while (1);
        lastContextDependency = currentlyRenderingFiber$1 = null;
        ReactSharedInternals.H = prevDispatcher;
        ReactSharedInternals.A = prevAsyncDispatcher;
        executionContext = prevExecutionContext;
        if (null !== workInProgress) return 0;
        workInProgressRoot = null;
        workInProgressRootRenderLanes = 0;
        finishQueueingConcurrentUpdates();
        return workInProgressRootExitStatus;
      }
      function workLoopConcurrentByScheduler() {
        for (; null !== workInProgress && !shouldYield(); )
          performUnitOfWork(workInProgress);
      }
      function performUnitOfWork(unitOfWork) {
        var next = beginWork(unitOfWork.alternate, unitOfWork, entangledRenderLanes);
        unitOfWork.memoizedProps = unitOfWork.pendingProps;
        null === next ? completeUnitOfWork(unitOfWork) : workInProgress = next;
      }
      function replaySuspendedUnitOfWork(unitOfWork) {
        var next = unitOfWork;
        var current = next.alternate;
        switch (next.tag) {
          case 15:
          case 0:
            next = replayFunctionComponent(
              current,
              next,
              next.pendingProps,
              next.type,
              void 0,
              workInProgressRootRenderLanes
            );
            break;
          case 11:
            next = replayFunctionComponent(
              current,
              next,
              next.pendingProps,
              next.type.render,
              next.ref,
              workInProgressRootRenderLanes
            );
            break;
          case 5:
            resetHooksOnUnwind(next);
          default:
            unwindInterruptedWork(current, next), next = workInProgress = resetWorkInProgress(next, entangledRenderLanes), next = beginWork(current, next, entangledRenderLanes);
        }
        unitOfWork.memoizedProps = unitOfWork.pendingProps;
        null === next ? completeUnitOfWork(unitOfWork) : workInProgress = next;
      }
      function throwAndUnwindWorkLoop(root2, unitOfWork, thrownValue, suspendedReason) {
        lastContextDependency = currentlyRenderingFiber$1 = null;
        resetHooksOnUnwind(unitOfWork);
        thenableState = null;
        thenableIndexCounter = 0;
        var returnFiber = unitOfWork.return;
        try {
          if (throwException(
            root2,
            returnFiber,
            unitOfWork,
            thrownValue,
            workInProgressRootRenderLanes
          )) {
            workInProgressRootExitStatus = 1;
            logUncaughtError(
              root2,
              createCapturedValueAtFiber(thrownValue, root2.current)
            );
            workInProgress = null;
            return;
          }
        } catch (error) {
          if (null !== returnFiber) throw workInProgress = returnFiber, error;
          workInProgressRootExitStatus = 1;
          logUncaughtError(
            root2,
            createCapturedValueAtFiber(thrownValue, root2.current)
          );
          workInProgress = null;
          return;
        }
        if (unitOfWork.flags & 32768) {
          if (isHydrating || 1 === suspendedReason) root2 = true;
          else if (workInProgressRootIsPrerendering || 0 !== (workInProgressRootRenderLanes & 536870912))
            root2 = false;
          else if (workInProgressRootDidSkipSuspendedSiblings = root2 = true, 2 === suspendedReason || 9 === suspendedReason || 3 === suspendedReason || 6 === suspendedReason)
            suspendedReason = suspenseHandlerStackCursor.current, null !== suspendedReason && 13 === suspendedReason.tag && (suspendedReason.flags |= 16384);
          unwindUnitOfWork(unitOfWork, root2);
        } else completeUnitOfWork(unitOfWork);
      }
      function completeUnitOfWork(unitOfWork) {
        var completedWork = unitOfWork;
        do {
          if (0 !== (completedWork.flags & 32768)) {
            unwindUnitOfWork(
              completedWork,
              workInProgressRootDidSkipSuspendedSiblings
            );
            return;
          }
          unitOfWork = completedWork.return;
          var next = completeWork(
            completedWork.alternate,
            completedWork,
            entangledRenderLanes
          );
          if (null !== next) {
            workInProgress = next;
            return;
          }
          completedWork = completedWork.sibling;
          if (null !== completedWork) {
            workInProgress = completedWork;
            return;
          }
          workInProgress = completedWork = unitOfWork;
        } while (null !== completedWork);
        0 === workInProgressRootExitStatus && (workInProgressRootExitStatus = 5);
      }
      function unwindUnitOfWork(unitOfWork, skipSiblings) {
        do {
          var next = unwindWork(unitOfWork.alternate, unitOfWork);
          if (null !== next) {
            next.flags &= 32767;
            workInProgress = next;
            return;
          }
          next = unitOfWork.return;
          null !== next && (next.flags |= 32768, next.subtreeFlags = 0, next.deletions = null);
          if (!skipSiblings && (unitOfWork = unitOfWork.sibling, null !== unitOfWork)) {
            workInProgress = unitOfWork;
            return;
          }
          workInProgress = unitOfWork = next;
        } while (null !== unitOfWork);
        workInProgressRootExitStatus = 6;
        workInProgress = null;
      }
      function commitRoot(root2, finishedWork, lanes, recoverableErrors, transitions, didIncludeRenderPhaseUpdate, spawnedLane, updatedLanes, suspendedRetryLanes) {
        root2.cancelPendingCommit = null;
        do
          flushPendingEffects();
        while (0 !== pendingEffectsStatus);
        if (0 !== (executionContext & 6)) throw Error(formatProdErrorMessage(327));
        if (null !== finishedWork) {
          if (finishedWork === root2.current) throw Error(formatProdErrorMessage(177));
          didIncludeRenderPhaseUpdate = finishedWork.lanes | finishedWork.childLanes;
          didIncludeRenderPhaseUpdate |= concurrentlyUpdatedLanes;
          markRootFinished(
            root2,
            lanes,
            didIncludeRenderPhaseUpdate,
            spawnedLane,
            updatedLanes,
            suspendedRetryLanes
          );
          root2 === workInProgressRoot && (workInProgress = workInProgressRoot = null, workInProgressRootRenderLanes = 0);
          pendingFinishedWork = finishedWork;
          pendingEffectsRoot = root2;
          pendingEffectsLanes = lanes;
          pendingEffectsRemainingLanes = didIncludeRenderPhaseUpdate;
          pendingPassiveTransitions = transitions;
          pendingRecoverableErrors = recoverableErrors;
          0 !== (finishedWork.subtreeFlags & 10256) || 0 !== (finishedWork.flags & 10256) ? (root2.callbackNode = null, root2.callbackPriority = 0, scheduleCallback$1(NormalPriority$1, function() {
            flushPassiveEffects(true);
            return null;
          })) : (root2.callbackNode = null, root2.callbackPriority = 0);
          recoverableErrors = 0 !== (finishedWork.flags & 13878);
          if (0 !== (finishedWork.subtreeFlags & 13878) || recoverableErrors) {
            recoverableErrors = ReactSharedInternals.T;
            ReactSharedInternals.T = null;
            transitions = ReactDOMSharedInternals.p;
            ReactDOMSharedInternals.p = 2;
            spawnedLane = executionContext;
            executionContext |= 4;
            try {
              commitBeforeMutationEffects(root2, finishedWork, lanes);
            } finally {
              executionContext = spawnedLane, ReactDOMSharedInternals.p = transitions, ReactSharedInternals.T = recoverableErrors;
            }
          }
          pendingEffectsStatus = 1;
          flushMutationEffects();
          flushLayoutEffects();
          flushSpawnedWork();
        }
      }
      function flushMutationEffects() {
        if (1 === pendingEffectsStatus) {
          pendingEffectsStatus = 0;
          var root2 = pendingEffectsRoot, finishedWork = pendingFinishedWork, rootMutationHasEffect = 0 !== (finishedWork.flags & 13878);
          if (0 !== (finishedWork.subtreeFlags & 13878) || rootMutationHasEffect) {
            rootMutationHasEffect = ReactSharedInternals.T;
            ReactSharedInternals.T = null;
            var previousPriority = ReactDOMSharedInternals.p;
            ReactDOMSharedInternals.p = 2;
            var prevExecutionContext = executionContext;
            executionContext |= 4;
            try {
              commitMutationEffectsOnFiber(finishedWork, root2);
              var priorSelectionInformation = selectionInformation, curFocusedElem = getActiveElementDeep(root2.containerInfo), priorFocusedElem = priorSelectionInformation.focusedElem, priorSelectionRange = priorSelectionInformation.selectionRange;
              if (curFocusedElem !== priorFocusedElem && priorFocusedElem && priorFocusedElem.ownerDocument && containsNode(
                priorFocusedElem.ownerDocument.documentElement,
                priorFocusedElem
              )) {
                if (null !== priorSelectionRange && hasSelectionCapabilities(priorFocusedElem)) {
                  var start = priorSelectionRange.start, end = priorSelectionRange.end;
                  void 0 === end && (end = start);
                  if ("selectionStart" in priorFocusedElem)
                    priorFocusedElem.selectionStart = start, priorFocusedElem.selectionEnd = Math.min(
                      end,
                      priorFocusedElem.value.length
                    );
                  else {
                    var doc = priorFocusedElem.ownerDocument || document, win = doc && doc.defaultView || window;
                    if (win.getSelection) {
                      var selection = win.getSelection(), length = priorFocusedElem.textContent.length, start$jscomp$0 = Math.min(priorSelectionRange.start, length), end$jscomp$0 = void 0 === priorSelectionRange.end ? start$jscomp$0 : Math.min(priorSelectionRange.end, length);
                      !selection.extend && start$jscomp$0 > end$jscomp$0 && (curFocusedElem = end$jscomp$0, end$jscomp$0 = start$jscomp$0, start$jscomp$0 = curFocusedElem);
                      var startMarker = getNodeForCharacterOffset(
                        priorFocusedElem,
                        start$jscomp$0
                      ), endMarker = getNodeForCharacterOffset(
                        priorFocusedElem,
                        end$jscomp$0
                      );
                      if (startMarker && endMarker && (1 !== selection.rangeCount || selection.anchorNode !== startMarker.node || selection.anchorOffset !== startMarker.offset || selection.focusNode !== endMarker.node || selection.focusOffset !== endMarker.offset)) {
                        var range = doc.createRange();
                        range.setStart(startMarker.node, startMarker.offset);
                        selection.removeAllRanges();
                        start$jscomp$0 > end$jscomp$0 ? (selection.addRange(range), selection.extend(endMarker.node, endMarker.offset)) : (range.setEnd(endMarker.node, endMarker.offset), selection.addRange(range));
                      }
                    }
                  }
                }
                doc = [];
                for (selection = priorFocusedElem; selection = selection.parentNode; )
                  1 === selection.nodeType && doc.push({
                    element: selection,
                    left: selection.scrollLeft,
                    top: selection.scrollTop
                  });
                "function" === typeof priorFocusedElem.focus && priorFocusedElem.focus();
                for (priorFocusedElem = 0; priorFocusedElem < doc.length; priorFocusedElem++) {
                  var info = doc[priorFocusedElem];
                  info.element.scrollLeft = info.left;
                  info.element.scrollTop = info.top;
                }
              }
              _enabled = !!eventsEnabled;
              selectionInformation = eventsEnabled = null;
            } finally {
              executionContext = prevExecutionContext, ReactDOMSharedInternals.p = previousPriority, ReactSharedInternals.T = rootMutationHasEffect;
            }
          }
          root2.current = finishedWork;
          pendingEffectsStatus = 2;
        }
      }
      function flushLayoutEffects() {
        if (2 === pendingEffectsStatus) {
          pendingEffectsStatus = 0;
          var root2 = pendingEffectsRoot, finishedWork = pendingFinishedWork, rootHasLayoutEffect = 0 !== (finishedWork.flags & 8772);
          if (0 !== (finishedWork.subtreeFlags & 8772) || rootHasLayoutEffect) {
            rootHasLayoutEffect = ReactSharedInternals.T;
            ReactSharedInternals.T = null;
            var previousPriority = ReactDOMSharedInternals.p;
            ReactDOMSharedInternals.p = 2;
            var prevExecutionContext = executionContext;
            executionContext |= 4;
            try {
              commitLayoutEffectOnFiber(root2, finishedWork.alternate, finishedWork);
            } finally {
              executionContext = prevExecutionContext, ReactDOMSharedInternals.p = previousPriority, ReactSharedInternals.T = rootHasLayoutEffect;
            }
          }
          pendingEffectsStatus = 3;
        }
      }
      function flushSpawnedWork() {
        if (4 === pendingEffectsStatus || 3 === pendingEffectsStatus) {
          pendingEffectsStatus = 0;
          requestPaint();
          var root2 = pendingEffectsRoot, finishedWork = pendingFinishedWork, lanes = pendingEffectsLanes, recoverableErrors = pendingRecoverableErrors;
          0 !== (finishedWork.subtreeFlags & 10256) || 0 !== (finishedWork.flags & 10256) ? pendingEffectsStatus = 5 : (pendingEffectsStatus = 0, pendingFinishedWork = pendingEffectsRoot = null, releaseRootPooledCache(root2, root2.pendingLanes));
          var remainingLanes = root2.pendingLanes;
          0 === remainingLanes && (legacyErrorBoundariesThatAlreadyFailed = null);
          lanesToEventPriority(lanes);
          finishedWork = finishedWork.stateNode;
          if (injectedHook && "function" === typeof injectedHook.onCommitFiberRoot)
            try {
              injectedHook.onCommitFiberRoot(
                rendererID,
                finishedWork,
                void 0,
                128 === (finishedWork.current.flags & 128)
              );
            } catch (err) {
            }
          if (null !== recoverableErrors) {
            finishedWork = ReactSharedInternals.T;
            remainingLanes = ReactDOMSharedInternals.p;
            ReactDOMSharedInternals.p = 2;
            ReactSharedInternals.T = null;
            try {
              for (var onRecoverableError = root2.onRecoverableError, i = 0; i < recoverableErrors.length; i++) {
                var recoverableError = recoverableErrors[i];
                onRecoverableError(recoverableError.value, {
                  componentStack: recoverableError.stack
                });
              }
            } finally {
              ReactSharedInternals.T = finishedWork, ReactDOMSharedInternals.p = remainingLanes;
            }
          }
          0 !== (pendingEffectsLanes & 3) && flushPendingEffects();
          ensureRootIsScheduled(root2);
          remainingLanes = root2.pendingLanes;
          0 !== (lanes & 4194090) && 0 !== (remainingLanes & 42) ? root2 === rootWithNestedUpdates ? nestedUpdateCount++ : (nestedUpdateCount = 0, rootWithNestedUpdates = root2) : nestedUpdateCount = 0;
          flushSyncWorkAcrossRoots_impl(0, false);
        }
      }
      function releaseRootPooledCache(root2, remainingLanes) {
        0 === (root2.pooledCacheLanes &= remainingLanes) && (remainingLanes = root2.pooledCache, null != remainingLanes && (root2.pooledCache = null, releaseCache(remainingLanes)));
      }
      function flushPendingEffects(wasDelayedCommit) {
        flushMutationEffects();
        flushLayoutEffects();
        flushSpawnedWork();
        return flushPassiveEffects(wasDelayedCommit);
      }
      function flushPassiveEffects() {
        if (5 !== pendingEffectsStatus) return false;
        var root2 = pendingEffectsRoot, remainingLanes = pendingEffectsRemainingLanes;
        pendingEffectsRemainingLanes = 0;
        var renderPriority = lanesToEventPriority(pendingEffectsLanes), prevTransition = ReactSharedInternals.T, previousPriority = ReactDOMSharedInternals.p;
        try {
          ReactDOMSharedInternals.p = 32 > renderPriority ? 32 : renderPriority;
          ReactSharedInternals.T = null;
          renderPriority = pendingPassiveTransitions;
          pendingPassiveTransitions = null;
          var root$jscomp$0 = pendingEffectsRoot, lanes = pendingEffectsLanes;
          pendingEffectsStatus = 0;
          pendingFinishedWork = pendingEffectsRoot = null;
          pendingEffectsLanes = 0;
          if (0 !== (executionContext & 6)) throw Error(formatProdErrorMessage(331));
          var prevExecutionContext = executionContext;
          executionContext |= 4;
          commitPassiveUnmountOnFiber(root$jscomp$0.current);
          commitPassiveMountOnFiber(
            root$jscomp$0,
            root$jscomp$0.current,
            lanes,
            renderPriority
          );
          executionContext = prevExecutionContext;
          flushSyncWorkAcrossRoots_impl(0, false);
          if (injectedHook && "function" === typeof injectedHook.onPostCommitFiberRoot)
            try {
              injectedHook.onPostCommitFiberRoot(rendererID, root$jscomp$0);
            } catch (err) {
            }
          return true;
        } finally {
          ReactDOMSharedInternals.p = previousPriority, ReactSharedInternals.T = prevTransition, releaseRootPooledCache(root2, remainingLanes);
        }
      }
      function captureCommitPhaseErrorOnRoot(rootFiber, sourceFiber, error) {
        sourceFiber = createCapturedValueAtFiber(error, sourceFiber);
        sourceFiber = createRootErrorUpdate(rootFiber.stateNode, sourceFiber, 2);
        rootFiber = enqueueUpdate(rootFiber, sourceFiber, 2);
        null !== rootFiber && (markRootUpdated$1(rootFiber, 2), ensureRootIsScheduled(rootFiber));
      }
      function captureCommitPhaseError(sourceFiber, nearestMountedAncestor, error) {
        if (3 === sourceFiber.tag)
          captureCommitPhaseErrorOnRoot(sourceFiber, sourceFiber, error);
        else
          for (; null !== nearestMountedAncestor; ) {
            if (3 === nearestMountedAncestor.tag) {
              captureCommitPhaseErrorOnRoot(
                nearestMountedAncestor,
                sourceFiber,
                error
              );
              break;
            } else if (1 === nearestMountedAncestor.tag) {
              var instance = nearestMountedAncestor.stateNode;
              if ("function" === typeof nearestMountedAncestor.type.getDerivedStateFromError || "function" === typeof instance.componentDidCatch && (null === legacyErrorBoundariesThatAlreadyFailed || !legacyErrorBoundariesThatAlreadyFailed.has(instance))) {
                sourceFiber = createCapturedValueAtFiber(error, sourceFiber);
                error = createClassErrorUpdate(2);
                instance = enqueueUpdate(nearestMountedAncestor, error, 2);
                null !== instance && (initializeClassErrorUpdate(
                  error,
                  instance,
                  nearestMountedAncestor,
                  sourceFiber
                ), markRootUpdated$1(instance, 2), ensureRootIsScheduled(instance));
                break;
              }
            }
            nearestMountedAncestor = nearestMountedAncestor.return;
          }
      }
      function attachPingListener(root2, wakeable, lanes) {
        var pingCache = root2.pingCache;
        if (null === pingCache) {
          pingCache = root2.pingCache = new PossiblyWeakMap();
          var threadIDs = /* @__PURE__ */ new Set();
          pingCache.set(wakeable, threadIDs);
        } else
          threadIDs = pingCache.get(wakeable), void 0 === threadIDs && (threadIDs = /* @__PURE__ */ new Set(), pingCache.set(wakeable, threadIDs));
        threadIDs.has(lanes) || (workInProgressRootDidAttachPingListener = true, threadIDs.add(lanes), root2 = pingSuspendedRoot.bind(null, root2, wakeable, lanes), wakeable.then(root2, root2));
      }
      function pingSuspendedRoot(root2, wakeable, pingedLanes) {
        var pingCache = root2.pingCache;
        null !== pingCache && pingCache.delete(wakeable);
        root2.pingedLanes |= root2.suspendedLanes & pingedLanes;
        root2.warmLanes &= ~pingedLanes;
        workInProgressRoot === root2 && (workInProgressRootRenderLanes & pingedLanes) === pingedLanes && (4 === workInProgressRootExitStatus || 3 === workInProgressRootExitStatus && (workInProgressRootRenderLanes & 62914560) === workInProgressRootRenderLanes && 300 > now() - globalMostRecentFallbackTime ? 0 === (executionContext & 2) && prepareFreshStack(root2, 0) : workInProgressRootPingedLanes |= pingedLanes, workInProgressSuspendedRetryLanes === workInProgressRootRenderLanes && (workInProgressSuspendedRetryLanes = 0));
        ensureRootIsScheduled(root2);
      }
      function retryTimedOutBoundary(boundaryFiber, retryLane) {
        0 === retryLane && (retryLane = claimNextRetryLane());
        boundaryFiber = enqueueConcurrentRenderForLane(boundaryFiber, retryLane);
        null !== boundaryFiber && (markRootUpdated$1(boundaryFiber, retryLane), ensureRootIsScheduled(boundaryFiber));
      }
      function retryDehydratedSuspenseBoundary(boundaryFiber) {
        var suspenseState = boundaryFiber.memoizedState, retryLane = 0;
        null !== suspenseState && (retryLane = suspenseState.retryLane);
        retryTimedOutBoundary(boundaryFiber, retryLane);
      }
      function resolveRetryWakeable(boundaryFiber, wakeable) {
        var retryLane = 0;
        switch (boundaryFiber.tag) {
          case 13:
            var retryCache = boundaryFiber.stateNode;
            var suspenseState = boundaryFiber.memoizedState;
            null !== suspenseState && (retryLane = suspenseState.retryLane);
            break;
          case 19:
            retryCache = boundaryFiber.stateNode;
            break;
          case 22:
            retryCache = boundaryFiber.stateNode._retryCache;
            break;
          default:
            throw Error(formatProdErrorMessage(314));
        }
        null !== retryCache && retryCache.delete(wakeable);
        retryTimedOutBoundary(boundaryFiber, retryLane);
      }
      function scheduleCallback$1(priorityLevel, callback) {
        return scheduleCallback$3(priorityLevel, callback);
      }
      var firstScheduledRoot = null;
      var lastScheduledRoot = null;
      var didScheduleMicrotask = false;
      var mightHavePendingSyncWork = false;
      var isFlushingWork = false;
      var currentEventTransitionLane = 0;
      function ensureRootIsScheduled(root2) {
        root2 !== lastScheduledRoot && null === root2.next && (null === lastScheduledRoot ? firstScheduledRoot = lastScheduledRoot = root2 : lastScheduledRoot = lastScheduledRoot.next = root2);
        mightHavePendingSyncWork = true;
        didScheduleMicrotask || (didScheduleMicrotask = true, scheduleImmediateRootScheduleTask());
      }
      function flushSyncWorkAcrossRoots_impl(syncTransitionLanes, onlyLegacy) {
        if (!isFlushingWork && mightHavePendingSyncWork) {
          isFlushingWork = true;
          do {
            var didPerformSomeWork = false;
            for (var root$174 = firstScheduledRoot; null !== root$174; ) {
              if (!onlyLegacy)
                if (0 !== syncTransitionLanes) {
                  var pendingLanes = root$174.pendingLanes;
                  if (0 === pendingLanes) var JSCompiler_inline_result = 0;
                  else {
                    var suspendedLanes = root$174.suspendedLanes, pingedLanes = root$174.pingedLanes;
                    JSCompiler_inline_result = (1 << 31 - clz32(42 | syncTransitionLanes) + 1) - 1;
                    JSCompiler_inline_result &= pendingLanes & ~(suspendedLanes & ~pingedLanes);
                    JSCompiler_inline_result = JSCompiler_inline_result & 201326741 ? JSCompiler_inline_result & 201326741 | 1 : JSCompiler_inline_result ? JSCompiler_inline_result | 2 : 0;
                  }
                  0 !== JSCompiler_inline_result && (didPerformSomeWork = true, performSyncWorkOnRoot(root$174, JSCompiler_inline_result));
                } else
                  JSCompiler_inline_result = workInProgressRootRenderLanes, JSCompiler_inline_result = getNextLanes(
                    root$174,
                    root$174 === workInProgressRoot ? JSCompiler_inline_result : 0,
                    null !== root$174.cancelPendingCommit || -1 !== root$174.timeoutHandle
                  ), 0 === (JSCompiler_inline_result & 3) || checkIfRootIsPrerendering(root$174, JSCompiler_inline_result) || (didPerformSomeWork = true, performSyncWorkOnRoot(root$174, JSCompiler_inline_result));
              root$174 = root$174.next;
            }
          } while (didPerformSomeWork);
          isFlushingWork = false;
        }
      }
      function processRootScheduleInImmediateTask() {
        processRootScheduleInMicrotask();
      }
      function processRootScheduleInMicrotask() {
        mightHavePendingSyncWork = didScheduleMicrotask = false;
        var syncTransitionLanes = 0;
        0 !== currentEventTransitionLane && (shouldAttemptEagerTransition() && (syncTransitionLanes = currentEventTransitionLane), currentEventTransitionLane = 0);
        for (var currentTime = now(), prev = null, root2 = firstScheduledRoot; null !== root2; ) {
          var next = root2.next, nextLanes = scheduleTaskForRootDuringMicrotask(root2, currentTime);
          if (0 === nextLanes)
            root2.next = null, null === prev ? firstScheduledRoot = next : prev.next = next, null === next && (lastScheduledRoot = prev);
          else if (prev = root2, 0 !== syncTransitionLanes || 0 !== (nextLanes & 3))
            mightHavePendingSyncWork = true;
          root2 = next;
        }
        flushSyncWorkAcrossRoots_impl(syncTransitionLanes, false);
      }
      function scheduleTaskForRootDuringMicrotask(root2, currentTime) {
        for (var suspendedLanes = root2.suspendedLanes, pingedLanes = root2.pingedLanes, expirationTimes = root2.expirationTimes, lanes = root2.pendingLanes & -62914561; 0 < lanes; ) {
          var index$3 = 31 - clz32(lanes), lane = 1 << index$3, expirationTime = expirationTimes[index$3];
          if (-1 === expirationTime) {
            if (0 === (lane & suspendedLanes) || 0 !== (lane & pingedLanes))
              expirationTimes[index$3] = computeExpirationTime(lane, currentTime);
          } else expirationTime <= currentTime && (root2.expiredLanes |= lane);
          lanes &= ~lane;
        }
        currentTime = workInProgressRoot;
        suspendedLanes = workInProgressRootRenderLanes;
        suspendedLanes = getNextLanes(
          root2,
          root2 === currentTime ? suspendedLanes : 0,
          null !== root2.cancelPendingCommit || -1 !== root2.timeoutHandle
        );
        pingedLanes = root2.callbackNode;
        if (0 === suspendedLanes || root2 === currentTime && (2 === workInProgressSuspendedReason || 9 === workInProgressSuspendedReason) || null !== root2.cancelPendingCommit)
          return null !== pingedLanes && null !== pingedLanes && cancelCallback$1(pingedLanes), root2.callbackNode = null, root2.callbackPriority = 0;
        if (0 === (suspendedLanes & 3) || checkIfRootIsPrerendering(root2, suspendedLanes)) {
          currentTime = suspendedLanes & -suspendedLanes;
          if (currentTime === root2.callbackPriority) return currentTime;
          null !== pingedLanes && cancelCallback$1(pingedLanes);
          switch (lanesToEventPriority(suspendedLanes)) {
            case 2:
            case 8:
              suspendedLanes = UserBlockingPriority;
              break;
            case 32:
              suspendedLanes = NormalPriority$1;
              break;
            case 268435456:
              suspendedLanes = IdlePriority;
              break;
            default:
              suspendedLanes = NormalPriority$1;
          }
          pingedLanes = performWorkOnRootViaSchedulerTask.bind(null, root2);
          suspendedLanes = scheduleCallback$3(suspendedLanes, pingedLanes);
          root2.callbackPriority = currentTime;
          root2.callbackNode = suspendedLanes;
          return currentTime;
        }
        null !== pingedLanes && null !== pingedLanes && cancelCallback$1(pingedLanes);
        root2.callbackPriority = 2;
        root2.callbackNode = null;
        return 2;
      }
      function performWorkOnRootViaSchedulerTask(root2, didTimeout) {
        if (0 !== pendingEffectsStatus && 5 !== pendingEffectsStatus)
          return root2.callbackNode = null, root2.callbackPriority = 0, null;
        var originalCallbackNode = root2.callbackNode;
        if (flushPendingEffects(true) && root2.callbackNode !== originalCallbackNode)
          return null;
        var workInProgressRootRenderLanes$jscomp$0 = workInProgressRootRenderLanes;
        workInProgressRootRenderLanes$jscomp$0 = getNextLanes(
          root2,
          root2 === workInProgressRoot ? workInProgressRootRenderLanes$jscomp$0 : 0,
          null !== root2.cancelPendingCommit || -1 !== root2.timeoutHandle
        );
        if (0 === workInProgressRootRenderLanes$jscomp$0) return null;
        performWorkOnRoot(root2, workInProgressRootRenderLanes$jscomp$0, didTimeout);
        scheduleTaskForRootDuringMicrotask(root2, now());
        return null != root2.callbackNode && root2.callbackNode === originalCallbackNode ? performWorkOnRootViaSchedulerTask.bind(null, root2) : null;
      }
      function performSyncWorkOnRoot(root2, lanes) {
        if (flushPendingEffects()) return null;
        performWorkOnRoot(root2, lanes, true);
      }
      function scheduleImmediateRootScheduleTask() {
        scheduleMicrotask(function() {
          0 !== (executionContext & 6) ? scheduleCallback$3(
            ImmediatePriority,
            processRootScheduleInImmediateTask
          ) : processRootScheduleInMicrotask();
        });
      }
      function requestTransitionLane() {
        0 === currentEventTransitionLane && (currentEventTransitionLane = claimNextTransitionLane());
        return currentEventTransitionLane;
      }
      function coerceFormActionProp(actionProp) {
        return null == actionProp || "symbol" === typeof actionProp || "boolean" === typeof actionProp ? null : "function" === typeof actionProp ? actionProp : sanitizeURL("" + actionProp);
      }
      function createFormDataWithSubmitter(form, submitter) {
        var temp = submitter.ownerDocument.createElement("input");
        temp.name = submitter.name;
        temp.value = submitter.value;
        form.id && temp.setAttribute("form", form.id);
        submitter.parentNode.insertBefore(temp, submitter);
        form = new FormData(form);
        temp.parentNode.removeChild(temp);
        return form;
      }
      function extractEvents$1(dispatchQueue, domEventName, maybeTargetInst, nativeEvent, nativeEventTarget) {
        if ("submit" === domEventName && maybeTargetInst && maybeTargetInst.stateNode === nativeEventTarget) {
          var action = coerceFormActionProp(
            (nativeEventTarget[internalPropsKey] || null).action
          ), submitter = nativeEvent.submitter;
          submitter && (domEventName = (domEventName = submitter[internalPropsKey] || null) ? coerceFormActionProp(domEventName.formAction) : submitter.getAttribute("formAction"), null !== domEventName && (action = domEventName, submitter = null));
          var event = new SyntheticEvent(
            "action",
            "action",
            null,
            nativeEvent,
            nativeEventTarget
          );
          dispatchQueue.push({
            event,
            listeners: [
              {
                instance: null,
                listener: function() {
                  if (nativeEvent.defaultPrevented) {
                    if (0 !== currentEventTransitionLane) {
                      var formData = submitter ? createFormDataWithSubmitter(nativeEventTarget, submitter) : new FormData(nativeEventTarget);
                      startHostTransition(
                        maybeTargetInst,
                        {
                          pending: true,
                          data: formData,
                          method: nativeEventTarget.method,
                          action
                        },
                        null,
                        formData
                      );
                    }
                  } else
                    "function" === typeof action && (event.preventDefault(), formData = submitter ? createFormDataWithSubmitter(nativeEventTarget, submitter) : new FormData(nativeEventTarget), startHostTransition(
                      maybeTargetInst,
                      {
                        pending: true,
                        data: formData,
                        method: nativeEventTarget.method,
                        action
                      },
                      action,
                      formData
                    ));
                },
                currentTarget: nativeEventTarget
              }
            ]
          });
        }
      }
      for (i$jscomp$inline_1528 = 0; i$jscomp$inline_1528 < simpleEventPluginEvents.length; i$jscomp$inline_1528++) {
        eventName$jscomp$inline_1529 = simpleEventPluginEvents[i$jscomp$inline_1528], domEventName$jscomp$inline_1530 = eventName$jscomp$inline_1529.toLowerCase(), capitalizedEvent$jscomp$inline_1531 = eventName$jscomp$inline_1529[0].toUpperCase() + eventName$jscomp$inline_1529.slice(1);
        registerSimpleEvent(
          domEventName$jscomp$inline_1530,
          "on" + capitalizedEvent$jscomp$inline_1531
        );
      }
      var eventName$jscomp$inline_1529;
      var domEventName$jscomp$inline_1530;
      var capitalizedEvent$jscomp$inline_1531;
      var i$jscomp$inline_1528;
      registerSimpleEvent(ANIMATION_END, "onAnimationEnd");
      registerSimpleEvent(ANIMATION_ITERATION, "onAnimationIteration");
      registerSimpleEvent(ANIMATION_START, "onAnimationStart");
      registerSimpleEvent("dblclick", "onDoubleClick");
      registerSimpleEvent("focusin", "onFocus");
      registerSimpleEvent("focusout", "onBlur");
      registerSimpleEvent(TRANSITION_RUN, "onTransitionRun");
      registerSimpleEvent(TRANSITION_START, "onTransitionStart");
      registerSimpleEvent(TRANSITION_CANCEL, "onTransitionCancel");
      registerSimpleEvent(TRANSITION_END, "onTransitionEnd");
      registerDirectEvent("onMouseEnter", ["mouseout", "mouseover"]);
      registerDirectEvent("onMouseLeave", ["mouseout", "mouseover"]);
      registerDirectEvent("onPointerEnter", ["pointerout", "pointerover"]);
      registerDirectEvent("onPointerLeave", ["pointerout", "pointerover"]);
      registerTwoPhaseEvent(
        "onChange",
        "change click focusin focusout input keydown keyup selectionchange".split(" ")
      );
      registerTwoPhaseEvent(
        "onSelect",
        "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(
          " "
        )
      );
      registerTwoPhaseEvent("onBeforeInput", [
        "compositionend",
        "keypress",
        "textInput",
        "paste"
      ]);
      registerTwoPhaseEvent(
        "onCompositionEnd",
        "compositionend focusout keydown keypress keyup mousedown".split(" ")
      );
      registerTwoPhaseEvent(
        "onCompositionStart",
        "compositionstart focusout keydown keypress keyup mousedown".split(" ")
      );
      registerTwoPhaseEvent(
        "onCompositionUpdate",
        "compositionupdate focusout keydown keypress keyup mousedown".split(" ")
      );
      var mediaEventTypes = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(
        " "
      );
      var nonDelegatedEvents = new Set(
        "beforetoggle cancel close invalid load scroll scrollend toggle".split(" ").concat(mediaEventTypes)
      );
      function processDispatchQueue(dispatchQueue, eventSystemFlags) {
        eventSystemFlags = 0 !== (eventSystemFlags & 4);
        for (var i = 0; i < dispatchQueue.length; i++) {
          var _dispatchQueue$i = dispatchQueue[i], event = _dispatchQueue$i.event;
          _dispatchQueue$i = _dispatchQueue$i.listeners;
          a: {
            var previousInstance = void 0;
            if (eventSystemFlags)
              for (var i$jscomp$0 = _dispatchQueue$i.length - 1; 0 <= i$jscomp$0; i$jscomp$0--) {
                var _dispatchListeners$i = _dispatchQueue$i[i$jscomp$0], instance = _dispatchListeners$i.instance, currentTarget = _dispatchListeners$i.currentTarget;
                _dispatchListeners$i = _dispatchListeners$i.listener;
                if (instance !== previousInstance && event.isPropagationStopped())
                  break a;
                previousInstance = _dispatchListeners$i;
                event.currentTarget = currentTarget;
                try {
                  previousInstance(event);
                } catch (error) {
                  reportGlobalError(error);
                }
                event.currentTarget = null;
                previousInstance = instance;
              }
            else
              for (i$jscomp$0 = 0; i$jscomp$0 < _dispatchQueue$i.length; i$jscomp$0++) {
                _dispatchListeners$i = _dispatchQueue$i[i$jscomp$0];
                instance = _dispatchListeners$i.instance;
                currentTarget = _dispatchListeners$i.currentTarget;
                _dispatchListeners$i = _dispatchListeners$i.listener;
                if (instance !== previousInstance && event.isPropagationStopped())
                  break a;
                previousInstance = _dispatchListeners$i;
                event.currentTarget = currentTarget;
                try {
                  previousInstance(event);
                } catch (error) {
                  reportGlobalError(error);
                }
                event.currentTarget = null;
                previousInstance = instance;
              }
          }
        }
      }
      function listenToNonDelegatedEvent(domEventName, targetElement) {
        var JSCompiler_inline_result = targetElement[internalEventHandlersKey];
        void 0 === JSCompiler_inline_result && (JSCompiler_inline_result = targetElement[internalEventHandlersKey] = /* @__PURE__ */ new Set());
        var listenerSetKey = domEventName + "__bubble";
        JSCompiler_inline_result.has(listenerSetKey) || (addTrappedEventListener(targetElement, domEventName, 2, false), JSCompiler_inline_result.add(listenerSetKey));
      }
      function listenToNativeEvent(domEventName, isCapturePhaseListener, target) {
        var eventSystemFlags = 0;
        isCapturePhaseListener && (eventSystemFlags |= 4);
        addTrappedEventListener(
          target,
          domEventName,
          eventSystemFlags,
          isCapturePhaseListener
        );
      }
      var listeningMarker = "_reactListening" + Math.random().toString(36).slice(2);
      function listenToAllSupportedEvents(rootContainerElement) {
        if (!rootContainerElement[listeningMarker]) {
          rootContainerElement[listeningMarker] = true;
          allNativeEvents.forEach(function(domEventName) {
            "selectionchange" !== domEventName && (nonDelegatedEvents.has(domEventName) || listenToNativeEvent(domEventName, false, rootContainerElement), listenToNativeEvent(domEventName, true, rootContainerElement));
          });
          var ownerDocument = 9 === rootContainerElement.nodeType ? rootContainerElement : rootContainerElement.ownerDocument;
          null === ownerDocument || ownerDocument[listeningMarker] || (ownerDocument[listeningMarker] = true, listenToNativeEvent("selectionchange", false, ownerDocument));
        }
      }
      function addTrappedEventListener(targetContainer, domEventName, eventSystemFlags, isCapturePhaseListener) {
        switch (getEventPriority(domEventName)) {
          case 2:
            var listenerWrapper = dispatchDiscreteEvent;
            break;
          case 8:
            listenerWrapper = dispatchContinuousEvent;
            break;
          default:
            listenerWrapper = dispatchEvent;
        }
        eventSystemFlags = listenerWrapper.bind(
          null,
          domEventName,
          eventSystemFlags,
          targetContainer
        );
        listenerWrapper = void 0;
        !passiveBrowserEventsSupported || "touchstart" !== domEventName && "touchmove" !== domEventName && "wheel" !== domEventName || (listenerWrapper = true);
        isCapturePhaseListener ? void 0 !== listenerWrapper ? targetContainer.addEventListener(domEventName, eventSystemFlags, {
          capture: true,
          passive: listenerWrapper
        }) : targetContainer.addEventListener(domEventName, eventSystemFlags, true) : void 0 !== listenerWrapper ? targetContainer.addEventListener(domEventName, eventSystemFlags, {
          passive: listenerWrapper
        }) : targetContainer.addEventListener(domEventName, eventSystemFlags, false);
      }
      function dispatchEventForPluginEventSystem(domEventName, eventSystemFlags, nativeEvent, targetInst$jscomp$0, targetContainer) {
        var ancestorInst = targetInst$jscomp$0;
        if (0 === (eventSystemFlags & 1) && 0 === (eventSystemFlags & 2) && null !== targetInst$jscomp$0)
          a: for (; ; ) {
            if (null === targetInst$jscomp$0) return;
            var nodeTag = targetInst$jscomp$0.tag;
            if (3 === nodeTag || 4 === nodeTag) {
              var container = targetInst$jscomp$0.stateNode.containerInfo;
              if (container === targetContainer) break;
              if (4 === nodeTag)
                for (nodeTag = targetInst$jscomp$0.return; null !== nodeTag; ) {
                  var grandTag = nodeTag.tag;
                  if ((3 === grandTag || 4 === grandTag) && nodeTag.stateNode.containerInfo === targetContainer)
                    return;
                  nodeTag = nodeTag.return;
                }
              for (; null !== container; ) {
                nodeTag = getClosestInstanceFromNode(container);
                if (null === nodeTag) return;
                grandTag = nodeTag.tag;
                if (5 === grandTag || 6 === grandTag || 26 === grandTag || 27 === grandTag) {
                  targetInst$jscomp$0 = ancestorInst = nodeTag;
                  continue a;
                }
                container = container.parentNode;
              }
            }
            targetInst$jscomp$0 = targetInst$jscomp$0.return;
          }
        batchedUpdates$1(function() {
          var targetInst = ancestorInst, nativeEventTarget = getEventTarget(nativeEvent), dispatchQueue = [];
          a: {
            var reactName = topLevelEventsToReactNames.get(domEventName);
            if (void 0 !== reactName) {
              var SyntheticEventCtor = SyntheticEvent, reactEventType = domEventName;
              switch (domEventName) {
                case "keypress":
                  if (0 === getEventCharCode(nativeEvent)) break a;
                case "keydown":
                case "keyup":
                  SyntheticEventCtor = SyntheticKeyboardEvent;
                  break;
                case "focusin":
                  reactEventType = "focus";
                  SyntheticEventCtor = SyntheticFocusEvent;
                  break;
                case "focusout":
                  reactEventType = "blur";
                  SyntheticEventCtor = SyntheticFocusEvent;
                  break;
                case "beforeblur":
                case "afterblur":
                  SyntheticEventCtor = SyntheticFocusEvent;
                  break;
                case "click":
                  if (2 === nativeEvent.button) break a;
                case "auxclick":
                case "dblclick":
                case "mousedown":
                case "mousemove":
                case "mouseup":
                case "mouseout":
                case "mouseover":
                case "contextmenu":
                  SyntheticEventCtor = SyntheticMouseEvent;
                  break;
                case "drag":
                case "dragend":
                case "dragenter":
                case "dragexit":
                case "dragleave":
                case "dragover":
                case "dragstart":
                case "drop":
                  SyntheticEventCtor = SyntheticDragEvent;
                  break;
                case "touchcancel":
                case "touchend":
                case "touchmove":
                case "touchstart":
                  SyntheticEventCtor = SyntheticTouchEvent;
                  break;
                case ANIMATION_END:
                case ANIMATION_ITERATION:
                case ANIMATION_START:
                  SyntheticEventCtor = SyntheticAnimationEvent;
                  break;
                case TRANSITION_END:
                  SyntheticEventCtor = SyntheticTransitionEvent;
                  break;
                case "scroll":
                case "scrollend":
                  SyntheticEventCtor = SyntheticUIEvent;
                  break;
                case "wheel":
                  SyntheticEventCtor = SyntheticWheelEvent;
                  break;
                case "copy":
                case "cut":
                case "paste":
                  SyntheticEventCtor = SyntheticClipboardEvent;
                  break;
                case "gotpointercapture":
                case "lostpointercapture":
                case "pointercancel":
                case "pointerdown":
                case "pointermove":
                case "pointerout":
                case "pointerover":
                case "pointerup":
                  SyntheticEventCtor = SyntheticPointerEvent;
                  break;
                case "toggle":
                case "beforetoggle":
                  SyntheticEventCtor = SyntheticToggleEvent;
              }
              var inCapturePhase = 0 !== (eventSystemFlags & 4), accumulateTargetOnly = !inCapturePhase && ("scroll" === domEventName || "scrollend" === domEventName), reactEventName = inCapturePhase ? null !== reactName ? reactName + "Capture" : null : reactName;
              inCapturePhase = [];
              for (var instance = targetInst, lastHostComponent; null !== instance; ) {
                var _instance = instance;
                lastHostComponent = _instance.stateNode;
                _instance = _instance.tag;
                5 !== _instance && 26 !== _instance && 27 !== _instance || null === lastHostComponent || null === reactEventName || (_instance = getListener(instance, reactEventName), null != _instance && inCapturePhase.push(
                  createDispatchListener(instance, _instance, lastHostComponent)
                ));
                if (accumulateTargetOnly) break;
                instance = instance.return;
              }
              0 < inCapturePhase.length && (reactName = new SyntheticEventCtor(
                reactName,
                reactEventType,
                null,
                nativeEvent,
                nativeEventTarget
              ), dispatchQueue.push({ event: reactName, listeners: inCapturePhase }));
            }
          }
          if (0 === (eventSystemFlags & 7)) {
            a: {
              reactName = "mouseover" === domEventName || "pointerover" === domEventName;
              SyntheticEventCtor = "mouseout" === domEventName || "pointerout" === domEventName;
              if (reactName && nativeEvent !== currentReplayingEvent && (reactEventType = nativeEvent.relatedTarget || nativeEvent.fromElement) && (getClosestInstanceFromNode(reactEventType) || reactEventType[internalContainerInstanceKey]))
                break a;
              if (SyntheticEventCtor || reactName) {
                reactName = nativeEventTarget.window === nativeEventTarget ? nativeEventTarget : (reactName = nativeEventTarget.ownerDocument) ? reactName.defaultView || reactName.parentWindow : window;
                if (SyntheticEventCtor) {
                  if (reactEventType = nativeEvent.relatedTarget || nativeEvent.toElement, SyntheticEventCtor = targetInst, reactEventType = reactEventType ? getClosestInstanceFromNode(reactEventType) : null, null !== reactEventType && (accumulateTargetOnly = getNearestMountedFiber(reactEventType), inCapturePhase = reactEventType.tag, reactEventType !== accumulateTargetOnly || 5 !== inCapturePhase && 27 !== inCapturePhase && 6 !== inCapturePhase))
                    reactEventType = null;
                } else SyntheticEventCtor = null, reactEventType = targetInst;
                if (SyntheticEventCtor !== reactEventType) {
                  inCapturePhase = SyntheticMouseEvent;
                  _instance = "onMouseLeave";
                  reactEventName = "onMouseEnter";
                  instance = "mouse";
                  if ("pointerout" === domEventName || "pointerover" === domEventName)
                    inCapturePhase = SyntheticPointerEvent, _instance = "onPointerLeave", reactEventName = "onPointerEnter", instance = "pointer";
                  accumulateTargetOnly = null == SyntheticEventCtor ? reactName : getNodeFromInstance(SyntheticEventCtor);
                  lastHostComponent = null == reactEventType ? reactName : getNodeFromInstance(reactEventType);
                  reactName = new inCapturePhase(
                    _instance,
                    instance + "leave",
                    SyntheticEventCtor,
                    nativeEvent,
                    nativeEventTarget
                  );
                  reactName.target = accumulateTargetOnly;
                  reactName.relatedTarget = lastHostComponent;
                  _instance = null;
                  getClosestInstanceFromNode(nativeEventTarget) === targetInst && (inCapturePhase = new inCapturePhase(
                    reactEventName,
                    instance + "enter",
                    reactEventType,
                    nativeEvent,
                    nativeEventTarget
                  ), inCapturePhase.target = lastHostComponent, inCapturePhase.relatedTarget = accumulateTargetOnly, _instance = inCapturePhase);
                  accumulateTargetOnly = _instance;
                  if (SyntheticEventCtor && reactEventType)
                    b: {
                      inCapturePhase = SyntheticEventCtor;
                      reactEventName = reactEventType;
                      instance = 0;
                      for (lastHostComponent = inCapturePhase; lastHostComponent; lastHostComponent = getParent(lastHostComponent))
                        instance++;
                      lastHostComponent = 0;
                      for (_instance = reactEventName; _instance; _instance = getParent(_instance))
                        lastHostComponent++;
                      for (; 0 < instance - lastHostComponent; )
                        inCapturePhase = getParent(inCapturePhase), instance--;
                      for (; 0 < lastHostComponent - instance; )
                        reactEventName = getParent(reactEventName), lastHostComponent--;
                      for (; instance--; ) {
                        if (inCapturePhase === reactEventName || null !== reactEventName && inCapturePhase === reactEventName.alternate)
                          break b;
                        inCapturePhase = getParent(inCapturePhase);
                        reactEventName = getParent(reactEventName);
                      }
                      inCapturePhase = null;
                    }
                  else inCapturePhase = null;
                  null !== SyntheticEventCtor && accumulateEnterLeaveListenersForEvent(
                    dispatchQueue,
                    reactName,
                    SyntheticEventCtor,
                    inCapturePhase,
                    false
                  );
                  null !== reactEventType && null !== accumulateTargetOnly && accumulateEnterLeaveListenersForEvent(
                    dispatchQueue,
                    accumulateTargetOnly,
                    reactEventType,
                    inCapturePhase,
                    true
                  );
                }
              }
            }
            a: {
              reactName = targetInst ? getNodeFromInstance(targetInst) : window;
              SyntheticEventCtor = reactName.nodeName && reactName.nodeName.toLowerCase();
              if ("select" === SyntheticEventCtor || "input" === SyntheticEventCtor && "file" === reactName.type)
                var getTargetInstFunc = getTargetInstForChangeEvent;
              else if (isTextInputElement(reactName))
                if (isInputEventSupported)
                  getTargetInstFunc = getTargetInstForInputOrChangeEvent;
                else {
                  getTargetInstFunc = getTargetInstForInputEventPolyfill;
                  var handleEventFunc = handleEventsForInputEventPolyfill;
                }
              else
                SyntheticEventCtor = reactName.nodeName, !SyntheticEventCtor || "input" !== SyntheticEventCtor.toLowerCase() || "checkbox" !== reactName.type && "radio" !== reactName.type ? targetInst && isCustomElement(targetInst.elementType) && (getTargetInstFunc = getTargetInstForChangeEvent) : getTargetInstFunc = getTargetInstForClickEvent;
              if (getTargetInstFunc && (getTargetInstFunc = getTargetInstFunc(domEventName, targetInst))) {
                createAndAccumulateChangeEvent(
                  dispatchQueue,
                  getTargetInstFunc,
                  nativeEvent,
                  nativeEventTarget
                );
                break a;
              }
              handleEventFunc && handleEventFunc(domEventName, reactName, targetInst);
              "focusout" === domEventName && targetInst && "number" === reactName.type && null != targetInst.memoizedProps.value && setDefaultValue(reactName, "number", reactName.value);
            }
            handleEventFunc = targetInst ? getNodeFromInstance(targetInst) : window;
            switch (domEventName) {
              case "focusin":
                if (isTextInputElement(handleEventFunc) || "true" === handleEventFunc.contentEditable)
                  activeElement = handleEventFunc, activeElementInst = targetInst, lastSelection = null;
                break;
              case "focusout":
                lastSelection = activeElementInst = activeElement = null;
                break;
              case "mousedown":
                mouseDown = true;
                break;
              case "contextmenu":
              case "mouseup":
              case "dragend":
                mouseDown = false;
                constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget);
                break;
              case "selectionchange":
                if (skipSelectionChangeEvent) break;
              case "keydown":
              case "keyup":
                constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget);
            }
            var fallbackData;
            if (canUseCompositionEvent)
              b: {
                switch (domEventName) {
                  case "compositionstart":
                    var eventType = "onCompositionStart";
                    break b;
                  case "compositionend":
                    eventType = "onCompositionEnd";
                    break b;
                  case "compositionupdate":
                    eventType = "onCompositionUpdate";
                    break b;
                }
                eventType = void 0;
              }
            else
              isComposing ? isFallbackCompositionEnd(domEventName, nativeEvent) && (eventType = "onCompositionEnd") : "keydown" === domEventName && 229 === nativeEvent.keyCode && (eventType = "onCompositionStart");
            eventType && (useFallbackCompositionData && "ko" !== nativeEvent.locale && (isComposing || "onCompositionStart" !== eventType ? "onCompositionEnd" === eventType && isComposing && (fallbackData = getData()) : (root = nativeEventTarget, startText = "value" in root ? root.value : root.textContent, isComposing = true)), handleEventFunc = accumulateTwoPhaseListeners(targetInst, eventType), 0 < handleEventFunc.length && (eventType = new SyntheticCompositionEvent(
              eventType,
              domEventName,
              null,
              nativeEvent,
              nativeEventTarget
            ), dispatchQueue.push({ event: eventType, listeners: handleEventFunc }), fallbackData ? eventType.data = fallbackData : (fallbackData = getDataFromCustomEvent(nativeEvent), null !== fallbackData && (eventType.data = fallbackData))));
            if (fallbackData = canUseTextInputEvent ? getNativeBeforeInputChars(domEventName, nativeEvent) : getFallbackBeforeInputChars(domEventName, nativeEvent))
              eventType = accumulateTwoPhaseListeners(targetInst, "onBeforeInput"), 0 < eventType.length && (handleEventFunc = new SyntheticCompositionEvent(
                "onBeforeInput",
                "beforeinput",
                null,
                nativeEvent,
                nativeEventTarget
              ), dispatchQueue.push({
                event: handleEventFunc,
                listeners: eventType
              }), handleEventFunc.data = fallbackData);
            extractEvents$1(
              dispatchQueue,
              domEventName,
              targetInst,
              nativeEvent,
              nativeEventTarget
            );
          }
          processDispatchQueue(dispatchQueue, eventSystemFlags);
        });
      }
      function createDispatchListener(instance, listener, currentTarget) {
        return {
          instance,
          listener,
          currentTarget
        };
      }
      function accumulateTwoPhaseListeners(targetFiber, reactName) {
        for (var captureName = reactName + "Capture", listeners = []; null !== targetFiber; ) {
          var _instance2 = targetFiber, stateNode = _instance2.stateNode;
          _instance2 = _instance2.tag;
          5 !== _instance2 && 26 !== _instance2 && 27 !== _instance2 || null === stateNode || (_instance2 = getListener(targetFiber, captureName), null != _instance2 && listeners.unshift(
            createDispatchListener(targetFiber, _instance2, stateNode)
          ), _instance2 = getListener(targetFiber, reactName), null != _instance2 && listeners.push(
            createDispatchListener(targetFiber, _instance2, stateNode)
          ));
          if (3 === targetFiber.tag) return listeners;
          targetFiber = targetFiber.return;
        }
        return [];
      }
      function getParent(inst) {
        if (null === inst) return null;
        do
          inst = inst.return;
        while (inst && 5 !== inst.tag && 27 !== inst.tag);
        return inst ? inst : null;
      }
      function accumulateEnterLeaveListenersForEvent(dispatchQueue, event, target, common, inCapturePhase) {
        for (var registrationName = event._reactName, listeners = []; null !== target && target !== common; ) {
          var _instance3 = target, alternate = _instance3.alternate, stateNode = _instance3.stateNode;
          _instance3 = _instance3.tag;
          if (null !== alternate && alternate === common) break;
          5 !== _instance3 && 26 !== _instance3 && 27 !== _instance3 || null === stateNode || (alternate = stateNode, inCapturePhase ? (stateNode = getListener(target, registrationName), null != stateNode && listeners.unshift(
            createDispatchListener(target, stateNode, alternate)
          )) : inCapturePhase || (stateNode = getListener(target, registrationName), null != stateNode && listeners.push(
            createDispatchListener(target, stateNode, alternate)
          )));
          target = target.return;
        }
        0 !== listeners.length && dispatchQueue.push({ event, listeners });
      }
      var NORMALIZE_NEWLINES_REGEX = /\r\n?/g;
      var NORMALIZE_NULL_AND_REPLACEMENT_REGEX = /\u0000|\uFFFD/g;
      function normalizeMarkupForTextOrAttribute(markup) {
        return ("string" === typeof markup ? markup : "" + markup).replace(NORMALIZE_NEWLINES_REGEX, "\n").replace(NORMALIZE_NULL_AND_REPLACEMENT_REGEX, "");
      }
      function checkForUnmatchedText(serverText, clientText) {
        clientText = normalizeMarkupForTextOrAttribute(clientText);
        return normalizeMarkupForTextOrAttribute(serverText) === clientText ? true : false;
      }
      function noop$1() {
      }
      function setProp(domElement, tag, key, value, props, prevValue) {
        switch (key) {
          case "children":
            "string" === typeof value ? "body" === tag || "textarea" === tag && "" === value || setTextContent(domElement, value) : ("number" === typeof value || "bigint" === typeof value) && "body" !== tag && setTextContent(domElement, "" + value);
            break;
          case "className":
            setValueForKnownAttribute(domElement, "class", value);
            break;
          case "tabIndex":
            setValueForKnownAttribute(domElement, "tabindex", value);
            break;
          case "dir":
          case "role":
          case "viewBox":
          case "width":
          case "height":
            setValueForKnownAttribute(domElement, key, value);
            break;
          case "style":
            setValueForStyles(domElement, value, prevValue);
            break;
          case "data":
            if ("object" !== tag) {
              setValueForKnownAttribute(domElement, "data", value);
              break;
            }
          case "src":
          case "href":
            if ("" === value && ("a" !== tag || "href" !== key)) {
              domElement.removeAttribute(key);
              break;
            }
            if (null == value || "function" === typeof value || "symbol" === typeof value || "boolean" === typeof value) {
              domElement.removeAttribute(key);
              break;
            }
            value = sanitizeURL("" + value);
            domElement.setAttribute(key, value);
            break;
          case "action":
          case "formAction":
            if ("function" === typeof value) {
              domElement.setAttribute(
                key,
                "javascript:throw new Error('A React form was unexpectedly submitted. If you called form.submit() manually, consider using form.requestSubmit() instead. If you\\'re trying to use event.stopPropagation() in a submit event handler, consider also calling event.preventDefault().')"
              );
              break;
            } else
              "function" === typeof prevValue && ("formAction" === key ? ("input" !== tag && setProp(domElement, tag, "name", props.name, props, null), setProp(
                domElement,
                tag,
                "formEncType",
                props.formEncType,
                props,
                null
              ), setProp(
                domElement,
                tag,
                "formMethod",
                props.formMethod,
                props,
                null
              ), setProp(
                domElement,
                tag,
                "formTarget",
                props.formTarget,
                props,
                null
              )) : (setProp(domElement, tag, "encType", props.encType, props, null), setProp(domElement, tag, "method", props.method, props, null), setProp(domElement, tag, "target", props.target, props, null)));
            if (null == value || "symbol" === typeof value || "boolean" === typeof value) {
              domElement.removeAttribute(key);
              break;
            }
            value = sanitizeURL("" + value);
            domElement.setAttribute(key, value);
            break;
          case "onClick":
            null != value && (domElement.onclick = noop$1);
            break;
          case "onScroll":
            null != value && listenToNonDelegatedEvent("scroll", domElement);
            break;
          case "onScrollEnd":
            null != value && listenToNonDelegatedEvent("scrollend", domElement);
            break;
          case "dangerouslySetInnerHTML":
            if (null != value) {
              if ("object" !== typeof value || !("__html" in value))
                throw Error(formatProdErrorMessage(61));
              key = value.__html;
              if (null != key) {
                if (null != props.children) throw Error(formatProdErrorMessage(60));
                domElement.innerHTML = key;
              }
            }
            break;
          case "multiple":
            domElement.multiple = value && "function" !== typeof value && "symbol" !== typeof value;
            break;
          case "muted":
            domElement.muted = value && "function" !== typeof value && "symbol" !== typeof value;
            break;
          case "suppressContentEditableWarning":
          case "suppressHydrationWarning":
          case "defaultValue":
          case "defaultChecked":
          case "innerHTML":
          case "ref":
            break;
          case "autoFocus":
            break;
          case "xlinkHref":
            if (null == value || "function" === typeof value || "boolean" === typeof value || "symbol" === typeof value) {
              domElement.removeAttribute("xlink:href");
              break;
            }
            key = sanitizeURL("" + value);
            domElement.setAttributeNS(
              "http://www.w3.org/1999/xlink",
              "xlink:href",
              key
            );
            break;
          case "contentEditable":
          case "spellCheck":
          case "draggable":
          case "value":
          case "autoReverse":
          case "externalResourcesRequired":
          case "focusable":
          case "preserveAlpha":
            null != value && "function" !== typeof value && "symbol" !== typeof value ? domElement.setAttribute(key, "" + value) : domElement.removeAttribute(key);
            break;
          case "inert":
          case "allowFullScreen":
          case "async":
          case "autoPlay":
          case "controls":
          case "default":
          case "defer":
          case "disabled":
          case "disablePictureInPicture":
          case "disableRemotePlayback":
          case "formNoValidate":
          case "hidden":
          case "loop":
          case "noModule":
          case "noValidate":
          case "open":
          case "playsInline":
          case "readOnly":
          case "required":
          case "reversed":
          case "scoped":
          case "seamless":
          case "itemScope":
            value && "function" !== typeof value && "symbol" !== typeof value ? domElement.setAttribute(key, "") : domElement.removeAttribute(key);
            break;
          case "capture":
          case "download":
            true === value ? domElement.setAttribute(key, "") : false !== value && null != value && "function" !== typeof value && "symbol" !== typeof value ? domElement.setAttribute(key, value) : domElement.removeAttribute(key);
            break;
          case "cols":
          case "rows":
          case "size":
          case "span":
            null != value && "function" !== typeof value && "symbol" !== typeof value && !isNaN(value) && 1 <= value ? domElement.setAttribute(key, value) : domElement.removeAttribute(key);
            break;
          case "rowSpan":
          case "start":
            null == value || "function" === typeof value || "symbol" === typeof value || isNaN(value) ? domElement.removeAttribute(key) : domElement.setAttribute(key, value);
            break;
          case "popover":
            listenToNonDelegatedEvent("beforetoggle", domElement);
            listenToNonDelegatedEvent("toggle", domElement);
            setValueForAttribute(domElement, "popover", value);
            break;
          case "xlinkActuate":
            setValueForNamespacedAttribute(
              domElement,
              "http://www.w3.org/1999/xlink",
              "xlink:actuate",
              value
            );
            break;
          case "xlinkArcrole":
            setValueForNamespacedAttribute(
              domElement,
              "http://www.w3.org/1999/xlink",
              "xlink:arcrole",
              value
            );
            break;
          case "xlinkRole":
            setValueForNamespacedAttribute(
              domElement,
              "http://www.w3.org/1999/xlink",
              "xlink:role",
              value
            );
            break;
          case "xlinkShow":
            setValueForNamespacedAttribute(
              domElement,
              "http://www.w3.org/1999/xlink",
              "xlink:show",
              value
            );
            break;
          case "xlinkTitle":
            setValueForNamespacedAttribute(
              domElement,
              "http://www.w3.org/1999/xlink",
              "xlink:title",
              value
            );
            break;
          case "xlinkType":
            setValueForNamespacedAttribute(
              domElement,
              "http://www.w3.org/1999/xlink",
              "xlink:type",
              value
            );
            break;
          case "xmlBase":
            setValueForNamespacedAttribute(
              domElement,
              "http://www.w3.org/XML/1998/namespace",
              "xml:base",
              value
            );
            break;
          case "xmlLang":
            setValueForNamespacedAttribute(
              domElement,
              "http://www.w3.org/XML/1998/namespace",
              "xml:lang",
              value
            );
            break;
          case "xmlSpace":
            setValueForNamespacedAttribute(
              domElement,
              "http://www.w3.org/XML/1998/namespace",
              "xml:space",
              value
            );
            break;
          case "is":
            setValueForAttribute(domElement, "is", value);
            break;
          case "innerText":
          case "textContent":
            break;
          default:
            if (!(2 < key.length) || "o" !== key[0] && "O" !== key[0] || "n" !== key[1] && "N" !== key[1])
              key = aliases.get(key) || key, setValueForAttribute(domElement, key, value);
        }
      }
      function setPropOnCustomElement(domElement, tag, key, value, props, prevValue) {
        switch (key) {
          case "style":
            setValueForStyles(domElement, value, prevValue);
            break;
          case "dangerouslySetInnerHTML":
            if (null != value) {
              if ("object" !== typeof value || !("__html" in value))
                throw Error(formatProdErrorMessage(61));
              key = value.__html;
              if (null != key) {
                if (null != props.children) throw Error(formatProdErrorMessage(60));
                domElement.innerHTML = key;
              }
            }
            break;
          case "children":
            "string" === typeof value ? setTextContent(domElement, value) : ("number" === typeof value || "bigint" === typeof value) && setTextContent(domElement, "" + value);
            break;
          case "onScroll":
            null != value && listenToNonDelegatedEvent("scroll", domElement);
            break;
          case "onScrollEnd":
            null != value && listenToNonDelegatedEvent("scrollend", domElement);
            break;
          case "onClick":
            null != value && (domElement.onclick = noop$1);
            break;
          case "suppressContentEditableWarning":
          case "suppressHydrationWarning":
          case "innerHTML":
          case "ref":
            break;
          case "innerText":
          case "textContent":
            break;
          default:
            if (!registrationNameDependencies.hasOwnProperty(key))
              a: {
                if ("o" === key[0] && "n" === key[1] && (props = key.endsWith("Capture"), tag = key.slice(2, props ? key.length - 7 : void 0), prevValue = domElement[internalPropsKey] || null, prevValue = null != prevValue ? prevValue[key] : null, "function" === typeof prevValue && domElement.removeEventListener(tag, prevValue, props), "function" === typeof value)) {
                  "function" !== typeof prevValue && null !== prevValue && (key in domElement ? domElement[key] = null : domElement.hasAttribute(key) && domElement.removeAttribute(key));
                  domElement.addEventListener(tag, value, props);
                  break a;
                }
                key in domElement ? domElement[key] = value : true === value ? domElement.setAttribute(key, "") : setValueForAttribute(domElement, key, value);
              }
        }
      }
      function setInitialProperties(domElement, tag, props) {
        switch (tag) {
          case "div":
          case "span":
          case "svg":
          case "path":
          case "a":
          case "g":
          case "p":
          case "li":
            break;
          case "img":
            listenToNonDelegatedEvent("error", domElement);
            listenToNonDelegatedEvent("load", domElement);
            var hasSrc = false, hasSrcSet = false, propKey;
            for (propKey in props)
              if (props.hasOwnProperty(propKey)) {
                var propValue = props[propKey];
                if (null != propValue)
                  switch (propKey) {
                    case "src":
                      hasSrc = true;
                      break;
                    case "srcSet":
                      hasSrcSet = true;
                      break;
                    case "children":
                    case "dangerouslySetInnerHTML":
                      throw Error(formatProdErrorMessage(137, tag));
                    default:
                      setProp(domElement, tag, propKey, propValue, props, null);
                  }
              }
            hasSrcSet && setProp(domElement, tag, "srcSet", props.srcSet, props, null);
            hasSrc && setProp(domElement, tag, "src", props.src, props, null);
            return;
          case "input":
            listenToNonDelegatedEvent("invalid", domElement);
            var defaultValue = propKey = propValue = hasSrcSet = null, checked = null, defaultChecked = null;
            for (hasSrc in props)
              if (props.hasOwnProperty(hasSrc)) {
                var propValue$188 = props[hasSrc];
                if (null != propValue$188)
                  switch (hasSrc) {
                    case "name":
                      hasSrcSet = propValue$188;
                      break;
                    case "type":
                      propValue = propValue$188;
                      break;
                    case "checked":
                      checked = propValue$188;
                      break;
                    case "defaultChecked":
                      defaultChecked = propValue$188;
                      break;
                    case "value":
                      propKey = propValue$188;
                      break;
                    case "defaultValue":
                      defaultValue = propValue$188;
                      break;
                    case "children":
                    case "dangerouslySetInnerHTML":
                      if (null != propValue$188)
                        throw Error(formatProdErrorMessage(137, tag));
                      break;
                    default:
                      setProp(domElement, tag, hasSrc, propValue$188, props, null);
                  }
              }
            initInput(
              domElement,
              propKey,
              defaultValue,
              checked,
              defaultChecked,
              propValue,
              hasSrcSet,
              false
            );
            track(domElement);
            return;
          case "select":
            listenToNonDelegatedEvent("invalid", domElement);
            hasSrc = propValue = propKey = null;
            for (hasSrcSet in props)
              if (props.hasOwnProperty(hasSrcSet) && (defaultValue = props[hasSrcSet], null != defaultValue))
                switch (hasSrcSet) {
                  case "value":
                    propKey = defaultValue;
                    break;
                  case "defaultValue":
                    propValue = defaultValue;
                    break;
                  case "multiple":
                    hasSrc = defaultValue;
                  default:
                    setProp(domElement, tag, hasSrcSet, defaultValue, props, null);
                }
            tag = propKey;
            props = propValue;
            domElement.multiple = !!hasSrc;
            null != tag ? updateOptions(domElement, !!hasSrc, tag, false) : null != props && updateOptions(domElement, !!hasSrc, props, true);
            return;
          case "textarea":
            listenToNonDelegatedEvent("invalid", domElement);
            propKey = hasSrcSet = hasSrc = null;
            for (propValue in props)
              if (props.hasOwnProperty(propValue) && (defaultValue = props[propValue], null != defaultValue))
                switch (propValue) {
                  case "value":
                    hasSrc = defaultValue;
                    break;
                  case "defaultValue":
                    hasSrcSet = defaultValue;
                    break;
                  case "children":
                    propKey = defaultValue;
                    break;
                  case "dangerouslySetInnerHTML":
                    if (null != defaultValue) throw Error(formatProdErrorMessage(91));
                    break;
                  default:
                    setProp(domElement, tag, propValue, defaultValue, props, null);
                }
            initTextarea(domElement, hasSrc, hasSrcSet, propKey);
            track(domElement);
            return;
          case "option":
            for (checked in props)
              if (props.hasOwnProperty(checked) && (hasSrc = props[checked], null != hasSrc))
                switch (checked) {
                  case "selected":
                    domElement.selected = hasSrc && "function" !== typeof hasSrc && "symbol" !== typeof hasSrc;
                    break;
                  default:
                    setProp(domElement, tag, checked, hasSrc, props, null);
                }
            return;
          case "dialog":
            listenToNonDelegatedEvent("beforetoggle", domElement);
            listenToNonDelegatedEvent("toggle", domElement);
            listenToNonDelegatedEvent("cancel", domElement);
            listenToNonDelegatedEvent("close", domElement);
            break;
          case "iframe":
          case "object":
            listenToNonDelegatedEvent("load", domElement);
            break;
          case "video":
          case "audio":
            for (hasSrc = 0; hasSrc < mediaEventTypes.length; hasSrc++)
              listenToNonDelegatedEvent(mediaEventTypes[hasSrc], domElement);
            break;
          case "image":
            listenToNonDelegatedEvent("error", domElement);
            listenToNonDelegatedEvent("load", domElement);
            break;
          case "details":
            listenToNonDelegatedEvent("toggle", domElement);
            break;
          case "embed":
          case "source":
          case "link":
            listenToNonDelegatedEvent("error", domElement), listenToNonDelegatedEvent("load", domElement);
          case "area":
          case "base":
          case "br":
          case "col":
          case "hr":
          case "keygen":
          case "meta":
          case "param":
          case "track":
          case "wbr":
          case "menuitem":
            for (defaultChecked in props)
              if (props.hasOwnProperty(defaultChecked) && (hasSrc = props[defaultChecked], null != hasSrc))
                switch (defaultChecked) {
                  case "children":
                  case "dangerouslySetInnerHTML":
                    throw Error(formatProdErrorMessage(137, tag));
                  default:
                    setProp(domElement, tag, defaultChecked, hasSrc, props, null);
                }
            return;
          default:
            if (isCustomElement(tag)) {
              for (propValue$188 in props)
                props.hasOwnProperty(propValue$188) && (hasSrc = props[propValue$188], void 0 !== hasSrc && setPropOnCustomElement(
                  domElement,
                  tag,
                  propValue$188,
                  hasSrc,
                  props,
                  void 0
                ));
              return;
            }
        }
        for (defaultValue in props)
          props.hasOwnProperty(defaultValue) && (hasSrc = props[defaultValue], null != hasSrc && setProp(domElement, tag, defaultValue, hasSrc, props, null));
      }
      function updateProperties(domElement, tag, lastProps, nextProps) {
        switch (tag) {
          case "div":
          case "span":
          case "svg":
          case "path":
          case "a":
          case "g":
          case "p":
          case "li":
            break;
          case "input":
            var name = null, type = null, value = null, defaultValue = null, lastDefaultValue = null, checked = null, defaultChecked = null;
            for (propKey in lastProps) {
              var lastProp = lastProps[propKey];
              if (lastProps.hasOwnProperty(propKey) && null != lastProp)
                switch (propKey) {
                  case "checked":
                    break;
                  case "value":
                    break;
                  case "defaultValue":
                    lastDefaultValue = lastProp;
                  default:
                    nextProps.hasOwnProperty(propKey) || setProp(domElement, tag, propKey, null, nextProps, lastProp);
                }
            }
            for (var propKey$205 in nextProps) {
              var propKey = nextProps[propKey$205];
              lastProp = lastProps[propKey$205];
              if (nextProps.hasOwnProperty(propKey$205) && (null != propKey || null != lastProp))
                switch (propKey$205) {
                  case "type":
                    type = propKey;
                    break;
                  case "name":
                    name = propKey;
                    break;
                  case "checked":
                    checked = propKey;
                    break;
                  case "defaultChecked":
                    defaultChecked = propKey;
                    break;
                  case "value":
                    value = propKey;
                    break;
                  case "defaultValue":
                    defaultValue = propKey;
                    break;
                  case "children":
                  case "dangerouslySetInnerHTML":
                    if (null != propKey)
                      throw Error(formatProdErrorMessage(137, tag));
                    break;
                  default:
                    propKey !== lastProp && setProp(
                      domElement,
                      tag,
                      propKey$205,
                      propKey,
                      nextProps,
                      lastProp
                    );
                }
            }
            updateInput(
              domElement,
              value,
              defaultValue,
              lastDefaultValue,
              checked,
              defaultChecked,
              type,
              name
            );
            return;
          case "select":
            propKey = value = defaultValue = propKey$205 = null;
            for (type in lastProps)
              if (lastDefaultValue = lastProps[type], lastProps.hasOwnProperty(type) && null != lastDefaultValue)
                switch (type) {
                  case "value":
                    break;
                  case "multiple":
                    propKey = lastDefaultValue;
                  default:
                    nextProps.hasOwnProperty(type) || setProp(
                      domElement,
                      tag,
                      type,
                      null,
                      nextProps,
                      lastDefaultValue
                    );
                }
            for (name in nextProps)
              if (type = nextProps[name], lastDefaultValue = lastProps[name], nextProps.hasOwnProperty(name) && (null != type || null != lastDefaultValue))
                switch (name) {
                  case "value":
                    propKey$205 = type;
                    break;
                  case "defaultValue":
                    defaultValue = type;
                    break;
                  case "multiple":
                    value = type;
                  default:
                    type !== lastDefaultValue && setProp(
                      domElement,
                      tag,
                      name,
                      type,
                      nextProps,
                      lastDefaultValue
                    );
                }
            tag = defaultValue;
            lastProps = value;
            nextProps = propKey;
            null != propKey$205 ? updateOptions(domElement, !!lastProps, propKey$205, false) : !!nextProps !== !!lastProps && (null != tag ? updateOptions(domElement, !!lastProps, tag, true) : updateOptions(domElement, !!lastProps, lastProps ? [] : "", false));
            return;
          case "textarea":
            propKey = propKey$205 = null;
            for (defaultValue in lastProps)
              if (name = lastProps[defaultValue], lastProps.hasOwnProperty(defaultValue) && null != name && !nextProps.hasOwnProperty(defaultValue))
                switch (defaultValue) {
                  case "value":
                    break;
                  case "children":
                    break;
                  default:
                    setProp(domElement, tag, defaultValue, null, nextProps, name);
                }
            for (value in nextProps)
              if (name = nextProps[value], type = lastProps[value], nextProps.hasOwnProperty(value) && (null != name || null != type))
                switch (value) {
                  case "value":
                    propKey$205 = name;
                    break;
                  case "defaultValue":
                    propKey = name;
                    break;
                  case "children":
                    break;
                  case "dangerouslySetInnerHTML":
                    if (null != name) throw Error(formatProdErrorMessage(91));
                    break;
                  default:
                    name !== type && setProp(domElement, tag, value, name, nextProps, type);
                }
            updateTextarea(domElement, propKey$205, propKey);
            return;
          case "option":
            for (var propKey$221 in lastProps)
              if (propKey$205 = lastProps[propKey$221], lastProps.hasOwnProperty(propKey$221) && null != propKey$205 && !nextProps.hasOwnProperty(propKey$221))
                switch (propKey$221) {
                  case "selected":
                    domElement.selected = false;
                    break;
                  default:
                    setProp(
                      domElement,
                      tag,
                      propKey$221,
                      null,
                      nextProps,
                      propKey$205
                    );
                }
            for (lastDefaultValue in nextProps)
              if (propKey$205 = nextProps[lastDefaultValue], propKey = lastProps[lastDefaultValue], nextProps.hasOwnProperty(lastDefaultValue) && propKey$205 !== propKey && (null != propKey$205 || null != propKey))
                switch (lastDefaultValue) {
                  case "selected":
                    domElement.selected = propKey$205 && "function" !== typeof propKey$205 && "symbol" !== typeof propKey$205;
                    break;
                  default:
                    setProp(
                      domElement,
                      tag,
                      lastDefaultValue,
                      propKey$205,
                      nextProps,
                      propKey
                    );
                }
            return;
          case "img":
          case "link":
          case "area":
          case "base":
          case "br":
          case "col":
          case "embed":
          case "hr":
          case "keygen":
          case "meta":
          case "param":
          case "source":
          case "track":
          case "wbr":
          case "menuitem":
            for (var propKey$226 in lastProps)
              propKey$205 = lastProps[propKey$226], lastProps.hasOwnProperty(propKey$226) && null != propKey$205 && !nextProps.hasOwnProperty(propKey$226) && setProp(domElement, tag, propKey$226, null, nextProps, propKey$205);
            for (checked in nextProps)
              if (propKey$205 = nextProps[checked], propKey = lastProps[checked], nextProps.hasOwnProperty(checked) && propKey$205 !== propKey && (null != propKey$205 || null != propKey))
                switch (checked) {
                  case "children":
                  case "dangerouslySetInnerHTML":
                    if (null != propKey$205)
                      throw Error(formatProdErrorMessage(137, tag));
                    break;
                  default:
                    setProp(
                      domElement,
                      tag,
                      checked,
                      propKey$205,
                      nextProps,
                      propKey
                    );
                }
            return;
          default:
            if (isCustomElement(tag)) {
              for (var propKey$231 in lastProps)
                propKey$205 = lastProps[propKey$231], lastProps.hasOwnProperty(propKey$231) && void 0 !== propKey$205 && !nextProps.hasOwnProperty(propKey$231) && setPropOnCustomElement(
                  domElement,
                  tag,
                  propKey$231,
                  void 0,
                  nextProps,
                  propKey$205
                );
              for (defaultChecked in nextProps)
                propKey$205 = nextProps[defaultChecked], propKey = lastProps[defaultChecked], !nextProps.hasOwnProperty(defaultChecked) || propKey$205 === propKey || void 0 === propKey$205 && void 0 === propKey || setPropOnCustomElement(
                  domElement,
                  tag,
                  defaultChecked,
                  propKey$205,
                  nextProps,
                  propKey
                );
              return;
            }
        }
        for (var propKey$236 in lastProps)
          propKey$205 = lastProps[propKey$236], lastProps.hasOwnProperty(propKey$236) && null != propKey$205 && !nextProps.hasOwnProperty(propKey$236) && setProp(domElement, tag, propKey$236, null, nextProps, propKey$205);
        for (lastProp in nextProps)
          propKey$205 = nextProps[lastProp], propKey = lastProps[lastProp], !nextProps.hasOwnProperty(lastProp) || propKey$205 === propKey || null == propKey$205 && null == propKey || setProp(domElement, tag, lastProp, propKey$205, nextProps, propKey);
      }
      var eventsEnabled = null;
      var selectionInformation = null;
      function getOwnerDocumentFromRootContainer(rootContainerElement) {
        return 9 === rootContainerElement.nodeType ? rootContainerElement : rootContainerElement.ownerDocument;
      }
      function getOwnHostContext(namespaceURI) {
        switch (namespaceURI) {
          case "http://www.w3.org/2000/svg":
            return 1;
          case "http://www.w3.org/1998/Math/MathML":
            return 2;
          default:
            return 0;
        }
      }
      function getChildHostContextProd(parentNamespace, type) {
        if (0 === parentNamespace)
          switch (type) {
            case "svg":
              return 1;
            case "math":
              return 2;
            default:
              return 0;
          }
        return 1 === parentNamespace && "foreignObject" === type ? 0 : parentNamespace;
      }
      function shouldSetTextContent(type, props) {
        return "textarea" === type || "noscript" === type || "string" === typeof props.children || "number" === typeof props.children || "bigint" === typeof props.children || "object" === typeof props.dangerouslySetInnerHTML && null !== props.dangerouslySetInnerHTML && null != props.dangerouslySetInnerHTML.__html;
      }
      var currentPopstateTransitionEvent = null;
      function shouldAttemptEagerTransition() {
        var event = window.event;
        if (event && "popstate" === event.type) {
          if (event === currentPopstateTransitionEvent) return false;
          currentPopstateTransitionEvent = event;
          return true;
        }
        currentPopstateTransitionEvent = null;
        return false;
      }
      var scheduleTimeout = "function" === typeof setTimeout ? setTimeout : void 0;
      var cancelTimeout = "function" === typeof clearTimeout ? clearTimeout : void 0;
      var localPromise = "function" === typeof Promise ? Promise : void 0;
      var scheduleMicrotask = "function" === typeof queueMicrotask ? queueMicrotask : "undefined" !== typeof localPromise ? function(callback) {
        return localPromise.resolve(null).then(callback).catch(handleErrorInNextTick);
      } : scheduleTimeout;
      function handleErrorInNextTick(error) {
        setTimeout(function() {
          throw error;
        });
      }
      function isSingletonScope(type) {
        return "head" === type;
      }
      function clearSuspenseBoundary(parentInstance, suspenseInstance) {
        var node = suspenseInstance, possiblePreambleContribution = 0, depth = 0;
        do {
          var nextNode = node.nextSibling;
          parentInstance.removeChild(node);
          if (nextNode && 8 === nextNode.nodeType)
            if (node = nextNode.data, "/$" === node) {
              if (0 < possiblePreambleContribution && 8 > possiblePreambleContribution) {
                node = possiblePreambleContribution;
                var ownerDocument = parentInstance.ownerDocument;
                node & 1 && releaseSingletonInstance(ownerDocument.documentElement);
                node & 2 && releaseSingletonInstance(ownerDocument.body);
                if (node & 4)
                  for (node = ownerDocument.head, releaseSingletonInstance(node), ownerDocument = node.firstChild; ownerDocument; ) {
                    var nextNode$jscomp$0 = ownerDocument.nextSibling, nodeName = ownerDocument.nodeName;
                    ownerDocument[internalHoistableMarker] || "SCRIPT" === nodeName || "STYLE" === nodeName || "LINK" === nodeName && "stylesheet" === ownerDocument.rel.toLowerCase() || node.removeChild(ownerDocument);
                    ownerDocument = nextNode$jscomp$0;
                  }
              }
              if (0 === depth) {
                parentInstance.removeChild(nextNode);
                retryIfBlockedOn(suspenseInstance);
                return;
              }
              depth--;
            } else
              "$" === node || "$?" === node || "$!" === node ? depth++ : possiblePreambleContribution = node.charCodeAt(0) - 48;
          else possiblePreambleContribution = 0;
          node = nextNode;
        } while (node);
        retryIfBlockedOn(suspenseInstance);
      }
      function clearContainerSparingly(container) {
        var nextNode = container.firstChild;
        nextNode && 10 === nextNode.nodeType && (nextNode = nextNode.nextSibling);
        for (; nextNode; ) {
          var node = nextNode;
          nextNode = nextNode.nextSibling;
          switch (node.nodeName) {
            case "HTML":
            case "HEAD":
            case "BODY":
              clearContainerSparingly(node);
              detachDeletedInstance(node);
              continue;
            case "SCRIPT":
            case "STYLE":
              continue;
            case "LINK":
              if ("stylesheet" === node.rel.toLowerCase()) continue;
          }
          container.removeChild(node);
        }
      }
      function canHydrateInstance(instance, type, props, inRootOrSingleton) {
        for (; 1 === instance.nodeType; ) {
          var anyProps = props;
          if (instance.nodeName.toLowerCase() !== type.toLowerCase()) {
            if (!inRootOrSingleton && ("INPUT" !== instance.nodeName || "hidden" !== instance.type))
              break;
          } else if (!inRootOrSingleton)
            if ("input" === type && "hidden" === instance.type) {
              var name = null == anyProps.name ? null : "" + anyProps.name;
              if ("hidden" === anyProps.type && instance.getAttribute("name") === name)
                return instance;
            } else return instance;
          else if (!instance[internalHoistableMarker])
            switch (type) {
              case "meta":
                if (!instance.hasAttribute("itemprop")) break;
                return instance;
              case "link":
                name = instance.getAttribute("rel");
                if ("stylesheet" === name && instance.hasAttribute("data-precedence"))
                  break;
                else if (name !== anyProps.rel || instance.getAttribute("href") !== (null == anyProps.href || "" === anyProps.href ? null : anyProps.href) || instance.getAttribute("crossorigin") !== (null == anyProps.crossOrigin ? null : anyProps.crossOrigin) || instance.getAttribute("title") !== (null == anyProps.title ? null : anyProps.title))
                  break;
                return instance;
              case "style":
                if (instance.hasAttribute("data-precedence")) break;
                return instance;
              case "script":
                name = instance.getAttribute("src");
                if ((name !== (null == anyProps.src ? null : anyProps.src) || instance.getAttribute("type") !== (null == anyProps.type ? null : anyProps.type) || instance.getAttribute("crossorigin") !== (null == anyProps.crossOrigin ? null : anyProps.crossOrigin)) && name && instance.hasAttribute("async") && !instance.hasAttribute("itemprop"))
                  break;
                return instance;
              default:
                return instance;
            }
          instance = getNextHydratable(instance.nextSibling);
          if (null === instance) break;
        }
        return null;
      }
      function canHydrateTextInstance(instance, text, inRootOrSingleton) {
        if ("" === text) return null;
        for (; 3 !== instance.nodeType; ) {
          if ((1 !== instance.nodeType || "INPUT" !== instance.nodeName || "hidden" !== instance.type) && !inRootOrSingleton)
            return null;
          instance = getNextHydratable(instance.nextSibling);
          if (null === instance) return null;
        }
        return instance;
      }
      function isSuspenseInstanceFallback(instance) {
        return "$!" === instance.data || "$?" === instance.data && "complete" === instance.ownerDocument.readyState;
      }
      function registerSuspenseInstanceRetry(instance, callback) {
        var ownerDocument = instance.ownerDocument;
        if ("$?" !== instance.data || "complete" === ownerDocument.readyState)
          callback();
        else {
          var listener = function() {
            callback();
            ownerDocument.removeEventListener("DOMContentLoaded", listener);
          };
          ownerDocument.addEventListener("DOMContentLoaded", listener);
          instance._reactRetry = listener;
        }
      }
      function getNextHydratable(node) {
        for (; null != node; node = node.nextSibling) {
          var nodeType = node.nodeType;
          if (1 === nodeType || 3 === nodeType) break;
          if (8 === nodeType) {
            nodeType = node.data;
            if ("$" === nodeType || "$!" === nodeType || "$?" === nodeType || "F!" === nodeType || "F" === nodeType)
              break;
            if ("/$" === nodeType) return null;
          }
        }
        return node;
      }
      var previousHydratableOnEnteringScopedSingleton = null;
      function getParentSuspenseInstance(targetInstance) {
        targetInstance = targetInstance.previousSibling;
        for (var depth = 0; targetInstance; ) {
          if (8 === targetInstance.nodeType) {
            var data = targetInstance.data;
            if ("$" === data || "$!" === data || "$?" === data) {
              if (0 === depth) return targetInstance;
              depth--;
            } else "/$" === data && depth++;
          }
          targetInstance = targetInstance.previousSibling;
        }
        return null;
      }
      function resolveSingletonInstance(type, props, rootContainerInstance) {
        props = getOwnerDocumentFromRootContainer(rootContainerInstance);
        switch (type) {
          case "html":
            type = props.documentElement;
            if (!type) throw Error(formatProdErrorMessage(452));
            return type;
          case "head":
            type = props.head;
            if (!type) throw Error(formatProdErrorMessage(453));
            return type;
          case "body":
            type = props.body;
            if (!type) throw Error(formatProdErrorMessage(454));
            return type;
          default:
            throw Error(formatProdErrorMessage(451));
        }
      }
      function releaseSingletonInstance(instance) {
        for (var attributes = instance.attributes; attributes.length; )
          instance.removeAttributeNode(attributes[0]);
        detachDeletedInstance(instance);
      }
      var preloadPropsMap = /* @__PURE__ */ new Map();
      var preconnectsSet = /* @__PURE__ */ new Set();
      function getHoistableRoot(container) {
        return "function" === typeof container.getRootNode ? container.getRootNode() : 9 === container.nodeType ? container : container.ownerDocument;
      }
      var previousDispatcher = ReactDOMSharedInternals.d;
      ReactDOMSharedInternals.d = {
        f: flushSyncWork,
        r: requestFormReset,
        D: prefetchDNS,
        C: preconnect,
        L: preload,
        m: preloadModule,
        X: preinitScript,
        S: preinitStyle,
        M: preinitModuleScript
      };
      function flushSyncWork() {
        var previousWasRendering = previousDispatcher.f(), wasRendering = flushSyncWork$1();
        return previousWasRendering || wasRendering;
      }
      function requestFormReset(form) {
        var formInst = getInstanceFromNode(form);
        null !== formInst && 5 === formInst.tag && "form" === formInst.type ? requestFormReset$1(formInst) : previousDispatcher.r(form);
      }
      var globalDocument = "undefined" === typeof document ? null : document;
      function preconnectAs(rel, href, crossOrigin) {
        var ownerDocument = globalDocument;
        if (ownerDocument && "string" === typeof href && href) {
          var limitedEscapedHref = escapeSelectorAttributeValueInsideDoubleQuotes(href);
          limitedEscapedHref = 'link[rel="' + rel + '"][href="' + limitedEscapedHref + '"]';
          "string" === typeof crossOrigin && (limitedEscapedHref += '[crossorigin="' + crossOrigin + '"]');
          preconnectsSet.has(limitedEscapedHref) || (preconnectsSet.add(limitedEscapedHref), rel = { rel, crossOrigin, href }, null === ownerDocument.querySelector(limitedEscapedHref) && (href = ownerDocument.createElement("link"), setInitialProperties(href, "link", rel), markNodeAsHoistable(href), ownerDocument.head.appendChild(href)));
        }
      }
      function prefetchDNS(href) {
        previousDispatcher.D(href);
        preconnectAs("dns-prefetch", href, null);
      }
      function preconnect(href, crossOrigin) {
        previousDispatcher.C(href, crossOrigin);
        preconnectAs("preconnect", href, crossOrigin);
      }
      function preload(href, as, options2) {
        previousDispatcher.L(href, as, options2);
        var ownerDocument = globalDocument;
        if (ownerDocument && href && as) {
          var preloadSelector = 'link[rel="preload"][as="' + escapeSelectorAttributeValueInsideDoubleQuotes(as) + '"]';
          "image" === as ? options2 && options2.imageSrcSet ? (preloadSelector += '[imagesrcset="' + escapeSelectorAttributeValueInsideDoubleQuotes(
            options2.imageSrcSet
          ) + '"]', "string" === typeof options2.imageSizes && (preloadSelector += '[imagesizes="' + escapeSelectorAttributeValueInsideDoubleQuotes(
            options2.imageSizes
          ) + '"]')) : preloadSelector += '[href="' + escapeSelectorAttributeValueInsideDoubleQuotes(href) + '"]' : preloadSelector += '[href="' + escapeSelectorAttributeValueInsideDoubleQuotes(href) + '"]';
          var key = preloadSelector;
          switch (as) {
            case "style":
              key = getStyleKey(href);
              break;
            case "script":
              key = getScriptKey(href);
          }
          preloadPropsMap.has(key) || (href = assign(
            {
              rel: "preload",
              href: "image" === as && options2 && options2.imageSrcSet ? void 0 : href,
              as
            },
            options2
          ), preloadPropsMap.set(key, href), null !== ownerDocument.querySelector(preloadSelector) || "style" === as && ownerDocument.querySelector(getStylesheetSelectorFromKey(key)) || "script" === as && ownerDocument.querySelector(getScriptSelectorFromKey(key)) || (as = ownerDocument.createElement("link"), setInitialProperties(as, "link", href), markNodeAsHoistable(as), ownerDocument.head.appendChild(as)));
        }
      }
      function preloadModule(href, options2) {
        previousDispatcher.m(href, options2);
        var ownerDocument = globalDocument;
        if (ownerDocument && href) {
          var as = options2 && "string" === typeof options2.as ? options2.as : "script", preloadSelector = 'link[rel="modulepreload"][as="' + escapeSelectorAttributeValueInsideDoubleQuotes(as) + '"][href="' + escapeSelectorAttributeValueInsideDoubleQuotes(href) + '"]', key = preloadSelector;
          switch (as) {
            case "audioworklet":
            case "paintworklet":
            case "serviceworker":
            case "sharedworker":
            case "worker":
            case "script":
              key = getScriptKey(href);
          }
          if (!preloadPropsMap.has(key) && (href = assign({ rel: "modulepreload", href }, options2), preloadPropsMap.set(key, href), null === ownerDocument.querySelector(preloadSelector))) {
            switch (as) {
              case "audioworklet":
              case "paintworklet":
              case "serviceworker":
              case "sharedworker":
              case "worker":
              case "script":
                if (ownerDocument.querySelector(getScriptSelectorFromKey(key)))
                  return;
            }
            as = ownerDocument.createElement("link");
            setInitialProperties(as, "link", href);
            markNodeAsHoistable(as);
            ownerDocument.head.appendChild(as);
          }
        }
      }
      function preinitStyle(href, precedence, options2) {
        previousDispatcher.S(href, precedence, options2);
        var ownerDocument = globalDocument;
        if (ownerDocument && href) {
          var styles = getResourcesFromRoot(ownerDocument).hoistableStyles, key = getStyleKey(href);
          precedence = precedence || "default";
          var resource = styles.get(key);
          if (!resource) {
            var state = { loading: 0, preload: null };
            if (resource = ownerDocument.querySelector(
              getStylesheetSelectorFromKey(key)
            ))
              state.loading = 5;
            else {
              href = assign(
                { rel: "stylesheet", href, "data-precedence": precedence },
                options2
              );
              (options2 = preloadPropsMap.get(key)) && adoptPreloadPropsForStylesheet(href, options2);
              var link = resource = ownerDocument.createElement("link");
              markNodeAsHoistable(link);
              setInitialProperties(link, "link", href);
              link._p = new Promise(function(resolve, reject) {
                link.onload = resolve;
                link.onerror = reject;
              });
              link.addEventListener("load", function() {
                state.loading |= 1;
              });
              link.addEventListener("error", function() {
                state.loading |= 2;
              });
              state.loading |= 4;
              insertStylesheet(resource, precedence, ownerDocument);
            }
            resource = {
              type: "stylesheet",
              instance: resource,
              count: 1,
              state
            };
            styles.set(key, resource);
          }
        }
      }
      function preinitScript(src, options2) {
        previousDispatcher.X(src, options2);
        var ownerDocument = globalDocument;
        if (ownerDocument && src) {
          var scripts = getResourcesFromRoot(ownerDocument).hoistableScripts, key = getScriptKey(src), resource = scripts.get(key);
          resource || (resource = ownerDocument.querySelector(getScriptSelectorFromKey(key)), resource || (src = assign({ src, async: true }, options2), (options2 = preloadPropsMap.get(key)) && adoptPreloadPropsForScript(src, options2), resource = ownerDocument.createElement("script"), markNodeAsHoistable(resource), setInitialProperties(resource, "link", src), ownerDocument.head.appendChild(resource)), resource = {
            type: "script",
            instance: resource,
            count: 1,
            state: null
          }, scripts.set(key, resource));
        }
      }
      function preinitModuleScript(src, options2) {
        previousDispatcher.M(src, options2);
        var ownerDocument = globalDocument;
        if (ownerDocument && src) {
          var scripts = getResourcesFromRoot(ownerDocument).hoistableScripts, key = getScriptKey(src), resource = scripts.get(key);
          resource || (resource = ownerDocument.querySelector(getScriptSelectorFromKey(key)), resource || (src = assign({ src, async: true, type: "module" }, options2), (options2 = preloadPropsMap.get(key)) && adoptPreloadPropsForScript(src, options2), resource = ownerDocument.createElement("script"), markNodeAsHoistable(resource), setInitialProperties(resource, "link", src), ownerDocument.head.appendChild(resource)), resource = {
            type: "script",
            instance: resource,
            count: 1,
            state: null
          }, scripts.set(key, resource));
        }
      }
      function getResource(type, currentProps, pendingProps, currentResource) {
        var JSCompiler_inline_result = (JSCompiler_inline_result = rootInstanceStackCursor.current) ? getHoistableRoot(JSCompiler_inline_result) : null;
        if (!JSCompiler_inline_result) throw Error(formatProdErrorMessage(446));
        switch (type) {
          case "meta":
          case "title":
            return null;
          case "style":
            return "string" === typeof pendingProps.precedence && "string" === typeof pendingProps.href ? (currentProps = getStyleKey(pendingProps.href), pendingProps = getResourcesFromRoot(
              JSCompiler_inline_result
            ).hoistableStyles, currentResource = pendingProps.get(currentProps), currentResource || (currentResource = {
              type: "style",
              instance: null,
              count: 0,
              state: null
            }, pendingProps.set(currentProps, currentResource)), currentResource) : { type: "void", instance: null, count: 0, state: null };
          case "link":
            if ("stylesheet" === pendingProps.rel && "string" === typeof pendingProps.href && "string" === typeof pendingProps.precedence) {
              type = getStyleKey(pendingProps.href);
              var styles$244 = getResourcesFromRoot(
                JSCompiler_inline_result
              ).hoistableStyles, resource$245 = styles$244.get(type);
              resource$245 || (JSCompiler_inline_result = JSCompiler_inline_result.ownerDocument || JSCompiler_inline_result, resource$245 = {
                type: "stylesheet",
                instance: null,
                count: 0,
                state: { loading: 0, preload: null }
              }, styles$244.set(type, resource$245), (styles$244 = JSCompiler_inline_result.querySelector(
                getStylesheetSelectorFromKey(type)
              )) && !styles$244._p && (resource$245.instance = styles$244, resource$245.state.loading = 5), preloadPropsMap.has(type) || (pendingProps = {
                rel: "preload",
                as: "style",
                href: pendingProps.href,
                crossOrigin: pendingProps.crossOrigin,
                integrity: pendingProps.integrity,
                media: pendingProps.media,
                hrefLang: pendingProps.hrefLang,
                referrerPolicy: pendingProps.referrerPolicy
              }, preloadPropsMap.set(type, pendingProps), styles$244 || preloadStylesheet(
                JSCompiler_inline_result,
                type,
                pendingProps,
                resource$245.state
              )));
              if (currentProps && null === currentResource)
                throw Error(formatProdErrorMessage(528, ""));
              return resource$245;
            }
            if (currentProps && null !== currentResource)
              throw Error(formatProdErrorMessage(529, ""));
            return null;
          case "script":
            return currentProps = pendingProps.async, pendingProps = pendingProps.src, "string" === typeof pendingProps && currentProps && "function" !== typeof currentProps && "symbol" !== typeof currentProps ? (currentProps = getScriptKey(pendingProps), pendingProps = getResourcesFromRoot(
              JSCompiler_inline_result
            ).hoistableScripts, currentResource = pendingProps.get(currentProps), currentResource || (currentResource = {
              type: "script",
              instance: null,
              count: 0,
              state: null
            }, pendingProps.set(currentProps, currentResource)), currentResource) : { type: "void", instance: null, count: 0, state: null };
          default:
            throw Error(formatProdErrorMessage(444, type));
        }
      }
      function getStyleKey(href) {
        return 'href="' + escapeSelectorAttributeValueInsideDoubleQuotes(href) + '"';
      }
      function getStylesheetSelectorFromKey(key) {
        return 'link[rel="stylesheet"][' + key + "]";
      }
      function stylesheetPropsFromRawProps(rawProps) {
        return assign({}, rawProps, {
          "data-precedence": rawProps.precedence,
          precedence: null
        });
      }
      function preloadStylesheet(ownerDocument, key, preloadProps, state) {
        ownerDocument.querySelector('link[rel="preload"][as="style"][' + key + "]") ? state.loading = 1 : (key = ownerDocument.createElement("link"), state.preload = key, key.addEventListener("load", function() {
          return state.loading |= 1;
        }), key.addEventListener("error", function() {
          return state.loading |= 2;
        }), setInitialProperties(key, "link", preloadProps), markNodeAsHoistable(key), ownerDocument.head.appendChild(key));
      }
      function getScriptKey(src) {
        return '[src="' + escapeSelectorAttributeValueInsideDoubleQuotes(src) + '"]';
      }
      function getScriptSelectorFromKey(key) {
        return "script[async]" + key;
      }
      function acquireResource(hoistableRoot, resource, props) {
        resource.count++;
        if (null === resource.instance)
          switch (resource.type) {
            case "style":
              var instance = hoistableRoot.querySelector(
                'style[data-href~="' + escapeSelectorAttributeValueInsideDoubleQuotes(props.href) + '"]'
              );
              if (instance)
                return resource.instance = instance, markNodeAsHoistable(instance), instance;
              var styleProps = assign({}, props, {
                "data-href": props.href,
                "data-precedence": props.precedence,
                href: null,
                precedence: null
              });
              instance = (hoistableRoot.ownerDocument || hoistableRoot).createElement(
                "style"
              );
              markNodeAsHoistable(instance);
              setInitialProperties(instance, "style", styleProps);
              insertStylesheet(instance, props.precedence, hoistableRoot);
              return resource.instance = instance;
            case "stylesheet":
              styleProps = getStyleKey(props.href);
              var instance$250 = hoistableRoot.querySelector(
                getStylesheetSelectorFromKey(styleProps)
              );
              if (instance$250)
                return resource.state.loading |= 4, resource.instance = instance$250, markNodeAsHoistable(instance$250), instance$250;
              instance = stylesheetPropsFromRawProps(props);
              (styleProps = preloadPropsMap.get(styleProps)) && adoptPreloadPropsForStylesheet(instance, styleProps);
              instance$250 = (hoistableRoot.ownerDocument || hoistableRoot).createElement("link");
              markNodeAsHoistable(instance$250);
              var linkInstance = instance$250;
              linkInstance._p = new Promise(function(resolve, reject) {
                linkInstance.onload = resolve;
                linkInstance.onerror = reject;
              });
              setInitialProperties(instance$250, "link", instance);
              resource.state.loading |= 4;
              insertStylesheet(instance$250, props.precedence, hoistableRoot);
              return resource.instance = instance$250;
            case "script":
              instance$250 = getScriptKey(props.src);
              if (styleProps = hoistableRoot.querySelector(
                getScriptSelectorFromKey(instance$250)
              ))
                return resource.instance = styleProps, markNodeAsHoistable(styleProps), styleProps;
              instance = props;
              if (styleProps = preloadPropsMap.get(instance$250))
                instance = assign({}, props), adoptPreloadPropsForScript(instance, styleProps);
              hoistableRoot = hoistableRoot.ownerDocument || hoistableRoot;
              styleProps = hoistableRoot.createElement("script");
              markNodeAsHoistable(styleProps);
              setInitialProperties(styleProps, "link", instance);
              hoistableRoot.head.appendChild(styleProps);
              return resource.instance = styleProps;
            case "void":
              return null;
            default:
              throw Error(formatProdErrorMessage(443, resource.type));
          }
        else
          "stylesheet" === resource.type && 0 === (resource.state.loading & 4) && (instance = resource.instance, resource.state.loading |= 4, insertStylesheet(instance, props.precedence, hoistableRoot));
        return resource.instance;
      }
      function insertStylesheet(instance, precedence, root2) {
        for (var nodes = root2.querySelectorAll(
          'link[rel="stylesheet"][data-precedence],style[data-precedence]'
        ), last = nodes.length ? nodes[nodes.length - 1] : null, prior = last, i = 0; i < nodes.length; i++) {
          var node = nodes[i];
          if (node.dataset.precedence === precedence) prior = node;
          else if (prior !== last) break;
        }
        prior ? prior.parentNode.insertBefore(instance, prior.nextSibling) : (precedence = 9 === root2.nodeType ? root2.head : root2, precedence.insertBefore(instance, precedence.firstChild));
      }
      function adoptPreloadPropsForStylesheet(stylesheetProps, preloadProps) {
        null == stylesheetProps.crossOrigin && (stylesheetProps.crossOrigin = preloadProps.crossOrigin);
        null == stylesheetProps.referrerPolicy && (stylesheetProps.referrerPolicy = preloadProps.referrerPolicy);
        null == stylesheetProps.title && (stylesheetProps.title = preloadProps.title);
      }
      function adoptPreloadPropsForScript(scriptProps, preloadProps) {
        null == scriptProps.crossOrigin && (scriptProps.crossOrigin = preloadProps.crossOrigin);
        null == scriptProps.referrerPolicy && (scriptProps.referrerPolicy = preloadProps.referrerPolicy);
        null == scriptProps.integrity && (scriptProps.integrity = preloadProps.integrity);
      }
      var tagCaches = null;
      function getHydratableHoistableCache(type, keyAttribute, ownerDocument) {
        if (null === tagCaches) {
          var cache = /* @__PURE__ */ new Map();
          var caches2 = tagCaches = /* @__PURE__ */ new Map();
          caches2.set(ownerDocument, cache);
        } else
          caches2 = tagCaches, cache = caches2.get(ownerDocument), cache || (cache = /* @__PURE__ */ new Map(), caches2.set(ownerDocument, cache));
        if (cache.has(type)) return cache;
        cache.set(type, null);
        ownerDocument = ownerDocument.getElementsByTagName(type);
        for (caches2 = 0; caches2 < ownerDocument.length; caches2++) {
          var node = ownerDocument[caches2];
          if (!(node[internalHoistableMarker] || node[internalInstanceKey] || "link" === type && "stylesheet" === node.getAttribute("rel")) && "http://www.w3.org/2000/svg" !== node.namespaceURI) {
            var nodeKey = node.getAttribute(keyAttribute) || "";
            nodeKey = type + nodeKey;
            var existing = cache.get(nodeKey);
            existing ? existing.push(node) : cache.set(nodeKey, [node]);
          }
        }
        return cache;
      }
      function mountHoistable(hoistableRoot, type, instance) {
        hoistableRoot = hoistableRoot.ownerDocument || hoistableRoot;
        hoistableRoot.head.insertBefore(
          instance,
          "title" === type ? hoistableRoot.querySelector("head > title") : null
        );
      }
      function isHostHoistableType(type, props, hostContext) {
        if (1 === hostContext || null != props.itemProp) return false;
        switch (type) {
          case "meta":
          case "title":
            return true;
          case "style":
            if ("string" !== typeof props.precedence || "string" !== typeof props.href || "" === props.href)
              break;
            return true;
          case "link":
            if ("string" !== typeof props.rel || "string" !== typeof props.href || "" === props.href || props.onLoad || props.onError)
              break;
            switch (props.rel) {
              case "stylesheet":
                return type = props.disabled, "string" === typeof props.precedence && null == type;
              default:
                return true;
            }
          case "script":
            if (props.async && "function" !== typeof props.async && "symbol" !== typeof props.async && !props.onLoad && !props.onError && props.src && "string" === typeof props.src)
              return true;
        }
        return false;
      }
      function preloadResource(resource) {
        return "stylesheet" === resource.type && 0 === (resource.state.loading & 3) ? false : true;
      }
      var suspendedState = null;
      function noop() {
      }
      function suspendResource(hoistableRoot, resource, props) {
        if (null === suspendedState) throw Error(formatProdErrorMessage(475));
        var state = suspendedState;
        if ("stylesheet" === resource.type && ("string" !== typeof props.media || false !== matchMedia(props.media).matches) && 0 === (resource.state.loading & 4)) {
          if (null === resource.instance) {
            var key = getStyleKey(props.href), instance = hoistableRoot.querySelector(
              getStylesheetSelectorFromKey(key)
            );
            if (instance) {
              hoistableRoot = instance._p;
              null !== hoistableRoot && "object" === typeof hoistableRoot && "function" === typeof hoistableRoot.then && (state.count++, state = onUnsuspend.bind(state), hoistableRoot.then(state, state));
              resource.state.loading |= 4;
              resource.instance = instance;
              markNodeAsHoistable(instance);
              return;
            }
            instance = hoistableRoot.ownerDocument || hoistableRoot;
            props = stylesheetPropsFromRawProps(props);
            (key = preloadPropsMap.get(key)) && adoptPreloadPropsForStylesheet(props, key);
            instance = instance.createElement("link");
            markNodeAsHoistable(instance);
            var linkInstance = instance;
            linkInstance._p = new Promise(function(resolve, reject) {
              linkInstance.onload = resolve;
              linkInstance.onerror = reject;
            });
            setInitialProperties(instance, "link", props);
            resource.instance = instance;
          }
          null === state.stylesheets && (state.stylesheets = /* @__PURE__ */ new Map());
          state.stylesheets.set(resource, hoistableRoot);
          (hoistableRoot = resource.state.preload) && 0 === (resource.state.loading & 3) && (state.count++, resource = onUnsuspend.bind(state), hoistableRoot.addEventListener("load", resource), hoistableRoot.addEventListener("error", resource));
        }
      }
      function waitForCommitToBeReady() {
        if (null === suspendedState) throw Error(formatProdErrorMessage(475));
        var state = suspendedState;
        state.stylesheets && 0 === state.count && insertSuspendedStylesheets(state, state.stylesheets);
        return 0 < state.count ? function(commit) {
          var stylesheetTimer = setTimeout(function() {
            state.stylesheets && insertSuspendedStylesheets(state, state.stylesheets);
            if (state.unsuspend) {
              var unsuspend = state.unsuspend;
              state.unsuspend = null;
              unsuspend();
            }
          }, 6e4);
          state.unsuspend = commit;
          return function() {
            state.unsuspend = null;
            clearTimeout(stylesheetTimer);
          };
        } : null;
      }
      function onUnsuspend() {
        this.count--;
        if (0 === this.count) {
          if (this.stylesheets) insertSuspendedStylesheets(this, this.stylesheets);
          else if (this.unsuspend) {
            var unsuspend = this.unsuspend;
            this.unsuspend = null;
            unsuspend();
          }
        }
      }
      var precedencesByRoot = null;
      function insertSuspendedStylesheets(state, resources) {
        state.stylesheets = null;
        null !== state.unsuspend && (state.count++, precedencesByRoot = /* @__PURE__ */ new Map(), resources.forEach(insertStylesheetIntoRoot, state), precedencesByRoot = null, onUnsuspend.call(state));
      }
      function insertStylesheetIntoRoot(root2, resource) {
        if (!(resource.state.loading & 4)) {
          var precedences = precedencesByRoot.get(root2);
          if (precedences) var last = precedences.get(null);
          else {
            precedences = /* @__PURE__ */ new Map();
            precedencesByRoot.set(root2, precedences);
            for (var nodes = root2.querySelectorAll(
              "link[data-precedence],style[data-precedence]"
            ), i = 0; i < nodes.length; i++) {
              var node = nodes[i];
              if ("LINK" === node.nodeName || "not all" !== node.getAttribute("media"))
                precedences.set(node.dataset.precedence, node), last = node;
            }
            last && precedences.set(null, last);
          }
          nodes = resource.instance;
          node = nodes.getAttribute("data-precedence");
          i = precedences.get(node) || last;
          i === last && precedences.set(null, nodes);
          precedences.set(node, nodes);
          this.count++;
          last = onUnsuspend.bind(this);
          nodes.addEventListener("load", last);
          nodes.addEventListener("error", last);
          i ? i.parentNode.insertBefore(nodes, i.nextSibling) : (root2 = 9 === root2.nodeType ? root2.head : root2, root2.insertBefore(nodes, root2.firstChild));
          resource.state.loading |= 4;
        }
      }
      var HostTransitionContext = {
        $$typeof: REACT_CONTEXT_TYPE,
        Provider: null,
        Consumer: null,
        _currentValue: sharedNotPendingObject,
        _currentValue2: sharedNotPendingObject,
        _threadCount: 0
      };
      function FiberRootNode(containerInfo, tag, hydrate, identifierPrefix, onUncaughtError, onCaughtError, onRecoverableError, formState) {
        this.tag = 1;
        this.containerInfo = containerInfo;
        this.pingCache = this.current = this.pendingChildren = null;
        this.timeoutHandle = -1;
        this.callbackNode = this.next = this.pendingContext = this.context = this.cancelPendingCommit = null;
        this.callbackPriority = 0;
        this.expirationTimes = createLaneMap(-1);
        this.entangledLanes = this.shellSuspendCounter = this.errorRecoveryDisabledLanes = this.expiredLanes = this.warmLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0;
        this.entanglements = createLaneMap(0);
        this.hiddenUpdates = createLaneMap(null);
        this.identifierPrefix = identifierPrefix;
        this.onUncaughtError = onUncaughtError;
        this.onCaughtError = onCaughtError;
        this.onRecoverableError = onRecoverableError;
        this.pooledCache = null;
        this.pooledCacheLanes = 0;
        this.formState = formState;
        this.incompleteTransitions = /* @__PURE__ */ new Map();
      }
      function createFiberRoot(containerInfo, tag, hydrate, initialChildren, hydrationCallbacks, isStrictMode, identifierPrefix, onUncaughtError, onCaughtError, onRecoverableError, transitionCallbacks, formState) {
        containerInfo = new FiberRootNode(
          containerInfo,
          tag,
          hydrate,
          identifierPrefix,
          onUncaughtError,
          onCaughtError,
          onRecoverableError,
          formState
        );
        tag = 1;
        true === isStrictMode && (tag |= 24);
        isStrictMode = createFiberImplClass(3, null, null, tag);
        containerInfo.current = isStrictMode;
        isStrictMode.stateNode = containerInfo;
        tag = createCache();
        tag.refCount++;
        containerInfo.pooledCache = tag;
        tag.refCount++;
        isStrictMode.memoizedState = {
          element: initialChildren,
          isDehydrated: hydrate,
          cache: tag
        };
        initializeUpdateQueue(isStrictMode);
        return containerInfo;
      }
      function getContextForSubtree(parentComponent) {
        if (!parentComponent) return emptyContextObject;
        parentComponent = emptyContextObject;
        return parentComponent;
      }
      function updateContainerImpl(rootFiber, lane, element, container, parentComponent, callback) {
        parentComponent = getContextForSubtree(parentComponent);
        null === container.context ? container.context = parentComponent : container.pendingContext = parentComponent;
        container = createUpdate(lane);
        container.payload = { element };
        callback = void 0 === callback ? null : callback;
        null !== callback && (container.callback = callback);
        element = enqueueUpdate(rootFiber, container, lane);
        null !== element && (scheduleUpdateOnFiber(element, rootFiber, lane), entangleTransitions(element, rootFiber, lane));
      }
      function markRetryLaneImpl(fiber, retryLane) {
        fiber = fiber.memoizedState;
        if (null !== fiber && null !== fiber.dehydrated) {
          var a = fiber.retryLane;
          fiber.retryLane = 0 !== a && a < retryLane ? a : retryLane;
        }
      }
      function markRetryLaneIfNotHydrated(fiber, retryLane) {
        markRetryLaneImpl(fiber, retryLane);
        (fiber = fiber.alternate) && markRetryLaneImpl(fiber, retryLane);
      }
      function attemptContinuousHydration(fiber) {
        if (13 === fiber.tag) {
          var root2 = enqueueConcurrentRenderForLane(fiber, 67108864);
          null !== root2 && scheduleUpdateOnFiber(root2, fiber, 67108864);
          markRetryLaneIfNotHydrated(fiber, 67108864);
        }
      }
      var _enabled = true;
      function dispatchDiscreteEvent(domEventName, eventSystemFlags, container, nativeEvent) {
        var prevTransition = ReactSharedInternals.T;
        ReactSharedInternals.T = null;
        var previousPriority = ReactDOMSharedInternals.p;
        try {
          ReactDOMSharedInternals.p = 2, dispatchEvent(domEventName, eventSystemFlags, container, nativeEvent);
        } finally {
          ReactDOMSharedInternals.p = previousPriority, ReactSharedInternals.T = prevTransition;
        }
      }
      function dispatchContinuousEvent(domEventName, eventSystemFlags, container, nativeEvent) {
        var prevTransition = ReactSharedInternals.T;
        ReactSharedInternals.T = null;
        var previousPriority = ReactDOMSharedInternals.p;
        try {
          ReactDOMSharedInternals.p = 8, dispatchEvent(domEventName, eventSystemFlags, container, nativeEvent);
        } finally {
          ReactDOMSharedInternals.p = previousPriority, ReactSharedInternals.T = prevTransition;
        }
      }
      function dispatchEvent(domEventName, eventSystemFlags, targetContainer, nativeEvent) {
        if (_enabled) {
          var blockedOn = findInstanceBlockingEvent(nativeEvent);
          if (null === blockedOn)
            dispatchEventForPluginEventSystem(
              domEventName,
              eventSystemFlags,
              nativeEvent,
              return_targetInst,
              targetContainer
            ), clearIfContinuousEvent(domEventName, nativeEvent);
          else if (queueIfContinuousEvent(
            blockedOn,
            domEventName,
            eventSystemFlags,
            targetContainer,
            nativeEvent
          ))
            nativeEvent.stopPropagation();
          else if (clearIfContinuousEvent(domEventName, nativeEvent), eventSystemFlags & 4 && -1 < discreteReplayableEvents.indexOf(domEventName)) {
            for (; null !== blockedOn; ) {
              var fiber = getInstanceFromNode(blockedOn);
              if (null !== fiber)
                switch (fiber.tag) {
                  case 3:
                    fiber = fiber.stateNode;
                    if (fiber.current.memoizedState.isDehydrated) {
                      var lanes = getHighestPriorityLanes(fiber.pendingLanes);
                      if (0 !== lanes) {
                        var root2 = fiber;
                        root2.pendingLanes |= 2;
                        for (root2.entangledLanes |= 2; lanes; ) {
                          var lane = 1 << 31 - clz32(lanes);
                          root2.entanglements[1] |= lane;
                          lanes &= ~lane;
                        }
                        ensureRootIsScheduled(fiber);
                        0 === (executionContext & 6) && (workInProgressRootRenderTargetTime = now() + 500, flushSyncWorkAcrossRoots_impl(0, false));
                      }
                    }
                    break;
                  case 13:
                    root2 = enqueueConcurrentRenderForLane(fiber, 2), null !== root2 && scheduleUpdateOnFiber(root2, fiber, 2), flushSyncWork$1(), markRetryLaneIfNotHydrated(fiber, 2);
                }
              fiber = findInstanceBlockingEvent(nativeEvent);
              null === fiber && dispatchEventForPluginEventSystem(
                domEventName,
                eventSystemFlags,
                nativeEvent,
                return_targetInst,
                targetContainer
              );
              if (fiber === blockedOn) break;
              blockedOn = fiber;
            }
            null !== blockedOn && nativeEvent.stopPropagation();
          } else
            dispatchEventForPluginEventSystem(
              domEventName,
              eventSystemFlags,
              nativeEvent,
              null,
              targetContainer
            );
        }
      }
      function findInstanceBlockingEvent(nativeEvent) {
        nativeEvent = getEventTarget(nativeEvent);
        return findInstanceBlockingTarget(nativeEvent);
      }
      var return_targetInst = null;
      function findInstanceBlockingTarget(targetNode) {
        return_targetInst = null;
        targetNode = getClosestInstanceFromNode(targetNode);
        if (null !== targetNode) {
          var nearestMounted = getNearestMountedFiber(targetNode);
          if (null === nearestMounted) targetNode = null;
          else {
            var tag = nearestMounted.tag;
            if (13 === tag) {
              targetNode = getSuspenseInstanceFromFiber(nearestMounted);
              if (null !== targetNode) return targetNode;
              targetNode = null;
            } else if (3 === tag) {
              if (nearestMounted.stateNode.current.memoizedState.isDehydrated)
                return 3 === nearestMounted.tag ? nearestMounted.stateNode.containerInfo : null;
              targetNode = null;
            } else nearestMounted !== targetNode && (targetNode = null);
          }
        }
        return_targetInst = targetNode;
        return null;
      }
      function getEventPriority(domEventName) {
        switch (domEventName) {
          case "beforetoggle":
          case "cancel":
          case "click":
          case "close":
          case "contextmenu":
          case "copy":
          case "cut":
          case "auxclick":
          case "dblclick":
          case "dragend":
          case "dragstart":
          case "drop":
          case "focusin":
          case "focusout":
          case "input":
          case "invalid":
          case "keydown":
          case "keypress":
          case "keyup":
          case "mousedown":
          case "mouseup":
          case "paste":
          case "pause":
          case "play":
          case "pointercancel":
          case "pointerdown":
          case "pointerup":
          case "ratechange":
          case "reset":
          case "resize":
          case "seeked":
          case "submit":
          case "toggle":
          case "touchcancel":
          case "touchend":
          case "touchstart":
          case "volumechange":
          case "change":
          case "selectionchange":
          case "textInput":
          case "compositionstart":
          case "compositionend":
          case "compositionupdate":
          case "beforeblur":
          case "afterblur":
          case "beforeinput":
          case "blur":
          case "fullscreenchange":
          case "focus":
          case "hashchange":
          case "popstate":
          case "select":
          case "selectstart":
            return 2;
          case "drag":
          case "dragenter":
          case "dragexit":
          case "dragleave":
          case "dragover":
          case "mousemove":
          case "mouseout":
          case "mouseover":
          case "pointermove":
          case "pointerout":
          case "pointerover":
          case "scroll":
          case "touchmove":
          case "wheel":
          case "mouseenter":
          case "mouseleave":
          case "pointerenter":
          case "pointerleave":
            return 8;
          case "message":
            switch (getCurrentPriorityLevel()) {
              case ImmediatePriority:
                return 2;
              case UserBlockingPriority:
                return 8;
              case NormalPriority$1:
              case LowPriority:
                return 32;
              case IdlePriority:
                return 268435456;
              default:
                return 32;
            }
          default:
            return 32;
        }
      }
      var hasScheduledReplayAttempt = false;
      var queuedFocus = null;
      var queuedDrag = null;
      var queuedMouse = null;
      var queuedPointers = /* @__PURE__ */ new Map();
      var queuedPointerCaptures = /* @__PURE__ */ new Map();
      var queuedExplicitHydrationTargets = [];
      var discreteReplayableEvents = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset".split(
        " "
      );
      function clearIfContinuousEvent(domEventName, nativeEvent) {
        switch (domEventName) {
          case "focusin":
          case "focusout":
            queuedFocus = null;
            break;
          case "dragenter":
          case "dragleave":
            queuedDrag = null;
            break;
          case "mouseover":
          case "mouseout":
            queuedMouse = null;
            break;
          case "pointerover":
          case "pointerout":
            queuedPointers.delete(nativeEvent.pointerId);
            break;
          case "gotpointercapture":
          case "lostpointercapture":
            queuedPointerCaptures.delete(nativeEvent.pointerId);
        }
      }
      function accumulateOrCreateContinuousQueuedReplayableEvent(existingQueuedEvent, blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent) {
        if (null === existingQueuedEvent || existingQueuedEvent.nativeEvent !== nativeEvent)
          return existingQueuedEvent = {
            blockedOn,
            domEventName,
            eventSystemFlags,
            nativeEvent,
            targetContainers: [targetContainer]
          }, null !== blockedOn && (blockedOn = getInstanceFromNode(blockedOn), null !== blockedOn && attemptContinuousHydration(blockedOn)), existingQueuedEvent;
        existingQueuedEvent.eventSystemFlags |= eventSystemFlags;
        blockedOn = existingQueuedEvent.targetContainers;
        null !== targetContainer && -1 === blockedOn.indexOf(targetContainer) && blockedOn.push(targetContainer);
        return existingQueuedEvent;
      }
      function queueIfContinuousEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent) {
        switch (domEventName) {
          case "focusin":
            return queuedFocus = accumulateOrCreateContinuousQueuedReplayableEvent(
              queuedFocus,
              blockedOn,
              domEventName,
              eventSystemFlags,
              targetContainer,
              nativeEvent
            ), true;
          case "dragenter":
            return queuedDrag = accumulateOrCreateContinuousQueuedReplayableEvent(
              queuedDrag,
              blockedOn,
              domEventName,
              eventSystemFlags,
              targetContainer,
              nativeEvent
            ), true;
          case "mouseover":
            return queuedMouse = accumulateOrCreateContinuousQueuedReplayableEvent(
              queuedMouse,
              blockedOn,
              domEventName,
              eventSystemFlags,
              targetContainer,
              nativeEvent
            ), true;
          case "pointerover":
            var pointerId = nativeEvent.pointerId;
            queuedPointers.set(
              pointerId,
              accumulateOrCreateContinuousQueuedReplayableEvent(
                queuedPointers.get(pointerId) || null,
                blockedOn,
                domEventName,
                eventSystemFlags,
                targetContainer,
                nativeEvent
              )
            );
            return true;
          case "gotpointercapture":
            return pointerId = nativeEvent.pointerId, queuedPointerCaptures.set(
              pointerId,
              accumulateOrCreateContinuousQueuedReplayableEvent(
                queuedPointerCaptures.get(pointerId) || null,
                blockedOn,
                domEventName,
                eventSystemFlags,
                targetContainer,
                nativeEvent
              )
            ), true;
        }
        return false;
      }
      function attemptExplicitHydrationTarget(queuedTarget) {
        var targetInst = getClosestInstanceFromNode(queuedTarget.target);
        if (null !== targetInst) {
          var nearestMounted = getNearestMountedFiber(targetInst);
          if (null !== nearestMounted) {
            if (targetInst = nearestMounted.tag, 13 === targetInst) {
              if (targetInst = getSuspenseInstanceFromFiber(nearestMounted), null !== targetInst) {
                queuedTarget.blockedOn = targetInst;
                runWithPriority(queuedTarget.priority, function() {
                  if (13 === nearestMounted.tag) {
                    var lane = requestUpdateLane();
                    lane = getBumpedLaneForHydrationByLane(lane);
                    var root2 = enqueueConcurrentRenderForLane(nearestMounted, lane);
                    null !== root2 && scheduleUpdateOnFiber(root2, nearestMounted, lane);
                    markRetryLaneIfNotHydrated(nearestMounted, lane);
                  }
                });
                return;
              }
            } else if (3 === targetInst && nearestMounted.stateNode.current.memoizedState.isDehydrated) {
              queuedTarget.blockedOn = 3 === nearestMounted.tag ? nearestMounted.stateNode.containerInfo : null;
              return;
            }
          }
        }
        queuedTarget.blockedOn = null;
      }
      function attemptReplayContinuousQueuedEvent(queuedEvent) {
        if (null !== queuedEvent.blockedOn) return false;
        for (var targetContainers = queuedEvent.targetContainers; 0 < targetContainers.length; ) {
          var nextBlockedOn = findInstanceBlockingEvent(queuedEvent.nativeEvent);
          if (null === nextBlockedOn) {
            nextBlockedOn = queuedEvent.nativeEvent;
            var nativeEventClone = new nextBlockedOn.constructor(
              nextBlockedOn.type,
              nextBlockedOn
            );
            currentReplayingEvent = nativeEventClone;
            nextBlockedOn.target.dispatchEvent(nativeEventClone);
            currentReplayingEvent = null;
          } else
            return targetContainers = getInstanceFromNode(nextBlockedOn), null !== targetContainers && attemptContinuousHydration(targetContainers), queuedEvent.blockedOn = nextBlockedOn, false;
          targetContainers.shift();
        }
        return true;
      }
      function attemptReplayContinuousQueuedEventInMap(queuedEvent, key, map) {
        attemptReplayContinuousQueuedEvent(queuedEvent) && map.delete(key);
      }
      function replayUnblockedEvents() {
        hasScheduledReplayAttempt = false;
        null !== queuedFocus && attemptReplayContinuousQueuedEvent(queuedFocus) && (queuedFocus = null);
        null !== queuedDrag && attemptReplayContinuousQueuedEvent(queuedDrag) && (queuedDrag = null);
        null !== queuedMouse && attemptReplayContinuousQueuedEvent(queuedMouse) && (queuedMouse = null);
        queuedPointers.forEach(attemptReplayContinuousQueuedEventInMap);
        queuedPointerCaptures.forEach(attemptReplayContinuousQueuedEventInMap);
      }
      function scheduleCallbackIfUnblocked(queuedEvent, unblocked) {
        queuedEvent.blockedOn === unblocked && (queuedEvent.blockedOn = null, hasScheduledReplayAttempt || (hasScheduledReplayAttempt = true, Scheduler.unstable_scheduleCallback(
          Scheduler.unstable_NormalPriority,
          replayUnblockedEvents
        )));
      }
      var lastScheduledReplayQueue = null;
      function scheduleReplayQueueIfNeeded(formReplayingQueue) {
        lastScheduledReplayQueue !== formReplayingQueue && (lastScheduledReplayQueue = formReplayingQueue, Scheduler.unstable_scheduleCallback(
          Scheduler.unstable_NormalPriority,
          function() {
            lastScheduledReplayQueue === formReplayingQueue && (lastScheduledReplayQueue = null);
            for (var i = 0; i < formReplayingQueue.length; i += 3) {
              var form = formReplayingQueue[i], submitterOrAction = formReplayingQueue[i + 1], formData = formReplayingQueue[i + 2];
              if ("function" !== typeof submitterOrAction)
                if (null === findInstanceBlockingTarget(submitterOrAction || form))
                  continue;
                else break;
              var formInst = getInstanceFromNode(form);
              null !== formInst && (formReplayingQueue.splice(i, 3), i -= 3, startHostTransition(
                formInst,
                {
                  pending: true,
                  data: formData,
                  method: form.method,
                  action: submitterOrAction
                },
                submitterOrAction,
                formData
              ));
            }
          }
        ));
      }
      function retryIfBlockedOn(unblocked) {
        function unblock(queuedEvent) {
          return scheduleCallbackIfUnblocked(queuedEvent, unblocked);
        }
        null !== queuedFocus && scheduleCallbackIfUnblocked(queuedFocus, unblocked);
        null !== queuedDrag && scheduleCallbackIfUnblocked(queuedDrag, unblocked);
        null !== queuedMouse && scheduleCallbackIfUnblocked(queuedMouse, unblocked);
        queuedPointers.forEach(unblock);
        queuedPointerCaptures.forEach(unblock);
        for (var i = 0; i < queuedExplicitHydrationTargets.length; i++) {
          var queuedTarget = queuedExplicitHydrationTargets[i];
          queuedTarget.blockedOn === unblocked && (queuedTarget.blockedOn = null);
        }
        for (; 0 < queuedExplicitHydrationTargets.length && (i = queuedExplicitHydrationTargets[0], null === i.blockedOn); )
          attemptExplicitHydrationTarget(i), null === i.blockedOn && queuedExplicitHydrationTargets.shift();
        i = (unblocked.ownerDocument || unblocked).$$reactFormReplay;
        if (null != i)
          for (queuedTarget = 0; queuedTarget < i.length; queuedTarget += 3) {
            var form = i[queuedTarget], submitterOrAction = i[queuedTarget + 1], formProps = form[internalPropsKey] || null;
            if ("function" === typeof submitterOrAction)
              formProps || scheduleReplayQueueIfNeeded(i);
            else if (formProps) {
              var action = null;
              if (submitterOrAction && submitterOrAction.hasAttribute("formAction"))
                if (form = submitterOrAction, formProps = submitterOrAction[internalPropsKey] || null)
                  action = formProps.formAction;
                else {
                  if (null !== findInstanceBlockingTarget(form)) continue;
                }
              else action = formProps.action;
              "function" === typeof action ? i[queuedTarget + 1] = action : (i.splice(queuedTarget, 3), queuedTarget -= 3);
              scheduleReplayQueueIfNeeded(i);
            }
          }
      }
      function ReactDOMRoot(internalRoot) {
        this._internalRoot = internalRoot;
      }
      ReactDOMHydrationRoot.prototype.render = ReactDOMRoot.prototype.render = function(children) {
        var root2 = this._internalRoot;
        if (null === root2) throw Error(formatProdErrorMessage(409));
        var current = root2.current, lane = requestUpdateLane();
        updateContainerImpl(current, lane, children, root2, null, null);
      };
      ReactDOMHydrationRoot.prototype.unmount = ReactDOMRoot.prototype.unmount = function() {
        var root2 = this._internalRoot;
        if (null !== root2) {
          this._internalRoot = null;
          var container = root2.containerInfo;
          updateContainerImpl(root2.current, 2, null, root2, null, null);
          flushSyncWork$1();
          container[internalContainerInstanceKey] = null;
        }
      };
      function ReactDOMHydrationRoot(internalRoot) {
        this._internalRoot = internalRoot;
      }
      ReactDOMHydrationRoot.prototype.unstable_scheduleHydration = function(target) {
        if (target) {
          var updatePriority = resolveUpdatePriority();
          target = { blockedOn: null, target, priority: updatePriority };
          for (var i = 0; i < queuedExplicitHydrationTargets.length && 0 !== updatePriority && updatePriority < queuedExplicitHydrationTargets[i].priority; i++) ;
          queuedExplicitHydrationTargets.splice(i, 0, target);
          0 === i && attemptExplicitHydrationTarget(target);
        }
      };
      var isomorphicReactPackageVersion$jscomp$inline_1785 = React.version;
      if ("19.1.0" !== isomorphicReactPackageVersion$jscomp$inline_1785)
        throw Error(
          formatProdErrorMessage(
            527,
            isomorphicReactPackageVersion$jscomp$inline_1785,
            "19.1.0"
          )
        );
      ReactDOMSharedInternals.findDOMNode = function(componentOrElement) {
        var fiber = componentOrElement._reactInternals;
        if (void 0 === fiber) {
          if ("function" === typeof componentOrElement.render)
            throw Error(formatProdErrorMessage(188));
          componentOrElement = Object.keys(componentOrElement).join(",");
          throw Error(formatProdErrorMessage(268, componentOrElement));
        }
        componentOrElement = findCurrentFiberUsingSlowPath(fiber);
        componentOrElement = null !== componentOrElement ? findCurrentHostFiberImpl(componentOrElement) : null;
        componentOrElement = null === componentOrElement ? null : componentOrElement.stateNode;
        return componentOrElement;
      };
      var internals$jscomp$inline_2256 = {
        bundleType: 0,
        version: "19.1.0",
        rendererPackageName: "react-dom",
        currentDispatcherRef: ReactSharedInternals,
        reconcilerVersion: "19.1.0"
      };
      if ("undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) {
        hook$jscomp$inline_2257 = __REACT_DEVTOOLS_GLOBAL_HOOK__;
        if (!hook$jscomp$inline_2257.isDisabled && hook$jscomp$inline_2257.supportsFiber)
          try {
            rendererID = hook$jscomp$inline_2257.inject(
              internals$jscomp$inline_2256
            ), injectedHook = hook$jscomp$inline_2257;
          } catch (err) {
          }
      }
      var hook$jscomp$inline_2257;
      exports.createRoot = function(container, options2) {
        if (!isValidContainer(container)) throw Error(formatProdErrorMessage(299));
        var isStrictMode = false, identifierPrefix = "", onUncaughtError = defaultOnUncaughtError, onCaughtError = defaultOnCaughtError, onRecoverableError = defaultOnRecoverableError, transitionCallbacks = null;
        null !== options2 && void 0 !== options2 && (true === options2.unstable_strictMode && (isStrictMode = true), void 0 !== options2.identifierPrefix && (identifierPrefix = options2.identifierPrefix), void 0 !== options2.onUncaughtError && (onUncaughtError = options2.onUncaughtError), void 0 !== options2.onCaughtError && (onCaughtError = options2.onCaughtError), void 0 !== options2.onRecoverableError && (onRecoverableError = options2.onRecoverableError), void 0 !== options2.unstable_transitionCallbacks && (transitionCallbacks = options2.unstable_transitionCallbacks));
        options2 = createFiberRoot(
          container,
          1,
          false,
          null,
          null,
          isStrictMode,
          identifierPrefix,
          onUncaughtError,
          onCaughtError,
          onRecoverableError,
          transitionCallbacks,
          null
        );
        container[internalContainerInstanceKey] = options2.current;
        listenToAllSupportedEvents(container);
        return new ReactDOMRoot(options2);
      };
      exports.hydrateRoot = function(container, initialChildren, options2) {
        if (!isValidContainer(container)) throw Error(formatProdErrorMessage(299));
        var isStrictMode = false, identifierPrefix = "", onUncaughtError = defaultOnUncaughtError, onCaughtError = defaultOnCaughtError, onRecoverableError = defaultOnRecoverableError, transitionCallbacks = null, formState = null;
        null !== options2 && void 0 !== options2 && (true === options2.unstable_strictMode && (isStrictMode = true), void 0 !== options2.identifierPrefix && (identifierPrefix = options2.identifierPrefix), void 0 !== options2.onUncaughtError && (onUncaughtError = options2.onUncaughtError), void 0 !== options2.onCaughtError && (onCaughtError = options2.onCaughtError), void 0 !== options2.onRecoverableError && (onRecoverableError = options2.onRecoverableError), void 0 !== options2.unstable_transitionCallbacks && (transitionCallbacks = options2.unstable_transitionCallbacks), void 0 !== options2.formState && (formState = options2.formState));
        initialChildren = createFiberRoot(
          container,
          1,
          true,
          initialChildren,
          null != options2 ? options2 : null,
          isStrictMode,
          identifierPrefix,
          onUncaughtError,
          onCaughtError,
          onRecoverableError,
          transitionCallbacks,
          formState
        );
        initialChildren.context = getContextForSubtree(null);
        options2 = initialChildren.current;
        isStrictMode = requestUpdateLane();
        isStrictMode = getBumpedLaneForHydrationByLane(isStrictMode);
        identifierPrefix = createUpdate(isStrictMode);
        identifierPrefix.callback = null;
        enqueueUpdate(options2, identifierPrefix, isStrictMode);
        options2 = isStrictMode;
        initialChildren.current.lanes = options2;
        markRootUpdated$1(initialChildren, options2);
        ensureRootIsScheduled(initialChildren);
        container[internalContainerInstanceKey] = initialChildren.current;
        listenToAllSupportedEvents(container);
        return new ReactDOMHydrationRoot(initialChildren);
      };
      exports.version = "19.1.0";
    }
  });

  // node_modules/react-dom/client.js
  var require_client = __commonJS({
    "node_modules/react-dom/client.js"(exports, module) {
      "use strict";
      function checkDCE() {
        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === "undefined" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== "function") {
          return;
        }
        if (false) {
          throw new Error("^_^");
        }
        try {
          __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
        } catch (err) {
          console.error(err);
        }
      }
      if (true) {
        checkDCE();
        module.exports = require_react_dom_client_production();
      } else {
        module.exports = null;
      }
    }
  });

  // node_modules/ethers/lib.esm/_version.js
  var version;
  var init_version = __esm({
    "node_modules/ethers/lib.esm/_version.js"() {
      version = "6.15.0";
    }
  });

  // node_modules/ethers/lib.esm/utils/properties.js
  function checkType(value, type, name) {
    const types = type.split("|").map((t) => t.trim());
    for (let i = 0; i < types.length; i++) {
      switch (type) {
        case "any":
          return;
        case "bigint":
        case "boolean":
        case "number":
        case "string":
          if (typeof value === type) {
            return;
          }
      }
    }
    const error = new Error(`invalid value for type ${type}`);
    error.code = "INVALID_ARGUMENT";
    error.argument = `value.${name}`;
    error.value = value;
    throw error;
  }
  async function resolveProperties(value) {
    const keys = Object.keys(value);
    const results = await Promise.all(keys.map((k) => Promise.resolve(value[k])));
    return results.reduce((accum, v, index2) => {
      accum[keys[index2]] = v;
      return accum;
    }, {});
  }
  function defineProperties(target, values, types) {
    for (let key in values) {
      let value = values[key];
      const type = types ? types[key] : null;
      if (type) {
        checkType(value, type, key);
      }
      Object.defineProperty(target, key, { enumerable: true, value, writable: false });
    }
  }
  var init_properties = __esm({
    "node_modules/ethers/lib.esm/utils/properties.js"() {
    }
  });

  // node_modules/ethers/lib.esm/utils/errors.js
  function stringify(value, seen) {
    if (value == null) {
      return "null";
    }
    if (seen == null) {
      seen = /* @__PURE__ */ new Set();
    }
    if (typeof value === "object") {
      if (seen.has(value)) {
        return "[Circular]";
      }
      seen.add(value);
    }
    if (Array.isArray(value)) {
      return "[ " + value.map((v) => stringify(v, seen)).join(", ") + " ]";
    }
    if (value instanceof Uint8Array) {
      const HEX = "0123456789abcdef";
      let result = "0x";
      for (let i = 0; i < value.length; i++) {
        result += HEX[value[i] >> 4];
        result += HEX[value[i] & 15];
      }
      return result;
    }
    if (typeof value === "object" && typeof value.toJSON === "function") {
      return stringify(value.toJSON(), seen);
    }
    switch (typeof value) {
      case "boolean":
      case "number":
      case "symbol":
        return value.toString();
      case "bigint":
        return BigInt(value).toString();
      case "string":
        return JSON.stringify(value);
      case "object": {
        const keys = Object.keys(value);
        keys.sort();
        return "{ " + keys.map((k) => `${stringify(k, seen)}: ${stringify(value[k], seen)}`).join(", ") + " }";
      }
    }
    return `[ COULD NOT SERIALIZE ]`;
  }
  function isError(error, code) {
    return error && error.code === code;
  }
  function isCallException(error) {
    return isError(error, "CALL_EXCEPTION");
  }
  function makeError(message, code, info) {
    let shortMessage = message;
    {
      const details = [];
      if (info) {
        if ("message" in info || "code" in info || "name" in info) {
          throw new Error(`value will overwrite populated values: ${stringify(info)}`);
        }
        for (const key in info) {
          if (key === "shortMessage") {
            continue;
          }
          const value = info[key];
          details.push(key + "=" + stringify(value));
        }
      }
      details.push(`code=${code}`);
      details.push(`version=${version}`);
      if (details.length) {
        message += " (" + details.join(", ") + ")";
      }
    }
    let error;
    switch (code) {
      case "INVALID_ARGUMENT":
        error = new TypeError(message);
        break;
      case "NUMERIC_FAULT":
      case "BUFFER_OVERRUN":
        error = new RangeError(message);
        break;
      default:
        error = new Error(message);
    }
    defineProperties(error, { code });
    if (info) {
      Object.assign(error, info);
    }
    if (error.shortMessage == null) {
      defineProperties(error, { shortMessage });
    }
    return error;
  }
  function assert(check, message, code, info) {
    if (!check) {
      throw makeError(message, code, info);
    }
  }
  function assertArgument(check, message, name, value) {
    assert(check, message, "INVALID_ARGUMENT", { argument: name, value });
  }
  function assertArgumentCount(count, expectedCount, message) {
    if (message == null) {
      message = "";
    }
    if (message) {
      message = ": " + message;
    }
    assert(count >= expectedCount, "missing argument" + message, "MISSING_ARGUMENT", {
      count,
      expectedCount
    });
    assert(count <= expectedCount, "too many arguments" + message, "UNEXPECTED_ARGUMENT", {
      count,
      expectedCount
    });
  }
  function assertNormalize(form) {
    assert(_normalizeForms.indexOf(form) >= 0, "platform missing String.prototype.normalize", "UNSUPPORTED_OPERATION", {
      operation: "String.prototype.normalize",
      info: { form }
    });
  }
  function assertPrivate(givenGuard, guard, className) {
    if (className == null) {
      className = "";
    }
    if (givenGuard !== guard) {
      let method = className, operation = "new";
      if (className) {
        method += ".";
        operation += " " + className;
      }
      assert(false, `private constructor; use ${method}from* methods`, "UNSUPPORTED_OPERATION", {
        operation
      });
    }
  }
  var _normalizeForms;
  var init_errors = __esm({
    "node_modules/ethers/lib.esm/utils/errors.js"() {
      init_version();
      init_properties();
      _normalizeForms = ["NFD", "NFC", "NFKD", "NFKC"].reduce((accum, form) => {
        try {
          if ("test".normalize(form) !== "test") {
            throw new Error("bad");
          }
          ;
          if (form === "NFD") {
            const check = String.fromCharCode(233).normalize("NFD");
            const expected = String.fromCharCode(101, 769);
            if (check !== expected) {
              throw new Error("broken");
            }
          }
          accum.push(form);
        } catch (error) {
        }
        return accum;
      }, []);
    }
  });

  // node_modules/ethers/lib.esm/utils/data.js
  function _getBytes(value, name, copy4) {
    if (value instanceof Uint8Array) {
      if (copy4) {
        return new Uint8Array(value);
      }
      return value;
    }
    if (typeof value === "string" && value.match(/^0x(?:[0-9a-f][0-9a-f])*$/i)) {
      const result = new Uint8Array((value.length - 2) / 2);
      let offset = 2;
      for (let i = 0; i < result.length; i++) {
        result[i] = parseInt(value.substring(offset, offset + 2), 16);
        offset += 2;
      }
      return result;
    }
    assertArgument(false, "invalid BytesLike value", name || "value", value);
  }
  function getBytes(value, name) {
    return _getBytes(value, name, false);
  }
  function getBytesCopy(value, name) {
    return _getBytes(value, name, true);
  }
  function isHexString(value, length) {
    if (typeof value !== "string" || !value.match(/^0x[0-9A-Fa-f]*$/)) {
      return false;
    }
    if (typeof length === "number" && value.length !== 2 + 2 * length) {
      return false;
    }
    if (length === true && value.length % 2 !== 0) {
      return false;
    }
    return true;
  }
  function isBytesLike(value) {
    return isHexString(value, true) || value instanceof Uint8Array;
  }
  function hexlify(data) {
    const bytes2 = getBytes(data);
    let result = "0x";
    for (let i = 0; i < bytes2.length; i++) {
      const v = bytes2[i];
      result += HexCharacters[(v & 240) >> 4] + HexCharacters[v & 15];
    }
    return result;
  }
  function concat(datas) {
    return "0x" + datas.map((d) => hexlify(d).substring(2)).join("");
  }
  function dataLength(data) {
    if (isHexString(data, true)) {
      return (data.length - 2) / 2;
    }
    return getBytes(data).length;
  }
  function dataSlice(data, start, end) {
    const bytes2 = getBytes(data);
    if (end != null && end > bytes2.length) {
      assert(false, "cannot slice beyond data bounds", "BUFFER_OVERRUN", {
        buffer: bytes2,
        length: bytes2.length,
        offset: end
      });
    }
    return hexlify(bytes2.slice(start == null ? 0 : start, end == null ? bytes2.length : end));
  }
  function stripZerosLeft(data) {
    let bytes2 = hexlify(data).substring(2);
    while (bytes2.startsWith("00")) {
      bytes2 = bytes2.substring(2);
    }
    return "0x" + bytes2;
  }
  function zeroPad(data, length, left) {
    const bytes2 = getBytes(data);
    assert(length >= bytes2.length, "padding exceeds data length", "BUFFER_OVERRUN", {
      buffer: new Uint8Array(bytes2),
      length,
      offset: length + 1
    });
    const result = new Uint8Array(length);
    result.fill(0);
    if (left) {
      result.set(bytes2, length - bytes2.length);
    } else {
      result.set(bytes2, 0);
    }
    return hexlify(result);
  }
  function zeroPadValue(data, length) {
    return zeroPad(data, length, true);
  }
  function zeroPadBytes(data, length) {
    return zeroPad(data, length, false);
  }
  var HexCharacters;
  var init_data = __esm({
    "node_modules/ethers/lib.esm/utils/data.js"() {
      init_errors();
      HexCharacters = "0123456789abcdef";
    }
  });

  // node_modules/ethers/lib.esm/utils/maths.js
  function fromTwos(_value2, _width) {
    const value = getUint(_value2, "value");
    const width = BigInt(getNumber(_width, "width"));
    assert(value >> width === BN_0, "overflow", "NUMERIC_FAULT", {
      operation: "fromTwos",
      fault: "overflow",
      value: _value2
    });
    if (value >> width - BN_1) {
      const mask2 = (BN_1 << width) - BN_1;
      return -((~value & mask2) + BN_1);
    }
    return value;
  }
  function toTwos(_value2, _width) {
    let value = getBigInt(_value2, "value");
    const width = BigInt(getNumber(_width, "width"));
    const limit = BN_1 << width - BN_1;
    if (value < BN_0) {
      value = -value;
      assert(value <= limit, "too low", "NUMERIC_FAULT", {
        operation: "toTwos",
        fault: "overflow",
        value: _value2
      });
      const mask2 = (BN_1 << width) - BN_1;
      return (~value & mask2) + BN_1;
    } else {
      assert(value < limit, "too high", "NUMERIC_FAULT", {
        operation: "toTwos",
        fault: "overflow",
        value: _value2
      });
    }
    return value;
  }
  function mask(_value2, _bits) {
    const value = getUint(_value2, "value");
    const bits = BigInt(getNumber(_bits, "bits"));
    return value & (BN_1 << bits) - BN_1;
  }
  function getBigInt(value, name) {
    switch (typeof value) {
      case "bigint":
        return value;
      case "number":
        assertArgument(Number.isInteger(value), "underflow", name || "value", value);
        assertArgument(value >= -maxValue && value <= maxValue, "overflow", name || "value", value);
        return BigInt(value);
      case "string":
        try {
          if (value === "") {
            throw new Error("empty string");
          }
          if (value[0] === "-" && value[1] !== "-") {
            return -BigInt(value.substring(1));
          }
          return BigInt(value);
        } catch (e) {
          assertArgument(false, `invalid BigNumberish string: ${e.message}`, name || "value", value);
        }
    }
    assertArgument(false, "invalid BigNumberish value", name || "value", value);
  }
  function getUint(value, name) {
    const result = getBigInt(value, name);
    assert(result >= BN_0, "unsigned value cannot be negative", "NUMERIC_FAULT", {
      fault: "overflow",
      operation: "getUint",
      value
    });
    return result;
  }
  function toBigInt(value) {
    if (value instanceof Uint8Array) {
      let result = "0x0";
      for (const v of value) {
        result += Nibbles[v >> 4];
        result += Nibbles[v & 15];
      }
      return BigInt(result);
    }
    return getBigInt(value);
  }
  function getNumber(value, name) {
    switch (typeof value) {
      case "bigint":
        assertArgument(value >= -maxValue && value <= maxValue, "overflow", name || "value", value);
        return Number(value);
      case "number":
        assertArgument(Number.isInteger(value), "underflow", name || "value", value);
        assertArgument(value >= -maxValue && value <= maxValue, "overflow", name || "value", value);
        return value;
      case "string":
        try {
          if (value === "") {
            throw new Error("empty string");
          }
          return getNumber(BigInt(value), name);
        } catch (e) {
          assertArgument(false, `invalid numeric string: ${e.message}`, name || "value", value);
        }
    }
    assertArgument(false, "invalid numeric value", name || "value", value);
  }
  function toNumber(value) {
    return getNumber(toBigInt(value));
  }
  function toBeHex(_value2, _width) {
    const value = getUint(_value2, "value");
    let result = value.toString(16);
    if (_width == null) {
      if (result.length % 2) {
        result = "0" + result;
      }
    } else {
      const width = getNumber(_width, "width");
      assert(width * 2 >= result.length, `value exceeds width (${width} bytes)`, "NUMERIC_FAULT", {
        operation: "toBeHex",
        fault: "overflow",
        value: _value2
      });
      while (result.length < width * 2) {
        result = "0" + result;
      }
    }
    return "0x" + result;
  }
  function toBeArray(_value2) {
    const value = getUint(_value2, "value");
    if (value === BN_0) {
      return new Uint8Array([]);
    }
    let hex = value.toString(16);
    if (hex.length % 2) {
      hex = "0" + hex;
    }
    const result = new Uint8Array(hex.length / 2);
    for (let i = 0; i < result.length; i++) {
      const offset = i * 2;
      result[i] = parseInt(hex.substring(offset, offset + 2), 16);
    }
    return result;
  }
  function toQuantity(value) {
    let result = hexlify(isBytesLike(value) ? value : toBeArray(value)).substring(2);
    while (result.startsWith("0")) {
      result = result.substring(1);
    }
    if (result === "") {
      result = "0";
    }
    return "0x" + result;
  }
  var BN_0, BN_1, maxValue, Nibbles;
  var init_maths = __esm({
    "node_modules/ethers/lib.esm/utils/maths.js"() {
      init_data();
      init_errors();
      BN_0 = BigInt(0);
      BN_1 = BigInt(1);
      maxValue = 9007199254740991;
      Nibbles = "0123456789abcdef";
    }
  });

  // node_modules/ethers/lib.esm/utils/base58.js
  function getAlpha(letter) {
    if (Lookup == null) {
      Lookup = {};
      for (let i = 0; i < Alphabet.length; i++) {
        Lookup[Alphabet[i]] = BigInt(i);
      }
    }
    const result = Lookup[letter];
    assertArgument(result != null, `invalid base58 value`, "letter", letter);
    return result;
  }
  function encodeBase58(_value2) {
    const bytes2 = getBytes(_value2);
    let value = toBigInt(bytes2);
    let result = "";
    while (value) {
      result = Alphabet[Number(value % BN_58)] + result;
      value /= BN_58;
    }
    for (let i = 0; i < bytes2.length; i++) {
      if (bytes2[i]) {
        break;
      }
      result = Alphabet[0] + result;
    }
    return result;
  }
  function decodeBase58(value) {
    let result = BN_02;
    for (let i = 0; i < value.length; i++) {
      result *= BN_58;
      result += getAlpha(value[i]);
    }
    return result;
  }
  var Alphabet, Lookup, BN_02, BN_58;
  var init_base58 = __esm({
    "node_modules/ethers/lib.esm/utils/base58.js"() {
      init_data();
      init_errors();
      init_maths();
      Alphabet = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
      Lookup = null;
      BN_02 = BigInt(0);
      BN_58 = BigInt(58);
    }
  });

  // node_modules/ethers/lib.esm/utils/base64-browser.js
  function decodeBase64(textData) {
    textData = atob(textData);
    const data = new Uint8Array(textData.length);
    for (let i = 0; i < textData.length; i++) {
      data[i] = textData.charCodeAt(i);
    }
    return getBytes(data);
  }
  function encodeBase64(_data5) {
    const data = getBytes(_data5);
    let textData = "";
    for (let i = 0; i < data.length; i++) {
      textData += String.fromCharCode(data[i]);
    }
    return btoa(textData);
  }
  var init_base64_browser = __esm({
    "node_modules/ethers/lib.esm/utils/base64-browser.js"() {
      init_data();
    }
  });

  // node_modules/ethers/lib.esm/utils/events.js
  var _listener, EventPayload;
  var init_events = __esm({
    "node_modules/ethers/lib.esm/utils/events.js"() {
      init_properties();
      EventPayload = class {
        /**
         *  Create a new **EventPayload** for %%emitter%% with
         *  the %%listener%% and for %%filter%%.
         */
        constructor(emitter, listener, filter) {
          /**
           *  The event filter.
           */
          __publicField(this, "filter");
          /**
           *  The **EventEmitterable**.
           */
          __publicField(this, "emitter");
          __privateAdd(this, _listener);
          __privateSet(this, _listener, listener);
          defineProperties(this, { emitter, filter });
        }
        /**
         *  Unregister the triggered listener for future events.
         */
        async removeListener() {
          if (__privateGet(this, _listener) == null) {
            return;
          }
          await this.emitter.off(this.filter, __privateGet(this, _listener));
        }
      };
      _listener = new WeakMap();
    }
  });

  // node_modules/ethers/lib.esm/utils/utf8.js
  function errorFunc(reason, offset, bytes2, output2, badCodepoint) {
    assertArgument(false, `invalid codepoint at offset ${offset}; ${reason}`, "bytes", bytes2);
  }
  function ignoreFunc(reason, offset, bytes2, output2, badCodepoint) {
    if (reason === "BAD_PREFIX" || reason === "UNEXPECTED_CONTINUE") {
      let i = 0;
      for (let o = offset + 1; o < bytes2.length; o++) {
        if (bytes2[o] >> 6 !== 2) {
          break;
        }
        i++;
      }
      return i;
    }
    if (reason === "OVERRUN") {
      return bytes2.length - offset - 1;
    }
    return 0;
  }
  function replaceFunc(reason, offset, bytes2, output2, badCodepoint) {
    if (reason === "OVERLONG") {
      assertArgument(typeof badCodepoint === "number", "invalid bad code point for replacement", "badCodepoint", badCodepoint);
      output2.push(badCodepoint);
      return 0;
    }
    output2.push(65533);
    return ignoreFunc(reason, offset, bytes2, output2, badCodepoint);
  }
  function getUtf8CodePoints(_bytes, onError) {
    if (onError == null) {
      onError = Utf8ErrorFuncs.error;
    }
    const bytes2 = getBytes(_bytes, "bytes");
    const result = [];
    let i = 0;
    while (i < bytes2.length) {
      const c = bytes2[i++];
      if (c >> 7 === 0) {
        result.push(c);
        continue;
      }
      let extraLength = null;
      let overlongMask = null;
      if ((c & 224) === 192) {
        extraLength = 1;
        overlongMask = 127;
      } else if ((c & 240) === 224) {
        extraLength = 2;
        overlongMask = 2047;
      } else if ((c & 248) === 240) {
        extraLength = 3;
        overlongMask = 65535;
      } else {
        if ((c & 192) === 128) {
          i += onError("UNEXPECTED_CONTINUE", i - 1, bytes2, result);
        } else {
          i += onError("BAD_PREFIX", i - 1, bytes2, result);
        }
        continue;
      }
      if (i - 1 + extraLength >= bytes2.length) {
        i += onError("OVERRUN", i - 1, bytes2, result);
        continue;
      }
      let res = c & (1 << 8 - extraLength - 1) - 1;
      for (let j = 0; j < extraLength; j++) {
        let nextChar = bytes2[i];
        if ((nextChar & 192) != 128) {
          i += onError("MISSING_CONTINUE", i, bytes2, result);
          res = null;
          break;
        }
        ;
        res = res << 6 | nextChar & 63;
        i++;
      }
      if (res === null) {
        continue;
      }
      if (res > 1114111) {
        i += onError("OUT_OF_RANGE", i - 1 - extraLength, bytes2, result, res);
        continue;
      }
      if (res >= 55296 && res <= 57343) {
        i += onError("UTF16_SURROGATE", i - 1 - extraLength, bytes2, result, res);
        continue;
      }
      if (res <= overlongMask) {
        i += onError("OVERLONG", i - 1 - extraLength, bytes2, result, res);
        continue;
      }
      result.push(res);
    }
    return result;
  }
  function toUtf8Bytes(str, form) {
    assertArgument(typeof str === "string", "invalid string value", "str", str);
    if (form != null) {
      assertNormalize(form);
      str = str.normalize(form);
    }
    let result = [];
    for (let i = 0; i < str.length; i++) {
      const c = str.charCodeAt(i);
      if (c < 128) {
        result.push(c);
      } else if (c < 2048) {
        result.push(c >> 6 | 192);
        result.push(c & 63 | 128);
      } else if ((c & 64512) == 55296) {
        i++;
        const c2 = str.charCodeAt(i);
        assertArgument(i < str.length && (c2 & 64512) === 56320, "invalid surrogate pair", "str", str);
        const pair = 65536 + ((c & 1023) << 10) + (c2 & 1023);
        result.push(pair >> 18 | 240);
        result.push(pair >> 12 & 63 | 128);
        result.push(pair >> 6 & 63 | 128);
        result.push(pair & 63 | 128);
      } else {
        result.push(c >> 12 | 224);
        result.push(c >> 6 & 63 | 128);
        result.push(c & 63 | 128);
      }
    }
    return new Uint8Array(result);
  }
  function _toUtf8String(codePoints) {
    return codePoints.map((codePoint) => {
      if (codePoint <= 65535) {
        return String.fromCharCode(codePoint);
      }
      codePoint -= 65536;
      return String.fromCharCode((codePoint >> 10 & 1023) + 55296, (codePoint & 1023) + 56320);
    }).join("");
  }
  function toUtf8String(bytes2, onError) {
    return _toUtf8String(getUtf8CodePoints(bytes2, onError));
  }
  function toUtf8CodePoints(str, form) {
    return getUtf8CodePoints(toUtf8Bytes(str, form));
  }
  var Utf8ErrorFuncs;
  var init_utf8 = __esm({
    "node_modules/ethers/lib.esm/utils/utf8.js"() {
      init_data();
      init_errors();
      Utf8ErrorFuncs = Object.freeze({
        error: errorFunc,
        ignore: ignoreFunc,
        replace: replaceFunc
      });
    }
  });

  // node_modules/ethers/lib.esm/utils/geturl-browser.js
  function createGetUrl(options) {
    async function getUrl3(req, _signal2) {
      assert(_signal2 == null || !_signal2.cancelled, "request cancelled before sending", "CANCELLED");
      const protocol = req.url.split(":")[0].toLowerCase();
      assert(protocol === "http" || protocol === "https", `unsupported protocol ${protocol}`, "UNSUPPORTED_OPERATION", {
        info: { protocol },
        operation: "request"
      });
      assert(protocol === "https" || !req.credentials || req.allowInsecureAuthentication, "insecure authorized connections unsupported", "UNSUPPORTED_OPERATION", {
        operation: "request"
      });
      let error = null;
      const controller = new AbortController();
      const timer = setTimeout(() => {
        error = makeError("request timeout", "TIMEOUT");
        controller.abort();
      }, req.timeout);
      if (_signal2) {
        _signal2.addListener(() => {
          error = makeError("request cancelled", "CANCELLED");
          controller.abort();
        });
      }
      const init2 = Object.assign({}, options, {
        method: req.method,
        headers: new Headers(Array.from(req)),
        body: req.body || void 0,
        signal: controller.signal
      });
      let resp;
      try {
        resp = await fetch(req.url, init2);
      } catch (_error2) {
        clearTimeout(timer);
        if (error) {
          throw error;
        }
        throw _error2;
      }
      clearTimeout(timer);
      const headers = {};
      resp.headers.forEach((value, key) => {
        headers[key.toLowerCase()] = value;
      });
      const respBody = await resp.arrayBuffer();
      const body = respBody == null ? null : new Uint8Array(respBody);
      return {
        statusCode: resp.status,
        statusMessage: resp.statusText,
        headers,
        body
      };
    }
    return getUrl3;
  }
  var defaultGetUrl;
  var init_geturl_browser = __esm({
    "node_modules/ethers/lib.esm/utils/geturl-browser.js"() {
      init_errors();
      defaultGetUrl = createGetUrl({});
    }
  });

  // node_modules/ethers/lib.esm/utils/fetch.js
  async function dataGatewayFunc(url, signal) {
    try {
      const match = url.match(reData);
      if (!match) {
        throw new Error("invalid data");
      }
      return new FetchResponse(200, "OK", {
        "content-type": match[1] || "text/plain"
      }, match[2] ? decodeBase64(match[3]) : unpercent(match[3]));
    } catch (error) {
      return new FetchResponse(599, "BAD REQUEST (invalid data: URI)", {}, null, new FetchRequest(url));
    }
  }
  function getIpfsGatewayFunc(baseUrl) {
    async function gatewayIpfs(url, signal) {
      try {
        const match = url.match(reIpfs);
        if (!match) {
          throw new Error("invalid link");
        }
        return new FetchRequest(`${baseUrl}${match[2]}`);
      } catch (error) {
        return new FetchResponse(599, "BAD REQUEST (invalid IPFS URI)", {}, null, new FetchRequest(url));
      }
    }
    return gatewayIpfs;
  }
  function checkSignal(signal) {
    if (signal == null) {
      throw new Error("missing signal; should not happen");
    }
    signal.checkSignal();
    return signal;
  }
  function getTime() {
    return (/* @__PURE__ */ new Date()).getTime();
  }
  function unpercent(value) {
    return toUtf8Bytes(value.replace(/%([0-9a-f][0-9a-f])/gi, (all, code) => {
      return String.fromCharCode(parseInt(code, 16));
    }));
  }
  function wait(delay) {
    return new Promise((resolve) => setTimeout(resolve, delay));
  }
  var MAX_ATTEMPTS, SLOT_INTERVAL, defaultGetUrlFunc, reData, reIpfs, locked, Gateways, fetchSignals, _listeners, _cancelled, FetchCancelSignal, _allowInsecure, _gzip, _headers, _method, _timeout, _url, _body, _bodyType, _creds, _preflight, _process, _retry, _signal, _throttle, _getUrlFunc, _FetchRequest_instances, send_fn, _FetchRequest, FetchRequest, _statusCode, _statusMessage, _headers2, _body2, _request, _error, _FetchResponse, FetchResponse;
  var init_fetch = __esm({
    "node_modules/ethers/lib.esm/utils/fetch.js"() {
      init_base64_browser();
      init_data();
      init_errors();
      init_properties();
      init_utf8();
      init_geturl_browser();
      MAX_ATTEMPTS = 12;
      SLOT_INTERVAL = 250;
      defaultGetUrlFunc = createGetUrl();
      reData = new RegExp("^data:([^;:]*)?(;base64)?,(.*)$", "i");
      reIpfs = new RegExp("^ipfs://(ipfs/)?(.*)$", "i");
      locked = false;
      Gateways = {
        "data": dataGatewayFunc,
        "ipfs": getIpfsGatewayFunc("https://gateway.ipfs.io/ipfs/")
      };
      fetchSignals = /* @__PURE__ */ new WeakMap();
      FetchCancelSignal = class {
        constructor(request) {
          __privateAdd(this, _listeners);
          __privateAdd(this, _cancelled);
          __privateSet(this, _listeners, []);
          __privateSet(this, _cancelled, false);
          fetchSignals.set(request, () => {
            if (__privateGet(this, _cancelled)) {
              return;
            }
            __privateSet(this, _cancelled, true);
            for (const listener of __privateGet(this, _listeners)) {
              setTimeout(() => {
                listener();
              }, 0);
            }
            __privateSet(this, _listeners, []);
          });
        }
        addListener(listener) {
          assert(!__privateGet(this, _cancelled), "singal already cancelled", "UNSUPPORTED_OPERATION", {
            operation: "fetchCancelSignal.addCancelListener"
          });
          __privateGet(this, _listeners).push(listener);
        }
        get cancelled() {
          return __privateGet(this, _cancelled);
        }
        checkSignal() {
          assert(!this.cancelled, "cancelled", "CANCELLED", {});
        }
      };
      _listeners = new WeakMap();
      _cancelled = new WeakMap();
      _FetchRequest = class _FetchRequest {
        /**
         *  Create a new FetchRequest instance with default values.
         *
         *  Once created, each property may be set before issuing a
         *  ``.send()`` to make the request.
         */
        constructor(url) {
          __privateAdd(this, _FetchRequest_instances);
          __privateAdd(this, _allowInsecure);
          __privateAdd(this, _gzip);
          __privateAdd(this, _headers);
          __privateAdd(this, _method);
          __privateAdd(this, _timeout);
          __privateAdd(this, _url);
          __privateAdd(this, _body);
          __privateAdd(this, _bodyType);
          __privateAdd(this, _creds);
          // Hooks
          __privateAdd(this, _preflight);
          __privateAdd(this, _process);
          __privateAdd(this, _retry);
          __privateAdd(this, _signal);
          __privateAdd(this, _throttle);
          __privateAdd(this, _getUrlFunc);
          __privateSet(this, _url, String(url));
          __privateSet(this, _allowInsecure, false);
          __privateSet(this, _gzip, true);
          __privateSet(this, _headers, {});
          __privateSet(this, _method, "");
          __privateSet(this, _timeout, 3e5);
          __privateSet(this, _throttle, {
            slotInterval: SLOT_INTERVAL,
            maxAttempts: MAX_ATTEMPTS
          });
          __privateSet(this, _getUrlFunc, null);
        }
        /**
         *  The fetch URL to request.
         */
        get url() {
          return __privateGet(this, _url);
        }
        set url(url) {
          __privateSet(this, _url, String(url));
        }
        /**
         *  The fetch body, if any, to send as the request body. //(default: null)//
         *
         *  When setting a body, the intrinsic ``Content-Type`` is automatically
         *  set and will be used if **not overridden** by setting a custom
         *  header.
         *
         *  If %%body%% is null, the body is cleared (along with the
         *  intrinsic ``Content-Type``).
         *
         *  If %%body%% is a string, the intrinsic ``Content-Type`` is set to
         *  ``text/plain``.
         *
         *  If %%body%% is a Uint8Array, the intrinsic ``Content-Type`` is set to
         *  ``application/octet-stream``.
         *
         *  If %%body%% is any other object, the intrinsic ``Content-Type`` is
         *  set to ``application/json``.
         */
        get body() {
          if (__privateGet(this, _body) == null) {
            return null;
          }
          return new Uint8Array(__privateGet(this, _body));
        }
        set body(body) {
          if (body == null) {
            __privateSet(this, _body, void 0);
            __privateSet(this, _bodyType, void 0);
          } else if (typeof body === "string") {
            __privateSet(this, _body, toUtf8Bytes(body));
            __privateSet(this, _bodyType, "text/plain");
          } else if (body instanceof Uint8Array) {
            __privateSet(this, _body, body);
            __privateSet(this, _bodyType, "application/octet-stream");
          } else if (typeof body === "object") {
            __privateSet(this, _body, toUtf8Bytes(JSON.stringify(body)));
            __privateSet(this, _bodyType, "application/json");
          } else {
            throw new Error("invalid body");
          }
        }
        /**
         *  Returns true if the request has a body.
         */
        hasBody() {
          return __privateGet(this, _body) != null;
        }
        /**
         *  The HTTP method to use when requesting the URI. If no method
         *  has been explicitly set, then ``GET`` is used if the body is
         *  null and ``POST`` otherwise.
         */
        get method() {
          if (__privateGet(this, _method)) {
            return __privateGet(this, _method);
          }
          if (this.hasBody()) {
            return "POST";
          }
          return "GET";
        }
        set method(method) {
          if (method == null) {
            method = "";
          }
          __privateSet(this, _method, String(method).toUpperCase());
        }
        /**
         *  The headers that will be used when requesting the URI. All
         *  keys are lower-case.
         *
         *  This object is a copy, so any changes will **NOT** be reflected
         *  in the ``FetchRequest``.
         *
         *  To set a header entry, use the ``setHeader`` method.
         */
        get headers() {
          const headers = Object.assign({}, __privateGet(this, _headers));
          if (__privateGet(this, _creds)) {
            headers["authorization"] = `Basic ${encodeBase64(toUtf8Bytes(__privateGet(this, _creds)))}`;
          }
          ;
          if (this.allowGzip) {
            headers["accept-encoding"] = "gzip";
          }
          if (headers["content-type"] == null && __privateGet(this, _bodyType)) {
            headers["content-type"] = __privateGet(this, _bodyType);
          }
          if (this.body) {
            headers["content-length"] = String(this.body.length);
          }
          return headers;
        }
        /**
         *  Get the header for %%key%%, ignoring case.
         */
        getHeader(key) {
          return this.headers[key.toLowerCase()];
        }
        /**
         *  Set the header for %%key%% to %%value%%. All values are coerced
         *  to a string.
         */
        setHeader(key, value) {
          __privateGet(this, _headers)[String(key).toLowerCase()] = String(value);
        }
        /**
         *  Clear all headers, resetting all intrinsic headers.
         */
        clearHeaders() {
          __privateSet(this, _headers, {});
        }
        [Symbol.iterator]() {
          const headers = this.headers;
          const keys = Object.keys(headers);
          let index2 = 0;
          return {
            next: () => {
              if (index2 < keys.length) {
                const key = keys[index2++];
                return {
                  value: [key, headers[key]],
                  done: false
                };
              }
              return { value: void 0, done: true };
            }
          };
        }
        /**
         *  The value that will be sent for the ``Authorization`` header.
         *
         *  To set the credentials, use the ``setCredentials`` method.
         */
        get credentials() {
          return __privateGet(this, _creds) || null;
        }
        /**
         *  Sets an ``Authorization`` for %%username%% with %%password%%.
         */
        setCredentials(username, password) {
          assertArgument(!username.match(/:/), "invalid basic authentication username", "username", "[REDACTED]");
          __privateSet(this, _creds, `${username}:${password}`);
        }
        /**
         *  Enable and request gzip-encoded responses. The response will
         *  automatically be decompressed. //(default: true)//
         */
        get allowGzip() {
          return __privateGet(this, _gzip);
        }
        set allowGzip(value) {
          __privateSet(this, _gzip, !!value);
        }
        /**
         *  Allow ``Authentication`` credentials to be sent over insecure
         *  channels. //(default: false)//
         */
        get allowInsecureAuthentication() {
          return !!__privateGet(this, _allowInsecure);
        }
        set allowInsecureAuthentication(value) {
          __privateSet(this, _allowInsecure, !!value);
        }
        /**
         *  The timeout (in milliseconds) to wait for a complete response.
         *  //(default: 5 minutes)//
         */
        get timeout() {
          return __privateGet(this, _timeout);
        }
        set timeout(timeout) {
          assertArgument(timeout >= 0, "timeout must be non-zero", "timeout", timeout);
          __privateSet(this, _timeout, timeout);
        }
        /**
         *  This function is called prior to each request, for example
         *  during a redirection or retry in case of server throttling.
         *
         *  This offers an opportunity to populate headers or update
         *  content before sending a request.
         */
        get preflightFunc() {
          return __privateGet(this, _preflight) || null;
        }
        set preflightFunc(preflight) {
          __privateSet(this, _preflight, preflight);
        }
        /**
         *  This function is called after each response, offering an
         *  opportunity to provide client-level throttling or updating
         *  response data.
         *
         *  Any error thrown in this causes the ``send()`` to throw.
         *
         *  To schedule a retry attempt (assuming the maximum retry limit
         *  has not been reached), use [[response.throwThrottleError]].
         */
        get processFunc() {
          return __privateGet(this, _process) || null;
        }
        set processFunc(process2) {
          __privateSet(this, _process, process2);
        }
        /**
         *  This function is called on each retry attempt.
         */
        get retryFunc() {
          return __privateGet(this, _retry) || null;
        }
        set retryFunc(retry) {
          __privateSet(this, _retry, retry);
        }
        /**
         *  This function is called to fetch content from HTTP and
         *  HTTPS URLs and is platform specific (e.g. nodejs vs
         *  browsers).
         *
         *  This is by default the currently registered global getUrl
         *  function, which can be changed using [[registerGetUrl]].
         *  If this has been set, setting is to ``null`` will cause
         *  this FetchRequest (and any future clones) to revert back to
         *  using the currently registered global getUrl function.
         *
         *  Setting this is generally not necessary, but may be useful
         *  for developers that wish to intercept requests or to
         *  configurege a proxy or other agent.
         */
        get getUrlFunc() {
          return __privateGet(this, _getUrlFunc) || defaultGetUrlFunc;
        }
        set getUrlFunc(value) {
          __privateSet(this, _getUrlFunc, value);
        }
        toString() {
          return `<FetchRequest method=${JSON.stringify(this.method)} url=${JSON.stringify(this.url)} headers=${JSON.stringify(this.headers)} body=${__privateGet(this, _body) ? hexlify(__privateGet(this, _body)) : "null"}>`;
        }
        /**
         *  Update the throttle parameters used to determine maximum
         *  attempts and exponential-backoff properties.
         */
        setThrottleParams(params) {
          if (params.slotInterval != null) {
            __privateGet(this, _throttle).slotInterval = params.slotInterval;
          }
          if (params.maxAttempts != null) {
            __privateGet(this, _throttle).maxAttempts = params.maxAttempts;
          }
        }
        /**
         *  Resolves to the response by sending the request.
         */
        send() {
          assert(__privateGet(this, _signal) == null, "request already sent", "UNSUPPORTED_OPERATION", { operation: "fetchRequest.send" });
          __privateSet(this, _signal, new FetchCancelSignal(this));
          return __privateMethod(this, _FetchRequest_instances, send_fn).call(this, 0, getTime() + this.timeout, 0, this, new FetchResponse(0, "", {}, null, this));
        }
        /**
         *  Cancels the inflight response, causing a ``CANCELLED``
         *  error to be rejected from the [[send]].
         */
        cancel() {
          assert(__privateGet(this, _signal) != null, "request has not been sent", "UNSUPPORTED_OPERATION", { operation: "fetchRequest.cancel" });
          const signal = fetchSignals.get(this);
          if (!signal) {
            throw new Error("missing signal; should not happen");
          }
          signal();
        }
        /**
         *  Returns a new [[FetchRequest]] that represents the redirection
         *  to %%location%%.
         */
        redirect(location) {
          const current = this.url.split(":")[0].toLowerCase();
          const target = location.split(":")[0].toLowerCase();
          assert(this.method === "GET" && (current !== "https" || target !== "http") && location.match(/^https?:/), `unsupported redirect`, "UNSUPPORTED_OPERATION", {
            operation: `redirect(${this.method} ${JSON.stringify(this.url)} => ${JSON.stringify(location)})`
          });
          const req = new _FetchRequest(location);
          req.method = "GET";
          req.allowGzip = this.allowGzip;
          req.timeout = this.timeout;
          __privateSet(req, _headers, Object.assign({}, __privateGet(this, _headers)));
          if (__privateGet(this, _body)) {
            __privateSet(req, _body, new Uint8Array(__privateGet(this, _body)));
          }
          __privateSet(req, _bodyType, __privateGet(this, _bodyType));
          return req;
        }
        /**
         *  Create a new copy of this request.
         */
        clone() {
          const clone = new _FetchRequest(this.url);
          __privateSet(clone, _method, __privateGet(this, _method));
          if (__privateGet(this, _body)) {
            __privateSet(clone, _body, __privateGet(this, _body));
          }
          __privateSet(clone, _bodyType, __privateGet(this, _bodyType));
          __privateSet(clone, _headers, Object.assign({}, __privateGet(this, _headers)));
          __privateSet(clone, _creds, __privateGet(this, _creds));
          if (this.allowGzip) {
            clone.allowGzip = true;
          }
          clone.timeout = this.timeout;
          if (this.allowInsecureAuthentication) {
            clone.allowInsecureAuthentication = true;
          }
          __privateSet(clone, _preflight, __privateGet(this, _preflight));
          __privateSet(clone, _process, __privateGet(this, _process));
          __privateSet(clone, _retry, __privateGet(this, _retry));
          __privateSet(clone, _throttle, Object.assign({}, __privateGet(this, _throttle)));
          __privateSet(clone, _getUrlFunc, __privateGet(this, _getUrlFunc));
          return clone;
        }
        /**
         *  Locks all static configuration for gateways and FetchGetUrlFunc
         *  registration.
         */
        static lockConfig() {
          locked = true;
        }
        /**
         *  Get the current Gateway function for %%scheme%%.
         */
        static getGateway(scheme) {
          return Gateways[scheme.toLowerCase()] || null;
        }
        /**
         *  Use the %%func%% when fetching URIs using %%scheme%%.
         *
         *  This method affects all requests globally.
         *
         *  If [[lockConfig]] has been called, no change is made and this
         *  throws.
         */
        static registerGateway(scheme, func) {
          scheme = scheme.toLowerCase();
          if (scheme === "http" || scheme === "https") {
            throw new Error(`cannot intercept ${scheme}; use registerGetUrl`);
          }
          if (locked) {
            throw new Error("gateways locked");
          }
          Gateways[scheme] = func;
        }
        /**
         *  Use %%getUrl%% when fetching URIs over HTTP and HTTPS requests.
         *
         *  This method affects all requests globally.
         *
         *  If [[lockConfig]] has been called, no change is made and this
         *  throws.
         */
        static registerGetUrl(getUrl3) {
          if (locked) {
            throw new Error("gateways locked");
          }
          defaultGetUrlFunc = getUrl3;
        }
        /**
         *  Creates a getUrl function that fetches content from HTTP and
         *  HTTPS URLs.
         *
         *  The available %%options%% are dependent on the platform
         *  implementation of the default getUrl function.
         *
         *  This is not generally something that is needed, but is useful
         *  when trying to customize simple behaviour when fetching HTTP
         *  content.
         */
        static createGetUrlFunc(options) {
          return createGetUrl(options);
        }
        /**
         *  Creates a function that can "fetch" data URIs.
         *
         *  Note that this is automatically done internally to support
         *  data URIs, so it is not necessary to register it.
         *
         *  This is not generally something that is needed, but may
         *  be useful in a wrapper to perfom custom data URI functionality.
         */
        static createDataGateway() {
          return dataGatewayFunc;
        }
        /**
         *  Creates a function that will fetch IPFS (unvalidated) from
         *  a custom gateway baseUrl.
         *
         *  The default IPFS gateway used internally is
         *  ``"https:/\/gateway.ipfs.io/ipfs/"``.
         */
        static createIpfsGatewayFunc(baseUrl) {
          return getIpfsGatewayFunc(baseUrl);
        }
      };
      _allowInsecure = new WeakMap();
      _gzip = new WeakMap();
      _headers = new WeakMap();
      _method = new WeakMap();
      _timeout = new WeakMap();
      _url = new WeakMap();
      _body = new WeakMap();
      _bodyType = new WeakMap();
      _creds = new WeakMap();
      _preflight = new WeakMap();
      _process = new WeakMap();
      _retry = new WeakMap();
      _signal = new WeakMap();
      _throttle = new WeakMap();
      _getUrlFunc = new WeakMap();
      _FetchRequest_instances = new WeakSet();
      send_fn = async function(attempt, expires, delay, _request3, _response) {
        var _a2, _b, _c;
        if (attempt >= __privateGet(this, _throttle).maxAttempts) {
          return _response.makeServerError("exceeded maximum retry limit");
        }
        assert(getTime() <= expires, "timeout", "TIMEOUT", {
          operation: "request.send",
          reason: "timeout",
          request: _request3
        });
        if (delay > 0) {
          await wait(delay);
        }
        let req = this.clone();
        const scheme = (req.url.split(":")[0] || "").toLowerCase();
        if (scheme in Gateways) {
          const result = await Gateways[scheme](req.url, checkSignal(__privateGet(_request3, _signal)));
          if (result instanceof FetchResponse) {
            let response2 = result;
            if (this.processFunc) {
              checkSignal(__privateGet(_request3, _signal));
              try {
                response2 = await this.processFunc(req, response2);
              } catch (error) {
                if (error.throttle == null || typeof error.stall !== "number") {
                  response2.makeServerError("error in post-processing function", error).assertOk();
                }
              }
            }
            return response2;
          }
          req = result;
        }
        if (this.preflightFunc) {
          req = await this.preflightFunc(req);
        }
        const resp = await this.getUrlFunc(req, checkSignal(__privateGet(_request3, _signal)));
        let response = new FetchResponse(resp.statusCode, resp.statusMessage, resp.headers, resp.body, _request3);
        if (response.statusCode === 301 || response.statusCode === 302) {
          try {
            const location = response.headers.location || "";
            return __privateMethod(_a2 = req.redirect(location), _FetchRequest_instances, send_fn).call(_a2, attempt + 1, expires, 0, _request3, response);
          } catch (error) {
          }
          return response;
        } else if (response.statusCode === 429) {
          if (this.retryFunc == null || await this.retryFunc(req, response, attempt)) {
            const retryAfter = response.headers["retry-after"];
            let delay2 = __privateGet(this, _throttle).slotInterval * Math.trunc(Math.random() * Math.pow(2, attempt));
            if (typeof retryAfter === "string" && retryAfter.match(/^[1-9][0-9]*$/)) {
              delay2 = parseInt(retryAfter);
            }
            return __privateMethod(_b = req.clone(), _FetchRequest_instances, send_fn).call(_b, attempt + 1, expires, delay2, _request3, response);
          }
        }
        if (this.processFunc) {
          checkSignal(__privateGet(_request3, _signal));
          try {
            response = await this.processFunc(req, response);
          } catch (error) {
            if (error.throttle == null || typeof error.stall !== "number") {
              response.makeServerError("error in post-processing function", error).assertOk();
            }
            let delay2 = __privateGet(this, _throttle).slotInterval * Math.trunc(Math.random() * Math.pow(2, attempt));
            ;
            if (error.stall >= 0) {
              delay2 = error.stall;
            }
            return __privateMethod(_c = req.clone(), _FetchRequest_instances, send_fn).call(_c, attempt + 1, expires, delay2, _request3, response);
          }
        }
        return response;
      };
      FetchRequest = _FetchRequest;
      _FetchResponse = class _FetchResponse {
        constructor(statusCode, statusMessage, headers, body, request) {
          __privateAdd(this, _statusCode);
          __privateAdd(this, _statusMessage);
          __privateAdd(this, _headers2);
          __privateAdd(this, _body2);
          __privateAdd(this, _request);
          __privateAdd(this, _error);
          __privateSet(this, _statusCode, statusCode);
          __privateSet(this, _statusMessage, statusMessage);
          __privateSet(this, _headers2, Object.keys(headers).reduce((accum, k) => {
            accum[k.toLowerCase()] = String(headers[k]);
            return accum;
          }, {}));
          __privateSet(this, _body2, body == null ? null : new Uint8Array(body));
          __privateSet(this, _request, request || null);
          __privateSet(this, _error, { message: "" });
        }
        toString() {
          return `<FetchResponse status=${this.statusCode} body=${__privateGet(this, _body2) ? hexlify(__privateGet(this, _body2)) : "null"}>`;
        }
        /**
         *  The response status code.
         */
        get statusCode() {
          return __privateGet(this, _statusCode);
        }
        /**
         *  The response status message.
         */
        get statusMessage() {
          return __privateGet(this, _statusMessage);
        }
        /**
         *  The response headers. All keys are lower-case.
         */
        get headers() {
          return Object.assign({}, __privateGet(this, _headers2));
        }
        /**
         *  The response body, or ``null`` if there was no body.
         */
        get body() {
          return __privateGet(this, _body2) == null ? null : new Uint8Array(__privateGet(this, _body2));
        }
        /**
         *  The response body as a UTF-8 encoded string, or the empty
         *  string (i.e. ``""``) if there was no body.
         *
         *  An error is thrown if the body is invalid UTF-8 data.
         */
        get bodyText() {
          try {
            return __privateGet(this, _body2) == null ? "" : toUtf8String(__privateGet(this, _body2));
          } catch (error) {
            assert(false, "response body is not valid UTF-8 data", "UNSUPPORTED_OPERATION", {
              operation: "bodyText",
              info: { response: this }
            });
          }
        }
        /**
         *  The response body, decoded as JSON.
         *
         *  An error is thrown if the body is invalid JSON-encoded data
         *  or if there was no body.
         */
        get bodyJson() {
          try {
            return JSON.parse(this.bodyText);
          } catch (error) {
            assert(false, "response body is not valid JSON", "UNSUPPORTED_OPERATION", {
              operation: "bodyJson",
              info: { response: this }
            });
          }
        }
        [Symbol.iterator]() {
          const headers = this.headers;
          const keys = Object.keys(headers);
          let index2 = 0;
          return {
            next: () => {
              if (index2 < keys.length) {
                const key = keys[index2++];
                return {
                  value: [key, headers[key]],
                  done: false
                };
              }
              return { value: void 0, done: true };
            }
          };
        }
        /**
         *  Return a Response with matching headers and body, but with
         *  an error status code (i.e. 599) and %%message%% with an
         *  optional %%error%%.
         */
        makeServerError(message, error) {
          let statusMessage;
          if (!message) {
            message = `${this.statusCode} ${this.statusMessage}`;
            statusMessage = `CLIENT ESCALATED SERVER ERROR (${message})`;
          } else {
            statusMessage = `CLIENT ESCALATED SERVER ERROR (${this.statusCode} ${this.statusMessage}; ${message})`;
          }
          const response = new _FetchResponse(599, statusMessage, this.headers, this.body, __privateGet(this, _request) || void 0);
          __privateSet(response, _error, { message, error });
          return response;
        }
        /**
         *  If called within a [request.processFunc](FetchRequest-processFunc)
         *  call, causes the request to retry as if throttled for %%stall%%
         *  milliseconds.
         */
        throwThrottleError(message, stall5) {
          if (stall5 == null) {
            stall5 = -1;
          } else {
            assertArgument(Number.isInteger(stall5) && stall5 >= 0, "invalid stall timeout", "stall", stall5);
          }
          const error = new Error(message || "throttling requests");
          defineProperties(error, { stall: stall5, throttle: true });
          throw error;
        }
        /**
         *  Get the header value for %%key%%, ignoring case.
         */
        getHeader(key) {
          return this.headers[key.toLowerCase()];
        }
        /**
         *  Returns true if the response has a body.
         */
        hasBody() {
          return __privateGet(this, _body2) != null;
        }
        /**
         *  The request made for this response.
         */
        get request() {
          return __privateGet(this, _request);
        }
        /**
         *  Returns true if this response was a success statusCode.
         */
        ok() {
          return __privateGet(this, _error).message === "" && this.statusCode >= 200 && this.statusCode < 300;
        }
        /**
         *  Throws a ``SERVER_ERROR`` if this response is not ok.
         */
        assertOk() {
          if (this.ok()) {
            return;
          }
          let { message, error } = __privateGet(this, _error);
          if (message === "") {
            message = `server response ${this.statusCode} ${this.statusMessage}`;
          }
          let requestUrl = null;
          if (this.request) {
            requestUrl = this.request.url;
          }
          let responseBody = null;
          try {
            if (__privateGet(this, _body2)) {
              responseBody = toUtf8String(__privateGet(this, _body2));
            }
          } catch (e) {
          }
          assert(false, message, "SERVER_ERROR", {
            request: this.request || "unknown request",
            response: this,
            error,
            info: {
              requestUrl,
              responseBody,
              responseStatus: `${this.statusCode} ${this.statusMessage}`
            }
          });
        }
      };
      _statusCode = new WeakMap();
      _statusMessage = new WeakMap();
      _headers2 = new WeakMap();
      _body2 = new WeakMap();
      _request = new WeakMap();
      _error = new WeakMap();
      FetchResponse = _FetchResponse;
    }
  });

  // node_modules/ethers/lib.esm/utils/fixednumber.js
  function getTens(decimals) {
    let result = Zeros;
    while (result.length < decimals) {
      result += result;
    }
    return BigInt("1" + result.substring(0, decimals));
  }
  function checkValue(val, format, safeOp) {
    const width = BigInt(format.width);
    if (format.signed) {
      const limit = BN_12 << width - BN_12;
      assert(safeOp == null || val >= -limit && val < limit, "overflow", "NUMERIC_FAULT", {
        operation: safeOp,
        fault: "overflow",
        value: val
      });
      if (val > BN_03) {
        val = fromTwos(mask(val, width), width);
      } else {
        val = -fromTwos(mask(-val, width), width);
      }
    } else {
      const limit = BN_12 << width;
      assert(safeOp == null || val >= 0 && val < limit, "overflow", "NUMERIC_FAULT", {
        operation: safeOp,
        fault: "overflow",
        value: val
      });
      val = (val % limit + limit) % limit & limit - BN_12;
    }
    return val;
  }
  function getFormat(value) {
    if (typeof value === "number") {
      value = `fixed128x${value}`;
    }
    let signed2 = true;
    let width = 128;
    let decimals = 18;
    if (typeof value === "string") {
      if (value === "fixed") {
      } else if (value === "ufixed") {
        signed2 = false;
      } else {
        const match = value.match(/^(u?)fixed([0-9]+)x([0-9]+)$/);
        assertArgument(match, "invalid fixed format", "format", value);
        signed2 = match[1] !== "u";
        width = parseInt(match[2]);
        decimals = parseInt(match[3]);
      }
    } else if (value) {
      const v = value;
      const check = (key, type, defaultValue) => {
        if (v[key] == null) {
          return defaultValue;
        }
        assertArgument(typeof v[key] === type, "invalid fixed format (" + key + " not " + type + ")", "format." + key, v[key]);
        return v[key];
      };
      signed2 = check("signed", "boolean", signed2);
      width = check("width", "number", width);
      decimals = check("decimals", "number", decimals);
    }
    assertArgument(width % 8 === 0, "invalid FixedNumber width (not byte aligned)", "format.width", width);
    assertArgument(decimals <= 80, "invalid FixedNumber decimals (too large)", "format.decimals", decimals);
    const name = (signed2 ? "" : "u") + "fixed" + String(width) + "x" + String(decimals);
    return { signed: signed2, width, decimals, name };
  }
  function toString(val, decimals) {
    let negative = "";
    if (val < BN_03) {
      negative = "-";
      val *= BN_N1;
    }
    let str = val.toString();
    if (decimals === 0) {
      return negative + str;
    }
    while (str.length <= decimals) {
      str = Zeros + str;
    }
    const index2 = str.length - decimals;
    str = str.substring(0, index2) + "." + str.substring(index2);
    while (str[0] === "0" && str[1] !== ".") {
      str = str.substring(1);
    }
    while (str[str.length - 1] === "0" && str[str.length - 2] !== ".") {
      str = str.substring(0, str.length - 1);
    }
    return negative + str;
  }
  var BN_N1, BN_03, BN_12, BN_5, _guard, Zeros, _format, _val, _tens, _FixedNumber_instances, checkFormat_fn, checkValue_fn, add_fn, sub_fn, mul_fn, div_fn, _FixedNumber, FixedNumber;
  var init_fixednumber = __esm({
    "node_modules/ethers/lib.esm/utils/fixednumber.js"() {
      init_data();
      init_errors();
      init_maths();
      init_properties();
      BN_N1 = BigInt(-1);
      BN_03 = BigInt(0);
      BN_12 = BigInt(1);
      BN_5 = BigInt(5);
      _guard = {};
      Zeros = "0000";
      while (Zeros.length < 80) {
        Zeros += Zeros;
      }
      _FixedNumber = class _FixedNumber {
        // Use this when changing this file to get some typing info,
        // but then switch to any to mask the internal type
        //constructor(guard: any, value: bigint, format: _FixedFormat) {
        /**
         *  @private
         */
        constructor(guard, value, format) {
          __privateAdd(this, _FixedNumber_instances);
          /**
           *  The specific fixed-point arithmetic field for this value.
           */
          __publicField(this, "format");
          __privateAdd(this, _format);
          // The actual value (accounting for decimals)
          __privateAdd(this, _val);
          // A base-10 value to multiple values by to maintain the magnitude
          __privateAdd(this, _tens);
          /**
           *  This is a property so console.log shows a human-meaningful value.
           *
           *  @private
           */
          __publicField(this, "_value");
          assertPrivate(guard, _guard, "FixedNumber");
          __privateSet(this, _val, value);
          __privateSet(this, _format, format);
          const _value2 = toString(value, format.decimals);
          defineProperties(this, { format: format.name, _value: _value2 });
          __privateSet(this, _tens, getTens(format.decimals));
        }
        /**
         *  If true, negative values are permitted, otherwise only
         *  positive values and zero are allowed.
         */
        get signed() {
          return __privateGet(this, _format).signed;
        }
        /**
         *  The number of bits available to store the value.
         */
        get width() {
          return __privateGet(this, _format).width;
        }
        /**
         *  The number of decimal places in the fixed-point arithment field.
         */
        get decimals() {
          return __privateGet(this, _format).decimals;
        }
        /**
         *  The value as an integer, based on the smallest unit the
         *  [[decimals]] allow.
         */
        get value() {
          return __privateGet(this, _val);
        }
        /**
         *  Returns a new [[FixedNumber]] with the result of %%this%% added
         *  to %%other%%, ignoring overflow.
         */
        addUnsafe(other) {
          return __privateMethod(this, _FixedNumber_instances, add_fn).call(this, other);
        }
        /**
         *  Returns a new [[FixedNumber]] with the result of %%this%% added
         *  to %%other%%. A [[NumericFaultError]] is thrown if overflow
         *  occurs.
         */
        add(other) {
          return __privateMethod(this, _FixedNumber_instances, add_fn).call(this, other, "add");
        }
        /**
         *  Returns a new [[FixedNumber]] with the result of %%other%% subtracted
         *  from %%this%%, ignoring overflow.
         */
        subUnsafe(other) {
          return __privateMethod(this, _FixedNumber_instances, sub_fn).call(this, other);
        }
        /**
         *  Returns a new [[FixedNumber]] with the result of %%other%% subtracted
         *  from %%this%%. A [[NumericFaultError]] is thrown if overflow
         *  occurs.
         */
        sub(other) {
          return __privateMethod(this, _FixedNumber_instances, sub_fn).call(this, other, "sub");
        }
        /**
         *  Returns a new [[FixedNumber]] with the result of %%this%% multiplied
         *  by %%other%%, ignoring overflow and underflow (precision loss).
         */
        mulUnsafe(other) {
          return __privateMethod(this, _FixedNumber_instances, mul_fn).call(this, other);
        }
        /**
         *  Returns a new [[FixedNumber]] with the result of %%this%% multiplied
         *  by %%other%%. A [[NumericFaultError]] is thrown if overflow
         *  occurs.
         */
        mul(other) {
          return __privateMethod(this, _FixedNumber_instances, mul_fn).call(this, other, "mul");
        }
        /**
         *  Returns a new [[FixedNumber]] with the result of %%this%% multiplied
         *  by %%other%%. A [[NumericFaultError]] is thrown if overflow
         *  occurs or if underflow (precision loss) occurs.
         */
        mulSignal(other) {
          __privateMethod(this, _FixedNumber_instances, checkFormat_fn).call(this, other);
          const value = __privateGet(this, _val) * __privateGet(other, _val);
          assert(value % __privateGet(this, _tens) === BN_03, "precision lost during signalling mul", "NUMERIC_FAULT", {
            operation: "mulSignal",
            fault: "underflow",
            value: this
          });
          return __privateMethod(this, _FixedNumber_instances, checkValue_fn).call(this, value / __privateGet(this, _tens), "mulSignal");
        }
        /**
         *  Returns a new [[FixedNumber]] with the result of %%this%% divided
         *  by %%other%%, ignoring underflow (precision loss). A
         *  [[NumericFaultError]] is thrown if overflow occurs.
         */
        divUnsafe(other) {
          return __privateMethod(this, _FixedNumber_instances, div_fn).call(this, other);
        }
        /**
         *  Returns a new [[FixedNumber]] with the result of %%this%% divided
         *  by %%other%%, ignoring underflow (precision loss). A
         *  [[NumericFaultError]] is thrown if overflow occurs.
         */
        div(other) {
          return __privateMethod(this, _FixedNumber_instances, div_fn).call(this, other, "div");
        }
        /**
         *  Returns a new [[FixedNumber]] with the result of %%this%% divided
         *  by %%other%%. A [[NumericFaultError]] is thrown if underflow
         *  (precision loss) occurs.
         */
        divSignal(other) {
          assert(__privateGet(other, _val) !== BN_03, "division by zero", "NUMERIC_FAULT", {
            operation: "div",
            fault: "divide-by-zero",
            value: this
          });
          __privateMethod(this, _FixedNumber_instances, checkFormat_fn).call(this, other);
          const value = __privateGet(this, _val) * __privateGet(this, _tens);
          assert(value % __privateGet(other, _val) === BN_03, "precision lost during signalling div", "NUMERIC_FAULT", {
            operation: "divSignal",
            fault: "underflow",
            value: this
          });
          return __privateMethod(this, _FixedNumber_instances, checkValue_fn).call(this, value / __privateGet(other, _val), "divSignal");
        }
        /**
         *  Returns a comparison result between %%this%% and %%other%%.
         *
         *  This is suitable for use in sorting, where ``-1`` implies %%this%%
         *  is smaller, ``1`` implies %%this%% is larger and ``0`` implies
         *  both are equal.
         */
        cmp(other) {
          let a = this.value, b2 = other.value;
          const delta = this.decimals - other.decimals;
          if (delta > 0) {
            b2 *= getTens(delta);
          } else if (delta < 0) {
            a *= getTens(-delta);
          }
          if (a < b2) {
            return -1;
          }
          if (a > b2) {
            return 1;
          }
          return 0;
        }
        /**
         *  Returns true if %%other%% is equal to %%this%%.
         */
        eq(other) {
          return this.cmp(other) === 0;
        }
        /**
         *  Returns true if %%other%% is less than to %%this%%.
         */
        lt(other) {
          return this.cmp(other) < 0;
        }
        /**
         *  Returns true if %%other%% is less than or equal to %%this%%.
         */
        lte(other) {
          return this.cmp(other) <= 0;
        }
        /**
         *  Returns true if %%other%% is greater than to %%this%%.
         */
        gt(other) {
          return this.cmp(other) > 0;
        }
        /**
         *  Returns true if %%other%% is greater than or equal to %%this%%.
         */
        gte(other) {
          return this.cmp(other) >= 0;
        }
        /**
         *  Returns a new [[FixedNumber]] which is the largest **integer**
         *  that is less than or equal to %%this%%.
         *
         *  The decimal component of the result will always be ``0``.
         */
        floor() {
          let val = __privateGet(this, _val);
          if (__privateGet(this, _val) < BN_03) {
            val -= __privateGet(this, _tens) - BN_12;
          }
          val = __privateGet(this, _val) / __privateGet(this, _tens) * __privateGet(this, _tens);
          return __privateMethod(this, _FixedNumber_instances, checkValue_fn).call(this, val, "floor");
        }
        /**
         *  Returns a new [[FixedNumber]] which is the smallest **integer**
         *  that is greater than or equal to %%this%%.
         *
         *  The decimal component of the result will always be ``0``.
         */
        ceiling() {
          let val = __privateGet(this, _val);
          if (__privateGet(this, _val) > BN_03) {
            val += __privateGet(this, _tens) - BN_12;
          }
          val = __privateGet(this, _val) / __privateGet(this, _tens) * __privateGet(this, _tens);
          return __privateMethod(this, _FixedNumber_instances, checkValue_fn).call(this, val, "ceiling");
        }
        /**
         *  Returns a new [[FixedNumber]] with the decimal component
         *  rounded up on ties at %%decimals%% places.
         */
        round(decimals) {
          if (decimals == null) {
            decimals = 0;
          }
          if (decimals >= this.decimals) {
            return this;
          }
          const delta = this.decimals - decimals;
          const bump = BN_5 * getTens(delta - 1);
          let value = this.value + bump;
          const tens = getTens(delta);
          value = value / tens * tens;
          checkValue(value, __privateGet(this, _format), "round");
          return new _FixedNumber(_guard, value, __privateGet(this, _format));
        }
        /**
         *  Returns true if %%this%% is equal to ``0``.
         */
        isZero() {
          return __privateGet(this, _val) === BN_03;
        }
        /**
         *  Returns true if %%this%% is less than ``0``.
         */
        isNegative() {
          return __privateGet(this, _val) < BN_03;
        }
        /**
         *  Returns the string representation of %%this%%.
         */
        toString() {
          return this._value;
        }
        /**
         *  Returns a float approximation.
         *
         *  Due to IEEE 754 precission (or lack thereof), this function
         *  can only return an approximation and most values will contain
         *  rounding errors.
         */
        toUnsafeFloat() {
          return parseFloat(this.toString());
        }
        /**
         *  Return a new [[FixedNumber]] with the same value but has had
         *  its field set to %%format%%.
         *
         *  This will throw if the value cannot fit into %%format%%.
         */
        toFormat(format) {
          return _FixedNumber.fromString(this.toString(), format);
        }
        /**
         *  Creates a new [[FixedNumber]] for %%value%% divided by
         *  %%decimal%% places with %%format%%.
         *
         *  This will throw a [[NumericFaultError]] if %%value%% (once adjusted
         *  for %%decimals%%) cannot fit in %%format%%, either due to overflow
         *  or underflow (precision loss).
         */
        static fromValue(_value2, _decimals, _format2) {
          const decimals = _decimals == null ? 0 : getNumber(_decimals);
          const format = getFormat(_format2);
          let value = getBigInt(_value2, "value");
          const delta = decimals - format.decimals;
          if (delta > 0) {
            const tens = getTens(delta);
            assert(value % tens === BN_03, "value loses precision for format", "NUMERIC_FAULT", {
              operation: "fromValue",
              fault: "underflow",
              value: _value2
            });
            value /= tens;
          } else if (delta < 0) {
            value *= getTens(-delta);
          }
          checkValue(value, format, "fromValue");
          return new _FixedNumber(_guard, value, format);
        }
        /**
         *  Creates a new [[FixedNumber]] for %%value%% with %%format%%.
         *
         *  This will throw a [[NumericFaultError]] if %%value%% cannot fit
         *  in %%format%%, either due to overflow or underflow (precision loss).
         */
        static fromString(_value2, _format2) {
          const match = _value2.match(/^(-?)([0-9]*)\.?([0-9]*)$/);
          assertArgument(match && match[2].length + match[3].length > 0, "invalid FixedNumber string value", "value", _value2);
          const format = getFormat(_format2);
          let whole = match[2] || "0", decimal = match[3] || "";
          while (decimal.length < format.decimals) {
            decimal += Zeros;
          }
          assert(decimal.substring(format.decimals).match(/^0*$/), "too many decimals for format", "NUMERIC_FAULT", {
            operation: "fromString",
            fault: "underflow",
            value: _value2
          });
          decimal = decimal.substring(0, format.decimals);
          const value = BigInt(match[1] + whole + decimal);
          checkValue(value, format, "fromString");
          return new _FixedNumber(_guard, value, format);
        }
        /**
         *  Creates a new [[FixedNumber]] with the big-endian representation
         *  %%value%% with %%format%%.
         *
         *  This will throw a [[NumericFaultError]] if %%value%% cannot fit
         *  in %%format%% due to overflow.
         */
        static fromBytes(_value2, _format2) {
          let value = toBigInt(getBytes(_value2, "value"));
          const format = getFormat(_format2);
          if (format.signed) {
            value = fromTwos(value, format.width);
          }
          checkValue(value, format, "fromBytes");
          return new _FixedNumber(_guard, value, format);
        }
      };
      _format = new WeakMap();
      _val = new WeakMap();
      _tens = new WeakMap();
      _FixedNumber_instances = new WeakSet();
      checkFormat_fn = function(other) {
        assertArgument(this.format === other.format, "incompatible format; use fixedNumber.toFormat", "other", other);
      };
      checkValue_fn = function(val, safeOp) {
        val = checkValue(val, __privateGet(this, _format), safeOp);
        return new _FixedNumber(_guard, val, __privateGet(this, _format));
      };
      add_fn = function(o, safeOp) {
        __privateMethod(this, _FixedNumber_instances, checkFormat_fn).call(this, o);
        return __privateMethod(this, _FixedNumber_instances, checkValue_fn).call(this, __privateGet(this, _val) + __privateGet(o, _val), safeOp);
      };
      sub_fn = function(o, safeOp) {
        __privateMethod(this, _FixedNumber_instances, checkFormat_fn).call(this, o);
        return __privateMethod(this, _FixedNumber_instances, checkValue_fn).call(this, __privateGet(this, _val) - __privateGet(o, _val), safeOp);
      };
      mul_fn = function(o, safeOp) {
        __privateMethod(this, _FixedNumber_instances, checkFormat_fn).call(this, o);
        return __privateMethod(this, _FixedNumber_instances, checkValue_fn).call(this, __privateGet(this, _val) * __privateGet(o, _val) / __privateGet(this, _tens), safeOp);
      };
      div_fn = function(o, safeOp) {
        assert(__privateGet(o, _val) !== BN_03, "division by zero", "NUMERIC_FAULT", {
          operation: "div",
          fault: "divide-by-zero",
          value: this
        });
        __privateMethod(this, _FixedNumber_instances, checkFormat_fn).call(this, o);
        return __privateMethod(this, _FixedNumber_instances, checkValue_fn).call(this, __privateGet(this, _val) * __privateGet(this, _tens) / __privateGet(o, _val), safeOp);
      };
      FixedNumber = _FixedNumber;
    }
  });

  // node_modules/ethers/lib.esm/utils/rlp-decode.js
  function hexlifyByte(value) {
    let result = value.toString(16);
    while (result.length < 2) {
      result = "0" + result;
    }
    return "0x" + result;
  }
  function unarrayifyInteger(data, offset, length) {
    let result = 0;
    for (let i = 0; i < length; i++) {
      result = result * 256 + data[offset + i];
    }
    return result;
  }
  function _decodeChildren(data, offset, childOffset, length) {
    const result = [];
    while (childOffset < offset + 1 + length) {
      const decoded = _decode(data, childOffset);
      result.push(decoded.result);
      childOffset += decoded.consumed;
      assert(childOffset <= offset + 1 + length, "child data too short", "BUFFER_OVERRUN", {
        buffer: data,
        length,
        offset
      });
    }
    return { consumed: 1 + length, result };
  }
  function _decode(data, offset) {
    assert(data.length !== 0, "data too short", "BUFFER_OVERRUN", {
      buffer: data,
      length: 0,
      offset: 1
    });
    const checkOffset = (offset2) => {
      assert(offset2 <= data.length, "data short segment too short", "BUFFER_OVERRUN", {
        buffer: data,
        length: data.length,
        offset: offset2
      });
    };
    if (data[offset] >= 248) {
      const lengthLength = data[offset] - 247;
      checkOffset(offset + 1 + lengthLength);
      const length = unarrayifyInteger(data, offset + 1, lengthLength);
      checkOffset(offset + 1 + lengthLength + length);
      return _decodeChildren(data, offset, offset + 1 + lengthLength, lengthLength + length);
    } else if (data[offset] >= 192) {
      const length = data[offset] - 192;
      checkOffset(offset + 1 + length);
      return _decodeChildren(data, offset, offset + 1, length);
    } else if (data[offset] >= 184) {
      const lengthLength = data[offset] - 183;
      checkOffset(offset + 1 + lengthLength);
      const length = unarrayifyInteger(data, offset + 1, lengthLength);
      checkOffset(offset + 1 + lengthLength + length);
      const result = hexlify(data.slice(offset + 1 + lengthLength, offset + 1 + lengthLength + length));
      return { consumed: 1 + lengthLength + length, result };
    } else if (data[offset] >= 128) {
      const length = data[offset] - 128;
      checkOffset(offset + 1 + length);
      const result = hexlify(data.slice(offset + 1, offset + 1 + length));
      return { consumed: 1 + length, result };
    }
    return { consumed: 1, result: hexlifyByte(data[offset]) };
  }
  function decodeRlp(_data5) {
    const data = getBytes(_data5, "data");
    const decoded = _decode(data, 0);
    assertArgument(decoded.consumed === data.length, "unexpected junk after rlp payload", "data", _data5);
    return decoded.result;
  }
  var init_rlp_decode = __esm({
    "node_modules/ethers/lib.esm/utils/rlp-decode.js"() {
      init_data();
      init_errors();
      init_data();
    }
  });

  // node_modules/ethers/lib.esm/utils/rlp-encode.js
  function arrayifyInteger(value) {
    const result = [];
    while (value) {
      result.unshift(value & 255);
      value >>= 8;
    }
    return result;
  }
  function _encode(object2) {
    if (Array.isArray(object2)) {
      let payload = [];
      object2.forEach(function(child) {
        payload = payload.concat(_encode(child));
      });
      if (payload.length <= 55) {
        payload.unshift(192 + payload.length);
        return payload;
      }
      const length2 = arrayifyInteger(payload.length);
      length2.unshift(247 + length2.length);
      return length2.concat(payload);
    }
    const data = Array.prototype.slice.call(getBytes(object2, "object"));
    if (data.length === 1 && data[0] <= 127) {
      return data;
    } else if (data.length <= 55) {
      data.unshift(128 + data.length);
      return data;
    }
    const length = arrayifyInteger(data.length);
    length.unshift(183 + length.length);
    return length.concat(data);
  }
  function encodeRlp(object2) {
    let result = "0x";
    for (const v of _encode(object2)) {
      result += nibbles[v >> 4];
      result += nibbles[v & 15];
    }
    return result;
  }
  var nibbles;
  var init_rlp_encode = __esm({
    "node_modules/ethers/lib.esm/utils/rlp-encode.js"() {
      init_data();
      nibbles = "0123456789abcdef";
    }
  });

  // node_modules/ethers/lib.esm/utils/units.js
  function formatUnits(value, unit) {
    let decimals = 18;
    if (typeof unit === "string") {
      const index2 = names.indexOf(unit);
      assertArgument(index2 >= 0, "invalid unit", "unit", unit);
      decimals = 3 * index2;
    } else if (unit != null) {
      decimals = getNumber(unit, "unit");
    }
    return FixedNumber.fromValue(value, decimals, { decimals, width: 512 }).toString();
  }
  function parseUnits(value, unit) {
    assertArgument(typeof value === "string", "value must be a string", "value", value);
    let decimals = 18;
    if (typeof unit === "string") {
      const index2 = names.indexOf(unit);
      assertArgument(index2 >= 0, "invalid unit", "unit", unit);
      decimals = 3 * index2;
    } else if (unit != null) {
      decimals = getNumber(unit, "unit");
    }
    return FixedNumber.fromString(value, { decimals, width: 512 }).value;
  }
  function formatEther(wei) {
    return formatUnits(wei, 18);
  }
  function parseEther(ether) {
    return parseUnits(ether, 18);
  }
  var names;
  var init_units = __esm({
    "node_modules/ethers/lib.esm/utils/units.js"() {
      init_errors();
      init_fixednumber();
      init_maths();
      names = [
        "wei",
        "kwei",
        "mwei",
        "gwei",
        "szabo",
        "finney",
        "ether"
      ];
    }
  });

  // node_modules/ethers/lib.esm/utils/uuid.js
  function uuidV4(randomBytes5) {
    const bytes2 = getBytes(randomBytes5, "randomBytes");
    bytes2[6] = bytes2[6] & 15 | 64;
    bytes2[8] = bytes2[8] & 63 | 128;
    const value = hexlify(bytes2);
    return [
      value.substring(2, 10),
      value.substring(10, 14),
      value.substring(14, 18),
      value.substring(18, 22),
      value.substring(22, 34)
    ].join("-");
  }
  var init_uuid = __esm({
    "node_modules/ethers/lib.esm/utils/uuid.js"() {
      init_data();
    }
  });

  // node_modules/ethers/lib.esm/utils/index.js
  var init_utils = __esm({
    "node_modules/ethers/lib.esm/utils/index.js"() {
      init_base58();
      init_base64_browser();
      init_data();
      init_errors();
      init_events();
      init_fetch();
      init_fixednumber();
      init_maths();
      init_properties();
      init_rlp_decode();
      init_rlp_encode();
      init_units();
      init_utf8();
      init_uuid();
    }
  });

  // node_modules/ethers/lib.esm/abi/coders/abstract-coder.js
  function getNames(result) {
    return resultNames.get(result);
  }
  function setNames(result, names2) {
    resultNames.set(result, names2);
  }
  function throwError(name, error) {
    const wrapped = new Error(`deferred error during ABI decoding triggered accessing ${name}`);
    wrapped.error = error;
    throw wrapped;
  }
  function toObject(names2, items, deep) {
    if (names2.indexOf(null) >= 0) {
      return items.map((item, index2) => {
        if (item instanceof Result) {
          return toObject(getNames(item), item, deep);
        }
        return item;
      });
    }
    return names2.reduce((accum, name, index2) => {
      let item = items.getValue(name);
      if (!(name in accum)) {
        if (deep && item instanceof Result) {
          item = toObject(getNames(item), item, deep);
        }
        accum[name] = item;
      }
      return accum;
    }, {});
  }
  function checkResultErrors(result) {
    const errors = [];
    const checkErrors = function(path, object2) {
      if (!Array.isArray(object2)) {
        return;
      }
      for (let key in object2) {
        const childPath = path.slice();
        childPath.push(key);
        try {
          checkErrors(childPath, object2[key]);
        } catch (error) {
          errors.push({ path: childPath, error });
        }
      }
    };
    checkErrors([], result);
    return errors;
  }
  function getValue(value) {
    let bytes2 = toBeArray(value);
    assert(bytes2.length <= WordSize, "value out-of-bounds", "BUFFER_OVERRUN", { buffer: bytes2, length: WordSize, offset: bytes2.length });
    if (bytes2.length !== WordSize) {
      bytes2 = getBytesCopy(concat([Padding.slice(bytes2.length % WordSize), bytes2]));
    }
    return bytes2;
  }
  var WordSize, Padding, passProperties, _guard2, resultNames, _names, _Result, Result, Coder, _data, _dataLength, _Writer_instances, writeData_fn, Writer, _data2, _offset, _bytesRead, _parent, _maxInflation, _Reader_instances, incrementBytesRead_fn, peekBytes_fn, _Reader, Reader;
  var init_abstract_coder = __esm({
    "node_modules/ethers/lib.esm/abi/coders/abstract-coder.js"() {
      init_utils();
      WordSize = 32;
      Padding = new Uint8Array(WordSize);
      passProperties = ["then"];
      _guard2 = {};
      resultNames = /* @__PURE__ */ new WeakMap();
      _Result = class _Result extends Array {
        /**
         *  @private
         */
        constructor(...args) {
          const guard = args[0];
          let items = args[1];
          let names2 = (args[2] || []).slice();
          let wrap = true;
          if (guard !== _guard2) {
            items = args;
            names2 = [];
            wrap = false;
          }
          super(items.length);
          // No longer used; but cannot be removed as it will remove the
          // #private field from the .d.ts which may break backwards
          // compatibility
          __privateAdd(this, _names);
          items.forEach((item, index2) => {
            this[index2] = item;
          });
          const nameCounts = names2.reduce((accum, name) => {
            if (typeof name === "string") {
              accum.set(name, (accum.get(name) || 0) + 1);
            }
            return accum;
          }, /* @__PURE__ */ new Map());
          setNames(this, Object.freeze(items.map((item, index2) => {
            const name = names2[index2];
            if (name != null && nameCounts.get(name) === 1) {
              return name;
            }
            return null;
          })));
          __privateSet(this, _names, []);
          if (__privateGet(this, _names) == null) {
            void __privateGet(this, _names);
          }
          if (!wrap) {
            return;
          }
          Object.freeze(this);
          const proxy = new Proxy(this, {
            get: (target, prop, receiver) => {
              if (typeof prop === "string") {
                if (prop.match(/^[0-9]+$/)) {
                  const index2 = getNumber(prop, "%index");
                  if (index2 < 0 || index2 >= this.length) {
                    throw new RangeError("out of result range");
                  }
                  const item = target[index2];
                  if (item instanceof Error) {
                    throwError(`index ${index2}`, item);
                  }
                  return item;
                }
                if (passProperties.indexOf(prop) >= 0) {
                  return Reflect.get(target, prop, receiver);
                }
                const value = target[prop];
                if (value instanceof Function) {
                  return function(...args2) {
                    return value.apply(this === receiver ? target : this, args2);
                  };
                } else if (!(prop in target)) {
                  return target.getValue.apply(this === receiver ? target : this, [prop]);
                }
              }
              return Reflect.get(target, prop, receiver);
            }
          });
          setNames(proxy, getNames(this));
          return proxy;
        }
        /**
         *  Returns the Result as a normal Array. If %%deep%%, any children
         *  which are Result objects are also converted to a normal Array.
         *
         *  This will throw if there are any outstanding deferred
         *  errors.
         */
        toArray(deep) {
          const result = [];
          this.forEach((item, index2) => {
            if (item instanceof Error) {
              throwError(`index ${index2}`, item);
            }
            if (deep && item instanceof _Result) {
              item = item.toArray(deep);
            }
            result.push(item);
          });
          return result;
        }
        /**
         *  Returns the Result as an Object with each name-value pair. If
         *  %%deep%%, any children which are Result objects are also
         *  converted to an Object.
         *
         *  This will throw if any value is unnamed, or if there are
         *  any outstanding deferred errors.
         */
        toObject(deep) {
          const names2 = getNames(this);
          return names2.reduce((accum, name, index2) => {
            assert(name != null, `value at index ${index2} unnamed`, "UNSUPPORTED_OPERATION", {
              operation: "toObject()"
            });
            return toObject(names2, this, deep);
          }, {});
        }
        /**
         *  @_ignore
         */
        slice(start, end) {
          if (start == null) {
            start = 0;
          }
          if (start < 0) {
            start += this.length;
            if (start < 0) {
              start = 0;
            }
          }
          if (end == null) {
            end = this.length;
          }
          if (end < 0) {
            end += this.length;
            if (end < 0) {
              end = 0;
            }
          }
          if (end > this.length) {
            end = this.length;
          }
          const _names2 = getNames(this);
          const result = [], names2 = [];
          for (let i = start; i < end; i++) {
            result.push(this[i]);
            names2.push(_names2[i]);
          }
          return new _Result(_guard2, result, names2);
        }
        /**
         *  @_ignore
         */
        filter(callback, thisArg) {
          const _names2 = getNames(this);
          const result = [], names2 = [];
          for (let i = 0; i < this.length; i++) {
            const item = this[i];
            if (item instanceof Error) {
              throwError(`index ${i}`, item);
            }
            if (callback.call(thisArg, item, i, this)) {
              result.push(item);
              names2.push(_names2[i]);
            }
          }
          return new _Result(_guard2, result, names2);
        }
        /**
         *  @_ignore
         */
        map(callback, thisArg) {
          const result = [];
          for (let i = 0; i < this.length; i++) {
            const item = this[i];
            if (item instanceof Error) {
              throwError(`index ${i}`, item);
            }
            result.push(callback.call(thisArg, item, i, this));
          }
          return result;
        }
        /**
         *  Returns the value for %%name%%.
         *
         *  Since it is possible to have a key whose name conflicts with
         *  a method on a [[Result]] or its superclass Array, or any
         *  JavaScript keyword, this ensures all named values are still
         *  accessible by name.
         */
        getValue(name) {
          const index2 = getNames(this).indexOf(name);
          if (index2 === -1) {
            return void 0;
          }
          const value = this[index2];
          if (value instanceof Error) {
            throwError(`property ${JSON.stringify(name)}`, value.error);
          }
          return value;
        }
        /**
         *  Creates a new [[Result]] for %%items%% with each entry
         *  also accessible by its corresponding name in %%keys%%.
         */
        static fromItems(items, keys) {
          return new _Result(_guard2, items, keys);
        }
      };
      _names = new WeakMap();
      Result = _Result;
      Coder = class {
        constructor(name, type, localName, dynamic) {
          // The coder name:
          //   - address, uint256, tuple, array, etc.
          __publicField(this, "name");
          // The fully expanded type, including composite types:
          //   - address, uint256, tuple(address,bytes), uint256[3][4][],  etc.
          __publicField(this, "type");
          // The localName bound in the signature, in this example it is "baz":
          //   - tuple(address foo, uint bar) baz
          __publicField(this, "localName");
          // Whether this type is dynamic:
          //  - Dynamic: bytes, string, address[], tuple(boolean[]), etc.
          //  - Not Dynamic: address, uint256, boolean[3], tuple(address, uint8)
          __publicField(this, "dynamic");
          defineProperties(this, { name, type, localName, dynamic }, {
            name: "string",
            type: "string",
            localName: "string",
            dynamic: "boolean"
          });
        }
        _throwError(message, value) {
          assertArgument(false, message, this.localName, value);
        }
      };
      Writer = class {
        constructor() {
          __privateAdd(this, _Writer_instances);
          // An array of WordSize lengthed objects to concatenation
          __privateAdd(this, _data);
          __privateAdd(this, _dataLength);
          __privateSet(this, _data, []);
          __privateSet(this, _dataLength, 0);
        }
        get data() {
          return concat(__privateGet(this, _data));
        }
        get length() {
          return __privateGet(this, _dataLength);
        }
        appendWriter(writer) {
          return __privateMethod(this, _Writer_instances, writeData_fn).call(this, getBytesCopy(writer.data));
        }
        // Arrayish item; pad on the right to *nearest* WordSize
        writeBytes(value) {
          let bytes2 = getBytesCopy(value);
          const paddingOffset = bytes2.length % WordSize;
          if (paddingOffset) {
            bytes2 = getBytesCopy(concat([bytes2, Padding.slice(paddingOffset)]));
          }
          return __privateMethod(this, _Writer_instances, writeData_fn).call(this, bytes2);
        }
        // Numeric item; pad on the left *to* WordSize
        writeValue(value) {
          return __privateMethod(this, _Writer_instances, writeData_fn).call(this, getValue(value));
        }
        // Inserts a numeric place-holder, returning a callback that can
        // be used to asjust the value later
        writeUpdatableValue() {
          const offset = __privateGet(this, _data).length;
          __privateGet(this, _data).push(Padding);
          __privateSet(this, _dataLength, __privateGet(this, _dataLength) + WordSize);
          return (value) => {
            __privateGet(this, _data)[offset] = getValue(value);
          };
        }
      };
      _data = new WeakMap();
      _dataLength = new WeakMap();
      _Writer_instances = new WeakSet();
      writeData_fn = function(data) {
        __privateGet(this, _data).push(data);
        __privateSet(this, _dataLength, __privateGet(this, _dataLength) + data.length);
        return data.length;
      };
      _Reader = class _Reader {
        constructor(data, allowLoose, maxInflation) {
          __privateAdd(this, _Reader_instances);
          // Allows incomplete unpadded data to be read; otherwise an error
          // is raised if attempting to overrun the buffer. This is required
          // to deal with an old Solidity bug, in which event data for
          // external (not public thoguh) was tightly packed.
          __publicField(this, "allowLoose");
          __privateAdd(this, _data2);
          __privateAdd(this, _offset);
          __privateAdd(this, _bytesRead);
          __privateAdd(this, _parent);
          __privateAdd(this, _maxInflation);
          defineProperties(this, { allowLoose: !!allowLoose });
          __privateSet(this, _data2, getBytesCopy(data));
          __privateSet(this, _bytesRead, 0);
          __privateSet(this, _parent, null);
          __privateSet(this, _maxInflation, maxInflation != null ? maxInflation : 1024);
          __privateSet(this, _offset, 0);
        }
        get data() {
          return hexlify(__privateGet(this, _data2));
        }
        get dataLength() {
          return __privateGet(this, _data2).length;
        }
        get consumed() {
          return __privateGet(this, _offset);
        }
        get bytes() {
          return new Uint8Array(__privateGet(this, _data2));
        }
        // Create a sub-reader with the same underlying data, but offset
        subReader(offset) {
          const reader = new _Reader(__privateGet(this, _data2).slice(__privateGet(this, _offset) + offset), this.allowLoose, __privateGet(this, _maxInflation));
          __privateSet(reader, _parent, this);
          return reader;
        }
        // Read bytes
        readBytes(length, loose) {
          let bytes2 = __privateMethod(this, _Reader_instances, peekBytes_fn).call(this, 0, length, !!loose);
          __privateMethod(this, _Reader_instances, incrementBytesRead_fn).call(this, length);
          __privateSet(this, _offset, __privateGet(this, _offset) + bytes2.length);
          return bytes2.slice(0, length);
        }
        // Read a numeric values
        readValue() {
          return toBigInt(this.readBytes(WordSize));
        }
        readIndex() {
          return toNumber(this.readBytes(WordSize));
        }
      };
      _data2 = new WeakMap();
      _offset = new WeakMap();
      _bytesRead = new WeakMap();
      _parent = new WeakMap();
      _maxInflation = new WeakMap();
      _Reader_instances = new WeakSet();
      incrementBytesRead_fn = function(count) {
        var _a2;
        if (__privateGet(this, _parent)) {
          return __privateMethod(_a2 = __privateGet(this, _parent), _Reader_instances, incrementBytesRead_fn).call(_a2, count);
        }
        __privateSet(this, _bytesRead, __privateGet(this, _bytesRead) + count);
        assert(__privateGet(this, _maxInflation) < 1 || __privateGet(this, _bytesRead) <= __privateGet(this, _maxInflation) * this.dataLength, `compressed ABI data exceeds inflation ratio of ${__privateGet(this, _maxInflation)} ( see: https://github.com/ethers-io/ethers.js/issues/4537 )`, "BUFFER_OVERRUN", {
          buffer: getBytesCopy(__privateGet(this, _data2)),
          offset: __privateGet(this, _offset),
          length: count,
          info: {
            bytesRead: __privateGet(this, _bytesRead),
            dataLength: this.dataLength
          }
        });
      };
      peekBytes_fn = function(offset, length, loose) {
        let alignedLength = Math.ceil(length / WordSize) * WordSize;
        if (__privateGet(this, _offset) + alignedLength > __privateGet(this, _data2).length) {
          if (this.allowLoose && loose && __privateGet(this, _offset) + length <= __privateGet(this, _data2).length) {
            alignedLength = length;
          } else {
            assert(false, "data out-of-bounds", "BUFFER_OVERRUN", {
              buffer: getBytesCopy(__privateGet(this, _data2)),
              length: __privateGet(this, _data2).length,
              offset: __privateGet(this, _offset) + alignedLength
            });
          }
        }
        return __privateGet(this, _data2).slice(__privateGet(this, _offset), __privateGet(this, _offset) + alignedLength);
      };
      Reader = _Reader;
    }
  });

  // node_modules/@noble/hashes/esm/_assert.js
  function number(n2) {
    if (!Number.isSafeInteger(n2) || n2 < 0)
      throw new Error(`Wrong positive integer: ${n2}`);
  }
  function bytes(b2, ...lengths) {
    if (!(b2 instanceof Uint8Array))
      throw new Error("Expected Uint8Array");
    if (lengths.length > 0 && !lengths.includes(b2.length))
      throw new Error(`Expected Uint8Array of length ${lengths}, not of length=${b2.length}`);
  }
  function hash(hash3) {
    if (typeof hash3 !== "function" || typeof hash3.create !== "function")
      throw new Error("Hash should be wrapped by utils.wrapConstructor");
    number(hash3.outputLen);
    number(hash3.blockLen);
  }
  function exists(instance, checkFinished = true) {
    if (instance.destroyed)
      throw new Error("Hash instance has been destroyed");
    if (checkFinished && instance.finished)
      throw new Error("Hash#digest() has already been called");
  }
  function output(out, instance) {
    bytes(out);
    const min = instance.outputLen;
    if (out.length < min) {
      throw new Error(`digestInto() expects output buffer of length at least ${min}`);
    }
  }
  var init_assert = __esm({
    "node_modules/@noble/hashes/esm/_assert.js"() {
    }
  });

  // node_modules/@noble/hashes/esm/crypto.js
  var crypto2;
  var init_crypto = __esm({
    "node_modules/@noble/hashes/esm/crypto.js"() {
      crypto2 = typeof globalThis === "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
    }
  });

  // node_modules/@noble/hashes/esm/utils.js
  async function asyncLoop(iters, tick, cb) {
    let ts = Date.now();
    for (let i = 0; i < iters; i++) {
      cb(i);
      const diff = Date.now() - ts;
      if (diff >= 0 && diff < tick)
        continue;
      await nextTick();
      ts += diff;
    }
  }
  function utf8ToBytes(str) {
    if (typeof str !== "string")
      throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
    return new Uint8Array(new TextEncoder().encode(str));
  }
  function toBytes(data) {
    if (typeof data === "string")
      data = utf8ToBytes(data);
    if (!u8a(data))
      throw new Error(`expected Uint8Array, got ${typeof data}`);
    return data;
  }
  function concatBytes(...arrays) {
    const r = new Uint8Array(arrays.reduce((sum, a) => sum + a.length, 0));
    let pad4 = 0;
    arrays.forEach((a) => {
      if (!u8a(a))
        throw new Error("Uint8Array expected");
      r.set(a, pad4);
      pad4 += a.length;
    });
    return r;
  }
  function checkOpts(defaults, opts) {
    if (opts !== void 0 && toStr.call(opts) !== "[object Object]")
      throw new Error("Options should be object or undefined");
    const merged = Object.assign(defaults, opts);
    return merged;
  }
  function wrapConstructor(hashCons) {
    const hashC = (msg) => hashCons().update(toBytes(msg)).digest();
    const tmp = hashCons();
    hashC.outputLen = tmp.outputLen;
    hashC.blockLen = tmp.blockLen;
    hashC.create = () => hashCons();
    return hashC;
  }
  function wrapXOFConstructorWithOpts(hashCons) {
    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();
    const tmp = hashCons({});
    hashC.outputLen = tmp.outputLen;
    hashC.blockLen = tmp.blockLen;
    hashC.create = (opts) => hashCons(opts);
    return hashC;
  }
  function randomBytes(bytesLength = 32) {
    if (crypto2 && typeof crypto2.getRandomValues === "function") {
      return crypto2.getRandomValues(new Uint8Array(bytesLength));
    }
    throw new Error("crypto.getRandomValues must be defined");
  }
  var u8a, u32, createView, rotr, isLE, nextTick, Hash, toStr;
  var init_utils2 = __esm({
    "node_modules/@noble/hashes/esm/utils.js"() {
      init_crypto();
      u8a = (a) => a instanceof Uint8Array;
      u32 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
      createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
      rotr = (word, shift) => word << 32 - shift | word >>> shift;
      isLE = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
      if (!isLE)
        throw new Error("Non little-endian hardware is not supported");
      nextTick = async () => {
      };
      Hash = class {
        // Safe version that clones internal state
        clone() {
          return this._cloneInto();
        }
      };
      toStr = {}.toString;
    }
  });

  // node_modules/@noble/hashes/esm/hmac.js
  var HMAC, hmac;
  var init_hmac = __esm({
    "node_modules/@noble/hashes/esm/hmac.js"() {
      init_assert();
      init_utils2();
      HMAC = class extends Hash {
        constructor(hash3, _key) {
          super();
          this.finished = false;
          this.destroyed = false;
          hash(hash3);
          const key = toBytes(_key);
          this.iHash = hash3.create();
          if (typeof this.iHash.update !== "function")
            throw new Error("Expected instance of class which extends utils.Hash");
          this.blockLen = this.iHash.blockLen;
          this.outputLen = this.iHash.outputLen;
          const blockLen = this.blockLen;
          const pad4 = new Uint8Array(blockLen);
          pad4.set(key.length > blockLen ? hash3.create().update(key).digest() : key);
          for (let i = 0; i < pad4.length; i++)
            pad4[i] ^= 54;
          this.iHash.update(pad4);
          this.oHash = hash3.create();
          for (let i = 0; i < pad4.length; i++)
            pad4[i] ^= 54 ^ 92;
          this.oHash.update(pad4);
          pad4.fill(0);
        }
        update(buf) {
          exists(this);
          this.iHash.update(buf);
          return this;
        }
        digestInto(out) {
          exists(this);
          bytes(out, this.outputLen);
          this.finished = true;
          this.iHash.digestInto(out);
          this.oHash.update(out);
          this.oHash.digestInto(out);
          this.destroy();
        }
        digest() {
          const out = new Uint8Array(this.oHash.outputLen);
          this.digestInto(out);
          return out;
        }
        _cloneInto(to) {
          to || (to = Object.create(Object.getPrototypeOf(this), {}));
          const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;
          to = to;
          to.finished = finished;
          to.destroyed = destroyed;
          to.blockLen = blockLen;
          to.outputLen = outputLen;
          to.oHash = oHash._cloneInto(to.oHash);
          to.iHash = iHash._cloneInto(to.iHash);
          return to;
        }
        destroy() {
          this.destroyed = true;
          this.oHash.destroy();
          this.iHash.destroy();
        }
      };
      hmac = (hash3, key, message) => new HMAC(hash3, key).update(message).digest();
      hmac.create = (hash3, key) => new HMAC(hash3, key);
    }
  });

  // node_modules/@noble/hashes/esm/pbkdf2.js
  function pbkdf2Init(hash3, _password, _salt, _opts) {
    hash(hash3);
    const opts = checkOpts({ dkLen: 32, asyncTick: 10 }, _opts);
    const { c, dkLen, asyncTick } = opts;
    number(c);
    number(dkLen);
    number(asyncTick);
    if (c < 1)
      throw new Error("PBKDF2: iterations (c) should be >= 1");
    const password = toBytes(_password);
    const salt = toBytes(_salt);
    const DK = new Uint8Array(dkLen);
    const PRF = hmac.create(hash3, password);
    const PRFSalt = PRF._cloneInto().update(salt);
    return { c, dkLen, asyncTick, DK, PRF, PRFSalt };
  }
  function pbkdf2Output(PRF, PRFSalt, DK, prfW, u) {
    PRF.destroy();
    PRFSalt.destroy();
    if (prfW)
      prfW.destroy();
    u.fill(0);
    return DK;
  }
  function pbkdf2(hash3, password, salt, opts) {
    const { c, dkLen, DK, PRF, PRFSalt } = pbkdf2Init(hash3, password, salt, opts);
    let prfW;
    const arr = new Uint8Array(4);
    const view = createView(arr);
    const u = new Uint8Array(PRF.outputLen);
    for (let ti = 1, pos = 0; pos < dkLen; ti++, pos += PRF.outputLen) {
      const Ti = DK.subarray(pos, pos + PRF.outputLen);
      view.setInt32(0, ti, false);
      (prfW = PRFSalt._cloneInto(prfW)).update(arr).digestInto(u);
      Ti.set(u.subarray(0, Ti.length));
      for (let ui = 1; ui < c; ui++) {
        PRF._cloneInto(prfW).update(u).digestInto(u);
        for (let i = 0; i < Ti.length; i++)
          Ti[i] ^= u[i];
      }
    }
    return pbkdf2Output(PRF, PRFSalt, DK, prfW, u);
  }
  var init_pbkdf2 = __esm({
    "node_modules/@noble/hashes/esm/pbkdf2.js"() {
      init_assert();
      init_hmac();
      init_utils2();
    }
  });

  // node_modules/@noble/hashes/esm/_sha2.js
  function setBigUint64(view, byteOffset, value, isLE4) {
    if (typeof view.setBigUint64 === "function")
      return view.setBigUint64(byteOffset, value, isLE4);
    const _32n4 = BigInt(32);
    const _u32_max = BigInt(4294967295);
    const wh = Number(value >> _32n4 & _u32_max);
    const wl = Number(value & _u32_max);
    const h = isLE4 ? 4 : 0;
    const l = isLE4 ? 0 : 4;
    view.setUint32(byteOffset + h, wh, isLE4);
    view.setUint32(byteOffset + l, wl, isLE4);
  }
  var SHA2;
  var init_sha2 = __esm({
    "node_modules/@noble/hashes/esm/_sha2.js"() {
      init_assert();
      init_utils2();
      SHA2 = class extends Hash {
        constructor(blockLen, outputLen, padOffset, isLE4) {
          super();
          this.blockLen = blockLen;
          this.outputLen = outputLen;
          this.padOffset = padOffset;
          this.isLE = isLE4;
          this.finished = false;
          this.length = 0;
          this.pos = 0;
          this.destroyed = false;
          this.buffer = new Uint8Array(blockLen);
          this.view = createView(this.buffer);
        }
        update(data) {
          exists(this);
          const { view, buffer: buffer2, blockLen } = this;
          data = toBytes(data);
          const len = data.length;
          for (let pos = 0; pos < len; ) {
            const take = Math.min(blockLen - this.pos, len - pos);
            if (take === blockLen) {
              const dataView = createView(data);
              for (; blockLen <= len - pos; pos += blockLen)
                this.process(dataView, pos);
              continue;
            }
            buffer2.set(data.subarray(pos, pos + take), this.pos);
            this.pos += take;
            pos += take;
            if (this.pos === blockLen) {
              this.process(view, 0);
              this.pos = 0;
            }
          }
          this.length += data.length;
          this.roundClean();
          return this;
        }
        digestInto(out) {
          exists(this);
          output(out, this);
          this.finished = true;
          const { buffer: buffer2, view, blockLen, isLE: isLE4 } = this;
          let { pos } = this;
          buffer2[pos++] = 128;
          this.buffer.subarray(pos).fill(0);
          if (this.padOffset > blockLen - pos) {
            this.process(view, 0);
            pos = 0;
          }
          for (let i = pos; i < blockLen; i++)
            buffer2[i] = 0;
          setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE4);
          this.process(view, 0);
          const oview = createView(out);
          const len = this.outputLen;
          if (len % 4)
            throw new Error("_sha2: outputLen should be aligned to 32bit");
          const outLen = len / 4;
          const state = this.get();
          if (outLen > state.length)
            throw new Error("_sha2: outputLen bigger than state");
          for (let i = 0; i < outLen; i++)
            oview.setUint32(4 * i, state[i], isLE4);
        }
        digest() {
          const { buffer: buffer2, outputLen } = this;
          this.digestInto(buffer2);
          const res = buffer2.slice(0, outputLen);
          this.destroy();
          return res;
        }
        _cloneInto(to) {
          to || (to = new this.constructor());
          to.set(...this.get());
          const { blockLen, buffer: buffer2, length, finished, destroyed, pos } = this;
          to.length = length;
          to.pos = pos;
          to.finished = finished;
          to.destroyed = destroyed;
          if (length % blockLen)
            to.buffer.set(buffer2);
          return to;
        }
      };
    }
  });

  // node_modules/@noble/hashes/esm/sha256.js
  var Chi, Maj, SHA256_K, IV, SHA256_W, SHA256, sha256;
  var init_sha256 = __esm({
    "node_modules/@noble/hashes/esm/sha256.js"() {
      init_sha2();
      init_utils2();
      Chi = (a, b2, c) => a & b2 ^ ~a & c;
      Maj = (a, b2, c) => a & b2 ^ a & c ^ b2 & c;
      SHA256_K = /* @__PURE__ */ new Uint32Array([
        1116352408,
        1899447441,
        3049323471,
        3921009573,
        961987163,
        1508970993,
        2453635748,
        2870763221,
        3624381080,
        310598401,
        607225278,
        1426881987,
        1925078388,
        2162078206,
        2614888103,
        3248222580,
        3835390401,
        4022224774,
        264347078,
        604807628,
        770255983,
        1249150122,
        1555081692,
        1996064986,
        2554220882,
        2821834349,
        2952996808,
        3210313671,
        3336571891,
        3584528711,
        113926993,
        338241895,
        666307205,
        773529912,
        1294757372,
        1396182291,
        1695183700,
        1986661051,
        2177026350,
        2456956037,
        2730485921,
        2820302411,
        3259730800,
        3345764771,
        3516065817,
        3600352804,
        4094571909,
        275423344,
        430227734,
        506948616,
        659060556,
        883997877,
        958139571,
        1322822218,
        1537002063,
        1747873779,
        1955562222,
        2024104815,
        2227730452,
        2361852424,
        2428436474,
        2756734187,
        3204031479,
        3329325298
      ]);
      IV = /* @__PURE__ */ new Uint32Array([
        1779033703,
        3144134277,
        1013904242,
        2773480762,
        1359893119,
        2600822924,
        528734635,
        1541459225
      ]);
      SHA256_W = /* @__PURE__ */ new Uint32Array(64);
      SHA256 = class extends SHA2 {
        constructor() {
          super(64, 32, 8, false);
          this.A = IV[0] | 0;
          this.B = IV[1] | 0;
          this.C = IV[2] | 0;
          this.D = IV[3] | 0;
          this.E = IV[4] | 0;
          this.F = IV[5] | 0;
          this.G = IV[6] | 0;
          this.H = IV[7] | 0;
        }
        get() {
          const { A, B, C, D, E, F, G, H } = this;
          return [A, B, C, D, E, F, G, H];
        }
        // prettier-ignore
        set(A, B, C, D, E, F, G, H) {
          this.A = A | 0;
          this.B = B | 0;
          this.C = C | 0;
          this.D = D | 0;
          this.E = E | 0;
          this.F = F | 0;
          this.G = G | 0;
          this.H = H | 0;
        }
        process(view, offset) {
          for (let i = 0; i < 16; i++, offset += 4)
            SHA256_W[i] = view.getUint32(offset, false);
          for (let i = 16; i < 64; i++) {
            const W15 = SHA256_W[i - 15];
            const W2 = SHA256_W[i - 2];
            const s0 = rotr(W15, 7) ^ rotr(W15, 18) ^ W15 >>> 3;
            const s1 = rotr(W2, 17) ^ rotr(W2, 19) ^ W2 >>> 10;
            SHA256_W[i] = s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16] | 0;
          }
          let { A, B, C, D, E, F, G, H } = this;
          for (let i = 0; i < 64; i++) {
            const sigma1 = rotr(E, 6) ^ rotr(E, 11) ^ rotr(E, 25);
            const T13 = H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i] | 0;
            const sigma0 = rotr(A, 2) ^ rotr(A, 13) ^ rotr(A, 22);
            const T22 = sigma0 + Maj(A, B, C) | 0;
            H = G;
            G = F;
            F = E;
            E = D + T13 | 0;
            D = C;
            C = B;
            B = A;
            A = T13 + T22 | 0;
          }
          A = A + this.A | 0;
          B = B + this.B | 0;
          C = C + this.C | 0;
          D = D + this.D | 0;
          E = E + this.E | 0;
          F = F + this.F | 0;
          G = G + this.G | 0;
          H = H + this.H | 0;
          this.set(A, B, C, D, E, F, G, H);
        }
        roundClean() {
          SHA256_W.fill(0);
        }
        destroy() {
          this.set(0, 0, 0, 0, 0, 0, 0, 0);
          this.buffer.fill(0);
        }
      };
      sha256 = /* @__PURE__ */ wrapConstructor(() => new SHA256());
    }
  });

  // node_modules/@noble/hashes/esm/_u64.js
  function fromBig(n2, le = false) {
    if (le)
      return { h: Number(n2 & U32_MASK64), l: Number(n2 >> _32n & U32_MASK64) };
    return { h: Number(n2 >> _32n & U32_MASK64) | 0, l: Number(n2 & U32_MASK64) | 0 };
  }
  function split(lst, le = false) {
    let Ah = new Uint32Array(lst.length);
    let Al = new Uint32Array(lst.length);
    for (let i = 0; i < lst.length; i++) {
      const { h, l } = fromBig(lst[i], le);
      [Ah[i], Al[i]] = [h, l];
    }
    return [Ah, Al];
  }
  function add(Ah, Al, Bh, Bl) {
    const l = (Al >>> 0) + (Bl >>> 0);
    return { h: Ah + Bh + (l / 2 ** 32 | 0) | 0, l: l | 0 };
  }
  var U32_MASK64, _32n, toBig, shrSH, shrSL, rotrSH, rotrSL, rotrBH, rotrBL, rotr32H, rotr32L, rotlSH, rotlSL, rotlBH, rotlBL, add3L, add3H, add4L, add4H, add5L, add5H, u64, u64_default;
  var init_u64 = __esm({
    "node_modules/@noble/hashes/esm/_u64.js"() {
      U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);
      _32n = /* @__PURE__ */ BigInt(32);
      toBig = (h, l) => BigInt(h >>> 0) << _32n | BigInt(l >>> 0);
      shrSH = (h, _l, s) => h >>> s;
      shrSL = (h, l, s) => h << 32 - s | l >>> s;
      rotrSH = (h, l, s) => h >>> s | l << 32 - s;
      rotrSL = (h, l, s) => h << 32 - s | l >>> s;
      rotrBH = (h, l, s) => h << 64 - s | l >>> s - 32;
      rotrBL = (h, l, s) => h >>> s - 32 | l << 64 - s;
      rotr32H = (_h, l) => l;
      rotr32L = (h, _l) => h;
      rotlSH = (h, l, s) => h << s | l >>> 32 - s;
      rotlSL = (h, l, s) => l << s | h >>> 32 - s;
      rotlBH = (h, l, s) => l << s - 32 | h >>> 64 - s;
      rotlBL = (h, l, s) => h << s - 32 | l >>> 64 - s;
      add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);
      add3H = (low, Ah, Bh, Ch) => Ah + Bh + Ch + (low / 2 ** 32 | 0) | 0;
      add4L = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);
      add4H = (low, Ah, Bh, Ch, Dh) => Ah + Bh + Ch + Dh + (low / 2 ** 32 | 0) | 0;
      add5L = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);
      add5H = (low, Ah, Bh, Ch, Dh, Eh) => Ah + Bh + Ch + Dh + Eh + (low / 2 ** 32 | 0) | 0;
      u64 = {
        fromBig,
        split,
        toBig,
        shrSH,
        shrSL,
        rotrSH,
        rotrSL,
        rotrBH,
        rotrBL,
        rotr32H,
        rotr32L,
        rotlSH,
        rotlSL,
        rotlBH,
        rotlBL,
        add,
        add3L,
        add3H,
        add4L,
        add4H,
        add5H,
        add5L
      };
      u64_default = u64;
    }
  });

  // node_modules/@noble/hashes/esm/sha512.js
  var SHA512_Kh, SHA512_Kl, SHA512_W_H, SHA512_W_L, SHA512, sha512;
  var init_sha512 = __esm({
    "node_modules/@noble/hashes/esm/sha512.js"() {
      init_sha2();
      init_u64();
      init_utils2();
      [SHA512_Kh, SHA512_Kl] = /* @__PURE__ */ (() => u64_default.split([
        "0x428a2f98d728ae22",
        "0x7137449123ef65cd",
        "0xb5c0fbcfec4d3b2f",
        "0xe9b5dba58189dbbc",
        "0x3956c25bf348b538",
        "0x59f111f1b605d019",
        "0x923f82a4af194f9b",
        "0xab1c5ed5da6d8118",
        "0xd807aa98a3030242",
        "0x12835b0145706fbe",
        "0x243185be4ee4b28c",
        "0x550c7dc3d5ffb4e2",
        "0x72be5d74f27b896f",
        "0x80deb1fe3b1696b1",
        "0x9bdc06a725c71235",
        "0xc19bf174cf692694",
        "0xe49b69c19ef14ad2",
        "0xefbe4786384f25e3",
        "0x0fc19dc68b8cd5b5",
        "0x240ca1cc77ac9c65",
        "0x2de92c6f592b0275",
        "0x4a7484aa6ea6e483",
        "0x5cb0a9dcbd41fbd4",
        "0x76f988da831153b5",
        "0x983e5152ee66dfab",
        "0xa831c66d2db43210",
        "0xb00327c898fb213f",
        "0xbf597fc7beef0ee4",
        "0xc6e00bf33da88fc2",
        "0xd5a79147930aa725",
        "0x06ca6351e003826f",
        "0x142929670a0e6e70",
        "0x27b70a8546d22ffc",
        "0x2e1b21385c26c926",
        "0x4d2c6dfc5ac42aed",
        "0x53380d139d95b3df",
        "0x650a73548baf63de",
        "0x766a0abb3c77b2a8",
        "0x81c2c92e47edaee6",
        "0x92722c851482353b",
        "0xa2bfe8a14cf10364",
        "0xa81a664bbc423001",
        "0xc24b8b70d0f89791",
        "0xc76c51a30654be30",
        "0xd192e819d6ef5218",
        "0xd69906245565a910",
        "0xf40e35855771202a",
        "0x106aa07032bbd1b8",
        "0x19a4c116b8d2d0c8",
        "0x1e376c085141ab53",
        "0x2748774cdf8eeb99",
        "0x34b0bcb5e19b48a8",
        "0x391c0cb3c5c95a63",
        "0x4ed8aa4ae3418acb",
        "0x5b9cca4f7763e373",
        "0x682e6ff3d6b2b8a3",
        "0x748f82ee5defb2fc",
        "0x78a5636f43172f60",
        "0x84c87814a1f0ab72",
        "0x8cc702081a6439ec",
        "0x90befffa23631e28",
        "0xa4506cebde82bde9",
        "0xbef9a3f7b2c67915",
        "0xc67178f2e372532b",
        "0xca273eceea26619c",
        "0xd186b8c721c0c207",
        "0xeada7dd6cde0eb1e",
        "0xf57d4f7fee6ed178",
        "0x06f067aa72176fba",
        "0x0a637dc5a2c898a6",
        "0x113f9804bef90dae",
        "0x1b710b35131c471b",
        "0x28db77f523047d84",
        "0x32caab7b40c72493",
        "0x3c9ebe0a15c9bebc",
        "0x431d67c49c100d4c",
        "0x4cc5d4becb3e42b6",
        "0x597f299cfc657e2a",
        "0x5fcb6fab3ad6faec",
        "0x6c44198c4a475817"
      ].map((n2) => BigInt(n2))))();
      SHA512_W_H = /* @__PURE__ */ new Uint32Array(80);
      SHA512_W_L = /* @__PURE__ */ new Uint32Array(80);
      SHA512 = class extends SHA2 {
        constructor() {
          super(128, 64, 16, false);
          this.Ah = 1779033703 | 0;
          this.Al = 4089235720 | 0;
          this.Bh = 3144134277 | 0;
          this.Bl = 2227873595 | 0;
          this.Ch = 1013904242 | 0;
          this.Cl = 4271175723 | 0;
          this.Dh = 2773480762 | 0;
          this.Dl = 1595750129 | 0;
          this.Eh = 1359893119 | 0;
          this.El = 2917565137 | 0;
          this.Fh = 2600822924 | 0;
          this.Fl = 725511199 | 0;
          this.Gh = 528734635 | 0;
          this.Gl = 4215389547 | 0;
          this.Hh = 1541459225 | 0;
          this.Hl = 327033209 | 0;
        }
        // prettier-ignore
        get() {
          const { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
          return [Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl];
        }
        // prettier-ignore
        set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl) {
          this.Ah = Ah | 0;
          this.Al = Al | 0;
          this.Bh = Bh | 0;
          this.Bl = Bl | 0;
          this.Ch = Ch | 0;
          this.Cl = Cl | 0;
          this.Dh = Dh | 0;
          this.Dl = Dl | 0;
          this.Eh = Eh | 0;
          this.El = El | 0;
          this.Fh = Fh | 0;
          this.Fl = Fl | 0;
          this.Gh = Gh | 0;
          this.Gl = Gl | 0;
          this.Hh = Hh | 0;
          this.Hl = Hl | 0;
        }
        process(view, offset) {
          for (let i = 0; i < 16; i++, offset += 4) {
            SHA512_W_H[i] = view.getUint32(offset);
            SHA512_W_L[i] = view.getUint32(offset += 4);
          }
          for (let i = 16; i < 80; i++) {
            const W15h = SHA512_W_H[i - 15] | 0;
            const W15l = SHA512_W_L[i - 15] | 0;
            const s0h = u64_default.rotrSH(W15h, W15l, 1) ^ u64_default.rotrSH(W15h, W15l, 8) ^ u64_default.shrSH(W15h, W15l, 7);
            const s0l = u64_default.rotrSL(W15h, W15l, 1) ^ u64_default.rotrSL(W15h, W15l, 8) ^ u64_default.shrSL(W15h, W15l, 7);
            const W2h = SHA512_W_H[i - 2] | 0;
            const W2l = SHA512_W_L[i - 2] | 0;
            const s1h = u64_default.rotrSH(W2h, W2l, 19) ^ u64_default.rotrBH(W2h, W2l, 61) ^ u64_default.shrSH(W2h, W2l, 6);
            const s1l = u64_default.rotrSL(W2h, W2l, 19) ^ u64_default.rotrBL(W2h, W2l, 61) ^ u64_default.shrSL(W2h, W2l, 6);
            const SUMl = u64_default.add4L(s0l, s1l, SHA512_W_L[i - 7], SHA512_W_L[i - 16]);
            const SUMh = u64_default.add4H(SUMl, s0h, s1h, SHA512_W_H[i - 7], SHA512_W_H[i - 16]);
            SHA512_W_H[i] = SUMh | 0;
            SHA512_W_L[i] = SUMl | 0;
          }
          let { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
          for (let i = 0; i < 80; i++) {
            const sigma1h = u64_default.rotrSH(Eh, El, 14) ^ u64_default.rotrSH(Eh, El, 18) ^ u64_default.rotrBH(Eh, El, 41);
            const sigma1l = u64_default.rotrSL(Eh, El, 14) ^ u64_default.rotrSL(Eh, El, 18) ^ u64_default.rotrBL(Eh, El, 41);
            const CHIh = Eh & Fh ^ ~Eh & Gh;
            const CHIl = El & Fl ^ ~El & Gl;
            const T1ll = u64_default.add5L(Hl, sigma1l, CHIl, SHA512_Kl[i], SHA512_W_L[i]);
            const T1h = u64_default.add5H(T1ll, Hh, sigma1h, CHIh, SHA512_Kh[i], SHA512_W_H[i]);
            const T1l = T1ll | 0;
            const sigma0h = u64_default.rotrSH(Ah, Al, 28) ^ u64_default.rotrBH(Ah, Al, 34) ^ u64_default.rotrBH(Ah, Al, 39);
            const sigma0l = u64_default.rotrSL(Ah, Al, 28) ^ u64_default.rotrBL(Ah, Al, 34) ^ u64_default.rotrBL(Ah, Al, 39);
            const MAJh = Ah & Bh ^ Ah & Ch ^ Bh & Ch;
            const MAJl = Al & Bl ^ Al & Cl ^ Bl & Cl;
            Hh = Gh | 0;
            Hl = Gl | 0;
            Gh = Fh | 0;
            Gl = Fl | 0;
            Fh = Eh | 0;
            Fl = El | 0;
            ({ h: Eh, l: El } = u64_default.add(Dh | 0, Dl | 0, T1h | 0, T1l | 0));
            Dh = Ch | 0;
            Dl = Cl | 0;
            Ch = Bh | 0;
            Cl = Bl | 0;
            Bh = Ah | 0;
            Bl = Al | 0;
            const All = u64_default.add3L(T1l, sigma0l, MAJl);
            Ah = u64_default.add3H(All, T1h, sigma0h, MAJh);
            Al = All | 0;
          }
          ({ h: Ah, l: Al } = u64_default.add(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0));
          ({ h: Bh, l: Bl } = u64_default.add(this.Bh | 0, this.Bl | 0, Bh | 0, Bl | 0));
          ({ h: Ch, l: Cl } = u64_default.add(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0));
          ({ h: Dh, l: Dl } = u64_default.add(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0));
          ({ h: Eh, l: El } = u64_default.add(this.Eh | 0, this.El | 0, Eh | 0, El | 0));
          ({ h: Fh, l: Fl } = u64_default.add(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0));
          ({ h: Gh, l: Gl } = u64_default.add(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0));
          ({ h: Hh, l: Hl } = u64_default.add(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0));
          this.set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);
        }
        roundClean() {
          SHA512_W_H.fill(0);
          SHA512_W_L.fill(0);
        }
        destroy() {
          this.buffer.fill(0);
          this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
        }
      };
      sha512 = /* @__PURE__ */ wrapConstructor(() => new SHA512());
    }
  });

  // node_modules/ethers/lib.esm/crypto/crypto-browser.js
  function getGlobal() {
    if (typeof self !== "undefined") {
      return self;
    }
    if (typeof window !== "undefined") {
      return window;
    }
    if (typeof global !== "undefined") {
      return global;
    }
    throw new Error("unable to locate global object");
  }
  function createHash(algo) {
    switch (algo) {
      case "sha256":
        return sha256.create();
      case "sha512":
        return sha512.create();
    }
    assertArgument(false, "invalid hashing algorithm name", "algorithm", algo);
  }
  function createHmac(_algo, key) {
    const algo = { sha256, sha512 }[_algo];
    assertArgument(algo != null, "invalid hmac algorithm", "algorithm", _algo);
    return hmac.create(algo, key);
  }
  function pbkdf2Sync(password, salt, iterations, keylen, _algo) {
    const algo = { sha256, sha512 }[_algo];
    assertArgument(algo != null, "invalid pbkdf2 algorithm", "algorithm", _algo);
    return pbkdf2(algo, password, salt, { c: iterations, dkLen: keylen });
  }
  function randomBytes2(length) {
    assert(crypto3 != null, "platform does not support secure random numbers", "UNSUPPORTED_OPERATION", {
      operation: "randomBytes"
    });
    assertArgument(Number.isInteger(length) && length > 0 && length <= 1024, "invalid length", "length", length);
    const result = new Uint8Array(length);
    crypto3.getRandomValues(result);
    return result;
  }
  var anyGlobal, crypto3;
  var init_crypto_browser = __esm({
    "node_modules/ethers/lib.esm/crypto/crypto-browser.js"() {
      init_hmac();
      init_pbkdf2();
      init_sha256();
      init_sha512();
      init_utils();
      anyGlobal = getGlobal();
      crypto3 = anyGlobal.crypto || anyGlobal.msCrypto;
    }
  });

  // node_modules/ethers/lib.esm/crypto/hmac.js
  function computeHmac(algorithm, _key, _data5) {
    const key = getBytes(_key, "key");
    const data = getBytes(_data5, "data");
    return hexlify(__computeHmac(algorithm, key, data));
  }
  var locked2, _computeHmac, __computeHmac;
  var init_hmac2 = __esm({
    "node_modules/ethers/lib.esm/crypto/hmac.js"() {
      init_crypto_browser();
      init_utils();
      locked2 = false;
      _computeHmac = function(algorithm, key, data) {
        return createHmac(algorithm, key).update(data).digest();
      };
      __computeHmac = _computeHmac;
      computeHmac._ = _computeHmac;
      computeHmac.lock = function() {
        locked2 = true;
      };
      computeHmac.register = function(func) {
        if (locked2) {
          throw new Error("computeHmac is locked");
        }
        __computeHmac = func;
      };
      Object.freeze(computeHmac);
    }
  });

  // node_modules/@noble/hashes/esm/sha3.js
  function keccakP(s, rounds = 24) {
    const B = new Uint32Array(5 * 2);
    for (let round = 24 - rounds; round < 24; round++) {
      for (let x = 0; x < 10; x++)
        B[x] = s[x] ^ s[x + 10] ^ s[x + 20] ^ s[x + 30] ^ s[x + 40];
      for (let x = 0; x < 10; x += 2) {
        const idx1 = (x + 8) % 10;
        const idx0 = (x + 2) % 10;
        const B0 = B[idx0];
        const B1 = B[idx0 + 1];
        const Th = rotlH(B0, B1, 1) ^ B[idx1];
        const Tl = rotlL(B0, B1, 1) ^ B[idx1 + 1];
        for (let y = 0; y < 50; y += 10) {
          s[x + y] ^= Th;
          s[x + y + 1] ^= Tl;
        }
      }
      let curH = s[2];
      let curL = s[3];
      for (let t = 0; t < 24; t++) {
        const shift = SHA3_ROTL[t];
        const Th = rotlH(curH, curL, shift);
        const Tl = rotlL(curH, curL, shift);
        const PI = SHA3_PI[t];
        curH = s[PI];
        curL = s[PI + 1];
        s[PI] = Th;
        s[PI + 1] = Tl;
      }
      for (let y = 0; y < 50; y += 10) {
        for (let x = 0; x < 10; x++)
          B[x] = s[y + x];
        for (let x = 0; x < 10; x++)
          s[y + x] ^= ~B[(x + 2) % 10] & B[(x + 4) % 10];
      }
      s[0] ^= SHA3_IOTA_H[round];
      s[1] ^= SHA3_IOTA_L[round];
    }
    B.fill(0);
  }
  var SHA3_PI, SHA3_ROTL, _SHA3_IOTA, _0n, _1n, _2n, _7n, _256n, _0x71n, SHA3_IOTA_H, SHA3_IOTA_L, rotlH, rotlL, Keccak, gen, sha3_224, sha3_256, sha3_384, sha3_512, keccak_224, keccak_256, keccak_384, keccak_512, genShake, shake128, shake256;
  var init_sha3 = __esm({
    "node_modules/@noble/hashes/esm/sha3.js"() {
      init_assert();
      init_u64();
      init_utils2();
      [SHA3_PI, SHA3_ROTL, _SHA3_IOTA] = [[], [], []];
      _0n = /* @__PURE__ */ BigInt(0);
      _1n = /* @__PURE__ */ BigInt(1);
      _2n = /* @__PURE__ */ BigInt(2);
      _7n = /* @__PURE__ */ BigInt(7);
      _256n = /* @__PURE__ */ BigInt(256);
      _0x71n = /* @__PURE__ */ BigInt(113);
      for (let round = 0, R = _1n, x = 1, y = 0; round < 24; round++) {
        [x, y] = [y, (2 * x + 3 * y) % 5];
        SHA3_PI.push(2 * (5 * y + x));
        SHA3_ROTL.push((round + 1) * (round + 2) / 2 % 64);
        let t = _0n;
        for (let j = 0; j < 7; j++) {
          R = (R << _1n ^ (R >> _7n) * _0x71n) % _256n;
          if (R & _2n)
            t ^= _1n << (_1n << /* @__PURE__ */ BigInt(j)) - _1n;
        }
        _SHA3_IOTA.push(t);
      }
      [SHA3_IOTA_H, SHA3_IOTA_L] = /* @__PURE__ */ split(_SHA3_IOTA, true);
      rotlH = (h, l, s) => s > 32 ? rotlBH(h, l, s) : rotlSH(h, l, s);
      rotlL = (h, l, s) => s > 32 ? rotlBL(h, l, s) : rotlSL(h, l, s);
      Keccak = class _Keccak extends Hash {
        // NOTE: we accept arguments in bytes instead of bits here.
        constructor(blockLen, suffix, outputLen, enableXOF = false, rounds = 24) {
          super();
          this.blockLen = blockLen;
          this.suffix = suffix;
          this.outputLen = outputLen;
          this.enableXOF = enableXOF;
          this.rounds = rounds;
          this.pos = 0;
          this.posOut = 0;
          this.finished = false;
          this.destroyed = false;
          number(outputLen);
          if (0 >= this.blockLen || this.blockLen >= 200)
            throw new Error("Sha3 supports only keccak-f1600 function");
          this.state = new Uint8Array(200);
          this.state32 = u32(this.state);
        }
        keccak() {
          keccakP(this.state32, this.rounds);
          this.posOut = 0;
          this.pos = 0;
        }
        update(data) {
          exists(this);
          const { blockLen, state } = this;
          data = toBytes(data);
          const len = data.length;
          for (let pos = 0; pos < len; ) {
            const take = Math.min(blockLen - this.pos, len - pos);
            for (let i = 0; i < take; i++)
              state[this.pos++] ^= data[pos++];
            if (this.pos === blockLen)
              this.keccak();
          }
          return this;
        }
        finish() {
          if (this.finished)
            return;
          this.finished = true;
          const { state, suffix, pos, blockLen } = this;
          state[pos] ^= suffix;
          if ((suffix & 128) !== 0 && pos === blockLen - 1)
            this.keccak();
          state[blockLen - 1] ^= 128;
          this.keccak();
        }
        writeInto(out) {
          exists(this, false);
          bytes(out);
          this.finish();
          const bufferOut = this.state;
          const { blockLen } = this;
          for (let pos = 0, len = out.length; pos < len; ) {
            if (this.posOut >= blockLen)
              this.keccak();
            const take = Math.min(blockLen - this.posOut, len - pos);
            out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);
            this.posOut += take;
            pos += take;
          }
          return out;
        }
        xofInto(out) {
          if (!this.enableXOF)
            throw new Error("XOF is not possible for this instance");
          return this.writeInto(out);
        }
        xof(bytes2) {
          number(bytes2);
          return this.xofInto(new Uint8Array(bytes2));
        }
        digestInto(out) {
          output(out, this);
          if (this.finished)
            throw new Error("digest() was already called");
          this.writeInto(out);
          this.destroy();
          return out;
        }
        digest() {
          return this.digestInto(new Uint8Array(this.outputLen));
        }
        destroy() {
          this.destroyed = true;
          this.state.fill(0);
        }
        _cloneInto(to) {
          const { blockLen, suffix, outputLen, rounds, enableXOF } = this;
          to || (to = new _Keccak(blockLen, suffix, outputLen, enableXOF, rounds));
          to.state32.set(this.state32);
          to.pos = this.pos;
          to.posOut = this.posOut;
          to.finished = this.finished;
          to.rounds = rounds;
          to.suffix = suffix;
          to.outputLen = outputLen;
          to.enableXOF = enableXOF;
          to.destroyed = this.destroyed;
          return to;
        }
      };
      gen = (suffix, blockLen, outputLen) => wrapConstructor(() => new Keccak(blockLen, suffix, outputLen));
      sha3_224 = /* @__PURE__ */ gen(6, 144, 224 / 8);
      sha3_256 = /* @__PURE__ */ gen(6, 136, 256 / 8);
      sha3_384 = /* @__PURE__ */ gen(6, 104, 384 / 8);
      sha3_512 = /* @__PURE__ */ gen(6, 72, 512 / 8);
      keccak_224 = /* @__PURE__ */ gen(1, 144, 224 / 8);
      keccak_256 = /* @__PURE__ */ gen(1, 136, 256 / 8);
      keccak_384 = /* @__PURE__ */ gen(1, 104, 384 / 8);
      keccak_512 = /* @__PURE__ */ gen(1, 72, 512 / 8);
      genShake = (suffix, blockLen, outputLen) => wrapXOFConstructorWithOpts((opts = {}) => new Keccak(blockLen, suffix, opts.dkLen === void 0 ? outputLen : opts.dkLen, true));
      shake128 = /* @__PURE__ */ genShake(31, 168, 128 / 8);
      shake256 = /* @__PURE__ */ genShake(31, 136, 256 / 8);
    }
  });

  // node_modules/ethers/lib.esm/crypto/keccak.js
  function keccak256(_data5) {
    const data = getBytes(_data5, "data");
    return hexlify(__keccak256(data));
  }
  var locked3, _keccak256, __keccak256;
  var init_keccak = __esm({
    "node_modules/ethers/lib.esm/crypto/keccak.js"() {
      init_sha3();
      init_utils();
      locked3 = false;
      _keccak256 = function(data) {
        return keccak_256(data);
      };
      __keccak256 = _keccak256;
      keccak256._ = _keccak256;
      keccak256.lock = function() {
        locked3 = true;
      };
      keccak256.register = function(func) {
        if (locked3) {
          throw new TypeError("keccak256 is locked");
        }
        __keccak256 = func;
      };
      Object.freeze(keccak256);
    }
  });

  // node_modules/@noble/hashes/esm/ripemd160.js
  function f(group, x, y, z) {
    if (group === 0)
      return x ^ y ^ z;
    else if (group === 1)
      return x & y | ~x & z;
    else if (group === 2)
      return (x | ~y) ^ z;
    else if (group === 3)
      return x & z | y & ~z;
    else
      return x ^ (y | ~z);
  }
  var Rho, Id, Pi, idxL, idxR, shifts, shiftsL, shiftsR, Kl, Kr, rotl, BUF, RIPEMD160, ripemd160;
  var init_ripemd160 = __esm({
    "node_modules/@noble/hashes/esm/ripemd160.js"() {
      init_sha2();
      init_utils2();
      Rho = /* @__PURE__ */ new Uint8Array([7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8]);
      Id = /* @__PURE__ */ Uint8Array.from({ length: 16 }, (_, i) => i);
      Pi = /* @__PURE__ */ Id.map((i) => (9 * i + 5) % 16);
      idxL = [Id];
      idxR = [Pi];
      for (let i = 0; i < 4; i++)
        for (let j of [idxL, idxR])
          j.push(j[i].map((k) => Rho[k]));
      shifts = /* @__PURE__ */ [
        [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8],
        [12, 13, 11, 15, 6, 9, 9, 7, 12, 15, 11, 13, 7, 8, 7, 7],
        [13, 15, 14, 11, 7, 7, 6, 8, 13, 14, 13, 12, 5, 5, 6, 9],
        [14, 11, 12, 14, 8, 6, 5, 5, 15, 12, 15, 14, 9, 9, 8, 6],
        [15, 12, 13, 13, 9, 5, 8, 6, 14, 11, 12, 11, 8, 6, 5, 5]
      ].map((i) => new Uint8Array(i));
      shiftsL = /* @__PURE__ */ idxL.map((idx, i) => idx.map((j) => shifts[i][j]));
      shiftsR = /* @__PURE__ */ idxR.map((idx, i) => idx.map((j) => shifts[i][j]));
      Kl = /* @__PURE__ */ new Uint32Array([
        0,
        1518500249,
        1859775393,
        2400959708,
        2840853838
      ]);
      Kr = /* @__PURE__ */ new Uint32Array([
        1352829926,
        1548603684,
        1836072691,
        2053994217,
        0
      ]);
      rotl = (word, shift) => word << shift | word >>> 32 - shift;
      BUF = /* @__PURE__ */ new Uint32Array(16);
      RIPEMD160 = class extends SHA2 {
        constructor() {
          super(64, 20, 8, true);
          this.h0 = 1732584193 | 0;
          this.h1 = 4023233417 | 0;
          this.h2 = 2562383102 | 0;
          this.h3 = 271733878 | 0;
          this.h4 = 3285377520 | 0;
        }
        get() {
          const { h0, h1, h2, h3, h4 } = this;
          return [h0, h1, h2, h3, h4];
        }
        set(h0, h1, h2, h3, h4) {
          this.h0 = h0 | 0;
          this.h1 = h1 | 0;
          this.h2 = h2 | 0;
          this.h3 = h3 | 0;
          this.h4 = h4 | 0;
        }
        process(view, offset) {
          for (let i = 0; i < 16; i++, offset += 4)
            BUF[i] = view.getUint32(offset, true);
          let al = this.h0 | 0, ar = al, bl = this.h1 | 0, br = bl, cl = this.h2 | 0, cr = cl, dl = this.h3 | 0, dr = dl, el = this.h4 | 0, er = el;
          for (let group = 0; group < 5; group++) {
            const rGroup = 4 - group;
            const hbl = Kl[group], hbr = Kr[group];
            const rl = idxL[group], rr = idxR[group];
            const sl = shiftsL[group], sr = shiftsR[group];
            for (let i = 0; i < 16; i++) {
              const tl = rotl(al + f(group, bl, cl, dl) + BUF[rl[i]] + hbl, sl[i]) + el | 0;
              al = el, el = dl, dl = rotl(cl, 10) | 0, cl = bl, bl = tl;
            }
            for (let i = 0; i < 16; i++) {
              const tr = rotl(ar + f(rGroup, br, cr, dr) + BUF[rr[i]] + hbr, sr[i]) + er | 0;
              ar = er, er = dr, dr = rotl(cr, 10) | 0, cr = br, br = tr;
            }
          }
          this.set(this.h1 + cl + dr | 0, this.h2 + dl + er | 0, this.h3 + el + ar | 0, this.h4 + al + br | 0, this.h0 + bl + cr | 0);
        }
        roundClean() {
          BUF.fill(0);
        }
        destroy() {
          this.destroyed = true;
          this.buffer.fill(0);
          this.set(0, 0, 0, 0, 0);
        }
      };
      ripemd160 = /* @__PURE__ */ wrapConstructor(() => new RIPEMD160());
    }
  });

  // node_modules/ethers/lib.esm/crypto/ripemd160.js
  function ripemd1602(_data5) {
    const data = getBytes(_data5, "data");
    return hexlify(__ripemd160(data));
  }
  var locked4, _ripemd160, __ripemd160;
  var init_ripemd1602 = __esm({
    "node_modules/ethers/lib.esm/crypto/ripemd160.js"() {
      init_ripemd160();
      init_utils();
      locked4 = false;
      _ripemd160 = function(data) {
        return ripemd160(data);
      };
      __ripemd160 = _ripemd160;
      ripemd1602._ = _ripemd160;
      ripemd1602.lock = function() {
        locked4 = true;
      };
      ripemd1602.register = function(func) {
        if (locked4) {
          throw new TypeError("ripemd160 is locked");
        }
        __ripemd160 = func;
      };
      Object.freeze(ripemd1602);
    }
  });

  // node_modules/ethers/lib.esm/crypto/pbkdf2.js
  function pbkdf22(_password, _salt, iterations, keylen, algo) {
    const password = getBytes(_password, "password");
    const salt = getBytes(_salt, "salt");
    return hexlify(__pbkdf2(password, salt, iterations, keylen, algo));
  }
  var locked5, _pbkdf2, __pbkdf2;
  var init_pbkdf22 = __esm({
    "node_modules/ethers/lib.esm/crypto/pbkdf2.js"() {
      init_crypto_browser();
      init_utils();
      locked5 = false;
      _pbkdf2 = function(password, salt, iterations, keylen, algo) {
        return pbkdf2Sync(password, salt, iterations, keylen, algo);
      };
      __pbkdf2 = _pbkdf2;
      pbkdf22._ = _pbkdf2;
      pbkdf22.lock = function() {
        locked5 = true;
      };
      pbkdf22.register = function(func) {
        if (locked5) {
          throw new Error("pbkdf2 is locked");
        }
        __pbkdf2 = func;
      };
      Object.freeze(pbkdf22);
    }
  });

  // node_modules/ethers/lib.esm/crypto/random.js
  function randomBytes3(length) {
    return __randomBytes(length);
  }
  var locked6, _randomBytes, __randomBytes;
  var init_random = __esm({
    "node_modules/ethers/lib.esm/crypto/random.js"() {
      init_crypto_browser();
      locked6 = false;
      _randomBytes = function(length) {
        return new Uint8Array(randomBytes2(length));
      };
      __randomBytes = _randomBytes;
      randomBytes3._ = _randomBytes;
      randomBytes3.lock = function() {
        locked6 = true;
      };
      randomBytes3.register = function(func) {
        if (locked6) {
          throw new Error("randomBytes is locked");
        }
        __randomBytes = func;
      };
      Object.freeze(randomBytes3);
    }
  });

  // node_modules/@noble/hashes/esm/scrypt.js
  function XorAndSalsa(prev, pi, input, ii, out, oi) {
    let y00 = prev[pi++] ^ input[ii++], y01 = prev[pi++] ^ input[ii++];
    let y02 = prev[pi++] ^ input[ii++], y03 = prev[pi++] ^ input[ii++];
    let y04 = prev[pi++] ^ input[ii++], y05 = prev[pi++] ^ input[ii++];
    let y06 = prev[pi++] ^ input[ii++], y07 = prev[pi++] ^ input[ii++];
    let y08 = prev[pi++] ^ input[ii++], y09 = prev[pi++] ^ input[ii++];
    let y10 = prev[pi++] ^ input[ii++], y11 = prev[pi++] ^ input[ii++];
    let y12 = prev[pi++] ^ input[ii++], y13 = prev[pi++] ^ input[ii++];
    let y14 = prev[pi++] ^ input[ii++], y15 = prev[pi++] ^ input[ii++];
    let x00 = y00, x01 = y01, x02 = y02, x03 = y03, x04 = y04, x05 = y05, x06 = y06, x07 = y07, x08 = y08, x09 = y09, x10 = y10, x11 = y11, x12 = y12, x13 = y13, x14 = y14, x15 = y15;
    for (let i = 0; i < 8; i += 2) {
      x04 ^= rotl2(x00 + x12 | 0, 7);
      x08 ^= rotl2(x04 + x00 | 0, 9);
      x12 ^= rotl2(x08 + x04 | 0, 13);
      x00 ^= rotl2(x12 + x08 | 0, 18);
      x09 ^= rotl2(x05 + x01 | 0, 7);
      x13 ^= rotl2(x09 + x05 | 0, 9);
      x01 ^= rotl2(x13 + x09 | 0, 13);
      x05 ^= rotl2(x01 + x13 | 0, 18);
      x14 ^= rotl2(x10 + x06 | 0, 7);
      x02 ^= rotl2(x14 + x10 | 0, 9);
      x06 ^= rotl2(x02 + x14 | 0, 13);
      x10 ^= rotl2(x06 + x02 | 0, 18);
      x03 ^= rotl2(x15 + x11 | 0, 7);
      x07 ^= rotl2(x03 + x15 | 0, 9);
      x11 ^= rotl2(x07 + x03 | 0, 13);
      x15 ^= rotl2(x11 + x07 | 0, 18);
      x01 ^= rotl2(x00 + x03 | 0, 7);
      x02 ^= rotl2(x01 + x00 | 0, 9);
      x03 ^= rotl2(x02 + x01 | 0, 13);
      x00 ^= rotl2(x03 + x02 | 0, 18);
      x06 ^= rotl2(x05 + x04 | 0, 7);
      x07 ^= rotl2(x06 + x05 | 0, 9);
      x04 ^= rotl2(x07 + x06 | 0, 13);
      x05 ^= rotl2(x04 + x07 | 0, 18);
      x11 ^= rotl2(x10 + x09 | 0, 7);
      x08 ^= rotl2(x11 + x10 | 0, 9);
      x09 ^= rotl2(x08 + x11 | 0, 13);
      x10 ^= rotl2(x09 + x08 | 0, 18);
      x12 ^= rotl2(x15 + x14 | 0, 7);
      x13 ^= rotl2(x12 + x15 | 0, 9);
      x14 ^= rotl2(x13 + x12 | 0, 13);
      x15 ^= rotl2(x14 + x13 | 0, 18);
    }
    out[oi++] = y00 + x00 | 0;
    out[oi++] = y01 + x01 | 0;
    out[oi++] = y02 + x02 | 0;
    out[oi++] = y03 + x03 | 0;
    out[oi++] = y04 + x04 | 0;
    out[oi++] = y05 + x05 | 0;
    out[oi++] = y06 + x06 | 0;
    out[oi++] = y07 + x07 | 0;
    out[oi++] = y08 + x08 | 0;
    out[oi++] = y09 + x09 | 0;
    out[oi++] = y10 + x10 | 0;
    out[oi++] = y11 + x11 | 0;
    out[oi++] = y12 + x12 | 0;
    out[oi++] = y13 + x13 | 0;
    out[oi++] = y14 + x14 | 0;
    out[oi++] = y15 + x15 | 0;
  }
  function BlockMix(input, ii, out, oi, r) {
    let head = oi + 0;
    let tail = oi + 16 * r;
    for (let i = 0; i < 16; i++)
      out[tail + i] = input[ii + (2 * r - 1) * 16 + i];
    for (let i = 0; i < r; i++, head += 16, ii += 16) {
      XorAndSalsa(out, tail, input, ii, out, head);
      if (i > 0)
        tail += 16;
      XorAndSalsa(out, head, input, ii += 16, out, tail);
    }
  }
  function scryptInit(password, salt, _opts) {
    const opts = checkOpts({
      dkLen: 32,
      asyncTick: 10,
      maxmem: 1024 ** 3 + 1024
    }, _opts);
    const { N: N3, r, p, dkLen, asyncTick, maxmem, onProgress } = opts;
    number(N3);
    number(r);
    number(p);
    number(dkLen);
    number(asyncTick);
    number(maxmem);
    if (onProgress !== void 0 && typeof onProgress !== "function")
      throw new Error("progressCb should be function");
    const blockSize = 128 * r;
    const blockSize32 = blockSize / 4;
    if (N3 <= 1 || (N3 & N3 - 1) !== 0 || N3 >= 2 ** (blockSize / 8) || N3 > 2 ** 32) {
      throw new Error("Scrypt: N must be larger than 1, a power of 2, less than 2^(128 * r / 8) and less than 2^32");
    }
    if (p < 0 || p > (2 ** 32 - 1) * 32 / blockSize) {
      throw new Error("Scrypt: p must be a positive integer less than or equal to ((2^32 - 1) * 32) / (128 * r)");
    }
    if (dkLen < 0 || dkLen > (2 ** 32 - 1) * 32) {
      throw new Error("Scrypt: dkLen should be positive integer less than or equal to (2^32 - 1) * 32");
    }
    const memUsed = blockSize * (N3 + p);
    if (memUsed > maxmem) {
      throw new Error(`Scrypt: parameters too large, ${memUsed} (128 * r * (N + p)) > ${maxmem} (maxmem)`);
    }
    const B = pbkdf2(sha256, password, salt, { c: 1, dkLen: blockSize * p });
    const B32 = u32(B);
    const V = u32(new Uint8Array(blockSize * N3));
    const tmp = u32(new Uint8Array(blockSize));
    let blockMixCb = () => {
    };
    if (onProgress) {
      const totalBlockMix = 2 * N3 * p;
      const callbackPer = Math.max(Math.floor(totalBlockMix / 1e4), 1);
      let blockMixCnt = 0;
      blockMixCb = () => {
        blockMixCnt++;
        if (onProgress && (!(blockMixCnt % callbackPer) || blockMixCnt === totalBlockMix))
          onProgress(blockMixCnt / totalBlockMix);
      };
    }
    return { N: N3, r, p, dkLen, blockSize32, V, B32, B, tmp, blockMixCb, asyncTick };
  }
  function scryptOutput(password, dkLen, B, V, tmp) {
    const res = pbkdf2(sha256, password, B, { c: 1, dkLen });
    B.fill(0);
    V.fill(0);
    tmp.fill(0);
    return res;
  }
  function scrypt(password, salt, opts) {
    const { N: N3, r, p, dkLen, blockSize32, V, B32, B, tmp, blockMixCb } = scryptInit(password, salt, opts);
    for (let pi = 0; pi < p; pi++) {
      const Pi2 = blockSize32 * pi;
      for (let i = 0; i < blockSize32; i++)
        V[i] = B32[Pi2 + i];
      for (let i = 0, pos = 0; i < N3 - 1; i++) {
        BlockMix(V, pos, V, pos += blockSize32, r);
        blockMixCb();
      }
      BlockMix(V, (N3 - 1) * blockSize32, B32, Pi2, r);
      blockMixCb();
      for (let i = 0; i < N3; i++) {
        const j = B32[Pi2 + blockSize32 - 16] % N3;
        for (let k = 0; k < blockSize32; k++)
          tmp[k] = B32[Pi2 + k] ^ V[j * blockSize32 + k];
        BlockMix(tmp, 0, B32, Pi2, r);
        blockMixCb();
      }
    }
    return scryptOutput(password, dkLen, B, V, tmp);
  }
  async function scryptAsync(password, salt, opts) {
    const { N: N3, r, p, dkLen, blockSize32, V, B32, B, tmp, blockMixCb, asyncTick } = scryptInit(password, salt, opts);
    for (let pi = 0; pi < p; pi++) {
      const Pi2 = blockSize32 * pi;
      for (let i = 0; i < blockSize32; i++)
        V[i] = B32[Pi2 + i];
      let pos = 0;
      await asyncLoop(N3 - 1, asyncTick, () => {
        BlockMix(V, pos, V, pos += blockSize32, r);
        blockMixCb();
      });
      BlockMix(V, (N3 - 1) * blockSize32, B32, Pi2, r);
      blockMixCb();
      await asyncLoop(N3, asyncTick, () => {
        const j = B32[Pi2 + blockSize32 - 16] % N3;
        for (let k = 0; k < blockSize32; k++)
          tmp[k] = B32[Pi2 + k] ^ V[j * blockSize32 + k];
        BlockMix(tmp, 0, B32, Pi2, r);
        blockMixCb();
      });
    }
    return scryptOutput(password, dkLen, B, V, tmp);
  }
  var rotl2;
  var init_scrypt = __esm({
    "node_modules/@noble/hashes/esm/scrypt.js"() {
      init_assert();
      init_sha256();
      init_pbkdf2();
      init_utils2();
      rotl2 = (a, b2) => a << b2 | a >>> 32 - b2;
    }
  });

  // node_modules/ethers/lib.esm/crypto/scrypt.js
  async function scrypt2(_passwd, _salt, N3, r, p, dkLen, progress) {
    const passwd = getBytes(_passwd, "passwd");
    const salt = getBytes(_salt, "salt");
    return hexlify(await __scryptAsync(passwd, salt, N3, r, p, dkLen, progress));
  }
  function scryptSync(_passwd, _salt, N3, r, p, dkLen) {
    const passwd = getBytes(_passwd, "passwd");
    const salt = getBytes(_salt, "salt");
    return hexlify(__scryptSync(passwd, salt, N3, r, p, dkLen));
  }
  var lockedSync, lockedAsync, _scryptAsync, _scryptSync, __scryptAsync, __scryptSync;
  var init_scrypt2 = __esm({
    "node_modules/ethers/lib.esm/crypto/scrypt.js"() {
      init_scrypt();
      init_utils();
      lockedSync = false;
      lockedAsync = false;
      _scryptAsync = async function(passwd, salt, N3, r, p, dkLen, onProgress) {
        return await scryptAsync(passwd, salt, { N: N3, r, p, dkLen, onProgress });
      };
      _scryptSync = function(passwd, salt, N3, r, p, dkLen) {
        return scrypt(passwd, salt, { N: N3, r, p, dkLen });
      };
      __scryptAsync = _scryptAsync;
      __scryptSync = _scryptSync;
      scrypt2._ = _scryptAsync;
      scrypt2.lock = function() {
        lockedAsync = true;
      };
      scrypt2.register = function(func) {
        if (lockedAsync) {
          throw new Error("scrypt is locked");
        }
        __scryptAsync = func;
      };
      Object.freeze(scrypt2);
      scryptSync._ = _scryptSync;
      scryptSync.lock = function() {
        lockedSync = true;
      };
      scryptSync.register = function(func) {
        if (lockedSync) {
          throw new Error("scryptSync is locked");
        }
        __scryptSync = func;
      };
      Object.freeze(scryptSync);
    }
  });

  // node_modules/ethers/lib.esm/crypto/sha2.js
  function sha2562(_data5) {
    const data = getBytes(_data5, "data");
    return hexlify(__sha256(data));
  }
  function sha5122(_data5) {
    const data = getBytes(_data5, "data");
    return hexlify(__sha512(data));
  }
  var _sha256, _sha512, __sha256, __sha512, locked256, locked512;
  var init_sha22 = __esm({
    "node_modules/ethers/lib.esm/crypto/sha2.js"() {
      init_crypto_browser();
      init_utils();
      _sha256 = function(data) {
        return createHash("sha256").update(data).digest();
      };
      _sha512 = function(data) {
        return createHash("sha512").update(data).digest();
      };
      __sha256 = _sha256;
      __sha512 = _sha512;
      locked256 = false;
      locked512 = false;
      sha2562._ = _sha256;
      sha2562.lock = function() {
        locked256 = true;
      };
      sha2562.register = function(func) {
        if (locked256) {
          throw new Error("sha256 is locked");
        }
        __sha256 = func;
      };
      Object.freeze(sha2562);
      sha5122._ = _sha512;
      sha5122.lock = function() {
        locked512 = true;
      };
      sha5122.register = function(func) {
        if (locked512) {
          throw new Error("sha512 is locked");
        }
        __sha512 = func;
      };
      Object.freeze(sha2562);
    }
  });

  // node_modules/@noble/curves/esm/abstract/utils.js
  var utils_exports = {};
  __export(utils_exports, {
    bitGet: () => bitGet,
    bitLen: () => bitLen,
    bitMask: () => bitMask,
    bitSet: () => bitSet,
    bytesToHex: () => bytesToHex,
    bytesToNumberBE: () => bytesToNumberBE,
    bytesToNumberLE: () => bytesToNumberLE,
    concatBytes: () => concatBytes2,
    createHmacDrbg: () => createHmacDrbg,
    ensureBytes: () => ensureBytes,
    equalBytes: () => equalBytes,
    hexToBytes: () => hexToBytes,
    hexToNumber: () => hexToNumber,
    numberToBytesBE: () => numberToBytesBE,
    numberToBytesLE: () => numberToBytesLE,
    numberToHexUnpadded: () => numberToHexUnpadded,
    numberToVarBytesBE: () => numberToVarBytesBE,
    utf8ToBytes: () => utf8ToBytes2,
    validateObject: () => validateObject
  });
  function bytesToHex(bytes2) {
    if (!u8a2(bytes2))
      throw new Error("Uint8Array expected");
    let hex = "";
    for (let i = 0; i < bytes2.length; i++) {
      hex += hexes[bytes2[i]];
    }
    return hex;
  }
  function numberToHexUnpadded(num2) {
    const hex = num2.toString(16);
    return hex.length & 1 ? `0${hex}` : hex;
  }
  function hexToNumber(hex) {
    if (typeof hex !== "string")
      throw new Error("hex string expected, got " + typeof hex);
    return BigInt(hex === "" ? "0" : `0x${hex}`);
  }
  function hexToBytes(hex) {
    if (typeof hex !== "string")
      throw new Error("hex string expected, got " + typeof hex);
    const len = hex.length;
    if (len % 2)
      throw new Error("padded hex string expected, got unpadded hex of length " + len);
    const array = new Uint8Array(len / 2);
    for (let i = 0; i < array.length; i++) {
      const j = i * 2;
      const hexByte = hex.slice(j, j + 2);
      const byte = Number.parseInt(hexByte, 16);
      if (Number.isNaN(byte) || byte < 0)
        throw new Error("Invalid byte sequence");
      array[i] = byte;
    }
    return array;
  }
  function bytesToNumberBE(bytes2) {
    return hexToNumber(bytesToHex(bytes2));
  }
  function bytesToNumberLE(bytes2) {
    if (!u8a2(bytes2))
      throw new Error("Uint8Array expected");
    return hexToNumber(bytesToHex(Uint8Array.from(bytes2).reverse()));
  }
  function numberToBytesBE(n2, len) {
    return hexToBytes(n2.toString(16).padStart(len * 2, "0"));
  }
  function numberToBytesLE(n2, len) {
    return numberToBytesBE(n2, len).reverse();
  }
  function numberToVarBytesBE(n2) {
    return hexToBytes(numberToHexUnpadded(n2));
  }
  function ensureBytes(title, hex, expectedLength) {
    let res;
    if (typeof hex === "string") {
      try {
        res = hexToBytes(hex);
      } catch (e) {
        throw new Error(`${title} must be valid hex string, got "${hex}". Cause: ${e}`);
      }
    } else if (u8a2(hex)) {
      res = Uint8Array.from(hex);
    } else {
      throw new Error(`${title} must be hex string or Uint8Array`);
    }
    const len = res.length;
    if (typeof expectedLength === "number" && len !== expectedLength)
      throw new Error(`${title} expected ${expectedLength} bytes, got ${len}`);
    return res;
  }
  function concatBytes2(...arrays) {
    const r = new Uint8Array(arrays.reduce((sum, a) => sum + a.length, 0));
    let pad4 = 0;
    arrays.forEach((a) => {
      if (!u8a2(a))
        throw new Error("Uint8Array expected");
      r.set(a, pad4);
      pad4 += a.length;
    });
    return r;
  }
  function equalBytes(b1, b2) {
    if (b1.length !== b2.length)
      return false;
    for (let i = 0; i < b1.length; i++)
      if (b1[i] !== b2[i])
        return false;
    return true;
  }
  function utf8ToBytes2(str) {
    if (typeof str !== "string")
      throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
    return new Uint8Array(new TextEncoder().encode(str));
  }
  function bitLen(n2) {
    let len;
    for (len = 0; n2 > _0n2; n2 >>= _1n2, len += 1)
      ;
    return len;
  }
  function bitGet(n2, pos) {
    return n2 >> BigInt(pos) & _1n2;
  }
  function createHmacDrbg(hashLen, qByteLen, hmacFn) {
    if (typeof hashLen !== "number" || hashLen < 2)
      throw new Error("hashLen must be a number");
    if (typeof qByteLen !== "number" || qByteLen < 2)
      throw new Error("qByteLen must be a number");
    if (typeof hmacFn !== "function")
      throw new Error("hmacFn must be a function");
    let v = u8n(hashLen);
    let k = u8n(hashLen);
    let i = 0;
    const reset = () => {
      v.fill(1);
      k.fill(0);
      i = 0;
    };
    const h = (...b2) => hmacFn(k, v, ...b2);
    const reseed = (seed = u8n()) => {
      k = h(u8fr([0]), seed);
      v = h();
      if (seed.length === 0)
        return;
      k = h(u8fr([1]), seed);
      v = h();
    };
    const gen4 = () => {
      if (i++ >= 1e3)
        throw new Error("drbg: tried 1000 values");
      let len = 0;
      const out = [];
      while (len < qByteLen) {
        v = h();
        const sl = v.slice();
        out.push(sl);
        len += v.length;
      }
      return concatBytes2(...out);
    };
    const genUntil = (seed, pred) => {
      reset();
      reseed(seed);
      let res = void 0;
      while (!(res = pred(gen4())))
        reseed();
      reset();
      return res;
    };
    return genUntil;
  }
  function validateObject(object2, validators, optValidators = {}) {
    const checkField = (fieldName, type, isOptional) => {
      const checkVal = validatorFns[type];
      if (typeof checkVal !== "function")
        throw new Error(`Invalid validator "${type}", expected function`);
      const val = object2[fieldName];
      if (isOptional && val === void 0)
        return;
      if (!checkVal(val, object2)) {
        throw new Error(`Invalid param ${String(fieldName)}=${val} (${typeof val}), expected ${type}`);
      }
    };
    for (const [fieldName, type] of Object.entries(validators))
      checkField(fieldName, type, false);
    for (const [fieldName, type] of Object.entries(optValidators))
      checkField(fieldName, type, true);
    return object2;
  }
  var _0n2, _1n2, _2n2, u8a2, hexes, bitSet, bitMask, u8n, u8fr, validatorFns;
  var init_utils3 = __esm({
    "node_modules/@noble/curves/esm/abstract/utils.js"() {
      _0n2 = BigInt(0);
      _1n2 = BigInt(1);
      _2n2 = BigInt(2);
      u8a2 = (a) => a instanceof Uint8Array;
      hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, "0"));
      bitSet = (n2, pos, value) => {
        return n2 | (value ? _1n2 : _0n2) << BigInt(pos);
      };
      bitMask = (n2) => (_2n2 << BigInt(n2 - 1)) - _1n2;
      u8n = (data) => new Uint8Array(data);
      u8fr = (arr) => Uint8Array.from(arr);
      validatorFns = {
        bigint: (val) => typeof val === "bigint",
        function: (val) => typeof val === "function",
        boolean: (val) => typeof val === "boolean",
        string: (val) => typeof val === "string",
        stringOrUint8Array: (val) => typeof val === "string" || val instanceof Uint8Array,
        isSafeInteger: (val) => Number.isSafeInteger(val),
        array: (val) => Array.isArray(val),
        field: (val, object2) => object2.Fp.isValid(val),
        hash: (val) => typeof val === "function" && Number.isSafeInteger(val.outputLen)
      };
    }
  });

  // node_modules/@noble/curves/esm/abstract/modular.js
  function mod(a, b2) {
    const result = a % b2;
    return result >= _0n3 ? result : b2 + result;
  }
  function pow(num2, power, modulo) {
    if (modulo <= _0n3 || power < _0n3)
      throw new Error("Expected power/modulo > 0");
    if (modulo === _1n3)
      return _0n3;
    let res = _1n3;
    while (power > _0n3) {
      if (power & _1n3)
        res = res * num2 % modulo;
      num2 = num2 * num2 % modulo;
      power >>= _1n3;
    }
    return res;
  }
  function pow2(x, power, modulo) {
    let res = x;
    while (power-- > _0n3) {
      res *= res;
      res %= modulo;
    }
    return res;
  }
  function invert(number2, modulo) {
    if (number2 === _0n3 || modulo <= _0n3) {
      throw new Error(`invert: expected positive integers, got n=${number2} mod=${modulo}`);
    }
    let a = mod(number2, modulo);
    let b2 = modulo;
    let x = _0n3, y = _1n3, u = _1n3, v = _0n3;
    while (a !== _0n3) {
      const q = b2 / a;
      const r = b2 % a;
      const m = x - u * q;
      const n2 = y - v * q;
      b2 = a, a = r, x = u, y = v, u = m, v = n2;
    }
    const gcd = b2;
    if (gcd !== _1n3)
      throw new Error("invert: does not exist");
    return mod(x, modulo);
  }
  function tonelliShanks(P) {
    const legendreC = (P - _1n3) / _2n3;
    let Q, S2, Z;
    for (Q = P - _1n3, S2 = 0; Q % _2n3 === _0n3; Q /= _2n3, S2++)
      ;
    for (Z = _2n3; Z < P && pow(Z, legendreC, P) !== P - _1n3; Z++)
      ;
    if (S2 === 1) {
      const p1div4 = (P + _1n3) / _4n;
      return function tonelliFast(Fp2, n2) {
        const root = Fp2.pow(n2, p1div4);
        if (!Fp2.eql(Fp2.sqr(root), n2))
          throw new Error("Cannot find square root");
        return root;
      };
    }
    const Q1div2 = (Q + _1n3) / _2n3;
    return function tonelliSlow(Fp2, n2) {
      if (Fp2.pow(n2, legendreC) === Fp2.neg(Fp2.ONE))
        throw new Error("Cannot find square root");
      let r = S2;
      let g = Fp2.pow(Fp2.mul(Fp2.ONE, Z), Q);
      let x = Fp2.pow(n2, Q1div2);
      let b2 = Fp2.pow(n2, Q);
      while (!Fp2.eql(b2, Fp2.ONE)) {
        if (Fp2.eql(b2, Fp2.ZERO))
          return Fp2.ZERO;
        let m = 1;
        for (let t2 = Fp2.sqr(b2); m < r; m++) {
          if (Fp2.eql(t2, Fp2.ONE))
            break;
          t2 = Fp2.sqr(t2);
        }
        const ge = Fp2.pow(g, _1n3 << BigInt(r - m - 1));
        g = Fp2.sqr(ge);
        x = Fp2.mul(x, ge);
        b2 = Fp2.mul(b2, g);
        r = m;
      }
      return x;
    };
  }
  function FpSqrt(P) {
    if (P % _4n === _3n) {
      const p1div4 = (P + _1n3) / _4n;
      return function sqrt3mod42(Fp2, n2) {
        const root = Fp2.pow(n2, p1div4);
        if (!Fp2.eql(Fp2.sqr(root), n2))
          throw new Error("Cannot find square root");
        return root;
      };
    }
    if (P % _8n === _5n) {
      const c1 = (P - _5n) / _8n;
      return function sqrt5mod82(Fp2, n2) {
        const n22 = Fp2.mul(n2, _2n3);
        const v = Fp2.pow(n22, c1);
        const nv = Fp2.mul(n2, v);
        const i = Fp2.mul(Fp2.mul(nv, _2n3), v);
        const root = Fp2.mul(nv, Fp2.sub(i, Fp2.ONE));
        if (!Fp2.eql(Fp2.sqr(root), n2))
          throw new Error("Cannot find square root");
        return root;
      };
    }
    if (P % _16n === _9n) {
    }
    return tonelliShanks(P);
  }
  function validateField(field) {
    const initial = {
      ORDER: "bigint",
      MASK: "bigint",
      BYTES: "isSafeInteger",
      BITS: "isSafeInteger"
    };
    const opts = FIELD_FIELDS.reduce((map, val) => {
      map[val] = "function";
      return map;
    }, initial);
    return validateObject(field, opts);
  }
  function FpPow(f2, num2, power) {
    if (power < _0n3)
      throw new Error("Expected power > 0");
    if (power === _0n3)
      return f2.ONE;
    if (power === _1n3)
      return num2;
    let p = f2.ONE;
    let d = num2;
    while (power > _0n3) {
      if (power & _1n3)
        p = f2.mul(p, d);
      d = f2.sqr(d);
      power >>= _1n3;
    }
    return p;
  }
  function FpInvertBatch(f2, nums) {
    const tmp = new Array(nums.length);
    const lastMultiplied = nums.reduce((acc, num2, i) => {
      if (f2.is0(num2))
        return acc;
      tmp[i] = acc;
      return f2.mul(acc, num2);
    }, f2.ONE);
    const inverted = f2.inv(lastMultiplied);
    nums.reduceRight((acc, num2, i) => {
      if (f2.is0(num2))
        return acc;
      tmp[i] = f2.mul(acc, tmp[i]);
      return f2.mul(acc, num2);
    }, inverted);
    return tmp;
  }
  function nLength(n2, nBitLength) {
    const _nBitLength = nBitLength !== void 0 ? nBitLength : n2.toString(2).length;
    const nByteLength = Math.ceil(_nBitLength / 8);
    return { nBitLength: _nBitLength, nByteLength };
  }
  function Field(ORDER, bitLen3, isLE4 = false, redef = {}) {
    if (ORDER <= _0n3)
      throw new Error(`Expected Field ORDER > 0, got ${ORDER}`);
    const { nBitLength: BITS, nByteLength: BYTES } = nLength(ORDER, bitLen3);
    if (BYTES > 2048)
      throw new Error("Field lengths over 2048 bytes are not supported");
    const sqrtP = FpSqrt(ORDER);
    const f2 = Object.freeze({
      ORDER,
      BITS,
      BYTES,
      MASK: bitMask(BITS),
      ZERO: _0n3,
      ONE: _1n3,
      create: (num2) => mod(num2, ORDER),
      isValid: (num2) => {
        if (typeof num2 !== "bigint")
          throw new Error(`Invalid field element: expected bigint, got ${typeof num2}`);
        return _0n3 <= num2 && num2 < ORDER;
      },
      is0: (num2) => num2 === _0n3,
      isOdd: (num2) => (num2 & _1n3) === _1n3,
      neg: (num2) => mod(-num2, ORDER),
      eql: (lhs, rhs) => lhs === rhs,
      sqr: (num2) => mod(num2 * num2, ORDER),
      add: (lhs, rhs) => mod(lhs + rhs, ORDER),
      sub: (lhs, rhs) => mod(lhs - rhs, ORDER),
      mul: (lhs, rhs) => mod(lhs * rhs, ORDER),
      pow: (num2, power) => FpPow(f2, num2, power),
      div: (lhs, rhs) => mod(lhs * invert(rhs, ORDER), ORDER),
      // Same as above, but doesn't normalize
      sqrN: (num2) => num2 * num2,
      addN: (lhs, rhs) => lhs + rhs,
      subN: (lhs, rhs) => lhs - rhs,
      mulN: (lhs, rhs) => lhs * rhs,
      inv: (num2) => invert(num2, ORDER),
      sqrt: redef.sqrt || ((n2) => sqrtP(f2, n2)),
      invertBatch: (lst) => FpInvertBatch(f2, lst),
      // TODO: do we really need constant cmov?
      // We don't have const-time bigints anyway, so probably will be not very useful
      cmov: (a, b2, c) => c ? b2 : a,
      toBytes: (num2) => isLE4 ? numberToBytesLE(num2, BYTES) : numberToBytesBE(num2, BYTES),
      fromBytes: (bytes2) => {
        if (bytes2.length !== BYTES)
          throw new Error(`Fp.fromBytes: expected ${BYTES}, got ${bytes2.length}`);
        return isLE4 ? bytesToNumberLE(bytes2) : bytesToNumberBE(bytes2);
      }
    });
    return Object.freeze(f2);
  }
  function getFieldBytesLength(fieldOrder) {
    if (typeof fieldOrder !== "bigint")
      throw new Error("field order must be bigint");
    const bitLength = fieldOrder.toString(2).length;
    return Math.ceil(bitLength / 8);
  }
  function getMinHashLength(fieldOrder) {
    const length = getFieldBytesLength(fieldOrder);
    return length + Math.ceil(length / 2);
  }
  function mapHashToField(key, fieldOrder, isLE4 = false) {
    const len = key.length;
    const fieldLen = getFieldBytesLength(fieldOrder);
    const minLen = getMinHashLength(fieldOrder);
    if (len < 16 || len < minLen || len > 1024)
      throw new Error(`expected ${minLen}-1024 bytes of input, got ${len}`);
    const num2 = isLE4 ? bytesToNumberBE(key) : bytesToNumberLE(key);
    const reduced = mod(num2, fieldOrder - _1n3) + _1n3;
    return isLE4 ? numberToBytesLE(reduced, fieldLen) : numberToBytesBE(reduced, fieldLen);
  }
  var _0n3, _1n3, _2n3, _3n, _4n, _5n, _8n, _9n, _16n, FIELD_FIELDS;
  var init_modular = __esm({
    "node_modules/@noble/curves/esm/abstract/modular.js"() {
      init_utils3();
      _0n3 = BigInt(0);
      _1n3 = BigInt(1);
      _2n3 = BigInt(2);
      _3n = BigInt(3);
      _4n = BigInt(4);
      _5n = BigInt(5);
      _8n = BigInt(8);
      _9n = BigInt(9);
      _16n = BigInt(16);
      FIELD_FIELDS = [
        "create",
        "isValid",
        "is0",
        "neg",
        "inv",
        "sqrt",
        "sqr",
        "eql",
        "add",
        "sub",
        "mul",
        "pow",
        "div",
        "addN",
        "subN",
        "mulN",
        "sqrN"
      ];
    }
  });

  // node_modules/@noble/curves/esm/abstract/curve.js
  function wNAF(c, bits) {
    const constTimeNegate = (condition, item) => {
      const neg = item.negate();
      return condition ? neg : item;
    };
    const opts = (W) => {
      const windows = Math.ceil(bits / W) + 1;
      const windowSize = 2 ** (W - 1);
      return { windows, windowSize };
    };
    return {
      constTimeNegate,
      // non-const time multiplication ladder
      unsafeLadder(elm, n2) {
        let p = c.ZERO;
        let d = elm;
        while (n2 > _0n4) {
          if (n2 & _1n4)
            p = p.add(d);
          d = d.double();
          n2 >>= _1n4;
        }
        return p;
      },
      /**
       * Creates a wNAF precomputation window. Used for caching.
       * Default window size is set by `utils.precompute()` and is equal to 8.
       * Number of precomputed points depends on the curve size:
       * 2^(1) * (Math.ceil( / ) + 1), where:
       * -  is the window size
       * -  is the bitlength of the curve order.
       * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.
       * @returns precomputed point tables flattened to a single array
       */
      precomputeWindow(elm, W) {
        const { windows, windowSize } = opts(W);
        const points = [];
        let p = elm;
        let base = p;
        for (let window2 = 0; window2 < windows; window2++) {
          base = p;
          points.push(base);
          for (let i = 1; i < windowSize; i++) {
            base = base.add(p);
            points.push(base);
          }
          p = base.double();
        }
        return points;
      },
      /**
       * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.
       * @param W window size
       * @param precomputes precomputed tables
       * @param n scalar (we don't check here, but should be less than curve order)
       * @returns real and fake (for const-time) points
       */
      wNAF(W, precomputes, n2) {
        const { windows, windowSize } = opts(W);
        let p = c.ZERO;
        let f2 = c.BASE;
        const mask2 = BigInt(2 ** W - 1);
        const maxNumber = 2 ** W;
        const shiftBy = BigInt(W);
        for (let window2 = 0; window2 < windows; window2++) {
          const offset = window2 * windowSize;
          let wbits = Number(n2 & mask2);
          n2 >>= shiftBy;
          if (wbits > windowSize) {
            wbits -= maxNumber;
            n2 += _1n4;
          }
          const offset1 = offset;
          const offset2 = offset + Math.abs(wbits) - 1;
          const cond1 = window2 % 2 !== 0;
          const cond2 = wbits < 0;
          if (wbits === 0) {
            f2 = f2.add(constTimeNegate(cond1, precomputes[offset1]));
          } else {
            p = p.add(constTimeNegate(cond2, precomputes[offset2]));
          }
        }
        return { p, f: f2 };
      },
      wNAFCached(P, precomputesMap, n2, transform) {
        const W = P._WINDOW_SIZE || 1;
        let comp = precomputesMap.get(P);
        if (!comp) {
          comp = this.precomputeWindow(P, W);
          if (W !== 1) {
            precomputesMap.set(P, transform(comp));
          }
        }
        return this.wNAF(W, comp, n2);
      }
    };
  }
  function validateBasic(curve) {
    validateField(curve.Fp);
    validateObject(curve, {
      n: "bigint",
      h: "bigint",
      Gx: "field",
      Gy: "field"
    }, {
      nBitLength: "isSafeInteger",
      nByteLength: "isSafeInteger"
    });
    return Object.freeze({
      ...nLength(curve.n, curve.nBitLength),
      ...curve,
      ...{ p: curve.Fp.ORDER }
    });
  }
  var _0n4, _1n4;
  var init_curve = __esm({
    "node_modules/@noble/curves/esm/abstract/curve.js"() {
      init_modular();
      init_utils3();
      _0n4 = BigInt(0);
      _1n4 = BigInt(1);
    }
  });

  // node_modules/@noble/curves/esm/abstract/weierstrass.js
  function validatePointOpts(curve) {
    const opts = validateBasic(curve);
    validateObject(opts, {
      a: "field",
      b: "field"
    }, {
      allowedPrivateKeyLengths: "array",
      wrapPrivateKey: "boolean",
      isTorsionFree: "function",
      clearCofactor: "function",
      allowInfinityPoint: "boolean",
      fromBytes: "function",
      toBytes: "function"
    });
    const { endo, Fp: Fp2, a } = opts;
    if (endo) {
      if (!Fp2.eql(a, Fp2.ZERO)) {
        throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");
      }
      if (typeof endo !== "object" || typeof endo.beta !== "bigint" || typeof endo.splitScalar !== "function") {
        throw new Error("Expected endomorphism with beta: bigint and splitScalar: function");
      }
    }
    return Object.freeze({ ...opts });
  }
  function weierstrassPoints(opts) {
    const CURVE = validatePointOpts(opts);
    const { Fp: Fp2 } = CURVE;
    const toBytes5 = CURVE.toBytes || ((_c, point, _isCompressed) => {
      const a = point.toAffine();
      return concatBytes2(Uint8Array.from([4]), Fp2.toBytes(a.x), Fp2.toBytes(a.y));
    });
    const fromBytes2 = CURVE.fromBytes || ((bytes2) => {
      const tail = bytes2.subarray(1);
      const x = Fp2.fromBytes(tail.subarray(0, Fp2.BYTES));
      const y = Fp2.fromBytes(tail.subarray(Fp2.BYTES, 2 * Fp2.BYTES));
      return { x, y };
    });
    function weierstrassEquation(x) {
      const { a, b: b2 } = CURVE;
      const x2 = Fp2.sqr(x);
      const x3 = Fp2.mul(x2, x);
      return Fp2.add(Fp2.add(x3, Fp2.mul(x, a)), b2);
    }
    if (!Fp2.eql(Fp2.sqr(CURVE.Gy), weierstrassEquation(CURVE.Gx)))
      throw new Error("bad generator point: equation left != right");
    function isWithinCurveOrder(num2) {
      return typeof num2 === "bigint" && _0n5 < num2 && num2 < CURVE.n;
    }
    function assertGE(num2) {
      if (!isWithinCurveOrder(num2))
        throw new Error("Expected valid bigint: 0 < bigint < curve.n");
    }
    function normPrivateKeyToScalar(key) {
      const { allowedPrivateKeyLengths: lengths, nByteLength, wrapPrivateKey, n: n2 } = CURVE;
      if (lengths && typeof key !== "bigint") {
        if (key instanceof Uint8Array)
          key = bytesToHex(key);
        if (typeof key !== "string" || !lengths.includes(key.length))
          throw new Error("Invalid key");
        key = key.padStart(nByteLength * 2, "0");
      }
      let num2;
      try {
        num2 = typeof key === "bigint" ? key : bytesToNumberBE(ensureBytes("private key", key, nByteLength));
      } catch (error) {
        throw new Error(`private key must be ${nByteLength} bytes, hex or bigint, not ${typeof key}`);
      }
      if (wrapPrivateKey)
        num2 = mod(num2, n2);
      assertGE(num2);
      return num2;
    }
    const pointPrecomputes2 = /* @__PURE__ */ new Map();
    function assertPrjPoint(other) {
      if (!(other instanceof Point3))
        throw new Error("ProjectivePoint expected");
    }
    class Point3 {
      constructor(px, py, pz) {
        this.px = px;
        this.py = py;
        this.pz = pz;
        if (px == null || !Fp2.isValid(px))
          throw new Error("x required");
        if (py == null || !Fp2.isValid(py))
          throw new Error("y required");
        if (pz == null || !Fp2.isValid(pz))
          throw new Error("z required");
      }
      // Does not validate if the point is on-curve.
      // Use fromHex instead, or call assertValidity() later.
      static fromAffine(p) {
        const { x, y } = p || {};
        if (!p || !Fp2.isValid(x) || !Fp2.isValid(y))
          throw new Error("invalid affine point");
        if (p instanceof Point3)
          throw new Error("projective point not allowed");
        const is0 = (i) => Fp2.eql(i, Fp2.ZERO);
        if (is0(x) && is0(y))
          return Point3.ZERO;
        return new Point3(x, y, Fp2.ONE);
      }
      get x() {
        return this.toAffine().x;
      }
      get y() {
        return this.toAffine().y;
      }
      /**
       * Takes a bunch of Projective Points but executes only one
       * inversion on all of them. Inversion is very slow operation,
       * so this improves performance massively.
       * Optimization: converts a list of projective points to a list of identical points with Z=1.
       */
      static normalizeZ(points) {
        const toInv = Fp2.invertBatch(points.map((p) => p.pz));
        return points.map((p, i) => p.toAffine(toInv[i])).map(Point3.fromAffine);
      }
      /**
       * Converts hash string or Uint8Array to Point.
       * @param hex short/long ECDSA hex
       */
      static fromHex(hex) {
        const P = Point3.fromAffine(fromBytes2(ensureBytes("pointHex", hex)));
        P.assertValidity();
        return P;
      }
      // Multiplies generator point by privateKey.
      static fromPrivateKey(privateKey) {
        return Point3.BASE.multiply(normPrivateKeyToScalar(privateKey));
      }
      // "Private method", don't use it directly
      _setWindowSize(windowSize) {
        this._WINDOW_SIZE = windowSize;
        pointPrecomputes2.delete(this);
      }
      // A point on curve is valid if it conforms to equation.
      assertValidity() {
        if (this.is0()) {
          if (CURVE.allowInfinityPoint && !Fp2.is0(this.py))
            return;
          throw new Error("bad point: ZERO");
        }
        const { x, y } = this.toAffine();
        if (!Fp2.isValid(x) || !Fp2.isValid(y))
          throw new Error("bad point: x or y not FE");
        const left = Fp2.sqr(y);
        const right = weierstrassEquation(x);
        if (!Fp2.eql(left, right))
          throw new Error("bad point: equation left != right");
        if (!this.isTorsionFree())
          throw new Error("bad point: not in prime-order subgroup");
      }
      hasEvenY() {
        const { y } = this.toAffine();
        if (Fp2.isOdd)
          return !Fp2.isOdd(y);
        throw new Error("Field doesn't support isOdd");
      }
      /**
       * Compare one point to another.
       */
      equals(other) {
        assertPrjPoint(other);
        const { px: X1, py: Y1, pz: Z1 } = this;
        const { px: X2, py: Y2, pz: Z2 } = other;
        const U12 = Fp2.eql(Fp2.mul(X1, Z2), Fp2.mul(X2, Z1));
        const U22 = Fp2.eql(Fp2.mul(Y1, Z2), Fp2.mul(Y2, Z1));
        return U12 && U22;
      }
      /**
       * Flips point to one corresponding to (x, -y) in Affine coordinates.
       */
      negate() {
        return new Point3(this.px, Fp2.neg(this.py), this.pz);
      }
      // Renes-Costello-Batina exception-free doubling formula.
      // There is 30% faster Jacobian formula, but it is not complete.
      // https://eprint.iacr.org/2015/1060, algorithm 3
      // Cost: 8M + 3S + 3*a + 2*b3 + 15add.
      double() {
        const { a, b: b2 } = CURVE;
        const b3 = Fp2.mul(b2, _3n2);
        const { px: X1, py: Y1, pz: Z1 } = this;
        let X3 = Fp2.ZERO, Y3 = Fp2.ZERO, Z3 = Fp2.ZERO;
        let t0 = Fp2.mul(X1, X1);
        let t1 = Fp2.mul(Y1, Y1);
        let t2 = Fp2.mul(Z1, Z1);
        let t3 = Fp2.mul(X1, Y1);
        t3 = Fp2.add(t3, t3);
        Z3 = Fp2.mul(X1, Z1);
        Z3 = Fp2.add(Z3, Z3);
        X3 = Fp2.mul(a, Z3);
        Y3 = Fp2.mul(b3, t2);
        Y3 = Fp2.add(X3, Y3);
        X3 = Fp2.sub(t1, Y3);
        Y3 = Fp2.add(t1, Y3);
        Y3 = Fp2.mul(X3, Y3);
        X3 = Fp2.mul(t3, X3);
        Z3 = Fp2.mul(b3, Z3);
        t2 = Fp2.mul(a, t2);
        t3 = Fp2.sub(t0, t2);
        t3 = Fp2.mul(a, t3);
        t3 = Fp2.add(t3, Z3);
        Z3 = Fp2.add(t0, t0);
        t0 = Fp2.add(Z3, t0);
        t0 = Fp2.add(t0, t2);
        t0 = Fp2.mul(t0, t3);
        Y3 = Fp2.add(Y3, t0);
        t2 = Fp2.mul(Y1, Z1);
        t2 = Fp2.add(t2, t2);
        t0 = Fp2.mul(t2, t3);
        X3 = Fp2.sub(X3, t0);
        Z3 = Fp2.mul(t2, t1);
        Z3 = Fp2.add(Z3, Z3);
        Z3 = Fp2.add(Z3, Z3);
        return new Point3(X3, Y3, Z3);
      }
      // Renes-Costello-Batina exception-free addition formula.
      // There is 30% faster Jacobian formula, but it is not complete.
      // https://eprint.iacr.org/2015/1060, algorithm 1
      // Cost: 12M + 0S + 3*a + 3*b3 + 23add.
      add(other) {
        assertPrjPoint(other);
        const { px: X1, py: Y1, pz: Z1 } = this;
        const { px: X2, py: Y2, pz: Z2 } = other;
        let X3 = Fp2.ZERO, Y3 = Fp2.ZERO, Z3 = Fp2.ZERO;
        const a = CURVE.a;
        const b3 = Fp2.mul(CURVE.b, _3n2);
        let t0 = Fp2.mul(X1, X2);
        let t1 = Fp2.mul(Y1, Y2);
        let t2 = Fp2.mul(Z1, Z2);
        let t3 = Fp2.add(X1, Y1);
        let t4 = Fp2.add(X2, Y2);
        t3 = Fp2.mul(t3, t4);
        t4 = Fp2.add(t0, t1);
        t3 = Fp2.sub(t3, t4);
        t4 = Fp2.add(X1, Z1);
        let t5 = Fp2.add(X2, Z2);
        t4 = Fp2.mul(t4, t5);
        t5 = Fp2.add(t0, t2);
        t4 = Fp2.sub(t4, t5);
        t5 = Fp2.add(Y1, Z1);
        X3 = Fp2.add(Y2, Z2);
        t5 = Fp2.mul(t5, X3);
        X3 = Fp2.add(t1, t2);
        t5 = Fp2.sub(t5, X3);
        Z3 = Fp2.mul(a, t4);
        X3 = Fp2.mul(b3, t2);
        Z3 = Fp2.add(X3, Z3);
        X3 = Fp2.sub(t1, Z3);
        Z3 = Fp2.add(t1, Z3);
        Y3 = Fp2.mul(X3, Z3);
        t1 = Fp2.add(t0, t0);
        t1 = Fp2.add(t1, t0);
        t2 = Fp2.mul(a, t2);
        t4 = Fp2.mul(b3, t4);
        t1 = Fp2.add(t1, t2);
        t2 = Fp2.sub(t0, t2);
        t2 = Fp2.mul(a, t2);
        t4 = Fp2.add(t4, t2);
        t0 = Fp2.mul(t1, t4);
        Y3 = Fp2.add(Y3, t0);
        t0 = Fp2.mul(t5, t4);
        X3 = Fp2.mul(t3, X3);
        X3 = Fp2.sub(X3, t0);
        t0 = Fp2.mul(t3, t1);
        Z3 = Fp2.mul(t5, Z3);
        Z3 = Fp2.add(Z3, t0);
        return new Point3(X3, Y3, Z3);
      }
      subtract(other) {
        return this.add(other.negate());
      }
      is0() {
        return this.equals(Point3.ZERO);
      }
      wNAF(n2) {
        return wnaf.wNAFCached(this, pointPrecomputes2, n2, (comp) => {
          const toInv = Fp2.invertBatch(comp.map((p) => p.pz));
          return comp.map((p, i) => p.toAffine(toInv[i])).map(Point3.fromAffine);
        });
      }
      /**
       * Non-constant-time multiplication. Uses double-and-add algorithm.
       * It's faster, but should only be used when you don't care about
       * an exposed private key e.g. sig verification, which works over *public* keys.
       */
      multiplyUnsafe(n2) {
        const I = Point3.ZERO;
        if (n2 === _0n5)
          return I;
        assertGE(n2);
        if (n2 === _1n5)
          return this;
        const { endo } = CURVE;
        if (!endo)
          return wnaf.unsafeLadder(this, n2);
        let { k1neg, k1, k2neg, k2 } = endo.splitScalar(n2);
        let k1p = I;
        let k2p = I;
        let d = this;
        while (k1 > _0n5 || k2 > _0n5) {
          if (k1 & _1n5)
            k1p = k1p.add(d);
          if (k2 & _1n5)
            k2p = k2p.add(d);
          d = d.double();
          k1 >>= _1n5;
          k2 >>= _1n5;
        }
        if (k1neg)
          k1p = k1p.negate();
        if (k2neg)
          k2p = k2p.negate();
        k2p = new Point3(Fp2.mul(k2p.px, endo.beta), k2p.py, k2p.pz);
        return k1p.add(k2p);
      }
      /**
       * Constant time multiplication.
       * Uses wNAF method. Windowed method may be 10% faster,
       * but takes 2x longer to generate and consumes 2x memory.
       * Uses precomputes when available.
       * Uses endomorphism for Koblitz curves.
       * @param scalar by which the point would be multiplied
       * @returns New point
       */
      multiply(scalar) {
        assertGE(scalar);
        let n2 = scalar;
        let point, fake;
        const { endo } = CURVE;
        if (endo) {
          const { k1neg, k1, k2neg, k2 } = endo.splitScalar(n2);
          let { p: k1p, f: f1p } = this.wNAF(k1);
          let { p: k2p, f: f2p } = this.wNAF(k2);
          k1p = wnaf.constTimeNegate(k1neg, k1p);
          k2p = wnaf.constTimeNegate(k2neg, k2p);
          k2p = new Point3(Fp2.mul(k2p.px, endo.beta), k2p.py, k2p.pz);
          point = k1p.add(k2p);
          fake = f1p.add(f2p);
        } else {
          const { p, f: f2 } = this.wNAF(n2);
          point = p;
          fake = f2;
        }
        return Point3.normalizeZ([point, fake])[0];
      }
      /**
       * Efficiently calculate `aP + bQ`. Unsafe, can expose private key, if used incorrectly.
       * Not using Strauss-Shamir trick: precomputation tables are faster.
       * The trick could be useful if both P and Q are not G (not in our case).
       * @returns non-zero affine point
       */
      multiplyAndAddUnsafe(Q, a, b2) {
        const G = Point3.BASE;
        const mul = (P, a2) => a2 === _0n5 || a2 === _1n5 || !P.equals(G) ? P.multiplyUnsafe(a2) : P.multiply(a2);
        const sum = mul(this, a).add(mul(Q, b2));
        return sum.is0() ? void 0 : sum;
      }
      // Converts Projective point to affine (x, y) coordinates.
      // Can accept precomputed Z^-1 - for example, from invertBatch.
      // (x, y, z)  (x=x/z, y=y/z)
      toAffine(iz) {
        const { px: x, py: y, pz: z } = this;
        const is0 = this.is0();
        if (iz == null)
          iz = is0 ? Fp2.ONE : Fp2.inv(z);
        const ax = Fp2.mul(x, iz);
        const ay = Fp2.mul(y, iz);
        const zz = Fp2.mul(z, iz);
        if (is0)
          return { x: Fp2.ZERO, y: Fp2.ZERO };
        if (!Fp2.eql(zz, Fp2.ONE))
          throw new Error("invZ was invalid");
        return { x: ax, y: ay };
      }
      isTorsionFree() {
        const { h: cofactor, isTorsionFree } = CURVE;
        if (cofactor === _1n5)
          return true;
        if (isTorsionFree)
          return isTorsionFree(Point3, this);
        throw new Error("isTorsionFree() has not been declared for the elliptic curve");
      }
      clearCofactor() {
        const { h: cofactor, clearCofactor } = CURVE;
        if (cofactor === _1n5)
          return this;
        if (clearCofactor)
          return clearCofactor(Point3, this);
        return this.multiplyUnsafe(CURVE.h);
      }
      toRawBytes(isCompressed = true) {
        this.assertValidity();
        return toBytes5(Point3, this, isCompressed);
      }
      toHex(isCompressed = true) {
        return bytesToHex(this.toRawBytes(isCompressed));
      }
    }
    Point3.BASE = new Point3(CURVE.Gx, CURVE.Gy, Fp2.ONE);
    Point3.ZERO = new Point3(Fp2.ZERO, Fp2.ONE, Fp2.ZERO);
    const _bits = CURVE.nBitLength;
    const wnaf = wNAF(Point3, CURVE.endo ? Math.ceil(_bits / 2) : _bits);
    return {
      CURVE,
      ProjectivePoint: Point3,
      normPrivateKeyToScalar,
      weierstrassEquation,
      isWithinCurveOrder
    };
  }
  function validateOpts(curve) {
    const opts = validateBasic(curve);
    validateObject(opts, {
      hash: "hash",
      hmac: "function",
      randomBytes: "function"
    }, {
      bits2int: "function",
      bits2int_modN: "function",
      lowS: "boolean"
    });
    return Object.freeze({ lowS: true, ...opts });
  }
  function weierstrass(curveDef) {
    const CURVE = validateOpts(curveDef);
    const { Fp: Fp2, n: CURVE_ORDER } = CURVE;
    const compressedLen = Fp2.BYTES + 1;
    const uncompressedLen = 2 * Fp2.BYTES + 1;
    function isValidFieldElement(num2) {
      return _0n5 < num2 && num2 < Fp2.ORDER;
    }
    function modN2(a) {
      return mod(a, CURVE_ORDER);
    }
    function invN(a) {
      return invert(a, CURVE_ORDER);
    }
    const { ProjectivePoint: Point3, normPrivateKeyToScalar, weierstrassEquation, isWithinCurveOrder } = weierstrassPoints({
      ...CURVE,
      toBytes(_c, point, isCompressed) {
        const a = point.toAffine();
        const x = Fp2.toBytes(a.x);
        const cat = concatBytes2;
        if (isCompressed) {
          return cat(Uint8Array.from([point.hasEvenY() ? 2 : 3]), x);
        } else {
          return cat(Uint8Array.from([4]), x, Fp2.toBytes(a.y));
        }
      },
      fromBytes(bytes2) {
        const len = bytes2.length;
        const head = bytes2[0];
        const tail = bytes2.subarray(1);
        if (len === compressedLen && (head === 2 || head === 3)) {
          const x = bytesToNumberBE(tail);
          if (!isValidFieldElement(x))
            throw new Error("Point is not on curve");
          const y2 = weierstrassEquation(x);
          let y = Fp2.sqrt(y2);
          const isYOdd = (y & _1n5) === _1n5;
          const isHeadOdd = (head & 1) === 1;
          if (isHeadOdd !== isYOdd)
            y = Fp2.neg(y);
          return { x, y };
        } else if (len === uncompressedLen && head === 4) {
          const x = Fp2.fromBytes(tail.subarray(0, Fp2.BYTES));
          const y = Fp2.fromBytes(tail.subarray(Fp2.BYTES, 2 * Fp2.BYTES));
          return { x, y };
        } else {
          throw new Error(`Point of length ${len} was invalid. Expected ${compressedLen} compressed bytes or ${uncompressedLen} uncompressed bytes`);
        }
      }
    });
    const numToNByteStr = (num2) => bytesToHex(numberToBytesBE(num2, CURVE.nByteLength));
    function isBiggerThanHalfOrder(number2) {
      const HALF = CURVE_ORDER >> _1n5;
      return number2 > HALF;
    }
    function normalizeS(s) {
      return isBiggerThanHalfOrder(s) ? modN2(-s) : s;
    }
    const slcNum = (b2, from5, to) => bytesToNumberBE(b2.slice(from5, to));
    class Signature2 {
      constructor(r, s, recovery) {
        this.r = r;
        this.s = s;
        this.recovery = recovery;
        this.assertValidity();
      }
      // pair (bytes of r, bytes of s)
      static fromCompact(hex) {
        const l = CURVE.nByteLength;
        hex = ensureBytes("compactSignature", hex, l * 2);
        return new Signature2(slcNum(hex, 0, l), slcNum(hex, l, 2 * l));
      }
      // DER encoded ECDSA signature
      // https://bitcoin.stackexchange.com/questions/57644/what-are-the-parts-of-a-bitcoin-transaction-input-script
      static fromDER(hex) {
        const { r, s } = DER.toSig(ensureBytes("DER", hex));
        return new Signature2(r, s);
      }
      assertValidity() {
        if (!isWithinCurveOrder(this.r))
          throw new Error("r must be 0 < r < CURVE.n");
        if (!isWithinCurveOrder(this.s))
          throw new Error("s must be 0 < s < CURVE.n");
      }
      addRecoveryBit(recovery) {
        return new Signature2(this.r, this.s, recovery);
      }
      recoverPublicKey(msgHash) {
        const { r, s, recovery: rec } = this;
        const h = bits2int_modN(ensureBytes("msgHash", msgHash));
        if (rec == null || ![0, 1, 2, 3].includes(rec))
          throw new Error("recovery id invalid");
        const radj = rec === 2 || rec === 3 ? r + CURVE.n : r;
        if (radj >= Fp2.ORDER)
          throw new Error("recovery id 2 or 3 invalid");
        const prefix = (rec & 1) === 0 ? "02" : "03";
        const R = Point3.fromHex(prefix + numToNByteStr(radj));
        const ir = invN(radj);
        const u1 = modN2(-h * ir);
        const u2 = modN2(s * ir);
        const Q = Point3.BASE.multiplyAndAddUnsafe(R, u1, u2);
        if (!Q)
          throw new Error("point at infinify");
        Q.assertValidity();
        return Q;
      }
      // Signatures should be low-s, to prevent malleability.
      hasHighS() {
        return isBiggerThanHalfOrder(this.s);
      }
      normalizeS() {
        return this.hasHighS() ? new Signature2(this.r, modN2(-this.s), this.recovery) : this;
      }
      // DER-encoded
      toDERRawBytes() {
        return hexToBytes(this.toDERHex());
      }
      toDERHex() {
        return DER.hexFromSig({ r: this.r, s: this.s });
      }
      // padded bytes of r, then padded bytes of s
      toCompactRawBytes() {
        return hexToBytes(this.toCompactHex());
      }
      toCompactHex() {
        return numToNByteStr(this.r) + numToNByteStr(this.s);
      }
    }
    const utils = {
      isValidPrivateKey(privateKey) {
        try {
          normPrivateKeyToScalar(privateKey);
          return true;
        } catch (error) {
          return false;
        }
      },
      normPrivateKeyToScalar,
      /**
       * Produces cryptographically secure private key from random of size
       * (groupLen + ceil(groupLen / 2)) with modulo bias being negligible.
       */
      randomPrivateKey: () => {
        const length = getMinHashLength(CURVE.n);
        return mapHashToField(CURVE.randomBytes(length), CURVE.n);
      },
      /**
       * Creates precompute table for an arbitrary EC point. Makes point "cached".
       * Allows to massively speed-up `point.multiply(scalar)`.
       * @returns cached point
       * @example
       * const fast = utils.precompute(8, ProjectivePoint.fromHex(someonesPubKey));
       * fast.multiply(privKey); // much faster ECDH now
       */
      precompute(windowSize = 8, point = Point3.BASE) {
        point._setWindowSize(windowSize);
        point.multiply(BigInt(3));
        return point;
      }
    };
    function getPublicKey(privateKey, isCompressed = true) {
      return Point3.fromPrivateKey(privateKey).toRawBytes(isCompressed);
    }
    function isProbPub(item) {
      const arr = item instanceof Uint8Array;
      const str = typeof item === "string";
      const len = (arr || str) && item.length;
      if (arr)
        return len === compressedLen || len === uncompressedLen;
      if (str)
        return len === 2 * compressedLen || len === 2 * uncompressedLen;
      if (item instanceof Point3)
        return true;
      return false;
    }
    function getSharedSecret(privateA, publicB, isCompressed = true) {
      if (isProbPub(privateA))
        throw new Error("first arg must be private key");
      if (!isProbPub(publicB))
        throw new Error("second arg must be public key");
      const b2 = Point3.fromHex(publicB);
      return b2.multiply(normPrivateKeyToScalar(privateA)).toRawBytes(isCompressed);
    }
    const bits2int = CURVE.bits2int || function(bytes2) {
      const num2 = bytesToNumberBE(bytes2);
      const delta = bytes2.length * 8 - CURVE.nBitLength;
      return delta > 0 ? num2 >> BigInt(delta) : num2;
    };
    const bits2int_modN = CURVE.bits2int_modN || function(bytes2) {
      return modN2(bits2int(bytes2));
    };
    const ORDER_MASK = bitMask(CURVE.nBitLength);
    function int2octets(num2) {
      if (typeof num2 !== "bigint")
        throw new Error("bigint expected");
      if (!(_0n5 <= num2 && num2 < ORDER_MASK))
        throw new Error(`bigint expected < 2^${CURVE.nBitLength}`);
      return numberToBytesBE(num2, CURVE.nByteLength);
    }
    function prepSig(msgHash, privateKey, opts = defaultSigOpts) {
      if (["recovered", "canonical"].some((k) => k in opts))
        throw new Error("sign() legacy options not supported");
      const { hash: hash3, randomBytes: randomBytes5 } = CURVE;
      let { lowS, prehash, extraEntropy: ent } = opts;
      if (lowS == null)
        lowS = true;
      msgHash = ensureBytes("msgHash", msgHash);
      if (prehash)
        msgHash = ensureBytes("prehashed msgHash", hash3(msgHash));
      const h1int = bits2int_modN(msgHash);
      const d = normPrivateKeyToScalar(privateKey);
      const seedArgs = [int2octets(d), int2octets(h1int)];
      if (ent != null) {
        const e = ent === true ? randomBytes5(Fp2.BYTES) : ent;
        seedArgs.push(ensureBytes("extraEntropy", e));
      }
      const seed = concatBytes2(...seedArgs);
      const m = h1int;
      function k2sig(kBytes) {
        const k = bits2int(kBytes);
        if (!isWithinCurveOrder(k))
          return;
        const ik = invN(k);
        const q = Point3.BASE.multiply(k).toAffine();
        const r = modN2(q.x);
        if (r === _0n5)
          return;
        const s = modN2(ik * modN2(m + r * d));
        if (s === _0n5)
          return;
        let recovery = (q.x === r ? 0 : 2) | Number(q.y & _1n5);
        let normS = s;
        if (lowS && isBiggerThanHalfOrder(s)) {
          normS = normalizeS(s);
          recovery ^= 1;
        }
        return new Signature2(r, normS, recovery);
      }
      return { seed, k2sig };
    }
    const defaultSigOpts = { lowS: CURVE.lowS, prehash: false };
    const defaultVerOpts = { lowS: CURVE.lowS, prehash: false };
    function sign2(msgHash, privKey, opts = defaultSigOpts) {
      const { seed, k2sig } = prepSig(msgHash, privKey, opts);
      const C = CURVE;
      const drbg = createHmacDrbg(C.hash.outputLen, C.nByteLength, C.hmac);
      return drbg(seed, k2sig);
    }
    Point3.BASE._setWindowSize(8);
    function verify(signature, msgHash, publicKey, opts = defaultVerOpts) {
      const sg = signature;
      msgHash = ensureBytes("msgHash", msgHash);
      publicKey = ensureBytes("publicKey", publicKey);
      if ("strict" in opts)
        throw new Error("options.strict was renamed to lowS");
      const { lowS, prehash } = opts;
      let _sig2 = void 0;
      let P;
      try {
        if (typeof sg === "string" || sg instanceof Uint8Array) {
          try {
            _sig2 = Signature2.fromDER(sg);
          } catch (derError) {
            if (!(derError instanceof DER.Err))
              throw derError;
            _sig2 = Signature2.fromCompact(sg);
          }
        } else if (typeof sg === "object" && typeof sg.r === "bigint" && typeof sg.s === "bigint") {
          const { r: r2, s: s2 } = sg;
          _sig2 = new Signature2(r2, s2);
        } else {
          throw new Error("PARSE");
        }
        P = Point3.fromHex(publicKey);
      } catch (error) {
        if (error.message === "PARSE")
          throw new Error(`signature must be Signature instance, Uint8Array or hex string`);
        return false;
      }
      if (lowS && _sig2.hasHighS())
        return false;
      if (prehash)
        msgHash = CURVE.hash(msgHash);
      const { r, s } = _sig2;
      const h = bits2int_modN(msgHash);
      const is = invN(s);
      const u1 = modN2(h * is);
      const u2 = modN2(r * is);
      const R = Point3.BASE.multiplyAndAddUnsafe(P, u1, u2)?.toAffine();
      if (!R)
        return false;
      const v = modN2(R.x);
      return v === r;
    }
    return {
      CURVE,
      getPublicKey,
      getSharedSecret,
      sign: sign2,
      verify,
      ProjectivePoint: Point3,
      Signature: Signature2,
      utils
    };
  }
  var b2n, h2b, DER, _0n5, _1n5, _2n4, _3n2, _4n2;
  var init_weierstrass = __esm({
    "node_modules/@noble/curves/esm/abstract/weierstrass.js"() {
      init_modular();
      init_utils3();
      init_utils3();
      init_curve();
      ({ bytesToNumberBE: b2n, hexToBytes: h2b } = utils_exports);
      DER = {
        // asn.1 DER encoding utils
        Err: class DERErr extends Error {
          constructor(m = "") {
            super(m);
          }
        },
        _parseInt(data) {
          const { Err: E } = DER;
          if (data.length < 2 || data[0] !== 2)
            throw new E("Invalid signature integer tag");
          const len = data[1];
          const res = data.subarray(2, len + 2);
          if (!len || res.length !== len)
            throw new E("Invalid signature integer: wrong length");
          if (res[0] & 128)
            throw new E("Invalid signature integer: negative");
          if (res[0] === 0 && !(res[1] & 128))
            throw new E("Invalid signature integer: unnecessary leading zero");
          return { d: b2n(res), l: data.subarray(len + 2) };
        },
        toSig(hex) {
          const { Err: E } = DER;
          const data = typeof hex === "string" ? h2b(hex) : hex;
          if (!(data instanceof Uint8Array))
            throw new Error("ui8a expected");
          let l = data.length;
          if (l < 2 || data[0] != 48)
            throw new E("Invalid signature tag");
          if (data[1] !== l - 2)
            throw new E("Invalid signature: incorrect length");
          const { d: r, l: sBytes } = DER._parseInt(data.subarray(2));
          const { d: s, l: rBytesLeft } = DER._parseInt(sBytes);
          if (rBytesLeft.length)
            throw new E("Invalid signature: left bytes after parsing");
          return { r, s };
        },
        hexFromSig(sig) {
          const slice3 = (s2) => Number.parseInt(s2[0], 16) & 8 ? "00" + s2 : s2;
          const h = (num2) => {
            const hex = num2.toString(16);
            return hex.length & 1 ? `0${hex}` : hex;
          };
          const s = slice3(h(sig.s));
          const r = slice3(h(sig.r));
          const shl = s.length / 2;
          const rhl = r.length / 2;
          const sl = h(shl);
          const rl = h(rhl);
          return `30${h(rhl + shl + 4)}02${rl}${r}02${sl}${s}`;
        }
      };
      _0n5 = BigInt(0);
      _1n5 = BigInt(1);
      _2n4 = BigInt(2);
      _3n2 = BigInt(3);
      _4n2 = BigInt(4);
    }
  });

  // node_modules/@noble/curves/esm/_shortw_utils.js
  function getHash(hash3) {
    return {
      hash: hash3,
      hmac: (key, ...msgs) => hmac(hash3, key, concatBytes(...msgs)),
      randomBytes
    };
  }
  function createCurve(curveDef, defHash) {
    const create = (hash3) => weierstrass({ ...curveDef, ...getHash(hash3) });
    return Object.freeze({ ...create(defHash), create });
  }
  var init_shortw_utils = __esm({
    "node_modules/@noble/curves/esm/_shortw_utils.js"() {
      init_hmac();
      init_utils2();
      init_weierstrass();
    }
  });

  // node_modules/@noble/curves/esm/secp256k1.js
  function sqrtMod(y) {
    const P = secp256k1P;
    const _3n5 = BigInt(3), _6n = BigInt(6), _11n = BigInt(11), _22n = BigInt(22);
    const _23n = BigInt(23), _44n = BigInt(44), _88n = BigInt(88);
    const b2 = y * y * y % P;
    const b3 = b2 * b2 * y % P;
    const b6 = pow2(b3, _3n5, P) * b3 % P;
    const b9 = pow2(b6, _3n5, P) * b3 % P;
    const b11 = pow2(b9, _2n5, P) * b2 % P;
    const b22 = pow2(b11, _11n, P) * b11 % P;
    const b44 = pow2(b22, _22n, P) * b22 % P;
    const b88 = pow2(b44, _44n, P) * b44 % P;
    const b176 = pow2(b88, _88n, P) * b88 % P;
    const b220 = pow2(b176, _44n, P) * b44 % P;
    const b223 = pow2(b220, _3n5, P) * b3 % P;
    const t1 = pow2(b223, _23n, P) * b22 % P;
    const t2 = pow2(t1, _6n, P) * b2 % P;
    const root = pow2(t2, _2n5, P);
    if (!Fp.eql(Fp.sqr(root), y))
      throw new Error("Cannot find square root");
    return root;
  }
  var secp256k1P, secp256k1N, _1n6, _2n5, divNearest, Fp, secp256k1, _0n6, Point;
  var init_secp256k1 = __esm({
    "node_modules/@noble/curves/esm/secp256k1.js"() {
      init_sha256();
      init_modular();
      init_shortw_utils();
      secp256k1P = BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f");
      secp256k1N = BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141");
      _1n6 = BigInt(1);
      _2n5 = BigInt(2);
      divNearest = (a, b2) => (a + b2 / _2n5) / b2;
      Fp = Field(secp256k1P, void 0, void 0, { sqrt: sqrtMod });
      secp256k1 = createCurve({
        a: BigInt(0),
        b: BigInt(7),
        Fp,
        n: secp256k1N,
        // Base point (x, y) aka generator point
        Gx: BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),
        Gy: BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),
        h: BigInt(1),
        lowS: true,
        /**
         * secp256k1 belongs to Koblitz curves: it has efficiently computable endomorphism.
         * Endomorphism uses 2x less RAM, speeds up precomputation by 2x and ECDH / key recovery by 20%.
         * For precomputed wNAF it trades off 1/2 init time & 1/3 ram for 20% perf hit.
         * Explanation: https://gist.github.com/paulmillr/eb670806793e84df628a7c434a873066
         */
        endo: {
          beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
          splitScalar: (k) => {
            const n2 = secp256k1N;
            const a1 = BigInt("0x3086d221a7d46bcde86c90e49284eb15");
            const b1 = -_1n6 * BigInt("0xe4437ed6010e88286f547fa90abfe4c3");
            const a2 = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8");
            const b2 = a1;
            const POW_2_128 = BigInt("0x100000000000000000000000000000000");
            const c1 = divNearest(b2 * k, n2);
            const c2 = divNearest(-b1 * k, n2);
            let k1 = mod(k - c1 * a1 - c2 * a2, n2);
            let k2 = mod(-c1 * b1 - c2 * b2, n2);
            const k1neg = k1 > POW_2_128;
            const k2neg = k2 > POW_2_128;
            if (k1neg)
              k1 = n2 - k1;
            if (k2neg)
              k2 = n2 - k2;
            if (k1 > POW_2_128 || k2 > POW_2_128) {
              throw new Error("splitScalar: Endomorphism failed, k=" + k);
            }
            return { k1neg, k1, k2neg, k2 };
          }
        }
      }, sha256);
      _0n6 = BigInt(0);
      Point = secp256k1.ProjectivePoint;
    }
  });

  // node_modules/ethers/lib.esm/constants/addresses.js
  var ZeroAddress;
  var init_addresses = __esm({
    "node_modules/ethers/lib.esm/constants/addresses.js"() {
      ZeroAddress = "0x0000000000000000000000000000000000000000";
    }
  });

  // node_modules/ethers/lib.esm/constants/hashes.js
  var ZeroHash;
  var init_hashes = __esm({
    "node_modules/ethers/lib.esm/constants/hashes.js"() {
      ZeroHash = "0x0000000000000000000000000000000000000000000000000000000000000000";
    }
  });

  // node_modules/ethers/lib.esm/constants/numbers.js
  var N, WeiPerEther, MaxUint256, MinInt256, MaxInt256;
  var init_numbers = __esm({
    "node_modules/ethers/lib.esm/constants/numbers.js"() {
      N = BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141");
      WeiPerEther = BigInt("1000000000000000000");
      MaxUint256 = BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
      MinInt256 = BigInt("0x8000000000000000000000000000000000000000000000000000000000000000") * BigInt(-1);
      MaxInt256 = BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
    }
  });

  // node_modules/ethers/lib.esm/constants/strings.js
  var EtherSymbol, MessagePrefix;
  var init_strings = __esm({
    "node_modules/ethers/lib.esm/constants/strings.js"() {
      EtherSymbol = "\u039E";
      MessagePrefix = "Ethereum Signed Message:\n";
    }
  });

  // node_modules/ethers/lib.esm/constants/index.js
  var init_constants = __esm({
    "node_modules/ethers/lib.esm/constants/index.js"() {
      init_addresses();
      init_hashes();
      init_numbers();
      init_strings();
    }
  });

  // node_modules/ethers/lib.esm/crypto/signature.js
  function toUint256(value) {
    return zeroPadValue(toBeArray(value), 32);
  }
  var BN_04, BN_13, BN_2, BN_27, BN_28, BN_35, _guard3, _r, _s, _v, _networkV, _Signature, Signature;
  var init_signature = __esm({
    "node_modules/ethers/lib.esm/crypto/signature.js"() {
      init_constants();
      init_utils();
      BN_04 = BigInt(0);
      BN_13 = BigInt(1);
      BN_2 = BigInt(2);
      BN_27 = BigInt(27);
      BN_28 = BigInt(28);
      BN_35 = BigInt(35);
      _guard3 = {};
      _Signature = class _Signature {
        /**
         *  @private
         */
        constructor(guard, r, s, v) {
          __privateAdd(this, _r);
          __privateAdd(this, _s);
          __privateAdd(this, _v);
          __privateAdd(this, _networkV);
          assertPrivate(guard, _guard3, "Signature");
          __privateSet(this, _r, r);
          __privateSet(this, _s, s);
          __privateSet(this, _v, v);
          __privateSet(this, _networkV, null);
        }
        /**
         *  The ``r`` value for a signature.
         *
         *  This represents the ``x`` coordinate of a "reference" or
         *  challenge point, from which the ``y`` can be computed.
         */
        get r() {
          return __privateGet(this, _r);
        }
        set r(value) {
          assertArgument(dataLength(value) === 32, "invalid r", "value", value);
          __privateSet(this, _r, hexlify(value));
        }
        /**
         *  The ``s`` value for a signature.
         */
        get s() {
          assertArgument(parseInt(__privateGet(this, _s).substring(0, 3)) < 8, "non-canonical s; use ._s", "s", __privateGet(this, _s));
          return __privateGet(this, _s);
        }
        set s(_value2) {
          assertArgument(dataLength(_value2) === 32, "invalid s", "value", _value2);
          __privateSet(this, _s, hexlify(_value2));
        }
        /**
         *  Return the s value, unchecked for EIP-2 compliance.
         *
         *  This should generally not be used and is for situations where
         *  a non-canonical S value might be relevant, such as Frontier blocks
         *  that were mined prior to EIP-2 or invalid Authorization List
         *  signatures.
         */
        get _s() {
          return __privateGet(this, _s);
        }
        /**
         *  Returns true if the Signature is valid for [[link-eip-2]] signatures.
         */
        isValid() {
          return parseInt(__privateGet(this, _s).substring(0, 3)) < 8;
        }
        /**
         *  The ``v`` value for a signature.
         *
         *  Since a given ``x`` value for ``r`` has two possible values for
         *  its correspondin ``y``, the ``v`` indicates which of the two ``y``
         *  values to use.
         *
         *  It is normalized to the values ``27`` or ``28`` for legacy
         *  purposes.
         */
        get v() {
          return __privateGet(this, _v);
        }
        set v(value) {
          const v = getNumber(value, "value");
          assertArgument(v === 27 || v === 28, "invalid v", "v", value);
          __privateSet(this, _v, v);
        }
        /**
         *  The EIP-155 ``v`` for legacy transactions. For non-legacy
         *  transactions, this value is ``null``.
         */
        get networkV() {
          return __privateGet(this, _networkV);
        }
        /**
         *  The chain ID for EIP-155 legacy transactions. For non-legacy
         *  transactions, this value is ``null``.
         */
        get legacyChainId() {
          const v = this.networkV;
          if (v == null) {
            return null;
          }
          return _Signature.getChainId(v);
        }
        /**
         *  The ``yParity`` for the signature.
         *
         *  See ``v`` for more details on how this value is used.
         */
        get yParity() {
          return this.v === 27 ? 0 : 1;
        }
        /**
         *  The [[link-eip-2098]] compact representation of the ``yParity``
         *  and ``s`` compacted into a single ``bytes32``.
         */
        get yParityAndS() {
          const yParityAndS = getBytes(this.s);
          if (this.yParity) {
            yParityAndS[0] |= 128;
          }
          return hexlify(yParityAndS);
        }
        /**
         *  The [[link-eip-2098]] compact representation.
         */
        get compactSerialized() {
          return concat([this.r, this.yParityAndS]);
        }
        /**
         *  The serialized representation.
         */
        get serialized() {
          return concat([this.r, this.s, this.yParity ? "0x1c" : "0x1b"]);
        }
        [Symbol.for("nodejs.util.inspect.custom")]() {
          return `Signature { r: "${this.r}", s: "${this._s}"${this.isValid() ? "" : ', valid: "false"'}, yParity: ${this.yParity}, networkV: ${this.networkV} }`;
        }
        /**
         *  Returns a new identical [[Signature]].
         */
        clone() {
          const clone = new _Signature(_guard3, this.r, this._s, this.v);
          if (this.networkV) {
            __privateSet(clone, _networkV, this.networkV);
          }
          return clone;
        }
        /**
         *  Returns a representation that is compatible with ``JSON.stringify``.
         */
        toJSON() {
          const networkV = this.networkV;
          return {
            _type: "signature",
            networkV: networkV != null ? networkV.toString() : null,
            r: this.r,
            s: this._s,
            v: this.v
          };
        }
        /**
         *  Compute the chain ID from the ``v`` in a legacy EIP-155 transactions.
         *
         *  @example:
         *    Signature.getChainId(45)
         *    //_result:
         *
         *    Signature.getChainId(46)
         *    //_result:
         */
        static getChainId(v) {
          const bv = getBigInt(v, "v");
          if (bv == BN_27 || bv == BN_28) {
            return BN_04;
          }
          assertArgument(bv >= BN_35, "invalid EIP-155 v", "v", v);
          return (bv - BN_35) / BN_2;
        }
        /**
         *  Compute the ``v`` for a chain ID for a legacy EIP-155 transactions.
         *
         *  Legacy transactions which use [[link-eip-155]] hijack the ``v``
         *  property to include the chain ID.
         *
         *  @example:
         *    Signature.getChainIdV(5, 27)
         *    //_result:
         *
         *    Signature.getChainIdV(5, 28)
         *    //_result:
         *
         */
        static getChainIdV(chainId, v) {
          return getBigInt(chainId) * BN_2 + BigInt(35 + v - 27);
        }
        /**
         *  Compute the normalized legacy transaction ``v`` from a ``yParirty``,
         *  a legacy transaction ``v`` or a legacy [[link-eip-155]] transaction.
         *
         *  @example:
         *    // The values 0 and 1 imply v is actually yParity
         *    Signature.getNormalizedV(0)
         *    //_result:
         *
         *    // Legacy non-EIP-1559 transaction (i.e. 27 or 28)
         *    Signature.getNormalizedV(27)
         *    //_result:
         *
         *    // Legacy EIP-155 transaction (i.e. >= 35)
         *    Signature.getNormalizedV(46)
         *    //_result:
         *
         *    // Invalid values throw
         *    Signature.getNormalizedV(5)
         *    //_error:
         */
        static getNormalizedV(v) {
          const bv = getBigInt(v);
          if (bv === BN_04 || bv === BN_27) {
            return 27;
          }
          if (bv === BN_13 || bv === BN_28) {
            return 28;
          }
          assertArgument(bv >= BN_35, "invalid v", "v", v);
          return bv & BN_13 ? 27 : 28;
        }
        /**
         *  Creates a new [[Signature]].
         *
         *  If no %%sig%% is provided, a new [[Signature]] is created
         *  with default values.
         *
         *  If %%sig%% is a string, it is parsed.
         */
        static from(sig) {
          function assertError(check, message) {
            assertArgument(check, message, "signature", sig);
          }
          ;
          if (sig == null) {
            return new _Signature(_guard3, ZeroHash, ZeroHash, 27);
          }
          if (typeof sig === "string") {
            const bytes2 = getBytes(sig, "signature");
            if (bytes2.length === 64) {
              const r2 = hexlify(bytes2.slice(0, 32));
              const s2 = bytes2.slice(32, 64);
              const v2 = s2[0] & 128 ? 28 : 27;
              s2[0] &= 127;
              return new _Signature(_guard3, r2, hexlify(s2), v2);
            }
            if (bytes2.length === 65) {
              const r2 = hexlify(bytes2.slice(0, 32));
              const s2 = hexlify(bytes2.slice(32, 64));
              const v2 = _Signature.getNormalizedV(bytes2[64]);
              return new _Signature(_guard3, r2, s2, v2);
            }
            assertError(false, "invalid raw signature length");
          }
          if (sig instanceof _Signature) {
            return sig.clone();
          }
          const _r2 = sig.r;
          assertError(_r2 != null, "missing r");
          const r = toUint256(_r2);
          const s = function(s2, yParityAndS) {
            if (s2 != null) {
              return toUint256(s2);
            }
            if (yParityAndS != null) {
              assertError(isHexString(yParityAndS, 32), "invalid yParityAndS");
              const bytes2 = getBytes(yParityAndS);
              bytes2[0] &= 127;
              return hexlify(bytes2);
            }
            assertError(false, "missing s");
          }(sig.s, sig.yParityAndS);
          const { networkV, v } = function(_v2, yParityAndS, yParity) {
            if (_v2 != null) {
              const v2 = getBigInt(_v2);
              return {
                networkV: v2 >= BN_35 ? v2 : void 0,
                v: _Signature.getNormalizedV(v2)
              };
            }
            if (yParityAndS != null) {
              assertError(isHexString(yParityAndS, 32), "invalid yParityAndS");
              return { v: getBytes(yParityAndS)[0] & 128 ? 28 : 27 };
            }
            if (yParity != null) {
              switch (getNumber(yParity, "sig.yParity")) {
                case 0:
                  return { v: 27 };
                case 1:
                  return { v: 28 };
              }
              assertError(false, "invalid yParity");
            }
            assertError(false, "missing v");
          }(sig.v, sig.yParityAndS, sig.yParity);
          const result = new _Signature(_guard3, r, s, v);
          if (networkV) {
            __privateSet(result, _networkV, networkV);
          }
          assertError(sig.yParity == null || getNumber(sig.yParity, "sig.yParity") === result.yParity, "yParity mismatch");
          assertError(sig.yParityAndS == null || sig.yParityAndS === result.yParityAndS, "yParityAndS mismatch");
          return result;
        }
      };
      _r = new WeakMap();
      _s = new WeakMap();
      _v = new WeakMap();
      _networkV = new WeakMap();
      Signature = _Signature;
    }
  });

  // node_modules/ethers/lib.esm/crypto/signing-key.js
  var _privateKey, _SigningKey, SigningKey;
  var init_signing_key = __esm({
    "node_modules/ethers/lib.esm/crypto/signing-key.js"() {
      init_secp256k1();
      init_utils();
      init_signature();
      _SigningKey = class _SigningKey {
        /**
         *  Creates a new **SigningKey** for %%privateKey%%.
         */
        constructor(privateKey) {
          __privateAdd(this, _privateKey);
          assertArgument(dataLength(privateKey) === 32, "invalid private key", "privateKey", "[REDACTED]");
          __privateSet(this, _privateKey, hexlify(privateKey));
        }
        /**
         *  The private key.
         */
        get privateKey() {
          return __privateGet(this, _privateKey);
        }
        /**
         *  The uncompressed public key.
         *
         * This will always begin with the prefix ``0x04`` and be 132
         * characters long (the ``0x`` prefix and 130 hexadecimal nibbles).
         */
        get publicKey() {
          return _SigningKey.computePublicKey(__privateGet(this, _privateKey));
        }
        /**
         *  The compressed public key.
         *
         *  This will always begin with either the prefix ``0x02`` or ``0x03``
         *  and be 68 characters long (the ``0x`` prefix and 33 hexadecimal
         *  nibbles)
         */
        get compressedPublicKey() {
          return _SigningKey.computePublicKey(__privateGet(this, _privateKey), true);
        }
        /**
         *  Return the signature of the signed %%digest%%.
         */
        sign(digest) {
          assertArgument(dataLength(digest) === 32, "invalid digest length", "digest", digest);
          const sig = secp256k1.sign(getBytesCopy(digest), getBytesCopy(__privateGet(this, _privateKey)), {
            lowS: true
          });
          return Signature.from({
            r: toBeHex(sig.r, 32),
            s: toBeHex(sig.s, 32),
            v: sig.recovery ? 28 : 27
          });
        }
        /**
         *  Returns the [[link-wiki-ecdh]] shared secret between this
         *  private key and the %%other%% key.
         *
         *  The %%other%% key may be any type of key, a raw public key,
         *  a compressed/uncompressed pubic key or aprivate key.
         *
         *  Best practice is usually to use a cryptographic hash on the
         *  returned value before using it as a symetric secret.
         *
         *  @example:
         *    sign1 = new SigningKey(id("some-secret-1"))
         *    sign2 = new SigningKey(id("some-secret-2"))
         *
         *    // Notice that privA.computeSharedSecret(pubB)...
         *    sign1.computeSharedSecret(sign2.publicKey)
         *    //_result:
         *
         *    // ...is equal to privB.computeSharedSecret(pubA).
         *    sign2.computeSharedSecret(sign1.publicKey)
         *    //_result:
         */
        computeSharedSecret(other) {
          const pubKey = _SigningKey.computePublicKey(other);
          return hexlify(secp256k1.getSharedSecret(getBytesCopy(__privateGet(this, _privateKey)), getBytes(pubKey), false));
        }
        /**
         *  Compute the public key for %%key%%, optionally %%compressed%%.
         *
         *  The %%key%% may be any type of key, a raw public key, a
         *  compressed/uncompressed public key or private key.
         *
         *  @example:
         *    sign = new SigningKey(id("some-secret"));
         *
         *    // Compute the uncompressed public key for a private key
         *    SigningKey.computePublicKey(sign.privateKey)
         *    //_result:
         *
         *    // Compute the compressed public key for a private key
         *    SigningKey.computePublicKey(sign.privateKey, true)
         *    //_result:
         *
         *    // Compute the uncompressed public key
         *    SigningKey.computePublicKey(sign.publicKey, false);
         *    //_result:
         *
         *    // Compute the Compressed a public key
         *    SigningKey.computePublicKey(sign.publicKey, true);
         *    //_result:
         */
        static computePublicKey(key, compressed) {
          let bytes2 = getBytes(key, "key");
          if (bytes2.length === 32) {
            const pubKey = secp256k1.getPublicKey(bytes2, !!compressed);
            return hexlify(pubKey);
          }
          if (bytes2.length === 64) {
            const pub = new Uint8Array(65);
            pub[0] = 4;
            pub.set(bytes2, 1);
            bytes2 = pub;
          }
          const point = secp256k1.ProjectivePoint.fromHex(bytes2);
          return hexlify(point.toRawBytes(compressed));
        }
        /**
         *  Returns the public key for the private key which produced the
         *  %%signature%% for the given %%digest%%.
         *
         *  @example:
         *    key = new SigningKey(id("some-secret"))
         *    digest = id("hello world")
         *    sig = key.sign(digest)
         *
         *    // Notice the signer public key...
         *    key.publicKey
         *    //_result:
         *
         *    // ...is equal to the recovered public key
         *    SigningKey.recoverPublicKey(digest, sig)
         *    //_result:
         *
         */
        static recoverPublicKey(digest, signature) {
          assertArgument(dataLength(digest) === 32, "invalid digest length", "digest", digest);
          const sig = Signature.from(signature);
          let secpSig = secp256k1.Signature.fromCompact(getBytesCopy(concat([sig.r, sig.s])));
          secpSig = secpSig.addRecoveryBit(sig.yParity);
          const pubKey = secpSig.recoverPublicKey(getBytesCopy(digest));
          assertArgument(pubKey != null, "invalid signature for digest", "signature", signature);
          return "0x" + pubKey.toHex(false);
        }
        /**
         *  Returns the point resulting from adding the ellipic curve points
         *  %%p0%% and %%p1%%.
         *
         *  This is not a common function most developers should require, but
         *  can be useful for certain privacy-specific techniques.
         *
         *  For example, it is used by [[HDNodeWallet]] to compute child
         *  addresses from parent public keys and chain codes.
         */
        static addPoints(p0, p1, compressed) {
          const pub0 = secp256k1.ProjectivePoint.fromHex(_SigningKey.computePublicKey(p0).substring(2));
          const pub1 = secp256k1.ProjectivePoint.fromHex(_SigningKey.computePublicKey(p1).substring(2));
          return "0x" + pub0.add(pub1).toHex(!!compressed);
        }
      };
      _privateKey = new WeakMap();
      SigningKey = _SigningKey;
    }
  });

  // node_modules/ethers/lib.esm/crypto/index.js
  function lock() {
    computeHmac.lock();
    keccak256.lock();
    pbkdf22.lock();
    randomBytes3.lock();
    ripemd1602.lock();
    scrypt2.lock();
    scryptSync.lock();
    sha2562.lock();
    sha5122.lock();
    randomBytes3.lock();
  }
  var init_crypto2 = __esm({
    "node_modules/ethers/lib.esm/crypto/index.js"() {
      init_hmac2();
      init_keccak();
      init_ripemd1602();
      init_pbkdf22();
      init_random();
      init_scrypt2();
      init_sha22();
      init_signing_key();
      init_signature();
    }
  });

  // node_modules/ethers/lib.esm/address/address.js
  function getChecksumAddress(address) {
    address = address.toLowerCase();
    const chars = address.substring(2).split("");
    const expanded = new Uint8Array(40);
    for (let i = 0; i < 40; i++) {
      expanded[i] = chars[i].charCodeAt(0);
    }
    const hashed = getBytes(keccak256(expanded));
    for (let i = 0; i < 40; i += 2) {
      if (hashed[i >> 1] >> 4 >= 8) {
        chars[i] = chars[i].toUpperCase();
      }
      if ((hashed[i >> 1] & 15) >= 8) {
        chars[i + 1] = chars[i + 1].toUpperCase();
      }
    }
    return "0x" + chars.join("");
  }
  function ibanChecksum(address) {
    address = address.toUpperCase();
    address = address.substring(4) + address.substring(0, 2) + "00";
    let expanded = address.split("").map((c) => {
      return ibanLookup[c];
    }).join("");
    while (expanded.length >= safeDigits) {
      let block = expanded.substring(0, safeDigits);
      expanded = parseInt(block, 10) % 97 + expanded.substring(block.length);
    }
    let checksum4 = String(98 - parseInt(expanded, 10) % 97);
    while (checksum4.length < 2) {
      checksum4 = "0" + checksum4;
    }
    return checksum4;
  }
  function fromBase36(value) {
    value = value.toLowerCase();
    let result = BN_05;
    for (let i = 0; i < value.length; i++) {
      result = result * BN_36 + Base36[value[i]];
    }
    return result;
  }
  function getAddress(address) {
    assertArgument(typeof address === "string", "invalid address", "address", address);
    if (address.match(/^(0x)?[0-9a-fA-F]{40}$/)) {
      if (!address.startsWith("0x")) {
        address = "0x" + address;
      }
      const result = getChecksumAddress(address);
      assertArgument(!address.match(/([A-F].*[a-f])|([a-f].*[A-F])/) || result === address, "bad address checksum", "address", address);
      return result;
    }
    if (address.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {
      assertArgument(address.substring(2, 4) === ibanChecksum(address), "bad icap checksum", "address", address);
      let result = fromBase36(address.substring(4)).toString(16);
      while (result.length < 40) {
        result = "0" + result;
      }
      return getChecksumAddress("0x" + result);
    }
    assertArgument(false, "invalid address", "address", address);
  }
  function getIcapAddress(address) {
    let base36 = BigInt(getAddress(address)).toString(36).toUpperCase();
    while (base36.length < 30) {
      base36 = "0" + base36;
    }
    return "XE" + ibanChecksum("XE00" + base36) + base36;
  }
  var BN_05, BN_36, ibanLookup, safeDigits, Base36;
  var init_address = __esm({
    "node_modules/ethers/lib.esm/address/address.js"() {
      init_crypto2();
      init_utils();
      BN_05 = BigInt(0);
      BN_36 = BigInt(36);
      ibanLookup = {};
      for (let i = 0; i < 10; i++) {
        ibanLookup[String(i)] = String(i);
      }
      for (let i = 0; i < 26; i++) {
        ibanLookup[String.fromCharCode(65 + i)] = String(10 + i);
      }
      safeDigits = 15;
      Base36 = function() {
        ;
        const result = {};
        for (let i = 0; i < 36; i++) {
          const key = "0123456789abcdefghijklmnopqrstuvwxyz"[i];
          result[key] = BigInt(i);
        }
        return result;
      }();
    }
  });

  // node_modules/ethers/lib.esm/address/contract-address.js
  function getCreateAddress(tx) {
    const from5 = getAddress(tx.from);
    const nonce = getBigInt(tx.nonce, "tx.nonce");
    let nonceHex = nonce.toString(16);
    if (nonceHex === "0") {
      nonceHex = "0x";
    } else if (nonceHex.length % 2) {
      nonceHex = "0x0" + nonceHex;
    } else {
      nonceHex = "0x" + nonceHex;
    }
    return getAddress(dataSlice(keccak256(encodeRlp([from5, nonceHex])), 12));
  }
  function getCreate2Address(_from, _salt, _initCodeHash) {
    const from5 = getAddress(_from);
    const salt = getBytes(_salt, "salt");
    const initCodeHash = getBytes(_initCodeHash, "initCodeHash");
    assertArgument(salt.length === 32, "salt must be 32 bytes", "salt", _salt);
    assertArgument(initCodeHash.length === 32, "initCodeHash must be 32 bytes", "initCodeHash", _initCodeHash);
    return getAddress(dataSlice(keccak256(concat(["0xff", from5, salt, initCodeHash])), 12));
  }
  var init_contract_address = __esm({
    "node_modules/ethers/lib.esm/address/contract-address.js"() {
      init_crypto2();
      init_utils();
      init_address();
    }
  });

  // node_modules/ethers/lib.esm/address/checks.js
  function isAddressable(value) {
    return value && typeof value.getAddress === "function";
  }
  function isAddress(value) {
    try {
      getAddress(value);
      return true;
    } catch (error) {
    }
    return false;
  }
  async function checkAddress(target, promise) {
    const result = await promise;
    if (result == null || result === "0x0000000000000000000000000000000000000000") {
      assert(typeof target !== "string", "unconfigured name", "UNCONFIGURED_NAME", { value: target });
      assertArgument(false, "invalid AddressLike value; did not resolve to a value address", "target", target);
    }
    return getAddress(result);
  }
  function resolveAddress(target, resolver) {
    if (typeof target === "string") {
      if (target.match(/^0x[0-9a-f]{40}$/i)) {
        return getAddress(target);
      }
      assert(resolver != null, "ENS resolution requires a provider", "UNSUPPORTED_OPERATION", { operation: "resolveName" });
      return checkAddress(target, resolver.resolveName(target));
    } else if (isAddressable(target)) {
      return checkAddress(target, target.getAddress());
    } else if (target && typeof target.then === "function") {
      return checkAddress(target, target);
    }
    assertArgument(false, "unsupported addressable value", "target", target);
  }
  var init_checks = __esm({
    "node_modules/ethers/lib.esm/address/checks.js"() {
      init_utils();
      init_address();
    }
  });

  // node_modules/ethers/lib.esm/address/index.js
  var init_address2 = __esm({
    "node_modules/ethers/lib.esm/address/index.js"() {
      init_address();
      init_contract_address();
      init_checks();
    }
  });

  // node_modules/ethers/lib.esm/abi/typed.js
  function n(value, width) {
    let signed2 = false;
    if (width < 0) {
      signed2 = true;
      width *= -1;
    }
    return new Typed(_gaurd, `${signed2 ? "" : "u"}int${width}`, value, { signed: signed2, width });
  }
  function b(value, size5) {
    return new Typed(_gaurd, `bytes${size5 ? size5 : ""}`, value, { size: size5 });
  }
  var _gaurd, _typedSymbol, _options, _Typed, Typed;
  var init_typed = __esm({
    "node_modules/ethers/lib.esm/abi/typed.js"() {
      init_utils();
      _gaurd = {};
      _typedSymbol = Symbol.for("_ethers_typed");
      _Typed = class _Typed {
        /**
         *  @_ignore:
         */
        constructor(gaurd, type, value, options) {
          /**
           *  The type, as a Solidity-compatible type.
           */
          __publicField(this, "type");
          /**
           *  The actual value.
           */
          __publicField(this, "value");
          __privateAdd(this, _options);
          /**
           *  @_ignore:
           */
          __publicField(this, "_typedSymbol");
          if (options == null) {
            options = null;
          }
          assertPrivate(_gaurd, gaurd, "Typed");
          defineProperties(this, { _typedSymbol, type, value });
          __privateSet(this, _options, options);
          this.format();
        }
        /**
         *  Format the type as a Human-Readable type.
         */
        format() {
          if (this.type === "array") {
            throw new Error("");
          } else if (this.type === "dynamicArray") {
            throw new Error("");
          } else if (this.type === "tuple") {
            return `tuple(${this.value.map((v) => v.format()).join(",")})`;
          }
          return this.type;
        }
        /**
         *  The default value returned by this type.
         */
        defaultValue() {
          return 0;
        }
        /**
         *  The minimum value for numeric types.
         */
        minValue() {
          return 0;
        }
        /**
         *  The maximum value for numeric types.
         */
        maxValue() {
          return 0;
        }
        /**
         *  Returns ``true`` and provides a type guard is this is a [[TypedBigInt]].
         */
        isBigInt() {
          return !!this.type.match(/^u?int[0-9]+$/);
        }
        /**
         *  Returns ``true`` and provides a type guard is this is a [[TypedData]].
         */
        isData() {
          return this.type.startsWith("bytes");
        }
        /**
         *  Returns ``true`` and provides a type guard is this is a [[TypedString]].
         */
        isString() {
          return this.type === "string";
        }
        /**
         *  Returns the tuple name, if this is a tuple. Throws otherwise.
         */
        get tupleName() {
          if (this.type !== "tuple") {
            throw TypeError("not a tuple");
          }
          return __privateGet(this, _options);
        }
        // Returns the length of this type as an array
        // - `null` indicates the length is unforced, it could be dynamic
        // - `-1` indicates the length is dynamic
        // - any other value indicates it is a static array and is its length
        /**
         *  Returns the length of the array type or ``-1`` if it is dynamic.
         *
         *  Throws if the type is not an array.
         */
        get arrayLength() {
          if (this.type !== "array") {
            throw TypeError("not an array");
          }
          if (__privateGet(this, _options) === true) {
            return -1;
          }
          if (__privateGet(this, _options) === false) {
            return this.value.length;
          }
          return null;
        }
        /**
         *  Returns a new **Typed** of %%type%% with the %%value%%.
         */
        static from(type, value) {
          return new _Typed(_gaurd, type, value);
        }
        /**
         *  Return a new ``uint8`` type for %%v%%.
         */
        static uint8(v) {
          return n(v, 8);
        }
        /**
         *  Return a new ``uint16`` type for %%v%%.
         */
        static uint16(v) {
          return n(v, 16);
        }
        /**
         *  Return a new ``uint24`` type for %%v%%.
         */
        static uint24(v) {
          return n(v, 24);
        }
        /**
         *  Return a new ``uint32`` type for %%v%%.
         */
        static uint32(v) {
          return n(v, 32);
        }
        /**
         *  Return a new ``uint40`` type for %%v%%.
         */
        static uint40(v) {
          return n(v, 40);
        }
        /**
         *  Return a new ``uint48`` type for %%v%%.
         */
        static uint48(v) {
          return n(v, 48);
        }
        /**
         *  Return a new ``uint56`` type for %%v%%.
         */
        static uint56(v) {
          return n(v, 56);
        }
        /**
         *  Return a new ``uint64`` type for %%v%%.
         */
        static uint64(v) {
          return n(v, 64);
        }
        /**
         *  Return a new ``uint72`` type for %%v%%.
         */
        static uint72(v) {
          return n(v, 72);
        }
        /**
         *  Return a new ``uint80`` type for %%v%%.
         */
        static uint80(v) {
          return n(v, 80);
        }
        /**
         *  Return a new ``uint88`` type for %%v%%.
         */
        static uint88(v) {
          return n(v, 88);
        }
        /**
         *  Return a new ``uint96`` type for %%v%%.
         */
        static uint96(v) {
          return n(v, 96);
        }
        /**
         *  Return a new ``uint104`` type for %%v%%.
         */
        static uint104(v) {
          return n(v, 104);
        }
        /**
         *  Return a new ``uint112`` type for %%v%%.
         */
        static uint112(v) {
          return n(v, 112);
        }
        /**
         *  Return a new ``uint120`` type for %%v%%.
         */
        static uint120(v) {
          return n(v, 120);
        }
        /**
         *  Return a new ``uint128`` type for %%v%%.
         */
        static uint128(v) {
          return n(v, 128);
        }
        /**
         *  Return a new ``uint136`` type for %%v%%.
         */
        static uint136(v) {
          return n(v, 136);
        }
        /**
         *  Return a new ``uint144`` type for %%v%%.
         */
        static uint144(v) {
          return n(v, 144);
        }
        /**
         *  Return a new ``uint152`` type for %%v%%.
         */
        static uint152(v) {
          return n(v, 152);
        }
        /**
         *  Return a new ``uint160`` type for %%v%%.
         */
        static uint160(v) {
          return n(v, 160);
        }
        /**
         *  Return a new ``uint168`` type for %%v%%.
         */
        static uint168(v) {
          return n(v, 168);
        }
        /**
         *  Return a new ``uint176`` type for %%v%%.
         */
        static uint176(v) {
          return n(v, 176);
        }
        /**
         *  Return a new ``uint184`` type for %%v%%.
         */
        static uint184(v) {
          return n(v, 184);
        }
        /**
         *  Return a new ``uint192`` type for %%v%%.
         */
        static uint192(v) {
          return n(v, 192);
        }
        /**
         *  Return a new ``uint200`` type for %%v%%.
         */
        static uint200(v) {
          return n(v, 200);
        }
        /**
         *  Return a new ``uint208`` type for %%v%%.
         */
        static uint208(v) {
          return n(v, 208);
        }
        /**
         *  Return a new ``uint216`` type for %%v%%.
         */
        static uint216(v) {
          return n(v, 216);
        }
        /**
         *  Return a new ``uint224`` type for %%v%%.
         */
        static uint224(v) {
          return n(v, 224);
        }
        /**
         *  Return a new ``uint232`` type for %%v%%.
         */
        static uint232(v) {
          return n(v, 232);
        }
        /**
         *  Return a new ``uint240`` type for %%v%%.
         */
        static uint240(v) {
          return n(v, 240);
        }
        /**
         *  Return a new ``uint248`` type for %%v%%.
         */
        static uint248(v) {
          return n(v, 248);
        }
        /**
         *  Return a new ``uint256`` type for %%v%%.
         */
        static uint256(v) {
          return n(v, 256);
        }
        /**
         *  Return a new ``uint256`` type for %%v%%.
         */
        static uint(v) {
          return n(v, 256);
        }
        /**
         *  Return a new ``int8`` type for %%v%%.
         */
        static int8(v) {
          return n(v, -8);
        }
        /**
         *  Return a new ``int16`` type for %%v%%.
         */
        static int16(v) {
          return n(v, -16);
        }
        /**
         *  Return a new ``int24`` type for %%v%%.
         */
        static int24(v) {
          return n(v, -24);
        }
        /**
         *  Return a new ``int32`` type for %%v%%.
         */
        static int32(v) {
          return n(v, -32);
        }
        /**
         *  Return a new ``int40`` type for %%v%%.
         */
        static int40(v) {
          return n(v, -40);
        }
        /**
         *  Return a new ``int48`` type for %%v%%.
         */
        static int48(v) {
          return n(v, -48);
        }
        /**
         *  Return a new ``int56`` type for %%v%%.
         */
        static int56(v) {
          return n(v, -56);
        }
        /**
         *  Return a new ``int64`` type for %%v%%.
         */
        static int64(v) {
          return n(v, -64);
        }
        /**
         *  Return a new ``int72`` type for %%v%%.
         */
        static int72(v) {
          return n(v, -72);
        }
        /**
         *  Return a new ``int80`` type for %%v%%.
         */
        static int80(v) {
          return n(v, -80);
        }
        /**
         *  Return a new ``int88`` type for %%v%%.
         */
        static int88(v) {
          return n(v, -88);
        }
        /**
         *  Return a new ``int96`` type for %%v%%.
         */
        static int96(v) {
          return n(v, -96);
        }
        /**
         *  Return a new ``int104`` type for %%v%%.
         */
        static int104(v) {
          return n(v, -104);
        }
        /**
         *  Return a new ``int112`` type for %%v%%.
         */
        static int112(v) {
          return n(v, -112);
        }
        /**
         *  Return a new ``int120`` type for %%v%%.
         */
        static int120(v) {
          return n(v, -120);
        }
        /**
         *  Return a new ``int128`` type for %%v%%.
         */
        static int128(v) {
          return n(v, -128);
        }
        /**
         *  Return a new ``int136`` type for %%v%%.
         */
        static int136(v) {
          return n(v, -136);
        }
        /**
         *  Return a new ``int144`` type for %%v%%.
         */
        static int144(v) {
          return n(v, -144);
        }
        /**
         *  Return a new ``int52`` type for %%v%%.
         */
        static int152(v) {
          return n(v, -152);
        }
        /**
         *  Return a new ``int160`` type for %%v%%.
         */
        static int160(v) {
          return n(v, -160);
        }
        /**
         *  Return a new ``int168`` type for %%v%%.
         */
        static int168(v) {
          return n(v, -168);
        }
        /**
         *  Return a new ``int176`` type for %%v%%.
         */
        static int176(v) {
          return n(v, -176);
        }
        /**
         *  Return a new ``int184`` type for %%v%%.
         */
        static int184(v) {
          return n(v, -184);
        }
        /**
         *  Return a new ``int92`` type for %%v%%.
         */
        static int192(v) {
          return n(v, -192);
        }
        /**
         *  Return a new ``int200`` type for %%v%%.
         */
        static int200(v) {
          return n(v, -200);
        }
        /**
         *  Return a new ``int208`` type for %%v%%.
         */
        static int208(v) {
          return n(v, -208);
        }
        /**
         *  Return a new ``int216`` type for %%v%%.
         */
        static int216(v) {
          return n(v, -216);
        }
        /**
         *  Return a new ``int224`` type for %%v%%.
         */
        static int224(v) {
          return n(v, -224);
        }
        /**
         *  Return a new ``int232`` type for %%v%%.
         */
        static int232(v) {
          return n(v, -232);
        }
        /**
         *  Return a new ``int240`` type for %%v%%.
         */
        static int240(v) {
          return n(v, -240);
        }
        /**
         *  Return a new ``int248`` type for %%v%%.
         */
        static int248(v) {
          return n(v, -248);
        }
        /**
         *  Return a new ``int256`` type for %%v%%.
         */
        static int256(v) {
          return n(v, -256);
        }
        /**
         *  Return a new ``int256`` type for %%v%%.
         */
        static int(v) {
          return n(v, -256);
        }
        /**
         *  Return a new ``bytes1`` type for %%v%%.
         */
        static bytes1(v) {
          return b(v, 1);
        }
        /**
         *  Return a new ``bytes2`` type for %%v%%.
         */
        static bytes2(v) {
          return b(v, 2);
        }
        /**
         *  Return a new ``bytes3`` type for %%v%%.
         */
        static bytes3(v) {
          return b(v, 3);
        }
        /**
         *  Return a new ``bytes4`` type for %%v%%.
         */
        static bytes4(v) {
          return b(v, 4);
        }
        /**
         *  Return a new ``bytes5`` type for %%v%%.
         */
        static bytes5(v) {
          return b(v, 5);
        }
        /**
         *  Return a new ``bytes6`` type for %%v%%.
         */
        static bytes6(v) {
          return b(v, 6);
        }
        /**
         *  Return a new ``bytes7`` type for %%v%%.
         */
        static bytes7(v) {
          return b(v, 7);
        }
        /**
         *  Return a new ``bytes8`` type for %%v%%.
         */
        static bytes8(v) {
          return b(v, 8);
        }
        /**
         *  Return a new ``bytes9`` type for %%v%%.
         */
        static bytes9(v) {
          return b(v, 9);
        }
        /**
         *  Return a new ``bytes10`` type for %%v%%.
         */
        static bytes10(v) {
          return b(v, 10);
        }
        /**
         *  Return a new ``bytes11`` type for %%v%%.
         */
        static bytes11(v) {
          return b(v, 11);
        }
        /**
         *  Return a new ``bytes12`` type for %%v%%.
         */
        static bytes12(v) {
          return b(v, 12);
        }
        /**
         *  Return a new ``bytes13`` type for %%v%%.
         */
        static bytes13(v) {
          return b(v, 13);
        }
        /**
         *  Return a new ``bytes14`` type for %%v%%.
         */
        static bytes14(v) {
          return b(v, 14);
        }
        /**
         *  Return a new ``bytes15`` type for %%v%%.
         */
        static bytes15(v) {
          return b(v, 15);
        }
        /**
         *  Return a new ``bytes16`` type for %%v%%.
         */
        static bytes16(v) {
          return b(v, 16);
        }
        /**
         *  Return a new ``bytes17`` type for %%v%%.
         */
        static bytes17(v) {
          return b(v, 17);
        }
        /**
         *  Return a new ``bytes18`` type for %%v%%.
         */
        static bytes18(v) {
          return b(v, 18);
        }
        /**
         *  Return a new ``bytes19`` type for %%v%%.
         */
        static bytes19(v) {
          return b(v, 19);
        }
        /**
         *  Return a new ``bytes20`` type for %%v%%.
         */
        static bytes20(v) {
          return b(v, 20);
        }
        /**
         *  Return a new ``bytes21`` type for %%v%%.
         */
        static bytes21(v) {
          return b(v, 21);
        }
        /**
         *  Return a new ``bytes22`` type for %%v%%.
         */
        static bytes22(v) {
          return b(v, 22);
        }
        /**
         *  Return a new ``bytes23`` type for %%v%%.
         */
        static bytes23(v) {
          return b(v, 23);
        }
        /**
         *  Return a new ``bytes24`` type for %%v%%.
         */
        static bytes24(v) {
          return b(v, 24);
        }
        /**
         *  Return a new ``bytes25`` type for %%v%%.
         */
        static bytes25(v) {
          return b(v, 25);
        }
        /**
         *  Return a new ``bytes26`` type for %%v%%.
         */
        static bytes26(v) {
          return b(v, 26);
        }
        /**
         *  Return a new ``bytes27`` type for %%v%%.
         */
        static bytes27(v) {
          return b(v, 27);
        }
        /**
         *  Return a new ``bytes28`` type for %%v%%.
         */
        static bytes28(v) {
          return b(v, 28);
        }
        /**
         *  Return a new ``bytes29`` type for %%v%%.
         */
        static bytes29(v) {
          return b(v, 29);
        }
        /**
         *  Return a new ``bytes30`` type for %%v%%.
         */
        static bytes30(v) {
          return b(v, 30);
        }
        /**
         *  Return a new ``bytes31`` type for %%v%%.
         */
        static bytes31(v) {
          return b(v, 31);
        }
        /**
         *  Return a new ``bytes32`` type for %%v%%.
         */
        static bytes32(v) {
          return b(v, 32);
        }
        /**
         *  Return a new ``address`` type for %%v%%.
         */
        static address(v) {
          return new _Typed(_gaurd, "address", v);
        }
        /**
         *  Return a new ``bool`` type for %%v%%.
         */
        static bool(v) {
          return new _Typed(_gaurd, "bool", !!v);
        }
        /**
         *  Return a new ``bytes`` type for %%v%%.
         */
        static bytes(v) {
          return new _Typed(_gaurd, "bytes", v);
        }
        /**
         *  Return a new ``string`` type for %%v%%.
         */
        static string(v) {
          return new _Typed(_gaurd, "string", v);
        }
        /**
         *  Return a new ``array`` type for %%v%%, allowing %%dynamic%% length.
         */
        static array(v, dynamic) {
          throw new Error("not implemented yet");
          return new _Typed(_gaurd, "array", v, dynamic);
        }
        /**
         *  Return a new ``tuple`` type for %%v%%, with the optional %%name%%.
         */
        static tuple(v, name) {
          throw new Error("not implemented yet");
          return new _Typed(_gaurd, "tuple", v, name);
        }
        /**
         *  Return a new ``uint8`` type for %%v%%.
         */
        static overrides(v) {
          return new _Typed(_gaurd, "overrides", Object.assign({}, v));
        }
        /**
         *  Returns true only if %%value%% is a [[Typed]] instance.
         */
        static isTyped(value) {
          return value && typeof value === "object" && "_typedSymbol" in value && value._typedSymbol === _typedSymbol;
        }
        /**
         *  If the value is a [[Typed]] instance, validates the underlying value
         *  and returns it, otherwise returns value directly.
         *
         *  This is useful for functions that with to accept either a [[Typed]]
         *  object or values.
         */
        static dereference(value, type) {
          if (_Typed.isTyped(value)) {
            if (value.type !== type) {
              throw new Error(`invalid type: expecetd ${type}, got ${value.type}`);
            }
            return value.value;
          }
          return value;
        }
      };
      _options = new WeakMap();
      Typed = _Typed;
    }
  });

  // node_modules/ethers/lib.esm/abi/coders/address.js
  var AddressCoder;
  var init_address3 = __esm({
    "node_modules/ethers/lib.esm/abi/coders/address.js"() {
      init_address2();
      init_maths();
      init_typed();
      init_abstract_coder();
      AddressCoder = class extends Coder {
        constructor(localName) {
          super("address", "address", localName, false);
        }
        defaultValue() {
          return "0x0000000000000000000000000000000000000000";
        }
        encode(writer, _value2) {
          let value = Typed.dereference(_value2, "string");
          try {
            value = getAddress(value);
          } catch (error) {
            return this._throwError(error.message, _value2);
          }
          return writer.writeValue(value);
        }
        decode(reader) {
          return getAddress(toBeHex(reader.readValue(), 20));
        }
      };
    }
  });

  // node_modules/ethers/lib.esm/abi/coders/anonymous.js
  var AnonymousCoder;
  var init_anonymous = __esm({
    "node_modules/ethers/lib.esm/abi/coders/anonymous.js"() {
      init_abstract_coder();
      AnonymousCoder = class extends Coder {
        constructor(coder) {
          super(coder.name, coder.type, "_", coder.dynamic);
          __publicField(this, "coder");
          this.coder = coder;
        }
        defaultValue() {
          return this.coder.defaultValue();
        }
        encode(writer, value) {
          return this.coder.encode(writer, value);
        }
        decode(reader) {
          return this.coder.decode(reader);
        }
      };
    }
  });

  // node_modules/ethers/lib.esm/abi/coders/array.js
  function pack(writer, coders, values) {
    let arrayValues = [];
    if (Array.isArray(values)) {
      arrayValues = values;
    } else if (values && typeof values === "object") {
      let unique = {};
      arrayValues = coders.map((coder) => {
        const name = coder.localName;
        assert(name, "cannot encode object for signature with missing names", "INVALID_ARGUMENT", { argument: "values", info: { coder }, value: values });
        assert(!unique[name], "cannot encode object for signature with duplicate names", "INVALID_ARGUMENT", { argument: "values", info: { coder }, value: values });
        unique[name] = true;
        return values[name];
      });
    } else {
      assertArgument(false, "invalid tuple value", "tuple", values);
    }
    assertArgument(coders.length === arrayValues.length, "types/value length mismatch", "tuple", values);
    let staticWriter = new Writer();
    let dynamicWriter = new Writer();
    let updateFuncs = [];
    coders.forEach((coder, index2) => {
      let value = arrayValues[index2];
      if (coder.dynamic) {
        let dynamicOffset = dynamicWriter.length;
        coder.encode(dynamicWriter, value);
        let updateFunc = staticWriter.writeUpdatableValue();
        updateFuncs.push((baseOffset) => {
          updateFunc(baseOffset + dynamicOffset);
        });
      } else {
        coder.encode(staticWriter, value);
      }
    });
    updateFuncs.forEach((func) => {
      func(staticWriter.length);
    });
    let length = writer.appendWriter(staticWriter);
    length += writer.appendWriter(dynamicWriter);
    return length;
  }
  function unpack(reader, coders) {
    let values = [];
    let keys = [];
    let baseReader = reader.subReader(0);
    coders.forEach((coder) => {
      let value = null;
      if (coder.dynamic) {
        let offset = reader.readIndex();
        let offsetReader = baseReader.subReader(offset);
        try {
          value = coder.decode(offsetReader);
        } catch (error) {
          if (isError(error, "BUFFER_OVERRUN")) {
            throw error;
          }
          value = error;
          value.baseType = coder.name;
          value.name = coder.localName;
          value.type = coder.type;
        }
      } else {
        try {
          value = coder.decode(reader);
        } catch (error) {
          if (isError(error, "BUFFER_OVERRUN")) {
            throw error;
          }
          value = error;
          value.baseType = coder.name;
          value.name = coder.localName;
          value.type = coder.type;
        }
      }
      if (value == void 0) {
        throw new Error("investigate");
      }
      values.push(value);
      keys.push(coder.localName || null);
    });
    return Result.fromItems(values, keys);
  }
  var ArrayCoder;
  var init_array = __esm({
    "node_modules/ethers/lib.esm/abi/coders/array.js"() {
      init_utils();
      init_typed();
      init_abstract_coder();
      init_anonymous();
      ArrayCoder = class extends Coder {
        constructor(coder, length, localName) {
          const type = coder.type + "[" + (length >= 0 ? length : "") + "]";
          const dynamic = length === -1 || coder.dynamic;
          super("array", type, localName, dynamic);
          __publicField(this, "coder");
          __publicField(this, "length");
          defineProperties(this, { coder, length });
        }
        defaultValue() {
          const defaultChild = this.coder.defaultValue();
          const result = [];
          for (let i = 0; i < this.length; i++) {
            result.push(defaultChild);
          }
          return result;
        }
        encode(writer, _value2) {
          const value = Typed.dereference(_value2, "array");
          if (!Array.isArray(value)) {
            this._throwError("expected array value", value);
          }
          let count = this.length;
          if (count === -1) {
            count = value.length;
            writer.writeValue(value.length);
          }
          assertArgumentCount(value.length, count, "coder array" + (this.localName ? " " + this.localName : ""));
          let coders = [];
          for (let i = 0; i < value.length; i++) {
            coders.push(this.coder);
          }
          return pack(writer, coders, value);
        }
        decode(reader) {
          let count = this.length;
          if (count === -1) {
            count = reader.readIndex();
            assert(count * WordSize <= reader.dataLength, "insufficient data length", "BUFFER_OVERRUN", { buffer: reader.bytes, offset: count * WordSize, length: reader.dataLength });
          }
          let coders = [];
          for (let i = 0; i < count; i++) {
            coders.push(new AnonymousCoder(this.coder));
          }
          return unpack(reader, coders);
        }
      };
    }
  });

  // node_modules/ethers/lib.esm/abi/coders/boolean.js
  var BooleanCoder;
  var init_boolean = __esm({
    "node_modules/ethers/lib.esm/abi/coders/boolean.js"() {
      init_typed();
      init_abstract_coder();
      BooleanCoder = class extends Coder {
        constructor(localName) {
          super("bool", "bool", localName, false);
        }
        defaultValue() {
          return false;
        }
        encode(writer, _value2) {
          const value = Typed.dereference(_value2, "bool");
          return writer.writeValue(value ? 1 : 0);
        }
        decode(reader) {
          return !!reader.readValue();
        }
      };
    }
  });

  // node_modules/ethers/lib.esm/abi/coders/bytes.js
  var DynamicBytesCoder, BytesCoder;
  var init_bytes = __esm({
    "node_modules/ethers/lib.esm/abi/coders/bytes.js"() {
      init_utils();
      init_abstract_coder();
      DynamicBytesCoder = class extends Coder {
        constructor(type, localName) {
          super(type, type, localName, true);
        }
        defaultValue() {
          return "0x";
        }
        encode(writer, value) {
          value = getBytesCopy(value);
          let length = writer.writeValue(value.length);
          length += writer.writeBytes(value);
          return length;
        }
        decode(reader) {
          return reader.readBytes(reader.readIndex(), true);
        }
      };
      BytesCoder = class extends DynamicBytesCoder {
        constructor(localName) {
          super("bytes", localName);
        }
        decode(reader) {
          return hexlify(super.decode(reader));
        }
      };
    }
  });

  // node_modules/ethers/lib.esm/abi/coders/fixed-bytes.js
  var FixedBytesCoder;
  var init_fixed_bytes = __esm({
    "node_modules/ethers/lib.esm/abi/coders/fixed-bytes.js"() {
      init_utils();
      init_typed();
      init_abstract_coder();
      FixedBytesCoder = class extends Coder {
        constructor(size5, localName) {
          let name = "bytes" + String(size5);
          super(name, name, localName, false);
          __publicField(this, "size");
          defineProperties(this, { size: size5 }, { size: "number" });
        }
        defaultValue() {
          return "0x0000000000000000000000000000000000000000000000000000000000000000".substring(0, 2 + this.size * 2);
        }
        encode(writer, _value2) {
          let data = getBytesCopy(Typed.dereference(_value2, this.type));
          if (data.length !== this.size) {
            this._throwError("incorrect data length", _value2);
          }
          return writer.writeBytes(data);
        }
        decode(reader) {
          return hexlify(reader.readBytes(this.size));
        }
      };
    }
  });

  // node_modules/ethers/lib.esm/abi/coders/null.js
  var Empty, NullCoder;
  var init_null = __esm({
    "node_modules/ethers/lib.esm/abi/coders/null.js"() {
      init_abstract_coder();
      Empty = new Uint8Array([]);
      NullCoder = class extends Coder {
        constructor(localName) {
          super("null", "", localName, false);
        }
        defaultValue() {
          return null;
        }
        encode(writer, value) {
          if (value != null) {
            this._throwError("not null", value);
          }
          return writer.writeBytes(Empty);
        }
        decode(reader) {
          reader.readBytes(0);
          return null;
        }
      };
    }
  });

  // node_modules/ethers/lib.esm/abi/coders/number.js
  var BN_06, BN_14, BN_MAX_UINT256, NumberCoder;
  var init_number = __esm({
    "node_modules/ethers/lib.esm/abi/coders/number.js"() {
      init_utils();
      init_typed();
      init_abstract_coder();
      BN_06 = BigInt(0);
      BN_14 = BigInt(1);
      BN_MAX_UINT256 = BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
      NumberCoder = class extends Coder {
        constructor(size5, signed2, localName) {
          const name = (signed2 ? "int" : "uint") + size5 * 8;
          super(name, name, localName, false);
          __publicField(this, "size");
          __publicField(this, "signed");
          defineProperties(this, { size: size5, signed: signed2 }, { size: "number", signed: "boolean" });
        }
        defaultValue() {
          return 0;
        }
        encode(writer, _value2) {
          let value = getBigInt(Typed.dereference(_value2, this.type));
          let maxUintValue = mask(BN_MAX_UINT256, WordSize * 8);
          if (this.signed) {
            let bounds = mask(maxUintValue, this.size * 8 - 1);
            if (value > bounds || value < -(bounds + BN_14)) {
              this._throwError("value out-of-bounds", _value2);
            }
            value = toTwos(value, 8 * WordSize);
          } else if (value < BN_06 || value > mask(maxUintValue, this.size * 8)) {
            this._throwError("value out-of-bounds", _value2);
          }
          return writer.writeValue(value);
        }
        decode(reader) {
          let value = mask(reader.readValue(), this.size * 8);
          if (this.signed) {
            value = fromTwos(value, this.size * 8);
          }
          return value;
        }
      };
    }
  });

  // node_modules/ethers/lib.esm/abi/coders/string.js
  var StringCoder;
  var init_string = __esm({
    "node_modules/ethers/lib.esm/abi/coders/string.js"() {
      init_utf8();
      init_typed();
      init_bytes();
      StringCoder = class extends DynamicBytesCoder {
        constructor(localName) {
          super("string", localName);
        }
        defaultValue() {
          return "";
        }
        encode(writer, _value2) {
          return super.encode(writer, toUtf8Bytes(Typed.dereference(_value2, "string")));
        }
        decode(reader) {
          return toUtf8String(super.decode(reader));
        }
      };
    }
  });

  // node_modules/ethers/lib.esm/abi/coders/tuple.js
  var TupleCoder;
  var init_tuple = __esm({
    "node_modules/ethers/lib.esm/abi/coders/tuple.js"() {
      init_properties();
      init_typed();
      init_abstract_coder();
      init_array();
      TupleCoder = class extends Coder {
        constructor(coders, localName) {
          let dynamic = false;
          const types = [];
          coders.forEach((coder) => {
            if (coder.dynamic) {
              dynamic = true;
            }
            types.push(coder.type);
          });
          const type = "tuple(" + types.join(",") + ")";
          super("tuple", type, localName, dynamic);
          __publicField(this, "coders");
          defineProperties(this, { coders: Object.freeze(coders.slice()) });
        }
        defaultValue() {
          const values = [];
          this.coders.forEach((coder) => {
            values.push(coder.defaultValue());
          });
          const uniqueNames = this.coders.reduce((accum, coder) => {
            const name = coder.localName;
            if (name) {
              if (!accum[name]) {
                accum[name] = 0;
              }
              accum[name]++;
            }
            return accum;
          }, {});
          this.coders.forEach((coder, index2) => {
            let name = coder.localName;
            if (!name || uniqueNames[name] !== 1) {
              return;
            }
            if (name === "length") {
              name = "_length";
            }
            if (values[name] != null) {
              return;
            }
            values[name] = values[index2];
          });
          return Object.freeze(values);
        }
        encode(writer, _value2) {
          const value = Typed.dereference(_value2, "tuple");
          return pack(writer, this.coders, value);
        }
        decode(reader) {
          return unpack(reader, this.coders);
        }
      };
    }
  });

  // node_modules/ethers/lib.esm/transaction/accesslist.js
  function accessSetify(addr, storageKeys) {
    return {
      address: getAddress(addr),
      storageKeys: storageKeys.map((storageKey, index2) => {
        assertArgument(isHexString(storageKey, 32), "invalid slot", `storageKeys[${index2}]`, storageKey);
        return storageKey.toLowerCase();
      })
    };
  }
  function accessListify(value) {
    if (Array.isArray(value)) {
      return value.map((set, index2) => {
        if (Array.isArray(set)) {
          assertArgument(set.length === 2, "invalid slot set", `value[${index2}]`, set);
          return accessSetify(set[0], set[1]);
        }
        assertArgument(set != null && typeof set === "object", "invalid address-slot set", "value", value);
        return accessSetify(set.address, set.storageKeys);
      });
    }
    assertArgument(value != null && typeof value === "object", "invalid access list", "value", value);
    const result = Object.keys(value).map((addr) => {
      const storageKeys = value[addr].reduce((accum, storageKey) => {
        accum[storageKey] = true;
        return accum;
      }, {});
      return accessSetify(addr, Object.keys(storageKeys).sort());
    });
    result.sort((a, b2) => a.address.localeCompare(b2.address));
    return result;
  }
  var init_accesslist = __esm({
    "node_modules/ethers/lib.esm/transaction/accesslist.js"() {
      init_address2();
      init_utils();
    }
  });

  // node_modules/ethers/lib.esm/transaction/authorization.js
  function authorizationify(auth) {
    return {
      address: getAddress(auth.address),
      nonce: getBigInt(auth.nonce != null ? auth.nonce : 0),
      chainId: getBigInt(auth.chainId != null ? auth.chainId : 0),
      signature: Signature.from(auth.signature)
    };
  }
  var init_authorization = __esm({
    "node_modules/ethers/lib.esm/transaction/authorization.js"() {
      init_address2();
      init_crypto2();
      init_utils();
    }
  });

  // node_modules/ethers/lib.esm/transaction/address.js
  function computeAddress(key) {
    let pubkey;
    if (typeof key === "string") {
      pubkey = SigningKey.computePublicKey(key, false);
    } else {
      pubkey = key.publicKey;
    }
    return getAddress(keccak256("0x" + pubkey.substring(4)).substring(26));
  }
  function recoverAddress(digest, signature) {
    return computeAddress(SigningKey.recoverPublicKey(digest, signature));
  }
  var init_address4 = __esm({
    "node_modules/ethers/lib.esm/transaction/address.js"() {
      init_address2();
      init_crypto2();
    }
  });

  // node_modules/ethers/lib.esm/transaction/transaction.js
  function getKzgLibrary(kzg) {
    const blobToKzgCommitment = (blob) => {
      if ("computeBlobProof" in kzg) {
        if ("blobToKzgCommitment" in kzg && typeof kzg.blobToKzgCommitment === "function") {
          return getBytes(kzg.blobToKzgCommitment(hexlify(blob)));
        }
      } else if ("blobToKzgCommitment" in kzg && typeof kzg.blobToKzgCommitment === "function") {
        return getBytes(kzg.blobToKzgCommitment(blob));
      }
      if ("blobToKZGCommitment" in kzg && typeof kzg.blobToKZGCommitment === "function") {
        return getBytes(kzg.blobToKZGCommitment(hexlify(blob)));
      }
      assertArgument(false, "unsupported KZG library", "kzg", kzg);
    };
    const computeBlobKzgProof = (blob, commitment) => {
      if ("computeBlobProof" in kzg && typeof kzg.computeBlobProof === "function") {
        return getBytes(kzg.computeBlobProof(hexlify(blob), hexlify(commitment)));
      }
      if ("computeBlobKzgProof" in kzg && typeof kzg.computeBlobKzgProof === "function") {
        return kzg.computeBlobKzgProof(blob, commitment);
      }
      if ("computeBlobKZGProof" in kzg && typeof kzg.computeBlobKZGProof === "function") {
        return getBytes(kzg.computeBlobKZGProof(hexlify(blob), hexlify(commitment)));
      }
      assertArgument(false, "unsupported KZG library", "kzg", kzg);
    };
    return { blobToKzgCommitment, computeBlobKzgProof };
  }
  function getVersionedHash(version5, hash3) {
    let versioned = version5.toString(16);
    while (versioned.length < 2) {
      versioned = "0" + versioned;
    }
    versioned += sha2562(hash3).substring(4);
    return "0x" + versioned;
  }
  function handleAddress(value) {
    if (value === "0x") {
      return null;
    }
    return getAddress(value);
  }
  function handleAccessList(value, param) {
    try {
      return accessListify(value);
    } catch (error) {
      assertArgument(false, error.message, param, value);
    }
  }
  function handleAuthorizationList(value, param) {
    try {
      if (!Array.isArray(value)) {
        throw new Error("authorizationList: invalid array");
      }
      const result = [];
      for (let i = 0; i < value.length; i++) {
        const auth = value[i];
        if (!Array.isArray(auth)) {
          throw new Error(`authorization[${i}]: invalid array`);
        }
        if (auth.length !== 6) {
          throw new Error(`authorization[${i}]: wrong length`);
        }
        if (!auth[1]) {
          throw new Error(`authorization[${i}]: null address`);
        }
        result.push({
          address: handleAddress(auth[1]),
          nonce: handleUint(auth[2], "nonce"),
          chainId: handleUint(auth[0], "chainId"),
          signature: Signature.from({
            yParity: handleNumber(auth[3], "yParity"),
            r: zeroPadValue(auth[4], 32),
            s: zeroPadValue(auth[5], 32)
          })
        });
      }
      return result;
    } catch (error) {
      assertArgument(false, error.message, param, value);
    }
  }
  function handleNumber(_value2, param) {
    if (_value2 === "0x") {
      return 0;
    }
    return getNumber(_value2, param);
  }
  function handleUint(_value2, param) {
    if (_value2 === "0x") {
      return BN_07;
    }
    const value = getBigInt(_value2, param);
    assertArgument(value <= BN_MAX_UINT, "value exceeds uint size", param, value);
    return value;
  }
  function formatNumber(_value2, name) {
    const value = getBigInt(_value2, "value");
    const result = toBeArray(value);
    assertArgument(result.length <= 32, `value too large`, `tx.${name}`, value);
    return result;
  }
  function formatAccessList(value) {
    return accessListify(value).map((set) => [set.address, set.storageKeys]);
  }
  function formatAuthorizationList(value) {
    return value.map((a) => {
      return [
        formatNumber(a.chainId, "chainId"),
        a.address,
        formatNumber(a.nonce, "nonce"),
        formatNumber(a.signature.yParity, "yParity"),
        toBeArray(a.signature.r),
        toBeArray(a.signature.s)
      ];
    });
  }
  function formatHashes(value, param) {
    assertArgument(Array.isArray(value), `invalid ${param}`, "value", value);
    for (let i = 0; i < value.length; i++) {
      assertArgument(isHexString(value[i], 32), "invalid ${ param } hash", `value[${i}]`, value[i]);
    }
    return value;
  }
  function _parseLegacy(data) {
    const fields = decodeRlp(data);
    assertArgument(Array.isArray(fields) && (fields.length === 9 || fields.length === 6), "invalid field count for legacy transaction", "data", data);
    const tx = {
      type: 0,
      nonce: handleNumber(fields[0], "nonce"),
      gasPrice: handleUint(fields[1], "gasPrice"),
      gasLimit: handleUint(fields[2], "gasLimit"),
      to: handleAddress(fields[3]),
      value: handleUint(fields[4], "value"),
      data: hexlify(fields[5]),
      chainId: BN_07
    };
    if (fields.length === 6) {
      return tx;
    }
    const v = handleUint(fields[6], "v");
    const r = handleUint(fields[7], "r");
    const s = handleUint(fields[8], "s");
    if (r === BN_07 && s === BN_07) {
      tx.chainId = v;
    } else {
      let chainId = (v - BN_352) / BN_22;
      if (chainId < BN_07) {
        chainId = BN_07;
      }
      tx.chainId = chainId;
      assertArgument(chainId !== BN_07 || (v === BN_272 || v === BN_282), "non-canonical legacy v", "v", fields[6]);
      tx.signature = Signature.from({
        r: zeroPadValue(fields[7], 32),
        s: zeroPadValue(fields[8], 32),
        v
      });
    }
    return tx;
  }
  function _serializeLegacy(tx, sig) {
    const fields = [
      formatNumber(tx.nonce, "nonce"),
      formatNumber(tx.gasPrice || 0, "gasPrice"),
      formatNumber(tx.gasLimit, "gasLimit"),
      tx.to || "0x",
      formatNumber(tx.value, "value"),
      tx.data
    ];
    let chainId = BN_07;
    if (tx.chainId != BN_07) {
      chainId = getBigInt(tx.chainId, "tx.chainId");
      assertArgument(!sig || sig.networkV == null || sig.legacyChainId === chainId, "tx.chainId/sig.v mismatch", "sig", sig);
    } else if (tx.signature) {
      const legacy = tx.signature.legacyChainId;
      if (legacy != null) {
        chainId = legacy;
      }
    }
    if (!sig) {
      if (chainId !== BN_07) {
        fields.push(toBeArray(chainId));
        fields.push("0x");
        fields.push("0x");
      }
      return encodeRlp(fields);
    }
    let v = BigInt(27 + sig.yParity);
    if (chainId !== BN_07) {
      v = Signature.getChainIdV(chainId, sig.v);
    } else if (BigInt(sig.v) !== v) {
      assertArgument(false, "tx.chainId/sig.v mismatch", "sig", sig);
    }
    fields.push(toBeArray(v));
    fields.push(toBeArray(sig.r));
    fields.push(toBeArray(sig.s));
    return encodeRlp(fields);
  }
  function _parseEipSignature(tx, fields) {
    let yParity;
    try {
      yParity = handleNumber(fields[0], "yParity");
      if (yParity !== 0 && yParity !== 1) {
        throw new Error("bad yParity");
      }
    } catch (error) {
      assertArgument(false, "invalid yParity", "yParity", fields[0]);
    }
    const r = zeroPadValue(fields[1], 32);
    const s = zeroPadValue(fields[2], 32);
    const signature = Signature.from({ r, s, yParity });
    tx.signature = signature;
  }
  function _parseEip1559(data) {
    const fields = decodeRlp(getBytes(data).slice(1));
    assertArgument(Array.isArray(fields) && (fields.length === 9 || fields.length === 12), "invalid field count for transaction type: 2", "data", hexlify(data));
    const tx = {
      type: 2,
      chainId: handleUint(fields[0], "chainId"),
      nonce: handleNumber(fields[1], "nonce"),
      maxPriorityFeePerGas: handleUint(fields[2], "maxPriorityFeePerGas"),
      maxFeePerGas: handleUint(fields[3], "maxFeePerGas"),
      gasPrice: null,
      gasLimit: handleUint(fields[4], "gasLimit"),
      to: handleAddress(fields[5]),
      value: handleUint(fields[6], "value"),
      data: hexlify(fields[7]),
      accessList: handleAccessList(fields[8], "accessList")
    };
    if (fields.length === 9) {
      return tx;
    }
    _parseEipSignature(tx, fields.slice(9));
    return tx;
  }
  function _serializeEip1559(tx, sig) {
    const fields = [
      formatNumber(tx.chainId, "chainId"),
      formatNumber(tx.nonce, "nonce"),
      formatNumber(tx.maxPriorityFeePerGas || 0, "maxPriorityFeePerGas"),
      formatNumber(tx.maxFeePerGas || 0, "maxFeePerGas"),
      formatNumber(tx.gasLimit, "gasLimit"),
      tx.to || "0x",
      formatNumber(tx.value, "value"),
      tx.data,
      formatAccessList(tx.accessList || [])
    ];
    if (sig) {
      fields.push(formatNumber(sig.yParity, "yParity"));
      fields.push(toBeArray(sig.r));
      fields.push(toBeArray(sig.s));
    }
    return concat(["0x02", encodeRlp(fields)]);
  }
  function _parseEip2930(data) {
    const fields = decodeRlp(getBytes(data).slice(1));
    assertArgument(Array.isArray(fields) && (fields.length === 8 || fields.length === 11), "invalid field count for transaction type: 1", "data", hexlify(data));
    const tx = {
      type: 1,
      chainId: handleUint(fields[0], "chainId"),
      nonce: handleNumber(fields[1], "nonce"),
      gasPrice: handleUint(fields[2], "gasPrice"),
      gasLimit: handleUint(fields[3], "gasLimit"),
      to: handleAddress(fields[4]),
      value: handleUint(fields[5], "value"),
      data: hexlify(fields[6]),
      accessList: handleAccessList(fields[7], "accessList")
    };
    if (fields.length === 8) {
      return tx;
    }
    _parseEipSignature(tx, fields.slice(8));
    return tx;
  }
  function _serializeEip2930(tx, sig) {
    const fields = [
      formatNumber(tx.chainId, "chainId"),
      formatNumber(tx.nonce, "nonce"),
      formatNumber(tx.gasPrice || 0, "gasPrice"),
      formatNumber(tx.gasLimit, "gasLimit"),
      tx.to || "0x",
      formatNumber(tx.value, "value"),
      tx.data,
      formatAccessList(tx.accessList || [])
    ];
    if (sig) {
      fields.push(formatNumber(sig.yParity, "recoveryParam"));
      fields.push(toBeArray(sig.r));
      fields.push(toBeArray(sig.s));
    }
    return concat(["0x01", encodeRlp(fields)]);
  }
  function _parseEip4844(data) {
    let fields = decodeRlp(getBytes(data).slice(1));
    let typeName = "3";
    let blobs = null;
    if (fields.length === 4 && Array.isArray(fields[0])) {
      typeName = "3 (network format)";
      const fBlobs = fields[1], fCommits = fields[2], fProofs = fields[3];
      assertArgument(Array.isArray(fBlobs), "invalid network format: blobs not an array", "fields[1]", fBlobs);
      assertArgument(Array.isArray(fCommits), "invalid network format: commitments not an array", "fields[2]", fCommits);
      assertArgument(Array.isArray(fProofs), "invalid network format: proofs not an array", "fields[3]", fProofs);
      assertArgument(fBlobs.length === fCommits.length, "invalid network format: blobs/commitments length mismatch", "fields", fields);
      assertArgument(fBlobs.length === fProofs.length, "invalid network format: blobs/proofs length mismatch", "fields", fields);
      blobs = [];
      for (let i = 0; i < fields[1].length; i++) {
        blobs.push({
          data: fBlobs[i],
          commitment: fCommits[i],
          proof: fProofs[i]
        });
      }
      fields = fields[0];
    }
    assertArgument(Array.isArray(fields) && (fields.length === 11 || fields.length === 14), `invalid field count for transaction type: ${typeName}`, "data", hexlify(data));
    const tx = {
      type: 3,
      chainId: handleUint(fields[0], "chainId"),
      nonce: handleNumber(fields[1], "nonce"),
      maxPriorityFeePerGas: handleUint(fields[2], "maxPriorityFeePerGas"),
      maxFeePerGas: handleUint(fields[3], "maxFeePerGas"),
      gasPrice: null,
      gasLimit: handleUint(fields[4], "gasLimit"),
      to: handleAddress(fields[5]),
      value: handleUint(fields[6], "value"),
      data: hexlify(fields[7]),
      accessList: handleAccessList(fields[8], "accessList"),
      maxFeePerBlobGas: handleUint(fields[9], "maxFeePerBlobGas"),
      blobVersionedHashes: fields[10]
    };
    if (blobs) {
      tx.blobs = blobs;
    }
    assertArgument(tx.to != null, `invalid address for transaction type: ${typeName}`, "data", data);
    assertArgument(Array.isArray(tx.blobVersionedHashes), "invalid blobVersionedHashes: must be an array", "data", data);
    for (let i = 0; i < tx.blobVersionedHashes.length; i++) {
      assertArgument(isHexString(tx.blobVersionedHashes[i], 32), `invalid blobVersionedHash at index ${i}: must be length 32`, "data", data);
    }
    if (fields.length === 11) {
      return tx;
    }
    _parseEipSignature(tx, fields.slice(11));
    return tx;
  }
  function _serializeEip4844(tx, sig, blobs) {
    const fields = [
      formatNumber(tx.chainId, "chainId"),
      formatNumber(tx.nonce, "nonce"),
      formatNumber(tx.maxPriorityFeePerGas || 0, "maxPriorityFeePerGas"),
      formatNumber(tx.maxFeePerGas || 0, "maxFeePerGas"),
      formatNumber(tx.gasLimit, "gasLimit"),
      tx.to || ZeroAddress,
      formatNumber(tx.value, "value"),
      tx.data,
      formatAccessList(tx.accessList || []),
      formatNumber(tx.maxFeePerBlobGas || 0, "maxFeePerBlobGas"),
      formatHashes(tx.blobVersionedHashes || [], "blobVersionedHashes")
    ];
    if (sig) {
      fields.push(formatNumber(sig.yParity, "yParity"));
      fields.push(toBeArray(sig.r));
      fields.push(toBeArray(sig.s));
      if (blobs) {
        return concat([
          "0x03",
          encodeRlp([
            fields,
            blobs.map((b2) => b2.data),
            blobs.map((b2) => b2.commitment),
            blobs.map((b2) => b2.proof)
          ])
        ]);
      }
    }
    return concat(["0x03", encodeRlp(fields)]);
  }
  function _parseEip7702(data) {
    const fields = decodeRlp(getBytes(data).slice(1));
    assertArgument(Array.isArray(fields) && (fields.length === 10 || fields.length === 13), "invalid field count for transaction type: 4", "data", hexlify(data));
    const tx = {
      type: 4,
      chainId: handleUint(fields[0], "chainId"),
      nonce: handleNumber(fields[1], "nonce"),
      maxPriorityFeePerGas: handleUint(fields[2], "maxPriorityFeePerGas"),
      maxFeePerGas: handleUint(fields[3], "maxFeePerGas"),
      gasPrice: null,
      gasLimit: handleUint(fields[4], "gasLimit"),
      to: handleAddress(fields[5]),
      value: handleUint(fields[6], "value"),
      data: hexlify(fields[7]),
      accessList: handleAccessList(fields[8], "accessList"),
      authorizationList: handleAuthorizationList(fields[9], "authorizationList")
    };
    if (fields.length === 10) {
      return tx;
    }
    _parseEipSignature(tx, fields.slice(10));
    return tx;
  }
  function _serializeEip7702(tx, sig) {
    const fields = [
      formatNumber(tx.chainId, "chainId"),
      formatNumber(tx.nonce, "nonce"),
      formatNumber(tx.maxPriorityFeePerGas || 0, "maxPriorityFeePerGas"),
      formatNumber(tx.maxFeePerGas || 0, "maxFeePerGas"),
      formatNumber(tx.gasLimit, "gasLimit"),
      tx.to || "0x",
      formatNumber(tx.value, "value"),
      tx.data,
      formatAccessList(tx.accessList || []),
      formatAuthorizationList(tx.authorizationList || [])
    ];
    if (sig) {
      fields.push(formatNumber(sig.yParity, "yParity"));
      fields.push(toBeArray(sig.r));
      fields.push(toBeArray(sig.s));
    }
    return concat(["0x04", encodeRlp(fields)]);
  }
  var BN_07, BN_22, BN_272, BN_282, BN_352, BN_MAX_UINT, BLOB_SIZE, _type, _to, _data3, _nonce, _gasLimit, _gasPrice, _maxPriorityFeePerGas, _maxFeePerGas, _value, _chainId, _sig, _accessList, _maxFeePerBlobGas, _blobVersionedHashes, _kzg, _blobs, _auths, _Transaction_instances, getSerialized_fn, _Transaction, Transaction;
  var init_transaction = __esm({
    "node_modules/ethers/lib.esm/transaction/transaction.js"() {
      init_address2();
      init_addresses();
      init_crypto2();
      init_utils();
      init_accesslist();
      init_authorization();
      init_address4();
      BN_07 = BigInt(0);
      BN_22 = BigInt(2);
      BN_272 = BigInt(27);
      BN_282 = BigInt(28);
      BN_352 = BigInt(35);
      BN_MAX_UINT = BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
      BLOB_SIZE = 4096 * 32;
      _Transaction = class _Transaction {
        /**
         *  Creates a new Transaction with default values.
         */
        constructor() {
          __privateAdd(this, _Transaction_instances);
          __privateAdd(this, _type);
          __privateAdd(this, _to);
          __privateAdd(this, _data3);
          __privateAdd(this, _nonce);
          __privateAdd(this, _gasLimit);
          __privateAdd(this, _gasPrice);
          __privateAdd(this, _maxPriorityFeePerGas);
          __privateAdd(this, _maxFeePerGas);
          __privateAdd(this, _value);
          __privateAdd(this, _chainId);
          __privateAdd(this, _sig);
          __privateAdd(this, _accessList);
          __privateAdd(this, _maxFeePerBlobGas);
          __privateAdd(this, _blobVersionedHashes);
          __privateAdd(this, _kzg);
          __privateAdd(this, _blobs);
          __privateAdd(this, _auths);
          __privateSet(this, _type, null);
          __privateSet(this, _to, null);
          __privateSet(this, _nonce, 0);
          __privateSet(this, _gasLimit, BN_07);
          __privateSet(this, _gasPrice, null);
          __privateSet(this, _maxPriorityFeePerGas, null);
          __privateSet(this, _maxFeePerGas, null);
          __privateSet(this, _data3, "0x");
          __privateSet(this, _value, BN_07);
          __privateSet(this, _chainId, BN_07);
          __privateSet(this, _sig, null);
          __privateSet(this, _accessList, null);
          __privateSet(this, _maxFeePerBlobGas, null);
          __privateSet(this, _blobVersionedHashes, null);
          __privateSet(this, _kzg, null);
          __privateSet(this, _blobs, null);
          __privateSet(this, _auths, null);
        }
        /**
         *  The transaction type.
         *
         *  If null, the type will be automatically inferred based on
         *  explicit properties.
         */
        get type() {
          return __privateGet(this, _type);
        }
        set type(value) {
          switch (value) {
            case null:
              __privateSet(this, _type, null);
              break;
            case 0:
            case "legacy":
              __privateSet(this, _type, 0);
              break;
            case 1:
            case "berlin":
            case "eip-2930":
              __privateSet(this, _type, 1);
              break;
            case 2:
            case "london":
            case "eip-1559":
              __privateSet(this, _type, 2);
              break;
            case 3:
            case "cancun":
            case "eip-4844":
              __privateSet(this, _type, 3);
              break;
            case 4:
            case "pectra":
            case "eip-7702":
              __privateSet(this, _type, 4);
              break;
            default:
              assertArgument(false, "unsupported transaction type", "type", value);
          }
        }
        /**
         *  The name of the transaction type.
         */
        get typeName() {
          switch (this.type) {
            case 0:
              return "legacy";
            case 1:
              return "eip-2930";
            case 2:
              return "eip-1559";
            case 3:
              return "eip-4844";
            case 4:
              return "eip-7702";
          }
          return null;
        }
        /**
         *  The ``to`` address for the transaction or ``null`` if the
         *  transaction is an ``init`` transaction.
         */
        get to() {
          const value = __privateGet(this, _to);
          if (value == null && this.type === 3) {
            return ZeroAddress;
          }
          return value;
        }
        set to(value) {
          __privateSet(this, _to, value == null ? null : getAddress(value));
        }
        /**
         *  The transaction nonce.
         */
        get nonce() {
          return __privateGet(this, _nonce);
        }
        set nonce(value) {
          __privateSet(this, _nonce, getNumber(value, "value"));
        }
        /**
         *  The gas limit.
         */
        get gasLimit() {
          return __privateGet(this, _gasLimit);
        }
        set gasLimit(value) {
          __privateSet(this, _gasLimit, getBigInt(value));
        }
        /**
         *  The gas price.
         *
         *  On legacy networks this defines the fee that will be paid. On
         *  EIP-1559 networks, this should be ``null``.
         */
        get gasPrice() {
          const value = __privateGet(this, _gasPrice);
          if (value == null && (this.type === 0 || this.type === 1)) {
            return BN_07;
          }
          return value;
        }
        set gasPrice(value) {
          __privateSet(this, _gasPrice, value == null ? null : getBigInt(value, "gasPrice"));
        }
        /**
         *  The maximum priority fee per unit of gas to pay. On legacy
         *  networks this should be ``null``.
         */
        get maxPriorityFeePerGas() {
          const value = __privateGet(this, _maxPriorityFeePerGas);
          if (value == null) {
            if (this.type === 2 || this.type === 3) {
              return BN_07;
            }
            return null;
          }
          return value;
        }
        set maxPriorityFeePerGas(value) {
          __privateSet(this, _maxPriorityFeePerGas, value == null ? null : getBigInt(value, "maxPriorityFeePerGas"));
        }
        /**
         *  The maximum total fee per unit of gas to pay. On legacy
         *  networks this should be ``null``.
         */
        get maxFeePerGas() {
          const value = __privateGet(this, _maxFeePerGas);
          if (value == null) {
            if (this.type === 2 || this.type === 3) {
              return BN_07;
            }
            return null;
          }
          return value;
        }
        set maxFeePerGas(value) {
          __privateSet(this, _maxFeePerGas, value == null ? null : getBigInt(value, "maxFeePerGas"));
        }
        /**
         *  The transaction data. For ``init`` transactions this is the
         *  deployment code.
         */
        get data() {
          return __privateGet(this, _data3);
        }
        set data(value) {
          __privateSet(this, _data3, hexlify(value));
        }
        /**
         *  The amount of ether (in wei) to send in this transactions.
         */
        get value() {
          return __privateGet(this, _value);
        }
        set value(value) {
          __privateSet(this, _value, getBigInt(value, "value"));
        }
        /**
         *  The chain ID this transaction is valid on.
         */
        get chainId() {
          return __privateGet(this, _chainId);
        }
        set chainId(value) {
          __privateSet(this, _chainId, getBigInt(value));
        }
        /**
         *  If signed, the signature for this transaction.
         */
        get signature() {
          return __privateGet(this, _sig) || null;
        }
        set signature(value) {
          __privateSet(this, _sig, value == null ? null : Signature.from(value));
        }
        /**
         *  The access list.
         *
         *  An access list permits discounted (but pre-paid) access to
         *  bytecode and state variable access within contract execution.
         */
        get accessList() {
          const value = __privateGet(this, _accessList) || null;
          if (value == null) {
            if (this.type === 1 || this.type === 2 || this.type === 3) {
              return [];
            }
            return null;
          }
          return value;
        }
        set accessList(value) {
          __privateSet(this, _accessList, value == null ? null : accessListify(value));
        }
        get authorizationList() {
          const value = __privateGet(this, _auths) || null;
          if (value == null) {
            if (this.type === 4) {
              return [];
            }
          }
          return value;
        }
        set authorizationList(auths) {
          __privateSet(this, _auths, auths == null ? null : auths.map((a) => authorizationify(a)));
        }
        /**
         *  The max fee per blob gas for Cancun transactions.
         */
        get maxFeePerBlobGas() {
          const value = __privateGet(this, _maxFeePerBlobGas);
          if (value == null && this.type === 3) {
            return BN_07;
          }
          return value;
        }
        set maxFeePerBlobGas(value) {
          __privateSet(this, _maxFeePerBlobGas, value == null ? null : getBigInt(value, "maxFeePerBlobGas"));
        }
        /**
         *  The BLOb versioned hashes for Cancun transactions.
         */
        get blobVersionedHashes() {
          let value = __privateGet(this, _blobVersionedHashes);
          if (value == null && this.type === 3) {
            return [];
          }
          return value;
        }
        set blobVersionedHashes(value) {
          if (value != null) {
            assertArgument(Array.isArray(value), "blobVersionedHashes must be an Array", "value", value);
            value = value.slice();
            for (let i = 0; i < value.length; i++) {
              assertArgument(isHexString(value[i], 32), "invalid blobVersionedHash", `value[${i}]`, value[i]);
            }
          }
          __privateSet(this, _blobVersionedHashes, value);
        }
        /**
         *  The BLObs for the Transaction, if any.
         *
         *  If ``blobs`` is non-``null``, then the [[seriailized]]
         *  will return the network formatted sidecar, otherwise it
         *  will return the standard [[link-eip-2718]] payload. The
         *  [[unsignedSerialized]] is unaffected regardless.
         *
         *  When setting ``blobs``, either fully valid [[Blob]] objects
         *  may be specified (i.e. correctly padded, with correct
         *  committments and proofs) or a raw [[BytesLike]] may
         *  be provided.
         *
         *  If raw [[BytesLike]] are provided, the [[kzg]] property **must**
         *  be already set. The blob will be correctly padded and the
         *  [[KzgLibrary]] will be used to compute the committment and
         *  proof for the blob.
         *
         *  A BLOb is a sequence of field elements, each of which must
         *  be within the BLS field modulo, so some additional processing
         *  may be required to encode arbitrary data to ensure each 32 byte
         *  field is within the valid range.
         *
         *  Setting this automatically populates [[blobVersionedHashes]],
         *  overwriting any existing values. Setting this to ``null``
         *  does **not** remove the [[blobVersionedHashes]], leaving them
         *  present.
         */
        get blobs() {
          if (__privateGet(this, _blobs) == null) {
            return null;
          }
          return __privateGet(this, _blobs).map((b2) => Object.assign({}, b2));
        }
        set blobs(_blobs2) {
          if (_blobs2 == null) {
            __privateSet(this, _blobs, null);
            return;
          }
          const blobs = [];
          const versionedHashes = [];
          for (let i = 0; i < _blobs2.length; i++) {
            const blob = _blobs2[i];
            if (isBytesLike(blob)) {
              assert(__privateGet(this, _kzg), "adding a raw blob requires a KZG library", "UNSUPPORTED_OPERATION", {
                operation: "set blobs()"
              });
              let data = getBytes(blob);
              assertArgument(data.length <= BLOB_SIZE, "blob is too large", `blobs[${i}]`, blob);
              if (data.length !== BLOB_SIZE) {
                const padded = new Uint8Array(BLOB_SIZE);
                padded.set(data);
                data = padded;
              }
              const commit = __privateGet(this, _kzg).blobToKzgCommitment(data);
              const proof = hexlify(__privateGet(this, _kzg).computeBlobKzgProof(data, commit));
              blobs.push({
                data: hexlify(data),
                commitment: hexlify(commit),
                proof
              });
              versionedHashes.push(getVersionedHash(1, commit));
            } else {
              const commit = hexlify(blob.commitment);
              blobs.push({
                data: hexlify(blob.data),
                commitment: commit,
                proof: hexlify(blob.proof)
              });
              versionedHashes.push(getVersionedHash(1, commit));
            }
          }
          __privateSet(this, _blobs, blobs);
          __privateSet(this, _blobVersionedHashes, versionedHashes);
        }
        get kzg() {
          return __privateGet(this, _kzg);
        }
        set kzg(kzg) {
          if (kzg == null) {
            __privateSet(this, _kzg, null);
          } else {
            __privateSet(this, _kzg, getKzgLibrary(kzg));
          }
        }
        /**
         *  The transaction hash, if signed. Otherwise, ``null``.
         */
        get hash() {
          if (this.signature == null) {
            return null;
          }
          return keccak256(__privateMethod(this, _Transaction_instances, getSerialized_fn).call(this, true, false));
        }
        /**
         *  The pre-image hash of this transaction.
         *
         *  This is the digest that a [[Signer]] must sign to authorize
         *  this transaction.
         */
        get unsignedHash() {
          return keccak256(this.unsignedSerialized);
        }
        /**
         *  The sending address, if signed. Otherwise, ``null``.
         */
        get from() {
          if (this.signature == null) {
            return null;
          }
          return recoverAddress(this.unsignedHash, this.signature);
        }
        /**
         *  The public key of the sender, if signed. Otherwise, ``null``.
         */
        get fromPublicKey() {
          if (this.signature == null) {
            return null;
          }
          return SigningKey.recoverPublicKey(this.unsignedHash, this.signature);
        }
        /**
         *  Returns true if signed.
         *
         *  This provides a Type Guard that properties requiring a signed
         *  transaction are non-null.
         */
        isSigned() {
          return this.signature != null;
        }
        /**
         *  The serialized transaction.
         *
         *  This throws if the transaction is unsigned. For the pre-image,
         *  use [[unsignedSerialized]].
         */
        get serialized() {
          return __privateMethod(this, _Transaction_instances, getSerialized_fn).call(this, true, true);
        }
        /**
         *  The transaction pre-image.
         *
         *  The hash of this is the digest which needs to be signed to
         *  authorize this transaction.
         */
        get unsignedSerialized() {
          return __privateMethod(this, _Transaction_instances, getSerialized_fn).call(this, false, false);
        }
        /**
         *  Return the most "likely" type; currently the highest
         *  supported transaction type.
         */
        inferType() {
          const types = this.inferTypes();
          if (types.indexOf(2) >= 0) {
            return 2;
          }
          return types.pop();
        }
        /**
         *  Validates the explicit properties and returns a list of compatible
         *  transaction types.
         */
        inferTypes() {
          const hasGasPrice = this.gasPrice != null;
          const hasFee = this.maxFeePerGas != null || this.maxPriorityFeePerGas != null;
          const hasAccessList = this.accessList != null;
          const hasBlob = __privateGet(this, _maxFeePerBlobGas) != null || __privateGet(this, _blobVersionedHashes);
          if (this.maxFeePerGas != null && this.maxPriorityFeePerGas != null) {
            assert(this.maxFeePerGas >= this.maxPriorityFeePerGas, "priorityFee cannot be more than maxFee", "BAD_DATA", { value: this });
          }
          assert(!hasFee || this.type !== 0 && this.type !== 1, "transaction type cannot have maxFeePerGas or maxPriorityFeePerGas", "BAD_DATA", { value: this });
          assert(this.type !== 0 || !hasAccessList, "legacy transaction cannot have accessList", "BAD_DATA", { value: this });
          const types = [];
          if (this.type != null) {
            types.push(this.type);
          } else {
            if (this.authorizationList && this.authorizationList.length) {
              types.push(4);
            } else if (hasFee) {
              types.push(2);
            } else if (hasGasPrice) {
              types.push(1);
              if (!hasAccessList) {
                types.push(0);
              }
            } else if (hasAccessList) {
              types.push(1);
              types.push(2);
            } else if (hasBlob && this.to) {
              types.push(3);
            } else {
              types.push(0);
              types.push(1);
              types.push(2);
              types.push(3);
            }
          }
          types.sort();
          return types;
        }
        /**
         *  Returns true if this transaction is a legacy transaction (i.e.
         *  ``type === 0``).
         *
         *  This provides a Type Guard that the related properties are
         *  non-null.
         */
        isLegacy() {
          return this.type === 0;
        }
        /**
         *  Returns true if this transaction is berlin hardform transaction (i.e.
         *  ``type === 1``).
         *
         *  This provides a Type Guard that the related properties are
         *  non-null.
         */
        isBerlin() {
          return this.type === 1;
        }
        /**
         *  Returns true if this transaction is london hardform transaction (i.e.
         *  ``type === 2``).
         *
         *  This provides a Type Guard that the related properties are
         *  non-null.
         */
        isLondon() {
          return this.type === 2;
        }
        /**
         *  Returns true if this transaction is an [[link-eip-4844]] BLOB
         *  transaction.
         *
         *  This provides a Type Guard that the related properties are
         *  non-null.
         */
        isCancun() {
          return this.type === 3;
        }
        /**
         *  Create a copy of this transaciton.
         */
        clone() {
          return _Transaction.from(this);
        }
        /**
         *  Return a JSON-friendly object.
         */
        toJSON() {
          const s = (v) => {
            if (v == null) {
              return null;
            }
            return v.toString();
          };
          return {
            type: this.type,
            to: this.to,
            //            from: this.from,
            data: this.data,
            nonce: this.nonce,
            gasLimit: s(this.gasLimit),
            gasPrice: s(this.gasPrice),
            maxPriorityFeePerGas: s(this.maxPriorityFeePerGas),
            maxFeePerGas: s(this.maxFeePerGas),
            value: s(this.value),
            chainId: s(this.chainId),
            sig: this.signature ? this.signature.toJSON() : null,
            accessList: this.accessList
          };
        }
        /**
         *  Create a **Transaction** from a serialized transaction or a
         *  Transaction-like object.
         */
        static from(tx) {
          if (tx == null) {
            return new _Transaction();
          }
          if (typeof tx === "string") {
            const payload = getBytes(tx);
            if (payload[0] >= 127) {
              return _Transaction.from(_parseLegacy(payload));
            }
            switch (payload[0]) {
              case 1:
                return _Transaction.from(_parseEip2930(payload));
              case 2:
                return _Transaction.from(_parseEip1559(payload));
              case 3:
                return _Transaction.from(_parseEip4844(payload));
              case 4:
                return _Transaction.from(_parseEip7702(payload));
            }
            assert(false, "unsupported transaction type", "UNSUPPORTED_OPERATION", { operation: "from" });
          }
          const result = new _Transaction();
          if (tx.type != null) {
            result.type = tx.type;
          }
          if (tx.to != null) {
            result.to = tx.to;
          }
          if (tx.nonce != null) {
            result.nonce = tx.nonce;
          }
          if (tx.gasLimit != null) {
            result.gasLimit = tx.gasLimit;
          }
          if (tx.gasPrice != null) {
            result.gasPrice = tx.gasPrice;
          }
          if (tx.maxPriorityFeePerGas != null) {
            result.maxPriorityFeePerGas = tx.maxPriorityFeePerGas;
          }
          if (tx.maxFeePerGas != null) {
            result.maxFeePerGas = tx.maxFeePerGas;
          }
          if (tx.maxFeePerBlobGas != null) {
            result.maxFeePerBlobGas = tx.maxFeePerBlobGas;
          }
          if (tx.data != null) {
            result.data = tx.data;
          }
          if (tx.value != null) {
            result.value = tx.value;
          }
          if (tx.chainId != null) {
            result.chainId = tx.chainId;
          }
          if (tx.signature != null) {
            result.signature = Signature.from(tx.signature);
          }
          if (tx.accessList != null) {
            result.accessList = tx.accessList;
          }
          if (tx.authorizationList != null) {
            result.authorizationList = tx.authorizationList;
          }
          if (tx.blobVersionedHashes != null) {
            result.blobVersionedHashes = tx.blobVersionedHashes;
          }
          if (tx.kzg != null) {
            result.kzg = tx.kzg;
          }
          if (tx.blobs != null) {
            result.blobs = tx.blobs;
          }
          if (tx.hash != null) {
            assertArgument(result.isSigned(), "unsigned transaction cannot define '.hash'", "tx", tx);
            assertArgument(result.hash === tx.hash, "hash mismatch", "tx", tx);
          }
          if (tx.from != null) {
            assertArgument(result.isSigned(), "unsigned transaction cannot define '.from'", "tx", tx);
            assertArgument(result.from.toLowerCase() === (tx.from || "").toLowerCase(), "from mismatch", "tx", tx);
          }
          return result;
        }
      };
      _type = new WeakMap();
      _to = new WeakMap();
      _data3 = new WeakMap();
      _nonce = new WeakMap();
      _gasLimit = new WeakMap();
      _gasPrice = new WeakMap();
      _maxPriorityFeePerGas = new WeakMap();
      _maxFeePerGas = new WeakMap();
      _value = new WeakMap();
      _chainId = new WeakMap();
      _sig = new WeakMap();
      _accessList = new WeakMap();
      _maxFeePerBlobGas = new WeakMap();
      _blobVersionedHashes = new WeakMap();
      _kzg = new WeakMap();
      _blobs = new WeakMap();
      _auths = new WeakMap();
      _Transaction_instances = new WeakSet();
      getSerialized_fn = function(signed2, sidecar) {
        assert(!signed2 || this.signature != null, "cannot serialize unsigned transaction; maybe you meant .unsignedSerialized", "UNSUPPORTED_OPERATION", { operation: ".serialized" });
        const sig = signed2 ? this.signature : null;
        switch (this.inferType()) {
          case 0:
            return _serializeLegacy(this, sig);
          case 1:
            return _serializeEip2930(this, sig);
          case 2:
            return _serializeEip1559(this, sig);
          case 3:
            return _serializeEip4844(this, sig, sidecar ? this.blobs : null);
          case 4:
            return _serializeEip7702(this, sig);
        }
        assert(false, "unsupported transaction type", "UNSUPPORTED_OPERATION", { operation: ".serialized" });
      };
      Transaction = _Transaction;
    }
  });

  // node_modules/ethers/lib.esm/transaction/index.js
  var init_transaction2 = __esm({
    "node_modules/ethers/lib.esm/transaction/index.js"() {
      init_accesslist();
      init_authorization();
      init_address4();
      init_transaction();
    }
  });

  // node_modules/ethers/lib.esm/hash/authorization.js
  function hashAuthorization(auth) {
    assertArgument(typeof auth.address === "string", "invalid address for hashAuthorization", "auth.address", auth);
    return keccak256(concat([
      "0x05",
      encodeRlp([
        auth.chainId != null ? toBeArray(auth.chainId) : "0x",
        getAddress(auth.address),
        auth.nonce != null ? toBeArray(auth.nonce) : "0x"
      ])
    ]));
  }
  function verifyAuthorization(auth, sig) {
    return recoverAddress(hashAuthorization(auth), sig);
  }
  var init_authorization2 = __esm({
    "node_modules/ethers/lib.esm/hash/authorization.js"() {
      init_address2();
      init_crypto2();
      init_transaction2();
      init_utils();
    }
  });

  // node_modules/ethers/lib.esm/hash/id.js
  function id(value) {
    return keccak256(toUtf8Bytes(value));
  }
  var init_id = __esm({
    "node_modules/ethers/lib.esm/hash/id.js"() {
      init_crypto2();
      init_utils();
    }
  });

  // node_modules/@adraffy/ens-normalize/dist/index.mjs
  function decode_arithmetic(bytes2) {
    let pos = 0;
    function u16() {
      return bytes2[pos++] << 8 | bytes2[pos++];
    }
    let symbol_count = u16();
    let total = 1;
    let acc = [0, 1];
    for (let i = 1; i < symbol_count; i++) {
      acc.push(total += u16());
    }
    let skip = u16();
    let pos_payload = pos;
    pos += skip;
    let read_width = 0;
    let read_buffer = 0;
    function read_bit() {
      if (read_width == 0) {
        read_buffer = read_buffer << 8 | bytes2[pos++];
        read_width = 8;
      }
      return read_buffer >> --read_width & 1;
    }
    const N3 = 31;
    const FULL = 2 ** N3;
    const HALF = FULL >>> 1;
    const QRTR = HALF >> 1;
    const MASK = FULL - 1;
    let register = 0;
    for (let i = 0; i < N3; i++) register = register << 1 | read_bit();
    let symbols = [];
    let low = 0;
    let range = FULL;
    while (true) {
      let value = Math.floor(((register - low + 1) * total - 1) / range);
      let start = 0;
      let end = symbol_count;
      while (end - start > 1) {
        let mid = start + end >>> 1;
        if (value < acc[mid]) {
          end = mid;
        } else {
          start = mid;
        }
      }
      if (start == 0) break;
      symbols.push(start);
      let a = low + Math.floor(range * acc[start] / total);
      let b2 = low + Math.floor(range * acc[start + 1] / total) - 1;
      while (((a ^ b2) & HALF) == 0) {
        register = register << 1 & MASK | read_bit();
        a = a << 1 & MASK;
        b2 = b2 << 1 & MASK | 1;
      }
      while (a & ~b2 & QRTR) {
        register = register & HALF | register << 1 & MASK >>> 1 | read_bit();
        a = a << 1 ^ HALF;
        b2 = (b2 ^ HALF) << 1 | HALF | 1;
      }
      low = a;
      range = 1 + b2 - a;
    }
    let offset = symbol_count - 4;
    return symbols.map((x) => {
      switch (x - offset) {
        case 3:
          return offset + 65792 + (bytes2[pos_payload++] << 16 | bytes2[pos_payload++] << 8 | bytes2[pos_payload++]);
        case 2:
          return offset + 256 + (bytes2[pos_payload++] << 8 | bytes2[pos_payload++]);
        case 1:
          return offset + bytes2[pos_payload++];
        default:
          return x - 1;
      }
    });
  }
  function read_payload(v) {
    let pos = 0;
    return () => v[pos++];
  }
  function read_compressed_payload(s) {
    return read_payload(decode_arithmetic(unsafe_atob(s)));
  }
  function unsafe_atob(s) {
    let lookup = [];
    [..."ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"].forEach((c, i) => lookup[c.charCodeAt(0)] = i);
    let n2 = s.length;
    let ret = new Uint8Array(6 * n2 >> 3);
    for (let i = 0, pos = 0, width = 0, carry = 0; i < n2; i++) {
      carry = carry << 6 | lookup[s.charCodeAt(i)];
      width += 6;
      if (width >= 8) {
        ret[pos++] = carry >> (width -= 8);
      }
    }
    return ret;
  }
  function signed(i) {
    return i & 1 ? ~i >> 1 : i >> 1;
  }
  function read_deltas(n2, next) {
    let v = Array(n2);
    for (let i = 0, x = 0; i < n2; i++) v[i] = x += signed(next());
    return v;
  }
  function read_sorted(next, prev = 0) {
    let ret = [];
    while (true) {
      let x = next();
      let n2 = next();
      if (!n2) break;
      prev += x;
      for (let i = 0; i < n2; i++) {
        ret.push(prev + i);
      }
      prev += n2 + 1;
    }
    return ret;
  }
  function read_sorted_arrays(next) {
    return read_array_while(() => {
      let v = read_sorted(next);
      if (v.length) return v;
    });
  }
  function read_mapped(next) {
    let ret = [];
    while (true) {
      let w = next();
      if (w == 0) break;
      ret.push(read_linear_table(w, next));
    }
    while (true) {
      let w = next() - 1;
      if (w < 0) break;
      ret.push(read_replacement_table(w, next));
    }
    return ret.flat();
  }
  function read_array_while(next) {
    let v = [];
    while (true) {
      let x = next(v.length);
      if (!x) break;
      v.push(x);
    }
    return v;
  }
  function read_transposed(n2, w, next) {
    let m = Array(n2).fill().map(() => []);
    for (let i = 0; i < w; i++) {
      read_deltas(n2, next).forEach((x, j) => m[j].push(x));
    }
    return m;
  }
  function read_linear_table(w, next) {
    let dx = 1 + next();
    let dy = next();
    let vN = read_array_while(next);
    let m = read_transposed(vN.length, 1 + w, next);
    return m.flatMap((v, i) => {
      let [x, ...ys] = v;
      return Array(vN[i]).fill().map((_, j) => {
        let j_dy = j * dy;
        return [x + j * dx, ys.map((y) => y + j_dy)];
      });
    });
  }
  function read_replacement_table(w, next) {
    let n2 = 1 + next();
    let m = read_transposed(n2, 1 + w, next);
    return m.map((v) => [v[0], v.slice(1)]);
  }
  function read_trie(next) {
    let ret = [];
    let sorted = read_sorted(next);
    expand(decode3([]), []);
    return ret;
    function decode3(Q) {
      let S2 = next();
      let B = read_array_while(() => {
        let cps = read_sorted(next).map((i) => sorted[i]);
        if (cps.length) return decode3(cps);
      });
      return { S: S2, B, Q };
    }
    function expand({ S: S2, B }, cps, saved) {
      if (S2 & 4 && saved === cps[cps.length - 1]) return;
      if (S2 & 2) saved = cps[cps.length - 1];
      if (S2 & 1) ret.push(cps);
      for (let br of B) {
        for (let cp of br.Q) {
          expand(br, [...cps, cp], saved);
        }
      }
    }
  }
  function hex_cp(cp) {
    return cp.toString(16).toUpperCase().padStart(2, "0");
  }
  function quote_cp(cp) {
    return `{${hex_cp(cp)}}`;
  }
  function explode_cp(s) {
    let cps = [];
    for (let pos = 0, len = s.length; pos < len; ) {
      let cp = s.codePointAt(pos);
      pos += cp < 65536 ? 1 : 2;
      cps.push(cp);
    }
    return cps;
  }
  function str_from_cps(cps) {
    const chunk = 4096;
    let len = cps.length;
    if (len < chunk) return String.fromCodePoint(...cps);
    let buf = [];
    for (let i = 0; i < len; ) {
      buf.push(String.fromCodePoint(...cps.slice(i, i += chunk)));
    }
    return buf.join("");
  }
  function compare_arrays(a, b2) {
    let n2 = a.length;
    let c = n2 - b2.length;
    for (let i = 0; c == 0 && i < n2; i++) c = a[i] - b2[i];
    return c;
  }
  function unpack_cc(packed) {
    return packed >> 24 & 255;
  }
  function unpack_cp(packed) {
    return packed & 16777215;
  }
  function init$1() {
    let r = read_compressed_payload(COMPRESSED);
    SHIFTED_RANK = new Map(read_sorted_arrays(r).flatMap((v, i) => v.map((x) => [x, i + 1 << 24])));
    EXCLUSIONS = new Set(read_sorted(r));
    DECOMP = /* @__PURE__ */ new Map();
    RECOMP = /* @__PURE__ */ new Map();
    for (let [cp, cps] of read_mapped(r)) {
      if (!EXCLUSIONS.has(cp) && cps.length == 2) {
        let [a, b2] = cps;
        let bucket = RECOMP.get(a);
        if (!bucket) {
          bucket = /* @__PURE__ */ new Map();
          RECOMP.set(a, bucket);
        }
        bucket.set(b2, cp);
      }
      DECOMP.set(cp, cps.reverse());
    }
  }
  function is_hangul(cp) {
    return cp >= S0 && cp < S1;
  }
  function compose_pair(a, b2) {
    if (a >= L0 && a < L1 && b2 >= V0 && b2 < V1) {
      return S0 + (a - L0) * N_COUNT + (b2 - V0) * T_COUNT;
    } else if (is_hangul(a) && b2 > T0 && b2 < T1 && (a - S0) % T_COUNT == 0) {
      return a + (b2 - T0);
    } else {
      let recomp = RECOMP.get(a);
      if (recomp) {
        recomp = recomp.get(b2);
        if (recomp) {
          return recomp;
        }
      }
      return -1;
    }
  }
  function decomposed(cps) {
    if (!SHIFTED_RANK) init$1();
    let ret = [];
    let buf = [];
    let check_order = false;
    function add2(cp) {
      let cc = SHIFTED_RANK.get(cp);
      if (cc) {
        check_order = true;
        cp |= cc;
      }
      ret.push(cp);
    }
    for (let cp of cps) {
      while (true) {
        if (cp < 128) {
          ret.push(cp);
        } else if (is_hangul(cp)) {
          let s_index = cp - S0;
          let l_index = s_index / N_COUNT | 0;
          let v_index = s_index % N_COUNT / T_COUNT | 0;
          let t_index = s_index % T_COUNT;
          add2(L0 + l_index);
          add2(V0 + v_index);
          if (t_index > 0) add2(T0 + t_index);
        } else {
          let mapped = DECOMP.get(cp);
          if (mapped) {
            buf.push(...mapped);
          } else {
            add2(cp);
          }
        }
        if (!buf.length) break;
        cp = buf.pop();
      }
    }
    if (check_order && ret.length > 1) {
      let prev_cc = unpack_cc(ret[0]);
      for (let i = 1; i < ret.length; i++) {
        let cc = unpack_cc(ret[i]);
        if (cc == 0 || prev_cc <= cc) {
          prev_cc = cc;
          continue;
        }
        let j = i - 1;
        while (true) {
          let tmp = ret[j + 1];
          ret[j + 1] = ret[j];
          ret[j] = tmp;
          if (!j) break;
          prev_cc = unpack_cc(ret[--j]);
          if (prev_cc <= cc) break;
        }
        prev_cc = unpack_cc(ret[i]);
      }
    }
    return ret;
  }
  function composed_from_decomposed(v) {
    let ret = [];
    let stack = [];
    let prev_cp = -1;
    let prev_cc = 0;
    for (let packed of v) {
      let cc = unpack_cc(packed);
      let cp = unpack_cp(packed);
      if (prev_cp == -1) {
        if (cc == 0) {
          prev_cp = cp;
        } else {
          ret.push(cp);
        }
      } else if (prev_cc > 0 && prev_cc >= cc) {
        if (cc == 0) {
          ret.push(prev_cp, ...stack);
          stack.length = 0;
          prev_cp = cp;
        } else {
          stack.push(cp);
        }
        prev_cc = cc;
      } else {
        let composed = compose_pair(prev_cp, cp);
        if (composed >= 0) {
          prev_cp = composed;
        } else if (prev_cc == 0 && cc == 0) {
          ret.push(prev_cp);
          prev_cp = cp;
        } else {
          stack.push(cp);
          prev_cc = cc;
        }
      }
    }
    if (prev_cp >= 0) {
      ret.push(prev_cp, ...stack);
    }
    return ret;
  }
  function nfd(cps) {
    return decomposed(cps).map(unpack_cp);
  }
  function nfc(cps) {
    return composed_from_decomposed(decomposed(cps));
  }
  function group_has_cp(g, cp) {
    return g.P.has(cp) || g.Q.has(cp);
  }
  function init() {
    if (MAPPED) return;
    let r = read_compressed_payload(COMPRESSED$1);
    const read_sorted_array = () => read_sorted(r);
    const read_sorted_set = () => new Set(read_sorted_array());
    const set_add_many = (set, v) => v.forEach((x) => set.add(x));
    MAPPED = new Map(read_mapped(r));
    IGNORED = read_sorted_set();
    CM = read_sorted_array();
    NSM = new Set(read_sorted_array().map((i) => CM[i]));
    CM = new Set(CM);
    ESCAPE = read_sorted_set();
    NFC_CHECK = read_sorted_set();
    let chunks = read_sorted_arrays(r);
    let unrestricted = r();
    const read_chunked = () => {
      let set = /* @__PURE__ */ new Set();
      read_sorted_array().forEach((i) => set_add_many(set, chunks[i]));
      set_add_many(set, read_sorted_array());
      return set;
    };
    GROUPS = read_array_while((i) => {
      let N3 = read_array_while(r).map((x) => x + 96);
      if (N3.length) {
        let R = i >= unrestricted;
        N3[0] -= 32;
        N3 = str_from_cps(N3);
        if (R) N3 = `Restricted[${N3}]`;
        let P = read_chunked();
        let Q = read_chunked();
        let M = !r();
        return { N: N3, P, Q, M, R };
      }
    });
    WHOLE_VALID = read_sorted_set();
    WHOLE_MAP = /* @__PURE__ */ new Map();
    let wholes = read_sorted_array().concat(Array_from(WHOLE_VALID)).sort((a, b2) => a - b2);
    wholes.forEach((cp, i) => {
      let d = r();
      let w = wholes[i] = d ? wholes[i - d] : { V: [], M: /* @__PURE__ */ new Map() };
      w.V.push(cp);
      if (!WHOLE_VALID.has(cp)) {
        WHOLE_MAP.set(cp, w);
      }
    });
    for (let { V, M } of new Set(WHOLE_MAP.values())) {
      let recs = [];
      for (let cp of V) {
        let gs = GROUPS.filter((g) => group_has_cp(g, cp));
        let rec = recs.find(({ G }) => gs.some((g) => G.has(g)));
        if (!rec) {
          rec = { G: /* @__PURE__ */ new Set(), V: [] };
          recs.push(rec);
        }
        rec.V.push(cp);
        set_add_many(rec.G, gs);
      }
      let union = recs.flatMap((x) => Array_from(x.G));
      for (let { G, V: V2 } of recs) {
        let complement = new Set(union.filter((g) => !G.has(g)));
        for (let cp of V2) {
          M.set(cp, complement);
        }
      }
    }
    VALID = /* @__PURE__ */ new Set();
    let multi = /* @__PURE__ */ new Set();
    const add_to_union = (cp) => VALID.has(cp) ? multi.add(cp) : VALID.add(cp);
    for (let g of GROUPS) {
      for (let cp of g.P) add_to_union(cp);
      for (let cp of g.Q) add_to_union(cp);
    }
    for (let cp of VALID) {
      if (!WHOLE_MAP.has(cp) && !multi.has(cp)) {
        WHOLE_MAP.set(cp, UNIQUE_PH);
      }
    }
    set_add_many(VALID, nfd(VALID));
    EMOJI_LIST = read_trie(r).map((v) => Emoji.from(v)).sort(compare_arrays);
    EMOJI_ROOT = /* @__PURE__ */ new Map();
    for (let cps of EMOJI_LIST) {
      let prev = [EMOJI_ROOT];
      for (let cp of cps) {
        let next = prev.map((node) => {
          let child = node.get(cp);
          if (!child) {
            child = /* @__PURE__ */ new Map();
            node.set(cp, child);
          }
          return child;
        });
        if (cp === FE0F) {
          prev.push(...next);
        } else {
          prev = next;
        }
      }
      for (let x of prev) {
        x.V = cps;
      }
    }
  }
  function quoted_cp(cp) {
    return (should_escape(cp) ? "" : `${bidi_qq(safe_str_from_cps([cp]))} `) + quote_cp(cp);
  }
  function bidi_qq(s) {
    return `"${s}"\u200E`;
  }
  function check_label_extension(cps) {
    if (cps.length >= 4 && cps[2] == HYPHEN && cps[3] == HYPHEN) {
      throw new Error(`invalid label extension: "${str_from_cps(cps.slice(0, 4))}"`);
    }
  }
  function check_leading_underscore(cps) {
    const UNDERSCORE = 95;
    for (let i = cps.lastIndexOf(UNDERSCORE); i > 0; ) {
      if (cps[--i] !== UNDERSCORE) {
        throw new Error("underscore allowed only at start");
      }
    }
  }
  function check_fenced(cps) {
    let cp = cps[0];
    let prev = FENCED.get(cp);
    if (prev) throw error_placement(`leading ${prev}`);
    let n2 = cps.length;
    let last = -1;
    for (let i = 1; i < n2; i++) {
      cp = cps[i];
      let match = FENCED.get(cp);
      if (match) {
        if (last == i) throw error_placement(`${prev} + ${match}`);
        last = i + 1;
        prev = match;
      }
    }
    if (last == n2) throw error_placement(`trailing ${prev}`);
  }
  function safe_str_from_cps(cps, max = Infinity, quoter = quote_cp) {
    let buf = [];
    if (is_combining_mark(cps[0])) buf.push("\u25CC");
    if (cps.length > max) {
      max >>= 1;
      cps = [...cps.slice(0, max), 8230, ...cps.slice(-max)];
    }
    let prev = 0;
    let n2 = cps.length;
    for (let i = 0; i < n2; i++) {
      let cp = cps[i];
      if (should_escape(cp)) {
        buf.push(str_from_cps(cps.slice(prev, i)));
        buf.push(quoter(cp));
        prev = i + 1;
      }
    }
    buf.push(str_from_cps(cps.slice(prev, n2)));
    return buf.join("");
  }
  function is_combining_mark(cp) {
    init();
    return CM.has(cp);
  }
  function should_escape(cp) {
    init();
    return ESCAPE.has(cp);
  }
  function ens_normalize(name) {
    return flatten(split2(name, nfc, filter_fe0f));
  }
  function split2(name, nf, ef) {
    if (!name) return [];
    init();
    let offset = 0;
    return name.split(STOP_CH).map((label) => {
      let input = explode_cp(label);
      let info = {
        input,
        offset
        // codepoint, not substring!
      };
      offset += input.length + 1;
      try {
        let tokens = info.tokens = tokens_from_str(input, nf, ef);
        let token_count = tokens.length;
        let type;
        if (!token_count) {
          throw new Error(`empty label`);
        }
        let norm = info.output = tokens.flat();
        check_leading_underscore(norm);
        let emoji = info.emoji = token_count > 1 || tokens[0].is_emoji;
        if (!emoji && norm.every((cp) => cp < 128)) {
          check_label_extension(norm);
          type = "ASCII";
        } else {
          let chars = tokens.flatMap((x) => x.is_emoji ? [] : x);
          if (!chars.length) {
            type = "Emoji";
          } else {
            if (CM.has(norm[0])) throw error_placement("leading combining mark");
            for (let i = 1; i < token_count; i++) {
              let cps = tokens[i];
              if (!cps.is_emoji && CM.has(cps[0])) {
                throw error_placement(`emoji + combining mark: "${str_from_cps(tokens[i - 1])} + ${safe_str_from_cps([cps[0]])}"`);
              }
            }
            check_fenced(norm);
            let unique = Array_from(new Set(chars));
            let [g] = determine_group(unique);
            check_group(g, chars);
            check_whole(g, unique);
            type = g.N;
          }
        }
        info.type = type;
      } catch (err) {
        info.error = err;
      }
      return info;
    });
  }
  function check_whole(group, unique) {
    let maker;
    let shared = [];
    for (let cp of unique) {
      let whole = WHOLE_MAP.get(cp);
      if (whole === UNIQUE_PH) return;
      if (whole) {
        let set = whole.M.get(cp);
        maker = maker ? maker.filter((g) => set.has(g)) : Array_from(set);
        if (!maker.length) return;
      } else {
        shared.push(cp);
      }
    }
    if (maker) {
      for (let g of maker) {
        if (shared.every((cp) => group_has_cp(g, cp))) {
          throw new Error(`whole-script confusable: ${group.N}/${g.N}`);
        }
      }
    }
  }
  function determine_group(unique) {
    let groups = GROUPS;
    for (let cp of unique) {
      let gs = groups.filter((g) => group_has_cp(g, cp));
      if (!gs.length) {
        if (!GROUPS.some((g) => group_has_cp(g, cp))) {
          throw error_disallowed(cp);
        } else {
          throw error_group_member(groups[0], cp);
        }
      }
      groups = gs;
      if (gs.length == 1) break;
    }
    return groups;
  }
  function flatten(split5) {
    return split5.map(({ input, error, output: output2 }) => {
      if (error) {
        let msg = error.message;
        throw new Error(split5.length == 1 ? msg : `Invalid label ${bidi_qq(safe_str_from_cps(input, 63))}: ${msg}`);
      }
      return str_from_cps(output2);
    }).join(STOP_CH);
  }
  function error_disallowed(cp) {
    return new Error(`disallowed character: ${quoted_cp(cp)}`);
  }
  function error_group_member(g, cp) {
    let quoted = quoted_cp(cp);
    let gg = GROUPS.find((g2) => g2.P.has(cp));
    if (gg) {
      quoted = `${gg.N} ${quoted}`;
    }
    return new Error(`illegal mixture: ${g.N} + ${quoted}`);
  }
  function error_placement(where) {
    return new Error(`illegal placement: ${where}`);
  }
  function check_group(g, cps) {
    for (let cp of cps) {
      if (!group_has_cp(g, cp)) {
        throw error_group_member(g, cp);
      }
    }
    if (g.M) {
      let decomposed2 = nfd(cps);
      for (let i = 1, e = decomposed2.length; i < e; i++) {
        if (NSM.has(decomposed2[i])) {
          let j = i + 1;
          for (let cp; j < e && NSM.has(cp = decomposed2[j]); j++) {
            for (let k = i; k < j; k++) {
              if (decomposed2[k] == cp) {
                throw new Error(`duplicate non-spacing marks: ${quoted_cp(cp)}`);
              }
            }
          }
          if (j - i > NSM_MAX) {
            throw new Error(`excessive non-spacing marks: ${bidi_qq(safe_str_from_cps(decomposed2.slice(i - 1, j)))} (${j - i}/${NSM_MAX})`);
          }
          i = j;
        }
      }
    }
  }
  function tokens_from_str(input, nf, ef) {
    let ret = [];
    let chars = [];
    input = input.slice().reverse();
    while (input.length) {
      let emoji = consume_emoji_reversed(input);
      if (emoji) {
        if (chars.length) {
          ret.push(nf(chars));
          chars = [];
        }
        ret.push(ef(emoji));
      } else {
        let cp = input.pop();
        if (VALID.has(cp)) {
          chars.push(cp);
        } else {
          let cps = MAPPED.get(cp);
          if (cps) {
            chars.push(...cps);
          } else if (!IGNORED.has(cp)) {
            throw error_disallowed(cp);
          }
        }
      }
    }
    if (chars.length) {
      ret.push(nf(chars));
    }
    return ret;
  }
  function filter_fe0f(cps) {
    return cps.filter((cp) => cp != FE0F);
  }
  function consume_emoji_reversed(cps, eaten) {
    let node = EMOJI_ROOT;
    let emoji;
    let pos = cps.length;
    while (pos) {
      node = node.get(cps[--pos]);
      if (!node) break;
      let { V } = node;
      if (V) {
        emoji = V;
        if (eaten) eaten.push(...cps.slice(pos).reverse());
        cps.length = pos;
      }
    }
    return emoji;
  }
  var COMPRESSED$1, FENCED, NSM_MAX, COMPRESSED, S0, L0, V0, T0, L_COUNT, V_COUNT, T_COUNT, N_COUNT, S_COUNT, S1, L1, V1, T1, SHIFTED_RANK, EXCLUSIONS, DECOMP, RECOMP, HYPHEN, STOP_CH, FE0F, UNIQUE_PH, Array_from, Emoji, MAPPED, IGNORED, CM, NSM, ESCAPE, NFC_CHECK, GROUPS, WHOLE_VALID, WHOLE_MAP, VALID, EMOJI_LIST, EMOJI_ROOT;
  var init_dist = __esm({
    "node_modules/@adraffy/ens-normalize/dist/index.mjs"() {
      COMPRESSED$1 = "AEEUdwmgDS8BxQKKAP4BOgDjATAAngDUAIMAoABoAOAAagCOAEQAhABMAHIAOwA9ACsANgAmAGIAHgAuACgAJwAXAC0AGgAjAB8ALwAUACkAEgAeAAkAGwARABkAFgA5ACgALQArADcAFQApABAAHgAiABAAGgAeABMAGAUhBe8BFxREN8sF2wC5AK5HAW8ArQkDzQCuhzc3NzcBP68NEfMABQdHBuw5BV8FYAA9MzkI9r4ZBg7QyQAWA9CeOwLNCjcCjqkChuA/lm+RAsXTAoP6ASfnEQDytQFJAjWVCkeXAOsA6godAB/cwdAUE0WlBCN/AQUCQRjFD/MRBjHxDQSJbw0jBzUAswBxme+tnIcAYwabAysG8QAjAEMMmxcDqgPKQyDXCMMxA7kUQwD3NXOrAKmFIAAfBC0D3x4BJQDBGdUFAhEgVD8JnwmQJiNWYUzrg0oAGwAUAB0AFnNcACkAFgBP9h3gPfsDOWDKneY2ChglX1UDYD30ABsAFAAdABZzIGRAnwDD8wAjAEEMzRbDqgMB2sAFYwXqAtCnAsS4AwpUJKRtFHsadUz9AMMVbwLpABM1NJEX0ZkCgYMBEyMAxRVvAukAEzUBUFAtmUwSAy4DBTER33EftQHfSwB5MxJ/AjkWKQLzL8E/cwBB6QH9LQDPDtO9ASNriQC5DQANAwCK21EFI91zHwCoL9kBqQcHBwcHKzUDowBvAQohPvU3fAQgHwCyAc8CKQMA5zMSezr7ULgFmDp/LzVQBgEGAi8FYQVgt8AFcTtlQhpCWEmfe5tmZ6IAExsDzQ8t+X8rBKtTAltbAn0jsy8Bl6utPWMDTR8Ei2kRANkDBrNHNysDBzECQWUAcwFpJ3kAiyUhAJ0BUb8AL3EfAbfNAz81KUsFWwF3YQZtAm0A+VEfAzEJDQBRSQCzAQBlAHsAM70GD/v3IZWHBwARKQAxALsjTwHZAeMPEzmXgIHwABIAGQA8AEUAQDt3gdvIEGcQZAkGTRFMdEIVEwK0D64L7REdDNkq09PgADSxB/MDWwfzA1sDWwfzB/MDWwfzA1sDWwNbA1scEvAi28gQZw9QBHUFlgWTBN4IiyZREYkHMAjaVBV0JhxPA00BBCMtSSQ7mzMTJUpMFE0LCAQ2SmyvfUADTzGzVP2QqgPTMlc5dAkGHnkSqAAyD3skNb1OhnpPcagKU0+2tYdJak5vAsY6sEAACikJm2/Dd1YGRRAfJ6kQ+ww3AbkBPw3xS9wE9QY/BM0fgRkdD9GVoAipLeEM8SbnLqWAXiP5KocF8Uv4POELUVFsD10LaQnnOmeBUgMlAREijwrhDT0IcRD3Cs1vDekRSQc9A9lJngCpBwULFR05FbkmFGKwCw05ewb/GvoLkyazEy17AAXXGiUGUQEtGwMA0y7rhbRaNVwgT2MGBwspI8sUrFAkDSlAu3hMGh8HGSWtApVDdEqLUToelyH6PEENai4XUYAH+TwJGVMLhTyiRq9FEhHWPpE9TCJNTDAEOYMsMyePCdMPiQy9fHYBXQklCbUMdRM1ERs3yQg9Bx0xlygnGQglRplgngT7owP3E9UDDwVDCUUHFwO5HDETMhUtBRGBKNsC9zbZLrcCk1aEARsFzw8pH+MQVEfkDu0InwJpA4cl7wAxFSUAGyKfCEdnAGOP3FMJLs8Iy2pwI3gDaxTrZRF3B5UOWwerHDcVwxzlcMxeD4YMKKezCV8BeQmdAWME5wgNNV+MpCBFZ1eLXBifIGVBQ14AAjUMaRWjRMGHfAKPD28SHwE5AXcHPQ0FAnsR8RFvEJkI74YINbkz/DopBFMhhyAVCisDU2zSCysm/Qz8bQGnEmYDEDRBd/Jnr2C6KBgBBx0yyUFkIfULlk/RDKAaxRhGVDIZ6AfDA/ca9yfuQVsGAwOnBxc6UTPyBMELbQiPCUMATQ6nGwfbGG4KdYzUATWPAbudA1uVhwJzkwY7Bw8Aaw+LBX3pACECqwinAAkA0wNbAD0CsQehAB0AiUUBQQMrMwEl6QKTA5cINc8BmTMB9y0EH8cMGQD7O25OAsO1AoBuZqYF4VwCkgJNOQFRKQQJUktVA7N15QDfAE8GF+NLARmvTs8e50cB43MvAMsA/wAJOQcJRQHRAfdxALsBYws1Caa3uQFR7S0AhwAZbwHbAo0A4QA5AIP1AVcAUQVd/QXXAlNNARU1HC9bZQG/AyMBNwERAH0Gz5GpzQsjBHEH1wIQHxXlAu8yB7kFAyLjE9FCyQK94lkAMhoKPAqrCqpgX2Q3CjV2PVQAEh+sPss/UgVVO1c7XDtXO1w7VztcO1c7XDtXO1wDm8Pmw+YKcF9JYe8Mqg3YRMw6TRPfYFVgNhPMLbsUxRXSJVoZQRrAJwkl6FUNDwgt12Y0CDA0eRfAAEMpbINFY4oeNApPHOtTlVT8LR8AtUumM7MNsBsZREQFS3XxYi4WEgomAmSFAmJGX1GzAV83JAKh+wJonAJmDQKfiDgfDwJmPwJmKgRyBIMDfxcDfpY5Cjl7GzmGOicnAmwhAjI6OA4CbcsCbbLzjgM3a0kvAWsA4gDlAE4JB5wMkQECD8YAEbkCdzMCdqZDAnlPRwJ4viFg30WyRvcCfEMCeswCfQ0CfPRIBEiBZygALxlJXEpfGRtK0ALRBQLQ0EsrA4hTA4fqRMmRNgLypV0HAwOyS9JMMSkH001QTbMCi0MCitzFHwshR2sJuwKOOwKOYESbhQKO3QKOYHxRuFM5AQ5S2FSJApP/ApMQAO0AIFUiVbNV1AosHymZijLleGpFPz0Cl6MC77ZYJawAXSkClpMCloCgAK1ZsFoNhVEAPwKWuQKWUlxIXNUCmc8CmWhczl0LHQKcnznGOqECnBoCn58CnryOACETNS4TAp31Ap6WALlBYThh8wKe1wKgcgGtAp6jIwKeUqljzGQrKS8CJ7MCJoICoP8CoFDbAqYzAqXSAqgDAIECp/ZogGi1AAdNaiBq1QKs5wKssgKtawKtBgJXIQJV4AKx5dsDH1JsmwKywRECsuwbbORtZ21MYwMl0QK2YD9DbpQDKUkCuGICuUsZArkue3A6cOUCvR0DLbYDMhUCvoxyBgMzdQK+HnMmc1MCw88CwwhzhnRPOUl05AM8qwEDPJ4DPcMCxYACxksCxhSNAshtVQLISALJUwLJMgJkoQLd1nh9ZXiyeSlL1AMYp2cGAmH4GfeVKHsPXpZevxUCz28Cz3AzT1fW9xejAMqxAs93AS3uA04Wfk8JAtwrAtuOAtJTA1JgA1NjAQUDVZCAjUMEzxrxZEl5A4LSg5EC2ssC2eKEFIRNp0ADhqkAMwNkEoZ1Xf0AWQLfaQLevHd7AuIz7RgB8zQrAfSfAfLWiwLr9wLpdH0DAur9AuroAP1LAb0C7o0C66CWrpcHAu5DA4XkmH1w5HGlAvMHAG0DjhqZlwL3FwORcgOSiwL3nAL53QL4apogmq+/O5siA52HAv7+AR8APZ8gAZ+3AwWRA6ZuA6bdANXJAwZuoYyiCQ0DDE0BEwEjB3EGZb1rCQC/BG/DFY8etxEAG3k9ACcDNxJRA42DAWcrJQCM8wAlAOanC6OVCLsGI6fJBgCvBRnDBvElRUYFFoAFcD9GSDNCKUK8X3kZX8QAls0FOgCQVCGbwTsuYDoZutcONxjOGJHJ/gVfBWAFXwVgBWsFYAVfBWAFXwVgBV8FYAVfBWBOHQjfjW8KCgoKbF7xMwTRA7kGN8PDAMMEr8MA70gxFroFTj5xPnhCR0K+X30/X/AAWBkzswCNBsxzzASm70aCRS4rDDMeLz49fnXfcsH5GcoscQFz13Y4HwVnBXLJycnACNdRYwgICAqEXoWTxgA7P4kACxbZBu21Kw0AjMsTAwkVAOVtJUUsJ1JCuULESUArXy9gPi9AKwnJRQYKTD9LPoA+iT54PnkCkULEUUpDX9NWV3JVEjQAc1w3A3IBE3YnX+g7QiMJb6MKaiszRCUuQrNCxDPMCcwEX9EWJzYREBEEBwIHKn6l33JCNVIfybPJtAltydPUCmhBZw/tEKsZAJOVJU1CLRuxbUHOQAo7P0s+eEJHHA8SJVRPdGM0NVrpvBoKhfUlM0JHHGUQUhEWO1xLSj8MO0ucNAqJIzVCRxv9EFsqKyA4OQgNj2nwZgp5ZNFgE2A1K3YHS2AhQQojJmC7DgpzGG1WYFUZCQYHZO9gHWCdYIVgu2BTYJlwFh8GvRbcXbG8YgtDHrMBwzPVyQonHQgkCyYBgQJ0Ajc4nVqIAwGSCsBPIgDsK3SWEtIVBa5N8gGjAo+kVwVIZwD/AEUSCDweX4ITrRQsJ8K3TwBXFDwEAB0TvzVcAtoTS20RIwDgVgZ9BBImYgA5AL4Coi8LFnezOkCnIQFjAY4KBAPh9RcGsgZSBsEAJctdsWIRu2kTkQstRw7DAcMBKgpPBGIGMDAwKCYnKTQaLg4AKRSVAFwCdl+YUZ0JdicFD3lPAdt1F9ZZKCGxuE3yBxkFVGcA/wBFEgiCBwAOLHQSjxOtQDg1z7deFRMAZ8QTAGtKb1ApIiPHADkAvgKiLy1DFtYCmBiDAlDDWNB0eo7fpaMO/aEVRRv0ATEQZBIODyMEAc8JQhCbDRgzFD4TAEMAu9YBCgCsAOkAm5I3ABwAYxvONnR+MhXJAxgKQyxL2+kkJhMbhQKDBMkSsvF0AD9BNQ6uQC7WqSQHwxEAEEIu1hkhAH2z4iQPwyJPHNWpdyYBRSpnJALzoBAEVPPsH20MxA0CCEQKRgAFyAtFAlMNwwjEDUQJRArELtapMg7DDZgJIw+TGukEIwvDFkMAqAtDEMMMBhioe+QAO3MMRAACrgnEBSPY9Q0FDnbSBoMAB8MSYxkSxAEJAPIJAAB8FWMOFtMc/HcXwxhDAC7DAvOowwAewwJdKDKHAAHDAALrFUQVwwAbwyvzpWMWv8wA/ABpAy++bcYDUKPD0KhDCwKmJ1MAAmMA5+UZwxAagwipBRL/eADfw6fDGOMCGsOjk3l6BwOpo4sAEsMOGxMAA5sAbcMOAAvDp0MJGkMDwgipnNIPAwfIqUMGAOGDAAPzABXDAAcDAAnDAGmTABrDAA7DChjDjnEWAwABYwAOcwAuUyYABsMAF8MIKQANUgC6wy4AA8MADqMq8wCyYgAcIwAB8wqpAAXOCx0V4wAHowBCwwEKAGnDAAuDAB3DAAjDCakABdIAbqcZ3QCZCCkABdIAAAFDAAfjAB2jCCkABqIACYMAGzMAbSMA5sOIAAhjAAhDABTDBAkpAAbSAOOTAAlDC6kOzPtnAAdDAG6kQFAATwAKwwwAA0MACbUDPwAHIwAZgwACE6cDAAojAApDAAoDp/MGwwAJIwADEwAQQwgAFEMAEXMAD5MADfMADcMAGRMOFiMAFUMAbqMWuwHDAMIAE0MLAGkzEgDhUwACQwAEWgAXgwUjAAbYABjDBSYBgzBaAEFNALcQBxUMegAwMngBrA0IZgJ0KxQHBREPd1N0ZzKRJwaIHAZqNT4DqQq8BwngAB4DAwt2AX56T1ocKQNXAh1GATQGC3tOxYNagkgAMQA5CQADAQEAWxLjAIOYNAEzAH7tFRk6TglSAF8NAAlYAQ+S1ACAQwQorQBiAN4dAJ1wPyeTANVzuQDX3AIeEMp9eyMgXiUAEdkBkJizKltbVVAaRMqRAAEAhyQ/SDEz6BmfVwB6ATEsOClKIRcDOF0E/832AFNt5AByAnkCRxGCOs94NjXdAwINGBonDBwPALW2AwICAgAAAAAAAAYDBQMDARrUAwAtAAAAAgEGBgYGBgYFBQUFBQUEBQYHCAkEBQUFBQQAAAICAAAAIgCNAJAAlT0A6gC7ANwApEQAwgCyAK0AqADuAKYA2gCjAOcBCAEDAMcAgQBiANIA1AEDAN4A8gCQAKkBMQDqAN8A3AsBCQ8yO9ra2tq8xuLT1tRJOB0BUgFcNU0BWgFpAWgBWwFMUUlLbhMBUxsNEAs6PhMOACcUKy0vMj5AQENDQ0RFFEYGJFdXV1dZWVhZL1pbXVxcI2NnZ2ZoZypsbnZ1eHh4eHh4enp6enp6enp6enp8fH18e2IARPIASQCaAHgAMgBm+ACOAFcAVwA3AnbvAIsABfj4AGQAk/IAnwBPAGIAZP//sACFAIUAaQBWALEAJAC2AIMCQAJDAPwA5wD+AP4A6AD/AOkA6QDoAOYALwJ7AVEBQAE+AVQBPgE+AT4BOQE4ATgBOAEcAVgXADEQCAEAUx8SHgsdHhYAjgCWAKYAUQBqIAIxAHYAbwCXAxUDJzIDIUlGTzEAkQJPAMcCVwKkAMAClgKWApYClgKWApYCiwKWApYClgKWApYClgKVApUCmAKgApcClgKWApQClAKUApQCkgKVAnUB1AKXAp8ClgKWApUeAIETBQD+DQOfAmECOh8BVBg9AuIZEjMbAU4/G1WZAXusRAFpYQEFA0FPAQYAmTEeIJdyADFoAHEANgCRA5zMk/C2jGINwjMWygIZCaXdfDILBCs5dAE7YnQBugDlhoiHhoiGiYqKhouOjIaNkI6Ij4qQipGGkoaThpSSlYaWhpeKmIaZhpqGm4aci52QnoqfhuIC4XTpAt90AIp0LHSoAIsAdHQEQwRABEIERQRDBEkERgRBBEcESQRIBEQERgRJAJ5udACrA490ALxuAQ10ANFZdHQA13QCFHQA/mJ0AP4BIQD+APwA/AD9APwDhGZ03ASMK23HAP4A/AD8AP0A/CR0dACRYnQA/gCRASEA/gCRAvQA/gCRA4RmdNwEjCttxyR0AP9idAEhAP4A/gD8APwA/QD8AP8A/AD8AP0A/AOEZnTcBIwrbcckdHQAkWJ0ASEA/gCRAP4AkQL0AP4AkQOEZnTcBIwrbcckdAJLAT50AlIBQXQCU8l0dAJfdHQDpgL0A6YDpgOnA6cDpwOnA4RmdNwEjCttxyR0dACRYnQBIQOmAJEDpgCRAvQDpgCRA4RmdNwEjCttxyR0BDh0AJEEOQCRDpU5dSgCADR03gV2CwArdAEFAM5iCnR0AF1iAAYcOgp0dACRCnQAXAEIwWZ0CnRmdHQAkWZ0CnRmdEXgAFF03gp0dEY0tlT2u3SOAQTwscwhjZZKrhYcBSfFp9XNbKiVDOD2b+cpe4/Z17mQnbtzzhaeQtE2GGj0IDNTjRUSyTxxw/RPHW/+vS7d1NfRt9z9QPZg4X7QFfhCnkvgNPIItOsC2eV6hPannZNHlZ9xrwZXIMOlu3jSoQSq78WEjwLjw1ELSlF1aBvfzwk5ZX7AUvQzjPQKbDuQ+sm4wNOp4A6AdVuRS0t1y/DZpg4R6m7FNjM9HgvW7Bi88zaMjOo6lM8wtBBdj8LP4ylv3zCXPhebMKJc066o9sF71oFW/8JXu86HJbwDID5lzw5GWLR/LhT0Qqnp2JQxNZNfcbLIzPy+YypqRm/lBmGmex+82+PisxUumSeJkALIT6rJezxMH+CTJmQtt5uwTVbL3ptmjDUQzlSIvWi8Tl7ng1NpuRn1Ng4n14Qc+3Iil7OwkvNWogLSPkn3pihIFytyIGmMhOe3n1tWsuMy9BdKyqF4Z3v2SgggTL9KVvMXPnCbRe+oOuFFP3HejBG/w9gvmfNYvg6JuWia2lcSSN1uIjBktzoIazOHPJZ7kKHPz8mRWVdW3lA8WGF9dQF6Bm673boov3BUWDU2JNcahR23GtfHKLOz/viZ+rYnZFaIznXO67CYEJ1fXuTRpZhYZkKe54xeoagkNGLs+NTZHE0rX45/XvQ2RGADX6vcAvdxIUBV27wxGm2zjZo4X3ILgAlrOFheuZ6wtsvaIj4yLY7qqawlliaIcrz2G+c3vscAnCkCuMzMmZvMfu9lLwTvfX+3cVSyPdN9ZwgDZhfjRgNJcLiJ67b9xx8JHswprbiE3v9UphotAPIgnXVIN5KmMc0piXhc6cChPnN+MRhG9adtdttQTTwSIpl8I4/j//d3sz1326qTBTpPRM/Hgh3kzqEXs8ZAk4ErQhNO8hzrQ0DLkWMA/N+91tn2MdOJnWC2FCZehkQrwzwbKOjhvZsbM95QoeL9skYyMf4srVPVJSgg7pOLUtr/n9eT99oe9nLtFRpjA9okV2Kj8h9k5HaC0oivRD8VyXkJ81tcd4fHNXPCfloIQasxsuO18/46dR2jgul/UIet2G0kRvnyONMKhHs6J26FEoqSqd+rfYjeEGwHWVDpX1fh1jBBcKGMqRepju9Y00mDVHC+Xdij/j44rKfvfjGinNs1jO/0F3jB83XCDINN/HB84axlP+3E/klktRo+vl3U/aiyMJbIodE1XSsDn6UAzIoMtUObY2+k/4gY/l+AkZJ5Sj2vQrkyLm3FoxjhDX+31UXBFf9XrAH31fFqoBmDEZvhvvpnZ87N+oZEu7U9O/nnk+QWj3x8uyoRbEnf+O5UMr9i0nHP38IF5AvzrBW8YWBUR0mIAzIvndQq9N3v/Jto3aPjPXUPl8ASdPPyAp7jENf8bk7VMM9ol9XGmlBmeDMuGqt+WzuL6CXAxXjIhCPM5vACchgMJ/8XBGLO/D1isVvGhwwHHr1DLaI5mn2Jr/b1pUD90uciDaS8cXNDzCWvNmT/PhQe5e8nTnnnkt8Ds/SIjibcum/fqDhKopxAY8AkSrPn+IGDEKOO+U3XOP6djFs2H5N9+orhOahiQk5KnEUWa+CzkVzhp8bMHRbg81qhjjXuIKbHjSLSIBKWqockGtKinY+z4/RdBUF6pcc3JmnlxVcNgrI4SEzKUZSwcD2QCyxzKve+gAmg6ZuSRkpPFa6mfThu7LJNu3H5K42uCpNvPAsoedolKV/LHe/eJ+BbaG5MG0NaSGVPRUmNFMFFSSpXEcXwbVh7UETOZZtoVNRGOIbbkig3McEtR68cG0RZAoJevWYo7Dg/lZ1CQzblWeUvVHmr8fY4Nqd9JJiH/zEX24mJviH60fAyFr0A3c4bC1j3yZU60VgJxXn8JgJXLUIsiBnmKmMYz+7yBQFBvqb2eYnuW59joZBf56/wXvWIR4R8wTmV80i1mZy+S4+BUES+hzjk0uXpC///z/IlqHZ1monzlXp8aCfhGKMti73FI1KbL1q6IKO4fuBuZ59gagjn5xU79muMpHXg6S+e+gDM/U9BKLHbl9l6o8czQKl4RUkJJiqftQG2i3BMg/TQlUYFkJDYBOOvAugYuzYSDnZbDDd/aSd9x0Oe6F+bJcHfl9+gp6L5/TgA+BdFFovbfCrQ40s5vMPw8866pNX8zyFGeFWdxIpPVp9Rg1UPOVFbFZrvaFq/YAzHQgqMWpahMYfqHpmwXfHL1/kpYmGuHFwT55mQu0dylfNuq2Oq0hTMCPwqfxnuBIPLXfci4Y1ANy+1CUipQxld/izVh16WyG2Q0CQQ9NqtAnx1HCHwDj7sYxOSB0wopZSnOzxQOcExmxrVTF2BkOthVpGfuhaGECfCJpJKpjnihY+xOT2QJxN61+9K6QSqtv2Shr82I3jgJrqBg0wELFZPjvHpvzTtaJnLK6Vb97Yn933koO/saN7fsjwNKzp4l2lJVx2orjCGzC/4ZL4zCver6aQYtC5sdoychuFE6ufOiog+VWi5UDkbmvmtah/3aArEBIi39s5ILUnlFLgilcGuz9CQshEY7fw2ouoILAYPVT/gyAIq3TFAIwVsl+ktkRz/qGfnCDGrm5gsl/l9QdvCWGsjPz3dU7XuqKfdUrr/6XIgjp4rey6AJBmCmUJMjITHVdFb5m1p+dLMCL8t55zD42cmftmLEJC0Da04YiRCVUBLLa8D071/N5UBNBXDh0LFsmhV/5B5ExOB4j3WVG/S3lfK5o+V6ELHvy6RR9n4ac+VsK4VE4yphPvV+kG9FegTBH4ZRXL2HytUHCduJazB/KykjfetYxOXTLws267aGOd+I+JhKP//+VnXmS90OD/jvLcVu0asyqcuYN1mSb6XTlCkqv1vigZPIYwNF/zpWcT1GR/6aEIRjkh0yhg4LXJfaGobYJTY4JI58KiAKgmmgAKWdl5nYCeLqavRJGQNuYuZtZFGx+IkI4w4NS2xwbetNMunOjBu/hmKCI/w7tfiiyUd//4rbTeWt4izBY8YvGIN6vyKYmP/8X8wHKCeN+WRcKM70+tXKNGyevU9H2Dg5BsljnTf8YbsJ1TmMs74Ce2XlHisleguhyeg44rQOHZuw/6HTkhnnurK2d62q6yS7210SsAIaR+jXMQA+svkrLpsUY+F30Uw89uOdGAR6vo4FIME0EfVVeHTu6eKicfhSqOeXJhbftcd08sWEnNUL1C9fnprTgd83IMut8onVUF0hvqzZfHduPjbjwEXIcoYmy+P6tcJZHmeOv6VrvEdkHDJecjHuHeWANe79VG662qTjA/HCvumVv3qL+LrOcpqGps2ZGwQdFJ7PU4iuyRlBrwfO+xnPyr47s2cXVbWzAyznDiBGjCM3ksxjjqM62GE9C8f5U38kB3VjtabKp/nRdvMESPGDG90bWRLAt1Qk5DyLuazRR1YzdC1c+hZXvAWV8xA72S4A8B67vjVhbba3MMop293FeEXpe7zItMWrJG/LOH9ByOXmYnNJfjmfuX9KbrpgLOba4nZ+fl8Gbdv/ihv+6wFGKHCYrVwmhFC0J3V2bn2tIB1wCc1CST3d3X2OyxhguXcs4sm679UngzofuSeBewMFJboIQHbUh/m2JhW2hG9DIvG2t7yZIzKBTz9wBtnNC+2pCRYhSIuQ1j8xsz5VvqnyUIthvuoyyu7fNIrg/KQUVmGQaqkqZk/Vx5b33/gsEs8yX7SC1J+NV4icz6bvIE7C5G6McBaI8rVg56q5QBJWxn/87Q1sPK4+sQa8fLU5gXo4paaq4cOcQ4wR0VBHPGjKh+UlPCbA1nLXyEUX45qZ8J7/Ln4FPJE2TdzD0Z8MLSNQiykMMmSyOCiFfy84Rq60emYB2vD09KjYwsoIpeDcBDTElBbXxND72yhd9pC/1CMid/5HUMvAL27OtcIJDzNKpRPNqPOpyt2aPGz9QWIs9hQ9LiX5s8m9hjTUu/f7MyIatjjd+tSfQ3ufZxPpmJhTaBtZtKLUcfOCUqADuO+QoH8B9v6U+P0HV1GLQmtoNFTb3s74ivZgjES0qfK+8RdGgBbcCMSy8eBvh98+et1KIFqSe1KQPyXULBMTsIYnysIwiZBJYdI20vseV+wuJkcqGemehKjaAb9L57xZm3g2zX0bZ2xk/fU+bCo7TlnbW7JuF1YdURo/2Gw7VclDG1W7LOtas2LX4upifZ/23rzpsnY/ALfRgrcWP5hYmV9VxVOQA1fZvp9F2UNU+7d7xRyVm5wiLp3/0dlV7vdw1PMiZrbDAYzIVqEjRY2YU03sJhPnlwIPcZUG5ltL6S8XCxU1eYS5cjr34veBmXAvy7yN4ZjArIG0dfD/5UpBNlX1ZPoxJOwyqRi3wQWtOzd4oNKh0LkoTm8cwqgIfKhqqGOhwo71I+zXnMemTv2B2AUzABWyFztGgGULjDDzWYwJUVBTjKCn5K2QGMK1CQT7SzziOjo+BhAmqBjzuc3xYym2eedGeOIRJVyTwDw37iCMe4g5Vbnsb5ZBdxOAnMT7HU4DHpxWGuQ7GeiY30Cpbvzss55+5Km1YsbD5ea3NI9QNYIXol5apgSu9dZ8f8xS5dtHpido5BclDuLWY4lhik0tbJa07yJhH0BOyEut/GRbYTS6RfiTYWGMCkNpfSHi7HvdiTglEVHKZXaVhezH4kkXiIvKopYAlPusftpE4a5IZwvw1x/eLvoDIh/zpo9FiQInsTb2SAkKHV42XYBjpJDg4374XiVb3ws4qM0s9eSQ5HzsMU4OZJKuopFjBM+dAZEl8RUMx5uU2N486Kr141tVsGQfGjORYMCJAMsxELeNT4RmWjRcpdTGBwcx6XN9drWqPmJzcrGrH4+DRc7+n1w3kPZwu0BkNr6hQrqgo7JTB9A5kdJ/H7P4cWBMwsmuixAzJB3yrQpnGIq90lxAXLzDCdn1LPibsRt7rHNjgQBklRgPZ8vTbjXdgXrTWQsK5MdrXXQVPp0Rinq3frzZKJ0qD6Qhc40VzAraUXlob1gvkhK3vpmHgI6FRlQZNx6eRqkp0zy4AQlX813fAPtL3jMRaitGFFjo0zmErloC+h+YYdVQ6k4F/epxAoF0BmqEoKNTt6j4vQZNQ2BoqF9Vj53TOIoNmDiu9Xp15RkIgQIGcoLpfoIbenzpGUAtqFJp5W+LLnx38jHeECTJ/navKY1NWfN0sY1T8/pB8kIH3DU3DX+u6W3YwpypBMYOhbSxGjq84RZ84fWJow8pyHqn4S/9J15EcCMsXqrfwyd9mhiu3+rEo9pPpoJkdZqHjra4NvzFwuThNKy6hao/SlLw3ZADUcUp3w3SRVfW2rhl80zOgTYnKE0Hs2qp1J6H3xqPqIkvUDRMFDYyRbsFI3M9MEyovPk8rlw7/0a81cDVLmBsR2ze2pBuKb23fbeZC0uXoIvDppfTwIDxk1Oq2dGesGc+oJXWJLGkOha3CX+DUnzgAp9HGH9RsPZN63Hn4RMA5eSVhPHO+9RcRb/IOgtW31V1Q5IPGtoxPjC+MEJbVlIMYADd9aHYWUIQKopuPOHmoqSkubnAKnzgKHqgIOfW5RdAgotN6BN+O2ZYHkuemLnvQ8U9THVrS1RtLmKbcC7PeeDsYznvqzeg6VCNwmr0Yyx1wnLjyT84BZz3EJyCptD3yeueAyDWIs0L2qs/VQ3HUyqfrja0V1LdDzqAikeWuV4sc7RLIB69jEIBjCkyZedoUHqCrOvShVzyd73OdrJW0hPOuQv2qOoHDc9xVb6Yu6uq3Xqp2ZaH46A7lzevbxQEmfrzvAYSJuZ4WDk1Hz3QX1LVdiUK0EvlAGAYlG3Md30r7dcPN63yqBCIj25prpvZP0nI4+EgWoFG95V596CurXpKRBGRjQlHCvy5Ib/iW8nZJWwrET3mgd6mEhfP4KCuaLjopWs7h+MdXFdIv8dHQJgg1xi1eYqB0uDYjxwVmri0Sv5XKut/onqapC+FQiC2C1lvYJ9MVco6yDYsS3AANUfMtvtbYI2hfwZatiSsnoUeMZd34GVjkMMKA+XnjJpXgRW2SHTZplVowPmJsvXy6w3cfO1AK2dvtZEKTkC/TY9LFiKHCG0DnrMQdGm2lzlBHM9iEYynH2UcVMhUEjsc0oDBTgo2ZSQ1gzkAHeWeBXYFjYLuuf8yzTCy7/RFR81WDjXMbq2BOH5dURnxo6oivmxL3cKzKInlZkD31nvpHB9Kk7GfcfE1t+1V64b9LtgeJGlpRFxQCAqWJ5DoY77ski8gsOEOr2uywZaoO/NGa0X0y1pNQHBi3b2SUGNpcZxDT7rLbBf1FSnQ8guxGW3W+36BW0gBje4DOz6Ba6SVk0xiKgt+q2JOFyr4SYfnu+Ic1QZYIuwHBrgzr6UvOcSCzPTOo7D6IC4ISeS7zkl4h+2VoeHpnG/uWR3+ysNgPcOIXQbv0n4mr3BwQcdKJxgPSeyuP/z1Jjg4e9nUvoXegqQVIE30EHx5GHv+FAVUNTowYDJgyFhf5IvlYmEqRif6+WN1MkEJmDcQITx9FX23a4mxy1AQRsOHO/+eImX9l8EMJI3oPWzVXxSOeHU1dUWYr2uAA7AMb+vAEZSbU3qob9ibCyXeypEMpZ6863o6QPqlqGHZkuWABSTVNd4cOh9hv3qEpSx2Zy/DJMP6cItEmiBJ5PFqQnDEIt3NrA3COlOSgz43D7gpNFNJ5MBh4oFzhDPiglC2ypsNU4ISywY2erkyb1NC3Qh/IfWj0eDgZI4/ln8WPfBsT3meTjq1Uqt1E7Zl/qftqkx6aM9KueMCekSnMrcHj1CqTWWzEzPsZGcDe3Ue4Ws+XFYVxNbOFF8ezkvQGR6ZOtOLU2lQEnMBStx47vE6Pb7AYMBRj2OOfZXfisjJnpTfSNjo6sZ6qSvNxZNmDeS7Gk3yYyCk1HtKN2UnhMIjOXUzAqDv90lx9O/q/AT1ZMnit5XQe9wmQxnE/WSH0CqZ9/2Hy+Sfmpeg8RwsHI5Z8kC8H293m/LHVVM/BA7HaTJYg5Enk7M/xWpq0192ACfBai2LA/qrCjCr6Dh1BIMzMXINBmX96MJ5Hn2nxln/RXPFhwHxUmSV0EV2V0jm86/dxxuYSU1W7sVkEbN9EzkG0QFwPhyHKyb3t+Fj5WoUUTErcazE/N6EW6Lvp0d//SDPj7EV9UdJN+Amnf3Wwk3A0SlJ9Z00yvXZ7n3z70G47Hfsow8Wq1JXcfwnA+Yxa5mFsgV464KKP4T31wqIgzFPd3eCe3j5ory5fBF2hgCFyVFrLzI9eetNXvM7oQqyFgDo4CTp/hDV9NMX9JDHQ/nyHTLvZLNLF6ftn2OxjGm8+PqOwhxnPHWipkE/8wbtyri80Sr7pMNkQGMfo4ZYK9OcCC4ESVFFbLMIvlxSoRqWie0wxqnLfcLSXMSpMMQEJYDVObYsXIQNv4TGNwjq1kvT1UOkicTrG3IaBZ3XdScS3u8sgeZPVpOLkbiF940FjbCeNRINNvDbd01EPBrTCPpm12m43ze1bBB59Ia6Ovhnur/Nvx3IxwSWol+3H2qfCJR8df6aQf4v6WiONxkK+IqT4pKQrZK/LplgDI/PJZbOep8dtbV7oCr6CgfpWa8NczOkPx81iSHbsNhVSJBOtrLIMrL31LK9TqHqAbAHe0RLmmV806kRLDLNEhUEJfm9u0sxpkL93Zgd6rw+tqBfTMi59xqXHLXSHwSbSBl0EK0+loECOPtrl+/nsaFe197di4yUgoe4jKoAJDXc6DGDjrQOoFDWZJ9HXwt8xDrQP+7aRwWKWI1GF8s8O4KzxWBBcwnl3vnl1Oez3oh6Ea1vjR7/z7DDTrFtqU2W/KAEzAuXDNZ7MY73MF216dzdSbWmUp4lcm7keJfWaMHgut9x5C9mj66Z0lJ+yhsjVvyiWrfk1lzPOTdhG15Y7gQlXtacvI7qv/XNSscDwqkgwHT/gUsD5yB7LdRRvJxQGYINn9hTpodKFVSTPrtGvyQw+HlRFXIkodErAGu9Iy1YpfSPc3jkFh5CX3lPxv7aqjE/JAfTIpEjGb/H7MO0e2vsViSW1qa/Lmi4/n4DEI3g7lYrcanspDfEpKkdV1OjSLOy0BCUqVoECaB55vs06rXl4jqmLsPsFM/7vYJ0vrBhDCm/00A/H81l1uekJ/6Lml3Hb9+NKiLqATJmDpyzfYZFHumEjC662L0Bwkxi7E9U4cQA0XMVDuMYAIeLMPgQaMVOd8fmt5SflFIfuBoszeAw7ow5gXPE2Y/yBc/7jExARUf/BxIHQBF5Sn3i61w4z5xJdCyO1F1X3+3ax+JSvMeZ7S6QSKp1Fp/sjYz6Z+VgCZzibGeEoujryfMulH7Rai5kAft9ebcW50DyJr2uo2z97mTWIu45YsSnNSMrrNUuG1XsYBtD9TDYzQffKB87vWbkM4EbPAFgoBV4GQS+vtFDUqOFAoi1nTtmIOvg38N4hT2Sn8r8clmBCXspBlMBYTnrqFJGBT3wZOzAyJDre9dHH7+x7qaaKDOB4UQALD5ecS0DE4obubQEiuJZ0EpBVpLuYcce8Aa4PYd/V4DLDAJBYKQPCWTcrEaZ5HYbJi11Gd6hjGom1ii18VHYnG28NKpkz2UKVPxlhYSp8uZr367iOmoy7zsxehW9wzcy2zG0a80PBMCRQMb32hnaHeOR8fnNDzZhaNYhkOdDsBUZ3loDMa1YP0uS0cjUP3b/6DBlqmZOeNABDsLl5BI5QJups8uxAuWJdkUB/pO6Zax6tsg7fN5mjjDgMGngO+DPcKqiHIDbFIGudxtPTIyDi9SFMKBDcfdGQRv41q1AqmxgkVfJMnP8w/Bc7N9/TR6C7mGObFqFkIEom8sKi2xYqJLTCHK7cxzaZvqODo22c3wisBCP4HeAgcRbNPAsBkNRhSmD48dHupdBRw4mIvtS5oeF6zeT1KMCyhMnmhpkFAGWnGscoNkwvQ8ZM5lE/vgTHFYL99OuNxdFBxTEDd5v2qLR8y9WkXsWgG6kZNndFG+pO/UAkOCipqIhL3hq7cRSdrCq7YhUsTocEcnaFa6nVkhnSeRYUA1YO0z5itF9Sly3VlxYDw239TJJH6f3EUfYO5lb7bcFcz8Bp7Oo8QmnsUHOz/fagVUBtKEw1iT88j+aKkv8cscKNkMxjYr8344D1kFoZ7/td1W6LCNYN594301tUGRmFjAzeRg5vyoM1F6+bJZ/Q54jN/k8SFd3DxPTYaAUsivsBfgTn7Mx8H2SpPt4GOdYRnEJOH6jHM2p6SgB0gzIRq6fHxGMmSmqaPCmlfwxiuloaVIitLGN8wie2CDWhkzLoCJcODh7KIOAqbHEvXdUxaS4TTTs07Clzj/6GmVs9kiZDerMxEnhUB6QQPlcfqkG9882RqHoLiHGBoHfQuXIsAG8GTAtao2KVwRnvvam8jo1e312GQAKWEa4sUVEAMG4G6ckcONDwRcg1e2D3+ohXgY4UAWF8wHKQMrSnzCgfFpsxh+aHXMGtPQroQasRY4U6UdG0rz1Vjbka0MekOGRZQEvqQFlxseFor8zWFgHek3v29+WqN6gaK5gZOTOMZzpQIC1201LkMCXild3vWXSc5UX9xcFYfbRPzGFa1FDcPfPB/jUEq/FeGt419CI3YmBlVoHsa4KdcwQP5ZSwHHhFJ7/Ph/Rap/4vmG91eDwPP0lDfCDRCLszTqfzM71xpmiKi2HwS4WlqvGNwtvwF5Dqpn6KTq8ax00UMPkxDcZrEEEsIvHiUXXEphdb4GB4FymlPwBz4Gperqq5pW7TQ6/yNRhW8VT5NhuP0udlxo4gILq5ZxAZk8ZGh3g4CqxJlPKY7AQxupfUcVpWT5VItp1+30UqoyP4wWsRo3olRRgkWZZ2ZN6VC3OZFeXB8NbnUrSdikNptD1QiGuKkr8EmSR/AK9Rw+FF3s5uwuPbvHGiPeFOViltMK7AUaOsq9+x9cndk3iJEE5LKZRlWJbKOZweROzmPNVPkjE3K/TyA57Rs68TkZ3MR8akKpm7cFjnjPd/DdkWjgYoKHSr5Wu5ssoBYU4acRs5g2DHxUmdq8VXOXRbunD8QN0LhgkssgahcdoYsNvuXGUK/KXD/7oFb+VGdhqIn02veuM5bLudJOc2Ky0GMaG4W/xWBxIJcL7yliJOXOpx0AkBqUgzlDczmLT4iILXDxxtRR1oZa2JWFgiAb43obrJnG/TZC2KSK2wqOzRZTXavZZFMb1f3bXvVaNaK828w9TO610gk8JNf3gMfETzXXsbcvRGCG9JWQZ6+cDPqc4466Yo2RcKH+PILeKOqtnlbInR3MmBeGG3FH10yzkybuqEC2HSQwpA0An7d9+73BkDUTm30bZmoP/RGbgFN+GrCOfADgqr0WbI1a1okpFms8iHYw9hm0zUvlEMivBRxModrbJJ+9/p3jUdQQ9BCtQdxnOGrT5dzRUmw0593/mbRSdBg0nRvRZM5/E16m7ZHmDEtWhwvfdZCZ8J8M12W0yRMszXamWfQTwIZ4ayYktrnscQuWr8idp3PjT2eF/jmtdhIfcpMnb+IfZY2FebW6UY/AK3jP4u3Tu4zE4qlnQgLFbM19EBIsNf7KhjdbqQ/D6yiDb+NlEi2SKD+ivXVUK8ib0oBo366gXkR8ZxGjpJIDcEgZPa9TcYe0TIbiPl/rPUQDu3XBJ9X/GNq3FAUsKsll57DzaGMrjcT+gctp+9MLYXCq+sqP81eVQ0r9lt+gcQfZbACRbEjvlMskztZG8gbC8Qn9tt26Q7y7nDrbZq/LEz7kR6Jc6pg3N9rVX8Y5MJrGlML9p9lU4jbTkKqCveeZUJjHB03m2KRKR2TytoFkTXOLg7keU1s1lrPMQJpoOKLuAAC+y1HlJucU6ysB5hsXhvSPPLq5J7JtnqHKZ4vYjC4Vy8153QY+6780xDuGARsGbOs1WqzH0QS765rnSKEbbKlkO8oI/VDwUd0is13tKpqILu1mDJFNy/iJAWcvDgjxvusIT+PGz3ST/J9r9Mtfd0jpaGeiLYIqXc7DiHSS8TcjFVksi66PEkxW1z6ujbLLUGNNYnzOWpH8BZGK4bCK7iR+MbIv8ncDAz1u4StN3vTTzewr9IQjk9wxFxn+6N1ddKs0vffJiS08N3a4G1SVrlZ97Q/M+8G9fe5AP6d9/Qq4WRnORVhofPIKEdCr3llspUfE0oKIIYoByBRPh+bX1HLS3JWGJRhIvE1aW4NTd8ePi4Z+kXb+Z8snYfSNcqijhAgVsx4RCM54cXUiYkjeBmmC4ajOHrChoELscJJC7+9jjMjw5BagZKlgRMiSNYz7h7vvZIoQqbtQmspc0cUk1G/73iXtSpROl5wtLgQi0mW2Ex8i3WULhcggx6E1LMVHUsdc9GHI1PH3U2Ko0PyGdn9KdVOLm7FPBui0i9a0HpA60MsewVE4z8CAt5d401Gv6zXlIT5Ybit1VIA0FCs7wtvYreru1fUyW3oLAZ/+aTnZrOcYRNVA8spoRtlRoWflsRClFcgzkqiHOrf0/SVw+EpVaFlJ0g4Kxq1MMOmiQdpMNpte8lMMQqm6cIFXlnGbfJllysKDi+0JJMotkqgIxOSQgU9dn/lWkeVf8nUm3iwX2Nl3WDw9i6AUK3vBAbZZrcJpDQ/N64AVwjT07Jef30GSSmtNu2WlW7YoyW2FlWfZFQUwk867EdLYKk9VG6JgEnBiBxkY7LMo4YLQJJlAo9l/oTvJkSARDF/XtyAzM8O2t3eT/iXa6wDN3WewNmQHdPfsxChU/KtLG2Mn8i4ZqKdSlIaBZadxJmRzVS/o4yA65RTSViq60oa395Lqw0pzY4SipwE0SXXsKV+GZraGSkr/RW08wPRvqvSUkYBMA9lPx4m24az+IHmCbXA+0faxTRE9wuGeO06DIXa6QlKJ3puIyiuAVfPr736vzo2pBirS+Vxel3TMm3JKhz9o2ZoRvaFVpIkykb0Hcm4oHFBMcNSNj7/4GJt43ogonY2Vg4nsDQIWxAcorpXACzgBqQPjYsE/VUpXpwNManEru4NwMCFPkXvMoqvoeLN3qyu/N1eWEHttMD65v19l/0kH2mR35iv/FI+yjoHJ9gPMz67af3Mq/BoWXqu3rphiWMXVkmnPSEkpGpUI2h1MThideGFEOK6YZHPwYzMBvpNC7+ZHxPb7epfefGyIB4JzO9DTNEYnDLVVHdQyvOEVefrk6Uv5kTQYVYWWdqrdcIl7yljwwIWdfQ/y+2QB3eR/qxYObuYyB4gTbo2in4PzarU1sO9nETkmj9/AoxDA+JM3GMqQtJR4jtduHtnoCLxd1gQUscHRB/MoRYIEsP2pDZ9KvHgtlk1iTbWWbHhohwFEYX7y51fUV2nuUmnoUcqnWIQAAgl9LTVX+Bc0QGNEhChxHR4YjfE51PUdGfsSFE6ck7BL3/hTf9jLq4G1IafINxOLKeAtO7quulYvH5YOBc+zX7CrMgWnW47/jfRsWnJjYYoE7xMfWV2HN2iyIqLI";
      FENCED = /* @__PURE__ */ new Map([[8217, "apostrophe"], [8260, "fraction slash"], [12539, "middle dot"]]);
      NSM_MAX = 4;
      COMPRESSED = "AEUDTAHBCFQATQDRADAAcgAgADQAFAAsABQAHwAOACQADQARAAoAFwAHABIACAAPAAUACwAFAAwABAAQAAMABwAEAAoABQAIAAIACgABAAQAFAALAAIACwABAAIAAQAHAAMAAwAEAAsADAAMAAwACgANAA0AAwAKAAkABAAdAAYAZwDSAdsDJgC0CkMB8xhZAqfoC190UGcThgBurwf7PT09Pb09AjgJum8OjDllxHYUKXAPxzq6tABAxgK8ysUvWAgMPT09PT09PSs6LT2HcgWXWwFLoSMEEEl5RFVMKvO0XQ8ExDdJMnIgsj26PTQyy8FfEQ8AY8IPAGcEbwRwBHEEcgRzBHQEdQR2BHcEeAR6BHsEfAR+BIAEgfndBQoBYgULAWIFDAFiBNcE2ATZBRAFEQUvBdALFAsVDPcNBw13DYcOMA4xDjMB4BllHI0B2grbAMDpHLkQ7QHVAPRNQQFnGRUEg0yEB2uaJF8AJpIBpob5AERSMAKNoAXqaQLUBMCzEiACnwRZEkkVsS7tANAsBG0RuAQLEPABv9HICTUBXigPZwRBApMDOwAamhtaABqEAY8KvKx3LQ4ArAB8UhwEBAVSagD8AEFZADkBIadVj2UMUgx5Il4ANQC9AxIB1BlbEPMAs30CGxlXAhwZKQIECBc6EbsCoxngzv7UzRQA8M0BawL6ZwkN7wABAD33OQRcsgLJCjMCjqUChtw/km+NAsXPAoP2BT84PwURAK0RAvptb6cApQS/OMMey5HJS84UdxpxTPkCogVFITaTOwERAK5pAvkNBOVyA7q3BKlOJSALAgUIBRcEdASpBXqzABXFSWZOawLCOqw//AolCZdvv3dSBkEQGyelEPcMMwG1ATsN7UvYBPEGOwTJH30ZGQ/NlZwIpS3dDO0m4y6hgFoj9SqDBe1L9DzdC01RaA9ZC2UJ4zpjgU4DIQENIosK3Q05CG0Q8wrJaw3lEUUHOQPVSZoApQcBCxEdNRW1JhBirAsJOXcG+xr2C48mrxMpevwF0xohBk0BKRr/AM8u54WwWjFcHE9fBgMLJSPHFKhQIA0lQLd4SBobBxUlqQKRQ3BKh1E2HpMh9jw9DWYuE1F8B/U8BRlPC4E8nkarRQ4R0j6NPUgiSUwsBDV/LC8niwnPD4UMuXxyAVkJIQmxDHETMREXN8UIOQcZLZckJxUIIUaVYJoE958D8xPRAwsFPwlBBxMDtRwtEy4VKQUNgSTXAvM21S6zAo9WgAEXBcsPJR/fEFBH4A7pCJsCZQODJesALRUhABcimwhDYwBfj9hTBS7LCMdqbCN0A2cU52ERcweRDlcHpxwzFb8c4XDIXguGCCijrwlbAXUJmQFfBOMICTVbjKAgQWdTi1gYmyBhQT9d/AIxDGUVn0S9h3gCiw9rEhsBNQFzBzkNAQJ3Ee0RaxCVCOuGBDW1M/g6JQRPIYMgEQonA09szgsnJvkM+GkBoxJiAww0PXfuZ6tgtiQX/QcZMsVBYCHxC5JPzQycGsEYQlQuGeQHvwPzGvMn6kFXBf8DowMTOk0z7gS9C2kIiwk/AEkOoxcH1xhqCnGM0AExiwG3mQNXkYMCb48GNwcLAGcLhwV55QAdAqcIowAFAM8DVwA5Aq0HnQAZAIVBAT0DJy8BIeUCjwOTCDHLAZUvAfMpBBvDDBUA9zduSgLDsQKAamaiBd1YAo4CSTUBTSUEBU5HUQOvceEA2wBLBhPfRwEVq0rLGuNDAd9vKwDHAPsABTUHBUEBzQHzbQC3AV8LMQmis7UBTekpAIMAFWsB1wKJAN0ANQB/8QFTAE0FWfkF0wJPSQERMRgrV2EBuwMfATMBDQB5BsuNpckHHwRtB9MCEBsV4QLvLge1AQMi3xPNQsUCvd5VoWACZIECYkJbTa9bNyACofcCaJgCZgkCn4Q4GwsCZjsCZiYEbgR/A38TA36SOQY5dxc5gjojIwJsHQIyNjgKAm3HAm2u74ozZ0UrAWcA3gDhAEoFB5gMjQD+C8IADbUCdy8CdqI/AnlLQwJ4uh1c20WuRtcCfD8CesgCfQkCfPAFWQUgSABIfWMkAoFtAoAAAoAFAn+uSVhKWxUXSswC0QEC0MxLJwOITwOH5kTFkTIC8qFdAwMDrkvOTC0lA89NTE2vAos/AorYwRsHHUNnBbcCjjcCjlxAl4ECjtkCjlx4UbRTNQpS1FSFApP7ApMMAOkAHFUeVa9V0AYsGymVhjLheGZFOzkCl58C77JYIagAWSUClo8ClnycAKlZrFoJgU0AOwKWtQKWTlxEXNECmcsCmWRcyl0HGQKcmznCOp0CnBYCn5sCnriKAB0PMSoPAp3xAp6SALU9YTRh7wKe0wKgbgGpAp6fHwKeTqVjyGQnJSsCJ68CJn4CoPsCoEwCot0CocQCpi8Cpc4Cp/8AfQKn8mh8aLEAA0lqHGrRAqzjAqyuAq1nAq0CAlcdAlXcArHh1wMfTmyXArK9DQKy6Bds4G1jbUhfAyXNArZcOz9ukAMpRQK4XgK5RxUCuSp3cDZw4QK9GQK72nCWAzIRAr6IcgIDM3ECvhpzInNPAsPLAsMEc4J0SzVFdOADPKcDPJoDPb8CxXwCxkcCxhCJAshpUQLIRALJTwLJLgJknQLd0nh5YXiueSVL0AMYo2cCAmH0GfOVJHsLXpJeuxECz2sCz2wvS1PS8xOfAMatAs9zASnqA04SfksFAtwnAtuKAtJPA1JcA1NfAQEDVYyAiT8AyxbtYEWCHILTgs6DjQLaxwLZ3oQQhEmnPAOGpQAvA2QOhnFZ+QBVAt9lAt64c3cC4i/tFAHzMCcB9JsB8tKHAuvzAulweQLq+QLq5AD5RwG5Au6JAuuclqqXAwLuPwOF4Jh5cOBxoQLzAwBpA44WmZMC9xMDkW4DkocC95gC+dkC+GaaHJqruzebHgOdgwL++gEbADmfHJ+zAwWNA6ZqA6bZANHFAwZqoYiiBQkDDEkCwAA/AwDhQRdTARHzA2sHl2cFAJMtK7evvdsBiZkUfxEEOQH7KQUhDp0JnwCS/SlXxQL3AZ0AtwW5AG8LbUEuFCaNLgFDAYD8AbUmAHUDDgRtACwCFgyhAAAKAj0CagPdA34EkQEgRQUhfAoABQBEABMANhICdwEABdUDa+8KxQIA9wqfJ7+xt+UBkSFBQgHpFH8RNMCJAAQAGwBaAkUChIsABjpTOpSNbQC4Oo860ACNOME63AClAOgAywE6gTo7Ofw5+Tt2iTpbO56JOm85GAFWATMBbAUvNV01njWtNWY1dTW2NcU1gjWRNdI14TWeNa017jX9NbI1wTYCNhE1xjXVNhY2JzXeNe02LjY9Ni41LSE2OjY9Njw2yTcIBJA8VzY4Nt03IDcPNsogN4k3MAoEsDxnNiQ3GTdsOo03IULUQwdC4EMLHA8PCZsobShRVQYA6X8A6bABFCnXAukBowC9BbcAbwNzBL8MDAMMAQgDAAkKCwsLCQoGBAVVBI/DvwDz9b29kaUCb0QtsRTNLt4eGBcSHAMZFhYZEhYEARAEBUEcQRxBHEEcQRxBHEEaQRxBHEFCSTxBPElISUhBNkM2QTYbNklISVmBVIgBFLWZAu0BhQCjBcEAbykBvwGJAaQcEZ0ePCklMAAhMvAIMAL54gC7Bm8EescjzQMpARQpKgDUABavAj626xQAJP0A3etzuf4NNRA7efy2Z9NQrCnC0OSyANz5BBIbJ5IFDR6miIavYS6tprjjmuKebxm5C74Q225X1pkaYYPb6f1DK4k3xMEBb9S2WMjEibTNWhsRJIA+vwNVEiXTE5iXs/wezV66oFLfp9NZGYW+Gk19J2+bCT6Ye2w6LDYdgzKMUabk595eLBCXANz9HUpWbATq9vqXVx9XDg+Pc9Xp4+bsS005SVM/BJBM4687WUuf+Uj9dEi8aDNaPxtpbDxcG1THTImUMZq4UCaaNYpsVqraNyKLJXDYsFZ/5jl7bLRtO88t7P3xZaAxhb5OdPMXqsSkp1WCieG8jXm1U99+blvLlXzPCS+M93VnJCiK+09LfaSaBAVBomyDgJua8dfUzR7ga34IvR2Nvj+A9heJ6lsl1KG4NkI1032Cnff1m1wof2B9oHJK4bi6JkEdSqeNeiuo6QoZZincoc73/TH9SXF8sCE7XyuYyW8WSgbGFCjPV0ihLKhdPs08Tx82fYAkLLc4I2wdl4apY7GU5lHRFzRWJep7Ww3wbeA3qmd59/86P4xuNaqDpygXt6M85glSBHOCGgJDnt+pN9bK7HApMguX6+06RZNjzVmcZJ+wcUrJ9//bpRNxNuKpNl9uFds+S9tdx7LaM5ZkIrPj6nIU9mnbFtVbs9s/uLgl8MVczAwet+iOEzzBlYW7RCMgE6gyNLeq6+1tIx4dpgZnd0DksJS5f+JNDpwwcPNXaaVspq1fbQajOrJgK0ofKtJ1Ne90L6VO4MOl5S886p7u6xo7OLjG8TGL+HU1JXGJgppg4nNbNJ5nlzSpuPYy21JUEcUA94PoFiZfjZue+QnyQ80ekOuZVkxx4g+cvhJfHgNl4hy1/a6+RKcKlar/J29y//EztlbVPHVUeQ1zX86eQVAjR/M3dA9w4W8LfaXp4EgM85wOWasli837PzVMOnsLzR+k3o75/lRPAJSE1xAKQzEi5v10ke+VBvRt1cwQRMd+U5mLCTGVd6XiZtgBG5cDi0w22GKcVNvHiu5LQbZEDVtz0onn7k5+heuKXVsZtSzilkLRAUmjMXEMB3J9YC50XBxPiz53SC+EhnPl9WsKCv92SM/OFFIMJZYfl0WW8tIO3UxYcwdMAj7FSmgrsZ2aAZO03BOhP1bNNZItyXYQFTpC3SG1VuPDqH9GkiCDmE+JwxyIVSO5siDErAOpEXFgjy6PQtOVDj+s6e1r8heWVvmZnTciuf4EiNZzCAd7SOMhXERIOlsHIMG399i9aLTy3m2hRLZjJVDNLS53iGIK11dPqQt0zBDyg6qc7YqkDm2M5Ve6dCWCaCbTXX2rToaIgz6+zh4lYUi/+6nqcFMAkQJKHYLK0wYk5N9szV6xihDbDDFr45lN1K4aCXBq/FitPSud9gLt5ZVn+ZqGX7cwm2z5EGMgfFpIFyhGGuDPmso6TItTMwny+7uPnLCf4W6goFQFV0oQSsc9VfMmVLcLr6ZetDZbaSFTLqnSO/bIPjA3/zAUoqgGFAEQS4IhuMzEp2I3jJzbzkk/IEmyax+rhZTwd6f+CGtwPixu8IvzACquPWPREu9ZvGkUzpRwvRRuaNN6cr0W1wWits9ICdYJ7ltbgMiSL3sTPeufgNcVqMVWFkCPDH4jG2jA0XcVgQj62Cb29v9f/z/+2KbYvIv/zzjpQAPkliaVDzNrW57TZ/ZOyZD0nlfMmAIBIAGAI0D3k/mdN4xr9v85ZbZbbqfH2jGd5hUqNZWwl5SPfoGmfElmazUIeNL1j/mkF7VNAzTq4jNt8JoQ11NQOcmhprXoxSxfRGJ9LDEOAQ+dmxAQH90iti9e2u/MoeuaGcDTHoC+xsmEeWmxEKefQuIzHbpw5Tc5cEocboAD09oipWQhtTO1wivf/O+DRe2rpl/E9wlrzBorjJsOeG1B/XPW4EaJEFdNlECEZga5ZoGRHXgYouGRuVkm8tDESiEyFNo+3s5M5puSdTyUL2llnINVHEt91XUNW4ewdMgJ4boJfEyt/iY5WXqbA+A2Fkt5Z0lutiWhe9nZIyIUjyXDC3UsaG1t+eNx6z4W/OYoTB7A6x+dNSTOi9AInctbESqm5gvOLww7OWXPrmHwVZasrl4eD113pm+JtT7JVOvnCXqdzzdTRHgJ0PiGTFYW5Gvt9R9LD6Lzfs0v/TZZHSmyVNq7viIHE6DBK7Qp07Iz55EM8SYtQvZf/obBniTWi5C2/ovHfw4VndkE5XYdjOhCMRjDeOEfXeN/CwfGduiUIfsoFeUxXeQXba7c7972XNv8w+dTjjUM0QeNAReW+J014dKAD/McQYXT7c0GQPIkn3Ll6R7gGjuiQoZD0TEeEqQpKoZ15g/0OPQI17QiSv9AUROa/V/TQN3dvLArec3RrsYlvBm1b8LWzltdugsC50lNKYLEp2a+ZZYqPejULRlOJh5zj/LVMyTDvwKhMxxwuDkxJ1QpoNI0OTWLom4Z71SNzI9TV1iXJrIu9Wcnd+MCaAw8o1jSXd94YU/1gnkrC9BUEOtQvEIQ7g0i6h+KL2JKk8Ydl7HruvgWMSAmNe+LshGhV4qnWHhO9/RIPQzY1tHRj2VqOyNsDpK0cww+56AdDC4gsWwY0XxoucIWIqs/GcwnWqlaT0KPr8mbK5U94/301i1WLt4YINTVvCFBrFZbIbY8eycOdeJ2teD5IfPLCRg7jjcFTwlMFNl9zdh/o3E/hHPwj7BWg0MU09pPrBLbrCgm54A6H+I6v27+jL5gkjWg/iYdks9jbfVP5y/n0dlgWEMlKasl7JvFZd56LfybW1eeaVO0gxTfXZwD8G4SI116yx7UKVRgui6Ya1YpixqXeNLc8IxtAwCU5IhwQgn+NqHnRaDv61CxKhOq4pOX7M6pkA+Pmpd4j1vn6ACUALoLLc4vpXci8VidLxzm7qFBe7s+quuJs6ETYmnpgS3LwSZxPIltgBDXz8M1k/W2ySNv2f9/NPhxLGK2D21dkHeSGmenRT3Yqcdl0m/h3OYr8V+lXNYGf8aCCpd4bWjE4QIPj7vUKN4Nrfs7ML6Y2OyS830JCnofg/k7lpFpt4SqZc5HGg1HCOrHvOdC8bP6FGDbE/VV0mX4IakzbdS/op+Kt3G24/8QbBV7y86sGSQ/vZzU8FXs7u6jIvwchsEP2BpIhW3G8uWNwa3HmjfH/ZjhhCWvluAcF+nMf14ClKg5hGgtPLJ98ueNAkc5Hs2WZlk2QHvfreCK1CCGO6nMZVSb99VM/ajr8WHTte9JSmkXq/i/U943HEbdzW6Re/S88dKgg8pGOLlAeNiqrcLkUR3/aClFpMXcOUP3rmETcWSfMXZE3TUOi8i+fqRnTYLflVx/Vb/6GJ7eIRZUA6k3RYR3iFSK9c4iDdNwJuZL2FKz/IK5VimcNWEqdXjSoxSgmF0UPlDoUlNrPcM7ftmA8Y9gKiqKEHuWN+AZRIwtVSxye2Kf8rM3lhJ5XcBXU9n4v0Oy1RU2M+4qM8AQPVwse8ErNSob5oFPWxuqZnVzo1qB/IBxkM3EVUKFUUlO3e51259GgNcJbCmlvrdjtoTW7rChm1wyCKzpCTwozUUEOIcWLneRLgMXh+SjGSFkAllzbGS5HK7LlfCMRNRDSvbQPjcXaenNYxCvu2Qyznz6StuxVj66SgI0T8B6/sfHAJYZaZ78thjOSIFumNWLQbeZixDCCC+v0YBtkxiBB3jefHqZ/dFHU+crbj6OvS1x/JDD7vlm7zOVPwpUC01nhxZuY/63E7g";
      S0 = 44032;
      L0 = 4352;
      V0 = 4449;
      T0 = 4519;
      L_COUNT = 19;
      V_COUNT = 21;
      T_COUNT = 28;
      N_COUNT = V_COUNT * T_COUNT;
      S_COUNT = L_COUNT * N_COUNT;
      S1 = S0 + S_COUNT;
      L1 = L0 + L_COUNT;
      V1 = V0 + V_COUNT;
      T1 = T0 + T_COUNT;
      HYPHEN = 45;
      STOP_CH = ".";
      FE0F = 65039;
      UNIQUE_PH = 1;
      Array_from = (x) => Array.from(x);
      Emoji = class extends Array {
        get is_emoji() {
          return true;
        }
        // free tagging system
      };
    }
  });

  // node_modules/ethers/lib.esm/hash/namehash.js
  function checkComponent(comp) {
    assertArgument(comp.length !== 0, "invalid ENS name; empty component", "comp", comp);
    return comp;
  }
  function ensNameSplit(name) {
    const bytes2 = toUtf8Bytes(ensNormalize(name));
    const comps = [];
    if (name.length === 0) {
      return comps;
    }
    let last = 0;
    for (let i = 0; i < bytes2.length; i++) {
      const d = bytes2[i];
      if (d === 46) {
        comps.push(checkComponent(bytes2.slice(last, i)));
        last = i + 1;
      }
    }
    assertArgument(last < bytes2.length, "invalid ENS name; empty component", "name", name);
    comps.push(checkComponent(bytes2.slice(last)));
    return comps;
  }
  function ensNormalize(name) {
    try {
      if (name.length === 0) {
        throw new Error("empty label");
      }
      return ens_normalize(name);
    } catch (error) {
      assertArgument(false, `invalid ENS name (${error.message})`, "name", name);
    }
  }
  function isValidName(name) {
    try {
      return ensNameSplit(name).length !== 0;
    } catch (error) {
    }
    return false;
  }
  function namehash(name) {
    assertArgument(typeof name === "string", "invalid ENS name; not a string", "name", name);
    assertArgument(name.length, `invalid ENS name (empty label)`, "name", name);
    let result = Zeros2;
    const comps = ensNameSplit(name);
    while (comps.length) {
      result = keccak256(concat([result, keccak256(comps.pop())]));
    }
    return hexlify(result);
  }
  function dnsEncode(name, _maxLength) {
    const length = _maxLength != null ? _maxLength : 63;
    assertArgument(length <= 255, "DNS encoded label cannot exceed 255", "length", length);
    return hexlify(concat(ensNameSplit(name).map((comp) => {
      assertArgument(comp.length <= length, `label ${JSON.stringify(name)} exceeds ${length} bytes`, "name", name);
      const bytes2 = new Uint8Array(comp.length + 1);
      bytes2.set(comp, 1);
      bytes2[0] = bytes2.length - 1;
      return bytes2;
    }))) + "00";
  }
  var Zeros2;
  var init_namehash = __esm({
    "node_modules/ethers/lib.esm/hash/namehash.js"() {
      init_crypto2();
      init_utils();
      init_dist();
      Zeros2 = new Uint8Array(32);
      Zeros2.fill(0);
    }
  });

  // node_modules/ethers/lib.esm/hash/message.js
  function hashMessage(message) {
    if (typeof message === "string") {
      message = toUtf8Bytes(message);
    }
    return keccak256(concat([
      toUtf8Bytes(MessagePrefix),
      toUtf8Bytes(String(message.length)),
      message
    ]));
  }
  function verifyMessage(message, sig) {
    const digest = hashMessage(message);
    return recoverAddress(digest, sig);
  }
  var init_message = __esm({
    "node_modules/ethers/lib.esm/hash/message.js"() {
      init_crypto2();
      init_constants();
      init_transaction2();
      init_utils();
    }
  });

  // node_modules/ethers/lib.esm/hash/solidity.js
  function _pack(type, value, isArray) {
    switch (type) {
      case "address":
        if (isArray) {
          return getBytes(zeroPadValue(value, 32));
        }
        return getBytes(getAddress(value));
      case "string":
        return toUtf8Bytes(value);
      case "bytes":
        return getBytes(value);
      case "bool":
        value = !!value ? "0x01" : "0x00";
        if (isArray) {
          return getBytes(zeroPadValue(value, 32));
        }
        return getBytes(value);
    }
    let match = type.match(regexNumber);
    if (match) {
      let signed2 = match[1] === "int";
      let size5 = parseInt(match[2] || "256");
      assertArgument((!match[2] || match[2] === String(size5)) && size5 % 8 === 0 && size5 !== 0 && size5 <= 256, "invalid number type", "type", type);
      if (isArray) {
        size5 = 256;
      }
      if (signed2) {
        value = toTwos(value, size5);
      }
      return getBytes(zeroPadValue(toBeArray(value), size5 / 8));
    }
    match = type.match(regexBytes);
    if (match) {
      const size5 = parseInt(match[1]);
      assertArgument(String(size5) === match[1] && size5 !== 0 && size5 <= 32, "invalid bytes type", "type", type);
      assertArgument(dataLength(value) === size5, `invalid value for ${type}`, "value", value);
      if (isArray) {
        return getBytes(zeroPadBytes(value, 32));
      }
      return value;
    }
    match = type.match(regexArray);
    if (match && Array.isArray(value)) {
      const baseType = match[1];
      const count = parseInt(match[2] || String(value.length));
      assertArgument(count === value.length, `invalid array length for ${type}`, "value", value);
      const result = [];
      value.forEach(function(value2) {
        result.push(_pack(baseType, value2, true));
      });
      return getBytes(concat(result));
    }
    assertArgument(false, "invalid type", "type", type);
  }
  function solidityPacked(types, values) {
    assertArgument(types.length === values.length, "wrong number of values; expected ${ types.length }", "values", values);
    const tight = [];
    types.forEach(function(type, index2) {
      tight.push(_pack(type, values[index2]));
    });
    return hexlify(concat(tight));
  }
  function solidityPackedKeccak256(types, values) {
    return keccak256(solidityPacked(types, values));
  }
  function solidityPackedSha256(types, values) {
    return sha2562(solidityPacked(types, values));
  }
  var regexBytes, regexNumber, regexArray;
  var init_solidity = __esm({
    "node_modules/ethers/lib.esm/hash/solidity.js"() {
      init_address2();
      init_crypto2();
      init_utils();
      regexBytes = new RegExp("^bytes([0-9]+)$");
      regexNumber = new RegExp("^(u?int)([0-9]*)$");
      regexArray = new RegExp("^(.*)\\[([0-9]*)\\]$");
    }
  });

  // node_modules/ethers/lib.esm/hash/typed-data.js
  function hexPadRight(value) {
    const bytes2 = getBytes(value);
    const padOffset = bytes2.length % 32;
    if (padOffset) {
      return concat([bytes2, padding.slice(padOffset)]);
    }
    return hexlify(bytes2);
  }
  function checkString(key) {
    return function(value) {
      assertArgument(typeof value === "string", `invalid domain value for ${JSON.stringify(key)}`, `domain.${key}`, value);
      return value;
    };
  }
  function getBaseEncoder(type) {
    {
      const match = type.match(/^(u?)int(\d+)$/);
      if (match) {
        const signed2 = match[1] === "";
        const width = parseInt(match[2]);
        assertArgument(width % 8 === 0 && width !== 0 && width <= 256 && match[2] === String(width), "invalid numeric width", "type", type);
        const boundsUpper = mask(BN_MAX_UINT2562, signed2 ? width - 1 : width);
        const boundsLower = signed2 ? (boundsUpper + BN_15) * BN__1 : BN_08;
        return function(_value2) {
          const value = getBigInt(_value2, "value");
          assertArgument(value >= boundsLower && value <= boundsUpper, `value out-of-bounds for ${type}`, "value", value);
          return toBeHex(signed2 ? toTwos(value, 256) : value, 32);
        };
      }
    }
    {
      const match = type.match(/^bytes(\d+)$/);
      if (match) {
        const width = parseInt(match[1]);
        assertArgument(width !== 0 && width <= 32 && match[1] === String(width), "invalid bytes width", "type", type);
        return function(value) {
          const bytes2 = getBytes(value);
          assertArgument(bytes2.length === width, `invalid length for ${type}`, "value", value);
          return hexPadRight(value);
        };
      }
    }
    switch (type) {
      case "address":
        return function(value) {
          return zeroPadValue(getAddress(value), 32);
        };
      case "bool":
        return function(value) {
          return !value ? hexFalse : hexTrue;
        };
      case "bytes":
        return function(value) {
          return keccak256(value);
        };
      case "string":
        return function(value) {
          return id(value);
        };
    }
    return null;
  }
  function encodeType(name, fields) {
    return `${name}(${fields.map(({ name: name2, type }) => type + " " + name2).join(",")})`;
  }
  function splitArray(type) {
    const match = type.match(/^([^\x5b]*)((\x5b\d*\x5d)*)(\x5b(\d*)\x5d)$/);
    if (match) {
      return {
        base: match[1],
        index: match[2] + match[4],
        array: {
          base: match[1],
          prefix: match[1] + match[2],
          count: match[5] ? parseInt(match[5]) : -1
        }
      };
    }
    return { base: type };
  }
  function verifyTypedData(domain, types, value, signature) {
    return recoverAddress(TypedDataEncoder.hash(domain, types, value), signature);
  }
  var padding, BN__1, BN_08, BN_15, BN_MAX_UINT2562, hexTrue, hexFalse, domainFieldTypes, domainFieldNames, domainChecks, _types, _fullTypes, _encoderCache, _TypedDataEncoder_instances, getEncoder_fn, _TypedDataEncoder, TypedDataEncoder;
  var init_typed_data = __esm({
    "node_modules/ethers/lib.esm/hash/typed-data.js"() {
      init_address2();
      init_crypto2();
      init_transaction2();
      init_utils();
      init_id();
      padding = new Uint8Array(32);
      padding.fill(0);
      BN__1 = BigInt(-1);
      BN_08 = BigInt(0);
      BN_15 = BigInt(1);
      BN_MAX_UINT2562 = BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
      hexTrue = toBeHex(BN_15, 32);
      hexFalse = toBeHex(BN_08, 32);
      domainFieldTypes = {
        name: "string",
        version: "string",
        chainId: "uint256",
        verifyingContract: "address",
        salt: "bytes32"
      };
      domainFieldNames = [
        "name",
        "version",
        "chainId",
        "verifyingContract",
        "salt"
      ];
      domainChecks = {
        name: checkString("name"),
        version: checkString("version"),
        chainId: function(_value2) {
          const value = getBigInt(_value2, "domain.chainId");
          assertArgument(value >= 0, "invalid chain ID", "domain.chainId", _value2);
          if (Number.isSafeInteger(value)) {
            return Number(value);
          }
          return toQuantity(value);
        },
        verifyingContract: function(value) {
          try {
            return getAddress(value).toLowerCase();
          } catch (error) {
          }
          assertArgument(false, `invalid domain value "verifyingContract"`, "domain.verifyingContract", value);
        },
        salt: function(value) {
          const bytes2 = getBytes(value, "domain.salt");
          assertArgument(bytes2.length === 32, `invalid domain value "salt"`, "domain.salt", value);
          return hexlify(bytes2);
        }
      };
      _TypedDataEncoder = class _TypedDataEncoder {
        /**
         *  Create a new **TypedDataEncoder** for %%types%%.
         *
         *  This performs all necessary checking that types are valid and
         *  do not violate the [[link-eip-712]] structural constraints as
         *  well as computes the [[primaryType]].
         */
        constructor(_types2) {
          __privateAdd(this, _TypedDataEncoder_instances);
          /**
           *  The primary type for the structured [[types]].
           *
           *  This is derived automatically from the [[types]], since no
           *  recursion is possible, once the DAG for the types is consturcted
           *  internally, the primary type must be the only remaining type with
           *  no parent nodes.
           */
          __publicField(this, "primaryType");
          __privateAdd(this, _types);
          __privateAdd(this, _fullTypes);
          __privateAdd(this, _encoderCache);
          __privateSet(this, _fullTypes, /* @__PURE__ */ new Map());
          __privateSet(this, _encoderCache, /* @__PURE__ */ new Map());
          const links = /* @__PURE__ */ new Map();
          const parents = /* @__PURE__ */ new Map();
          const subtypes = /* @__PURE__ */ new Map();
          const types = {};
          Object.keys(_types2).forEach((type) => {
            types[type] = _types2[type].map(({ name, type: type2 }) => {
              let { base, index: index2 } = splitArray(type2);
              if (base === "int" && !_types2["int"]) {
                base = "int256";
              }
              if (base === "uint" && !_types2["uint"]) {
                base = "uint256";
              }
              return { name, type: base + (index2 || "") };
            });
            links.set(type, /* @__PURE__ */ new Set());
            parents.set(type, []);
            subtypes.set(type, /* @__PURE__ */ new Set());
          });
          __privateSet(this, _types, JSON.stringify(types));
          for (const name in types) {
            const uniqueNames = /* @__PURE__ */ new Set();
            for (const field of types[name]) {
              assertArgument(!uniqueNames.has(field.name), `duplicate variable name ${JSON.stringify(field.name)} in ${JSON.stringify(name)}`, "types", _types2);
              uniqueNames.add(field.name);
              const baseType = splitArray(field.type).base;
              assertArgument(baseType !== name, `circular type reference to ${JSON.stringify(baseType)}`, "types", _types2);
              const encoder5 = getBaseEncoder(baseType);
              if (encoder5) {
                continue;
              }
              assertArgument(parents.has(baseType), `unknown type ${JSON.stringify(baseType)}`, "types", _types2);
              parents.get(baseType).push(name);
              links.get(name).add(baseType);
            }
          }
          const primaryTypes = Array.from(parents.keys()).filter((n2) => parents.get(n2).length === 0);
          assertArgument(primaryTypes.length !== 0, "missing primary type", "types", _types2);
          assertArgument(primaryTypes.length === 1, `ambiguous primary types or unused types: ${primaryTypes.map((t) => JSON.stringify(t)).join(", ")}`, "types", _types2);
          defineProperties(this, { primaryType: primaryTypes[0] });
          function checkCircular(type, found) {
            assertArgument(!found.has(type), `circular type reference to ${JSON.stringify(type)}`, "types", _types2);
            found.add(type);
            for (const child of links.get(type)) {
              if (!parents.has(child)) {
                continue;
              }
              checkCircular(child, found);
              for (const subtype of found) {
                subtypes.get(subtype).add(child);
              }
            }
            found.delete(type);
          }
          checkCircular(this.primaryType, /* @__PURE__ */ new Set());
          for (const [name, set] of subtypes) {
            const st = Array.from(set);
            st.sort();
            __privateGet(this, _fullTypes).set(name, encodeType(name, types[name]) + st.map((t) => encodeType(t, types[t])).join(""));
          }
        }
        /**
         *  The types.
         */
        get types() {
          return JSON.parse(__privateGet(this, _types));
        }
        /**
         *  Returnthe encoder for the specific %%type%%.
         */
        getEncoder(type) {
          let encoder5 = __privateGet(this, _encoderCache).get(type);
          if (!encoder5) {
            encoder5 = __privateMethod(this, _TypedDataEncoder_instances, getEncoder_fn).call(this, type);
            __privateGet(this, _encoderCache).set(type, encoder5);
          }
          return encoder5;
        }
        /**
         *  Return the full type for %%name%%.
         */
        encodeType(name) {
          const result = __privateGet(this, _fullTypes).get(name);
          assertArgument(result, `unknown type: ${JSON.stringify(name)}`, "name", name);
          return result;
        }
        /**
         *  Return the encoded %%value%% for the %%type%%.
         */
        encodeData(type, value) {
          return this.getEncoder(type)(value);
        }
        /**
         *  Returns the hash of %%value%% for the type of %%name%%.
         */
        hashStruct(name, value) {
          return keccak256(this.encodeData(name, value));
        }
        /**
         *  Return the fulled encoded %%value%% for the [[types]].
         */
        encode(value) {
          return this.encodeData(this.primaryType, value);
        }
        /**
         *  Return the hash of the fully encoded %%value%% for the [[types]].
         */
        hash(value) {
          return this.hashStruct(this.primaryType, value);
        }
        /**
         *  @_ignore:
         */
        _visit(type, value, callback) {
          {
            const encoder5 = getBaseEncoder(type);
            if (encoder5) {
              return callback(type, value);
            }
          }
          const array = splitArray(type).array;
          if (array) {
            assertArgument(array.count === -1 || array.count === value.length, `array length mismatch; expected length ${array.count}`, "value", value);
            return value.map((v) => this._visit(array.prefix, v, callback));
          }
          const fields = this.types[type];
          if (fields) {
            return fields.reduce((accum, { name, type: type2 }) => {
              accum[name] = this._visit(type2, value[name], callback);
              return accum;
            }, {});
          }
          assertArgument(false, `unknown type: ${type}`, "type", type);
        }
        /**
         *  Call %%calback%% for each value in %%value%%, passing the type and
         *  component within %%value%%.
         *
         *  This is useful for replacing addresses or other transformation that
         *  may be desired on each component, based on its type.
         */
        visit(value, callback) {
          return this._visit(this.primaryType, value, callback);
        }
        /**
         *  Create a new **TypedDataEncoder** for %%types%%.
         */
        static from(types) {
          return new _TypedDataEncoder(types);
        }
        /**
         *  Return the primary type for %%types%%.
         */
        static getPrimaryType(types) {
          return _TypedDataEncoder.from(types).primaryType;
        }
        /**
         *  Return the hashed struct for %%value%% using %%types%% and %%name%%.
         */
        static hashStruct(name, types, value) {
          return _TypedDataEncoder.from(types).hashStruct(name, value);
        }
        /**
         *  Return the domain hash for %%domain%%.
         */
        static hashDomain(domain) {
          const domainFields = [];
          for (const name in domain) {
            if (domain[name] == null) {
              continue;
            }
            const type = domainFieldTypes[name];
            assertArgument(type, `invalid typed-data domain key: ${JSON.stringify(name)}`, "domain", domain);
            domainFields.push({ name, type });
          }
          domainFields.sort((a, b2) => {
            return domainFieldNames.indexOf(a.name) - domainFieldNames.indexOf(b2.name);
          });
          return _TypedDataEncoder.hashStruct("EIP712Domain", { EIP712Domain: domainFields }, domain);
        }
        /**
         *  Return the fully encoded [[link-eip-712]] %%value%% for %%types%% with %%domain%%.
         */
        static encode(domain, types, value) {
          return concat([
            "0x1901",
            _TypedDataEncoder.hashDomain(domain),
            _TypedDataEncoder.from(types).hash(value)
          ]);
        }
        /**
         *  Return the hash of the fully encoded [[link-eip-712]] %%value%% for %%types%% with %%domain%%.
         */
        static hash(domain, types, value) {
          return keccak256(_TypedDataEncoder.encode(domain, types, value));
        }
        // Replaces all address types with ENS names with their looked up address
        /**
         * Resolves to the value from resolving all addresses in %%value%% for
         * %%types%% and the %%domain%%.
         */
        static async resolveNames(domain, types, value, resolveName) {
          domain = Object.assign({}, domain);
          for (const key in domain) {
            if (domain[key] == null) {
              delete domain[key];
            }
          }
          const ensCache = {};
          if (domain.verifyingContract && !isHexString(domain.verifyingContract, 20)) {
            ensCache[domain.verifyingContract] = "0x";
          }
          const encoder5 = _TypedDataEncoder.from(types);
          encoder5.visit(value, (type, value2) => {
            if (type === "address" && !isHexString(value2, 20)) {
              ensCache[value2] = "0x";
            }
            return value2;
          });
          for (const name in ensCache) {
            ensCache[name] = await resolveName(name);
          }
          if (domain.verifyingContract && ensCache[domain.verifyingContract]) {
            domain.verifyingContract = ensCache[domain.verifyingContract];
          }
          value = encoder5.visit(value, (type, value2) => {
            if (type === "address" && ensCache[value2]) {
              return ensCache[value2];
            }
            return value2;
          });
          return { domain, value };
        }
        /**
         *  Returns the JSON-encoded payload expected by nodes which implement
         *  the JSON-RPC [[link-eip-712]] method.
         */
        static getPayload(domain, types, value) {
          _TypedDataEncoder.hashDomain(domain);
          const domainValues = {};
          const domainTypes = [];
          domainFieldNames.forEach((name) => {
            const value2 = domain[name];
            if (value2 == null) {
              return;
            }
            domainValues[name] = domainChecks[name](value2);
            domainTypes.push({ name, type: domainFieldTypes[name] });
          });
          const encoder5 = _TypedDataEncoder.from(types);
          types = encoder5.types;
          const typesWithDomain = Object.assign({}, types);
          assertArgument(typesWithDomain.EIP712Domain == null, "types must not contain EIP712Domain type", "types.EIP712Domain", types);
          typesWithDomain.EIP712Domain = domainTypes;
          encoder5.encode(value);
          return {
            types: typesWithDomain,
            domain: domainValues,
            primaryType: encoder5.primaryType,
            message: encoder5.visit(value, (type, value2) => {
              if (type.match(/^bytes(\d*)/)) {
                return hexlify(getBytes(value2));
              }
              if (type.match(/^u?int/)) {
                return getBigInt(value2).toString();
              }
              switch (type) {
                case "address":
                  return value2.toLowerCase();
                case "bool":
                  return !!value2;
                case "string":
                  assertArgument(typeof value2 === "string", "invalid string", "value", value2);
                  return value2;
              }
              assertArgument(false, "unsupported type", "type", type);
            })
          };
        }
      };
      _types = new WeakMap();
      _fullTypes = new WeakMap();
      _encoderCache = new WeakMap();
      _TypedDataEncoder_instances = new WeakSet();
      getEncoder_fn = function(type) {
        {
          const encoder5 = getBaseEncoder(type);
          if (encoder5) {
            return encoder5;
          }
        }
        const array = splitArray(type).array;
        if (array) {
          const subtype = array.prefix;
          const subEncoder = this.getEncoder(subtype);
          return (value) => {
            assertArgument(array.count === -1 || array.count === value.length, `array length mismatch; expected length ${array.count}`, "value", value);
            let result = value.map(subEncoder);
            if (__privateGet(this, _fullTypes).has(subtype)) {
              result = result.map(keccak256);
            }
            return keccak256(concat(result));
          };
        }
        const fields = this.types[type];
        if (fields) {
          const encodedType = id(__privateGet(this, _fullTypes).get(type));
          return (value) => {
            const values = fields.map(({ name, type: type2 }) => {
              const result = this.getEncoder(type2)(value[name]);
              if (__privateGet(this, _fullTypes).has(type2)) {
                return keccak256(result);
              }
              return result;
            });
            values.unshift(encodedType);
            return concat(values);
          };
        }
        assertArgument(false, `unknown type: ${type}`, "type", type);
      };
      TypedDataEncoder = _TypedDataEncoder;
    }
  });

  // node_modules/ethers/lib.esm/hash/index.js
  var init_hash = __esm({
    "node_modules/ethers/lib.esm/hash/index.js"() {
      init_authorization2();
      init_id();
      init_namehash();
      init_message();
      init_solidity();
      init_typed_data();
    }
  });

  // node_modules/ethers/lib.esm/abi/fragments.js
  function setify(items) {
    const result = /* @__PURE__ */ new Set();
    items.forEach((k) => result.add(k));
    return Object.freeze(result);
  }
  function lex(text) {
    const tokens = [];
    const throwError2 = (message) => {
      const token = offset < text.length ? JSON.stringify(text[offset]) : "$EOI";
      throw new Error(`invalid token ${token} at ${offset}: ${message}`);
    };
    let brackets = [];
    let commas = [];
    let offset = 0;
    while (offset < text.length) {
      let cur = text.substring(offset);
      let match = cur.match(regexWhitespacePrefix);
      if (match) {
        offset += match[1].length;
        cur = text.substring(offset);
      }
      const token = { depth: brackets.length, linkBack: -1, linkNext: -1, match: -1, type: "", text: "", offset, value: -1 };
      tokens.push(token);
      let type = SimpleTokens[cur[0]] || "";
      if (type) {
        token.type = type;
        token.text = cur[0];
        offset++;
        if (type === "OPEN_PAREN") {
          brackets.push(tokens.length - 1);
          commas.push(tokens.length - 1);
        } else if (type == "CLOSE_PAREN") {
          if (brackets.length === 0) {
            throwError2("no matching open bracket");
          }
          token.match = brackets.pop();
          tokens[token.match].match = tokens.length - 1;
          token.depth--;
          token.linkBack = commas.pop();
          tokens[token.linkBack].linkNext = tokens.length - 1;
        } else if (type === "COMMA") {
          token.linkBack = commas.pop();
          tokens[token.linkBack].linkNext = tokens.length - 1;
          commas.push(tokens.length - 1);
        } else if (type === "OPEN_BRACKET") {
          token.type = "BRACKET";
        } else if (type === "CLOSE_BRACKET") {
          let suffix = tokens.pop().text;
          if (tokens.length > 0 && tokens[tokens.length - 1].type === "NUMBER") {
            const value = tokens.pop().text;
            suffix = value + suffix;
            tokens[tokens.length - 1].value = getNumber(value);
          }
          if (tokens.length === 0 || tokens[tokens.length - 1].type !== "BRACKET") {
            throw new Error("missing opening bracket");
          }
          tokens[tokens.length - 1].text += suffix;
        }
        continue;
      }
      match = cur.match(regexIdPrefix);
      if (match) {
        token.text = match[1];
        offset += token.text.length;
        if (Keywords.has(token.text)) {
          token.type = "KEYWORD";
          continue;
        }
        if (token.text.match(regexType)) {
          token.type = "TYPE";
          continue;
        }
        token.type = "ID";
        continue;
      }
      match = cur.match(regexNumberPrefix);
      if (match) {
        token.text = match[1];
        token.type = "NUMBER";
        offset += token.text.length;
        continue;
      }
      throw new Error(`unexpected token ${JSON.stringify(cur[0])} at position ${offset}`);
    }
    return new TokenString(tokens.map((t) => Object.freeze(t)));
  }
  function allowSingle(set, allowed) {
    let included = [];
    for (const key in allowed.keys()) {
      if (set.has(key)) {
        included.push(key);
      }
    }
    if (included.length > 1) {
      throw new Error(`conflicting types: ${included.join(", ")}`);
    }
  }
  function consumeName(type, tokens) {
    if (tokens.peekKeyword(KwTypes)) {
      const keyword = tokens.pop().text;
      if (keyword !== type) {
        throw new Error(`expected ${type}, got ${keyword}`);
      }
    }
    return tokens.popType("ID");
  }
  function consumeKeywords(tokens, allowed) {
    const keywords = /* @__PURE__ */ new Set();
    while (true) {
      const keyword = tokens.peekType("KEYWORD");
      if (keyword == null || allowed && !allowed.has(keyword)) {
        break;
      }
      tokens.pop();
      if (keywords.has(keyword)) {
        throw new Error(`duplicate keywords: ${JSON.stringify(keyword)}`);
      }
      keywords.add(keyword);
    }
    return Object.freeze(keywords);
  }
  function consumeMutability(tokens) {
    let modifiers = consumeKeywords(tokens, KwVisib);
    allowSingle(modifiers, setify("constant payable nonpayable".split(" ")));
    allowSingle(modifiers, setify("pure view payable nonpayable".split(" ")));
    if (modifiers.has("view")) {
      return "view";
    }
    if (modifiers.has("pure")) {
      return "pure";
    }
    if (modifiers.has("payable")) {
      return "payable";
    }
    if (modifiers.has("nonpayable")) {
      return "nonpayable";
    }
    if (modifiers.has("constant")) {
      return "view";
    }
    return "nonpayable";
  }
  function consumeParams(tokens, allowIndexed) {
    return tokens.popParams().map((t) => ParamType.from(t, allowIndexed));
  }
  function consumeGas(tokens) {
    if (tokens.peekType("AT")) {
      tokens.pop();
      if (tokens.peekType("NUMBER")) {
        return getBigInt(tokens.pop().text);
      }
      throw new Error("invalid gas");
    }
    return null;
  }
  function consumeEoi(tokens) {
    if (tokens.length) {
      throw new Error(`unexpected tokens at offset ${tokens.offset}: ${tokens.toString()}`);
    }
  }
  function verifyBasicType(type) {
    const match = type.match(regexType);
    assertArgument(match, "invalid type", "type", type);
    if (type === "uint") {
      return "uint256";
    }
    if (type === "int") {
      return "int256";
    }
    if (match[2]) {
      const length = parseInt(match[2]);
      assertArgument(length !== 0 && length <= 32, "invalid bytes length", "type", type);
    } else if (match[3]) {
      const size5 = parseInt(match[3]);
      assertArgument(size5 !== 0 && size5 <= 256 && size5 % 8 === 0, "invalid numeric width", "type", type);
    }
    return type;
  }
  function joinParams(format, params) {
    return "(" + params.map((p) => p.format(format)).join(format === "full" ? ", " : ",") + ")";
  }
  var _kwVisibDeploy, KwVisibDeploy, _kwVisib, KwVisib, _kwTypes, KwTypes, _kwModifiers, KwModifiers, _kwOther, _keywords, Keywords, SimpleTokens, regexWhitespacePrefix, regexNumberPrefix, regexIdPrefix, regexId, regexType, _offset2, _tokens, _TokenString_instances, subTokenString_fn, _TokenString, TokenString, regexArrayType, _guard4, internal, ParamTypeInternal, ErrorFragmentInternal, EventFragmentInternal, ConstructorFragmentInternal, FallbackFragmentInternal, FunctionFragmentInternal, StructFragmentInternal, _ParamType_instances, walkAsync_fn, _ParamType, ParamType, Fragment, NamedFragment, ErrorFragment, EventFragment, ConstructorFragment, FallbackFragment, FunctionFragment, StructFragment;
  var init_fragments = __esm({
    "node_modules/ethers/lib.esm/abi/fragments.js"() {
      init_utils();
      init_hash();
      _kwVisibDeploy = "external public payable override";
      KwVisibDeploy = setify(_kwVisibDeploy.split(" "));
      _kwVisib = "constant external internal payable private public pure view override";
      KwVisib = setify(_kwVisib.split(" "));
      _kwTypes = "constructor error event fallback function receive struct";
      KwTypes = setify(_kwTypes.split(" "));
      _kwModifiers = "calldata memory storage payable indexed";
      KwModifiers = setify(_kwModifiers.split(" "));
      _kwOther = "tuple returns";
      _keywords = [_kwTypes, _kwModifiers, _kwOther, _kwVisib].join(" ");
      Keywords = setify(_keywords.split(" "));
      SimpleTokens = {
        "(": "OPEN_PAREN",
        ")": "CLOSE_PAREN",
        "[": "OPEN_BRACKET",
        "]": "CLOSE_BRACKET",
        ",": "COMMA",
        "@": "AT"
      };
      regexWhitespacePrefix = new RegExp("^(\\s*)");
      regexNumberPrefix = new RegExp("^([0-9]+)");
      regexIdPrefix = new RegExp("^([a-zA-Z$_][a-zA-Z0-9$_]*)");
      regexId = new RegExp("^([a-zA-Z$_][a-zA-Z0-9$_]*)$");
      regexType = new RegExp("^(address|bool|bytes([0-9]*)|string|u?int([0-9]*))$");
      _TokenString = class _TokenString {
        constructor(tokens) {
          __privateAdd(this, _TokenString_instances);
          __privateAdd(this, _offset2);
          __privateAdd(this, _tokens);
          __privateSet(this, _offset2, 0);
          __privateSet(this, _tokens, tokens.slice());
        }
        get offset() {
          return __privateGet(this, _offset2);
        }
        get length() {
          return __privateGet(this, _tokens).length - __privateGet(this, _offset2);
        }
        clone() {
          return new _TokenString(__privateGet(this, _tokens));
        }
        reset() {
          __privateSet(this, _offset2, 0);
        }
        // Pops and returns the value of the next token, if it is a keyword in allowed; throws if out of tokens
        popKeyword(allowed) {
          const top = this.peek();
          if (top.type !== "KEYWORD" || !allowed.has(top.text)) {
            throw new Error(`expected keyword ${top.text}`);
          }
          return this.pop().text;
        }
        // Pops and returns the value of the next token if it is `type`; throws if out of tokens
        popType(type) {
          if (this.peek().type !== type) {
            const top = this.peek();
            throw new Error(`expected ${type}; got ${top.type} ${JSON.stringify(top.text)}`);
          }
          return this.pop().text;
        }
        // Pops and returns a "(" TOKENS ")"
        popParen() {
          const top = this.peek();
          if (top.type !== "OPEN_PAREN") {
            throw new Error("bad start");
          }
          const result = __privateMethod(this, _TokenString_instances, subTokenString_fn).call(this, __privateGet(this, _offset2) + 1, top.match + 1);
          __privateSet(this, _offset2, top.match + 1);
          return result;
        }
        // Pops and returns the items within "(" ITEM1 "," ITEM2 "," ... ")"
        popParams() {
          const top = this.peek();
          if (top.type !== "OPEN_PAREN") {
            throw new Error("bad start");
          }
          const result = [];
          while (__privateGet(this, _offset2) < top.match - 1) {
            const link = this.peek().linkNext;
            result.push(__privateMethod(this, _TokenString_instances, subTokenString_fn).call(this, __privateGet(this, _offset2) + 1, link));
            __privateSet(this, _offset2, link);
          }
          __privateSet(this, _offset2, top.match + 1);
          return result;
        }
        // Returns the top Token, throwing if out of tokens
        peek() {
          if (__privateGet(this, _offset2) >= __privateGet(this, _tokens).length) {
            throw new Error("out-of-bounds");
          }
          return __privateGet(this, _tokens)[__privateGet(this, _offset2)];
        }
        // Returns the next value, if it is a keyword in `allowed`
        peekKeyword(allowed) {
          const top = this.peekType("KEYWORD");
          return top != null && allowed.has(top) ? top : null;
        }
        // Returns the value of the next token if it is `type`
        peekType(type) {
          if (this.length === 0) {
            return null;
          }
          const top = this.peek();
          return top.type === type ? top.text : null;
        }
        // Returns the next token; throws if out of tokens
        pop() {
          const result = this.peek();
          __privateWrapper(this, _offset2)._++;
          return result;
        }
        toString() {
          const tokens = [];
          for (let i = __privateGet(this, _offset2); i < __privateGet(this, _tokens).length; i++) {
            const token = __privateGet(this, _tokens)[i];
            tokens.push(`${token.type}:${token.text}`);
          }
          return `<TokenString ${tokens.join(" ")}>`;
        }
      };
      _offset2 = new WeakMap();
      _tokens = new WeakMap();
      _TokenString_instances = new WeakSet();
      subTokenString_fn = function(from5 = 0, to = 0) {
        return new _TokenString(__privateGet(this, _tokens).slice(from5, to).map((t) => {
          return Object.freeze(Object.assign({}, t, {
            match: t.match - from5,
            linkBack: t.linkBack - from5,
            linkNext: t.linkNext - from5
          }));
        }));
      };
      TokenString = _TokenString;
      regexArrayType = new RegExp(/^(.*)\[([0-9]*)\]$/);
      _guard4 = {};
      internal = Symbol.for("_ethers_internal");
      ParamTypeInternal = "_ParamTypeInternal";
      ErrorFragmentInternal = "_ErrorInternal";
      EventFragmentInternal = "_EventInternal";
      ConstructorFragmentInternal = "_ConstructorInternal";
      FallbackFragmentInternal = "_FallbackInternal";
      FunctionFragmentInternal = "_FunctionInternal";
      StructFragmentInternal = "_StructInternal";
      _ParamType = class _ParamType {
        /**
         *  @private
         */
        constructor(guard, name, type, baseType, indexed, components, arrayLength, arrayChildren) {
          __privateAdd(this, _ParamType_instances);
          /**
           *  The local name of the parameter (or ``""`` if unbound)
           */
          __publicField(this, "name");
          /**
           *  The fully qualified type (e.g. ``"address"``, ``"tuple(address)"``,
           *  ``"uint256[3][]"``)
           */
          __publicField(this, "type");
          /**
           *  The base type (e.g. ``"address"``, ``"tuple"``, ``"array"``)
           */
          __publicField(this, "baseType");
          /**
           *  True if the parameters is indexed.
           *
           *  For non-indexable types this is ``null``.
           */
          __publicField(this, "indexed");
          /**
           *  The components for the tuple.
           *
           *  For non-tuple types this is ``null``.
           */
          __publicField(this, "components");
          /**
           *  The array length, or ``-1`` for dynamic-lengthed arrays.
           *
           *  For non-array types this is ``null``.
           */
          __publicField(this, "arrayLength");
          /**
           *  The type of each child in the array.
           *
           *  For non-array types this is ``null``.
           */
          __publicField(this, "arrayChildren");
          assertPrivate(guard, _guard4, "ParamType");
          Object.defineProperty(this, internal, { value: ParamTypeInternal });
          if (components) {
            components = Object.freeze(components.slice());
          }
          if (baseType === "array") {
            if (arrayLength == null || arrayChildren == null) {
              throw new Error("");
            }
          } else if (arrayLength != null || arrayChildren != null) {
            throw new Error("");
          }
          if (baseType === "tuple") {
            if (components == null) {
              throw new Error("");
            }
          } else if (components != null) {
            throw new Error("");
          }
          defineProperties(this, {
            name,
            type,
            baseType,
            indexed,
            components,
            arrayLength,
            arrayChildren
          });
        }
        /**
         *  Return a string representation of this type.
         *
         *  For example,
         *
         *  ``sighash" => "(uint256,address)"``
         *
         *  ``"minimal" => "tuple(uint256,address) indexed"``
         *
         *  ``"full" => "tuple(uint256 foo, address bar) indexed baz"``
         */
        format(format) {
          if (format == null) {
            format = "sighash";
          }
          if (format === "json") {
            const name = this.name || "";
            if (this.isArray()) {
              const result3 = JSON.parse(this.arrayChildren.format("json"));
              result3.name = name;
              result3.type += `[${this.arrayLength < 0 ? "" : String(this.arrayLength)}]`;
              return JSON.stringify(result3);
            }
            const result2 = {
              type: this.baseType === "tuple" ? "tuple" : this.type,
              name
            };
            if (typeof this.indexed === "boolean") {
              result2.indexed = this.indexed;
            }
            if (this.isTuple()) {
              result2.components = this.components.map((c) => JSON.parse(c.format(format)));
            }
            return JSON.stringify(result2);
          }
          let result = "";
          if (this.isArray()) {
            result += this.arrayChildren.format(format);
            result += `[${this.arrayLength < 0 ? "" : String(this.arrayLength)}]`;
          } else {
            if (this.isTuple()) {
              result += "(" + this.components.map((comp) => comp.format(format)).join(format === "full" ? ", " : ",") + ")";
            } else {
              result += this.type;
            }
          }
          if (format !== "sighash") {
            if (this.indexed === true) {
              result += " indexed";
            }
            if (format === "full" && this.name) {
              result += " " + this.name;
            }
          }
          return result;
        }
        /**
         *  Returns true if %%this%% is an Array type.
         *
         *  This provides a type gaurd ensuring that [[arrayChildren]]
         *  and [[arrayLength]] are non-null.
         */
        isArray() {
          return this.baseType === "array";
        }
        /**
         *  Returns true if %%this%% is a Tuple type.
         *
         *  This provides a type gaurd ensuring that [[components]]
         *  is non-null.
         */
        isTuple() {
          return this.baseType === "tuple";
        }
        /**
         *  Returns true if %%this%% is an Indexable type.
         *
         *  This provides a type gaurd ensuring that [[indexed]]
         *  is non-null.
         */
        isIndexable() {
          return this.indexed != null;
        }
        /**
         *  Walks the **ParamType** with %%value%%, calling %%process%%
         *  on each type, destructing the %%value%% recursively.
         */
        walk(value, process2) {
          if (this.isArray()) {
            if (!Array.isArray(value)) {
              throw new Error("invalid array value");
            }
            if (this.arrayLength !== -1 && value.length !== this.arrayLength) {
              throw new Error("array is wrong length");
            }
            const _this = this;
            return value.map((v) => _this.arrayChildren.walk(v, process2));
          }
          if (this.isTuple()) {
            if (!Array.isArray(value)) {
              throw new Error("invalid tuple value");
            }
            if (value.length !== this.components.length) {
              throw new Error("array is wrong length");
            }
            const _this = this;
            return value.map((v, i) => _this.components[i].walk(v, process2));
          }
          return process2(this.type, value);
        }
        /**
         *  Walks the **ParamType** with %%value%%, asynchronously calling
         *  %%process%% on each type, destructing the %%value%% recursively.
         *
         *  This can be used to resolve ENS names by walking and resolving each
         *  ``"address"`` type.
         */
        async walkAsync(value, process2) {
          const promises = [];
          const result = [value];
          __privateMethod(this, _ParamType_instances, walkAsync_fn).call(this, promises, value, process2, (value2) => {
            result[0] = value2;
          });
          if (promises.length) {
            await Promise.all(promises);
          }
          return result[0];
        }
        /**
         *  Creates a new **ParamType** for %%obj%%.
         *
         *  If %%allowIndexed%% then the ``indexed`` keyword is permitted,
         *  otherwise the ``indexed`` keyword will throw an error.
         */
        static from(obj, allowIndexed) {
          if (_ParamType.isParamType(obj)) {
            return obj;
          }
          if (typeof obj === "string") {
            try {
              return _ParamType.from(lex(obj), allowIndexed);
            } catch (error) {
              assertArgument(false, "invalid param type", "obj", obj);
            }
          } else if (obj instanceof TokenString) {
            let type2 = "", baseType = "";
            let comps = null;
            if (consumeKeywords(obj, setify(["tuple"])).has("tuple") || obj.peekType("OPEN_PAREN")) {
              baseType = "tuple";
              comps = obj.popParams().map((t) => _ParamType.from(t));
              type2 = `tuple(${comps.map((c) => c.format()).join(",")})`;
            } else {
              type2 = verifyBasicType(obj.popType("TYPE"));
              baseType = type2;
            }
            let arrayChildren = null;
            let arrayLength = null;
            while (obj.length && obj.peekType("BRACKET")) {
              const bracket = obj.pop();
              arrayChildren = new _ParamType(_guard4, "", type2, baseType, null, comps, arrayLength, arrayChildren);
              arrayLength = bracket.value;
              type2 += bracket.text;
              baseType = "array";
              comps = null;
            }
            let indexed2 = null;
            const keywords = consumeKeywords(obj, KwModifiers);
            if (keywords.has("indexed")) {
              if (!allowIndexed) {
                throw new Error("");
              }
              indexed2 = true;
            }
            const name2 = obj.peekType("ID") ? obj.pop().text : "";
            if (obj.length) {
              throw new Error("leftover tokens");
            }
            return new _ParamType(_guard4, name2, type2, baseType, indexed2, comps, arrayLength, arrayChildren);
          }
          const name = obj.name;
          assertArgument(!name || typeof name === "string" && name.match(regexId), "invalid name", "obj.name", name);
          let indexed = obj.indexed;
          if (indexed != null) {
            assertArgument(allowIndexed, "parameter cannot be indexed", "obj.indexed", obj.indexed);
            indexed = !!indexed;
          }
          let type = obj.type;
          let arrayMatch = type.match(regexArrayType);
          if (arrayMatch) {
            const arrayLength = parseInt(arrayMatch[2] || "-1");
            const arrayChildren = _ParamType.from({
              type: arrayMatch[1],
              components: obj.components
            });
            return new _ParamType(_guard4, name || "", type, "array", indexed, null, arrayLength, arrayChildren);
          }
          if (type === "tuple" || type.startsWith(
            "tuple("
            /* fix: ) */
          ) || type.startsWith(
            "("
            /* fix: ) */
          )) {
            const comps = obj.components != null ? obj.components.map((c) => _ParamType.from(c)) : null;
            const tuple = new _ParamType(_guard4, name || "", type, "tuple", indexed, comps, null, null);
            return tuple;
          }
          type = verifyBasicType(obj.type);
          return new _ParamType(_guard4, name || "", type, type, indexed, null, null, null);
        }
        /**
         *  Returns true if %%value%% is a **ParamType**.
         */
        static isParamType(value) {
          return value && value[internal] === ParamTypeInternal;
        }
      };
      _ParamType_instances = new WeakSet();
      walkAsync_fn = function(promises, value, process2, setValue) {
        if (this.isArray()) {
          if (!Array.isArray(value)) {
            throw new Error("invalid array value");
          }
          if (this.arrayLength !== -1 && value.length !== this.arrayLength) {
            throw new Error("array is wrong length");
          }
          const childType = this.arrayChildren;
          const result2 = value.slice();
          result2.forEach((value2, index2) => {
            var _a2;
            __privateMethod(_a2 = childType, _ParamType_instances, walkAsync_fn).call(_a2, promises, value2, process2, (value3) => {
              result2[index2] = value3;
            });
          });
          setValue(result2);
          return;
        }
        if (this.isTuple()) {
          const components = this.components;
          let result2;
          if (Array.isArray(value)) {
            result2 = value.slice();
          } else {
            if (value == null || typeof value !== "object") {
              throw new Error("invalid tuple value");
            }
            result2 = components.map((param) => {
              if (!param.name) {
                throw new Error("cannot use object value with unnamed components");
              }
              if (!(param.name in value)) {
                throw new Error(`missing value for component ${param.name}`);
              }
              return value[param.name];
            });
          }
          if (result2.length !== this.components.length) {
            throw new Error("array is wrong length");
          }
          result2.forEach((value2, index2) => {
            var _a2;
            __privateMethod(_a2 = components[index2], _ParamType_instances, walkAsync_fn).call(_a2, promises, value2, process2, (value3) => {
              result2[index2] = value3;
            });
          });
          setValue(result2);
          return;
        }
        const result = process2(this.type, value);
        if (result.then) {
          promises.push(async function() {
            setValue(await result);
          }());
        } else {
          setValue(result);
        }
      };
      ParamType = _ParamType;
      Fragment = class _Fragment {
        /**
         *  @private
         */
        constructor(guard, type, inputs) {
          /**
           *  The type of the fragment.
           */
          __publicField(this, "type");
          /**
           *  The inputs for the fragment.
           */
          __publicField(this, "inputs");
          assertPrivate(guard, _guard4, "Fragment");
          inputs = Object.freeze(inputs.slice());
          defineProperties(this, { type, inputs });
        }
        /**
         *  Creates a new **Fragment** for %%obj%%, wich can be any supported
         *  ABI frgament type.
         */
        static from(obj) {
          if (typeof obj === "string") {
            try {
              _Fragment.from(JSON.parse(obj));
            } catch (e) {
            }
            return _Fragment.from(lex(obj));
          }
          if (obj instanceof TokenString) {
            const type = obj.peekKeyword(KwTypes);
            switch (type) {
              case "constructor":
                return ConstructorFragment.from(obj);
              case "error":
                return ErrorFragment.from(obj);
              case "event":
                return EventFragment.from(obj);
              case "fallback":
              case "receive":
                return FallbackFragment.from(obj);
              case "function":
                return FunctionFragment.from(obj);
              case "struct":
                return StructFragment.from(obj);
            }
          } else if (typeof obj === "object") {
            switch (obj.type) {
              case "constructor":
                return ConstructorFragment.from(obj);
              case "error":
                return ErrorFragment.from(obj);
              case "event":
                return EventFragment.from(obj);
              case "fallback":
              case "receive":
                return FallbackFragment.from(obj);
              case "function":
                return FunctionFragment.from(obj);
              case "struct":
                return StructFragment.from(obj);
            }
            assert(false, `unsupported type: ${obj.type}`, "UNSUPPORTED_OPERATION", {
              operation: "Fragment.from"
            });
          }
          assertArgument(false, "unsupported frgament object", "obj", obj);
        }
        /**
         *  Returns true if %%value%% is a [[ConstructorFragment]].
         */
        static isConstructor(value) {
          return ConstructorFragment.isFragment(value);
        }
        /**
         *  Returns true if %%value%% is an [[ErrorFragment]].
         */
        static isError(value) {
          return ErrorFragment.isFragment(value);
        }
        /**
         *  Returns true if %%value%% is an [[EventFragment]].
         */
        static isEvent(value) {
          return EventFragment.isFragment(value);
        }
        /**
         *  Returns true if %%value%% is a [[FunctionFragment]].
         */
        static isFunction(value) {
          return FunctionFragment.isFragment(value);
        }
        /**
         *  Returns true if %%value%% is a [[StructFragment]].
         */
        static isStruct(value) {
          return StructFragment.isFragment(value);
        }
      };
      NamedFragment = class extends Fragment {
        /**
         *  @private
         */
        constructor(guard, type, name, inputs) {
          super(guard, type, inputs);
          /**
           *  The name of the fragment.
           */
          __publicField(this, "name");
          assertArgument(typeof name === "string" && name.match(regexId), "invalid identifier", "name", name);
          inputs = Object.freeze(inputs.slice());
          defineProperties(this, { name });
        }
      };
      ErrorFragment = class _ErrorFragment extends NamedFragment {
        /**
         *  @private
         */
        constructor(guard, name, inputs) {
          super(guard, "error", name, inputs);
          Object.defineProperty(this, internal, { value: ErrorFragmentInternal });
        }
        /**
         *  The Custom Error selector.
         */
        get selector() {
          return id(this.format("sighash")).substring(0, 10);
        }
        /**
         *  Returns a string representation of this fragment as %%format%%.
         */
        format(format) {
          if (format == null) {
            format = "sighash";
          }
          if (format === "json") {
            return JSON.stringify({
              type: "error",
              name: this.name,
              inputs: this.inputs.map((input) => JSON.parse(input.format(format)))
            });
          }
          const result = [];
          if (format !== "sighash") {
            result.push("error");
          }
          result.push(this.name + joinParams(format, this.inputs));
          return result.join(" ");
        }
        /**
         *  Returns a new **ErrorFragment** for %%obj%%.
         */
        static from(obj) {
          if (_ErrorFragment.isFragment(obj)) {
            return obj;
          }
          if (typeof obj === "string") {
            return _ErrorFragment.from(lex(obj));
          } else if (obj instanceof TokenString) {
            const name = consumeName("error", obj);
            const inputs = consumeParams(obj);
            consumeEoi(obj);
            return new _ErrorFragment(_guard4, name, inputs);
          }
          return new _ErrorFragment(_guard4, obj.name, obj.inputs ? obj.inputs.map(ParamType.from) : []);
        }
        /**
         *  Returns ``true`` and provides a type guard if %%value%% is an
         *  **ErrorFragment**.
         */
        static isFragment(value) {
          return value && value[internal] === ErrorFragmentInternal;
        }
      };
      EventFragment = class _EventFragment extends NamedFragment {
        /**
         *  @private
         */
        constructor(guard, name, inputs, anonymous) {
          super(guard, "event", name, inputs);
          /**
           *  Whether this event is anonymous.
           */
          __publicField(this, "anonymous");
          Object.defineProperty(this, internal, { value: EventFragmentInternal });
          defineProperties(this, { anonymous });
        }
        /**
         *  The Event topic hash.
         */
        get topicHash() {
          return id(this.format("sighash"));
        }
        /**
         *  Returns a string representation of this event as %%format%%.
         */
        format(format) {
          if (format == null) {
            format = "sighash";
          }
          if (format === "json") {
            return JSON.stringify({
              type: "event",
              anonymous: this.anonymous,
              name: this.name,
              inputs: this.inputs.map((i) => JSON.parse(i.format(format)))
            });
          }
          const result = [];
          if (format !== "sighash") {
            result.push("event");
          }
          result.push(this.name + joinParams(format, this.inputs));
          if (format !== "sighash" && this.anonymous) {
            result.push("anonymous");
          }
          return result.join(" ");
        }
        /**
         *  Return the topic hash for an event with %%name%% and %%params%%.
         */
        static getTopicHash(name, params) {
          params = (params || []).map((p) => ParamType.from(p));
          const fragment = new _EventFragment(_guard4, name, params, false);
          return fragment.topicHash;
        }
        /**
         *  Returns a new **EventFragment** for %%obj%%.
         */
        static from(obj) {
          if (_EventFragment.isFragment(obj)) {
            return obj;
          }
          if (typeof obj === "string") {
            try {
              return _EventFragment.from(lex(obj));
            } catch (error) {
              assertArgument(false, "invalid event fragment", "obj", obj);
            }
          } else if (obj instanceof TokenString) {
            const name = consumeName("event", obj);
            const inputs = consumeParams(obj, true);
            const anonymous = !!consumeKeywords(obj, setify(["anonymous"])).has("anonymous");
            consumeEoi(obj);
            return new _EventFragment(_guard4, name, inputs, anonymous);
          }
          return new _EventFragment(_guard4, obj.name, obj.inputs ? obj.inputs.map((p) => ParamType.from(p, true)) : [], !!obj.anonymous);
        }
        /**
         *  Returns ``true`` and provides a type guard if %%value%% is an
         *  **EventFragment**.
         */
        static isFragment(value) {
          return value && value[internal] === EventFragmentInternal;
        }
      };
      ConstructorFragment = class _ConstructorFragment extends Fragment {
        /**
         *  @private
         */
        constructor(guard, type, inputs, payable, gas) {
          super(guard, type, inputs);
          /**
           *  Whether the constructor can receive an endowment.
           */
          __publicField(this, "payable");
          /**
           *  The recommended gas limit for deployment or ``null``.
           */
          __publicField(this, "gas");
          Object.defineProperty(this, internal, { value: ConstructorFragmentInternal });
          defineProperties(this, { payable, gas });
        }
        /**
         *  Returns a string representation of this constructor as %%format%%.
         */
        format(format) {
          assert(format != null && format !== "sighash", "cannot format a constructor for sighash", "UNSUPPORTED_OPERATION", { operation: "format(sighash)" });
          if (format === "json") {
            return JSON.stringify({
              type: "constructor",
              stateMutability: this.payable ? "payable" : "undefined",
              payable: this.payable,
              gas: this.gas != null ? this.gas : void 0,
              inputs: this.inputs.map((i) => JSON.parse(i.format(format)))
            });
          }
          const result = [`constructor${joinParams(format, this.inputs)}`];
          if (this.payable) {
            result.push("payable");
          }
          if (this.gas != null) {
            result.push(`@${this.gas.toString()}`);
          }
          return result.join(" ");
        }
        /**
         *  Returns a new **ConstructorFragment** for %%obj%%.
         */
        static from(obj) {
          if (_ConstructorFragment.isFragment(obj)) {
            return obj;
          }
          if (typeof obj === "string") {
            try {
              return _ConstructorFragment.from(lex(obj));
            } catch (error) {
              assertArgument(false, "invalid constuctor fragment", "obj", obj);
            }
          } else if (obj instanceof TokenString) {
            consumeKeywords(obj, setify(["constructor"]));
            const inputs = consumeParams(obj);
            const payable = !!consumeKeywords(obj, KwVisibDeploy).has("payable");
            const gas = consumeGas(obj);
            consumeEoi(obj);
            return new _ConstructorFragment(_guard4, "constructor", inputs, payable, gas);
          }
          return new _ConstructorFragment(_guard4, "constructor", obj.inputs ? obj.inputs.map(ParamType.from) : [], !!obj.payable, obj.gas != null ? obj.gas : null);
        }
        /**
         *  Returns ``true`` and provides a type guard if %%value%% is a
         *  **ConstructorFragment**.
         */
        static isFragment(value) {
          return value && value[internal] === ConstructorFragmentInternal;
        }
      };
      FallbackFragment = class _FallbackFragment extends Fragment {
        constructor(guard, inputs, payable) {
          super(guard, "fallback", inputs);
          /**
           *  If the function can be sent value during invocation.
           */
          __publicField(this, "payable");
          Object.defineProperty(this, internal, { value: FallbackFragmentInternal });
          defineProperties(this, { payable });
        }
        /**
         *  Returns a string representation of this fallback as %%format%%.
         */
        format(format) {
          const type = this.inputs.length === 0 ? "receive" : "fallback";
          if (format === "json") {
            const stateMutability = this.payable ? "payable" : "nonpayable";
            return JSON.stringify({ type, stateMutability });
          }
          return `${type}()${this.payable ? " payable" : ""}`;
        }
        /**
         *  Returns a new **FallbackFragment** for %%obj%%.
         */
        static from(obj) {
          if (_FallbackFragment.isFragment(obj)) {
            return obj;
          }
          if (typeof obj === "string") {
            try {
              return _FallbackFragment.from(lex(obj));
            } catch (error) {
              assertArgument(false, "invalid fallback fragment", "obj", obj);
            }
          } else if (obj instanceof TokenString) {
            const errorObj = obj.toString();
            const topIsValid = obj.peekKeyword(setify(["fallback", "receive"]));
            assertArgument(topIsValid, "type must be fallback or receive", "obj", errorObj);
            const type = obj.popKeyword(setify(["fallback", "receive"]));
            if (type === "receive") {
              const inputs2 = consumeParams(obj);
              assertArgument(inputs2.length === 0, `receive cannot have arguments`, "obj.inputs", inputs2);
              consumeKeywords(obj, setify(["payable"]));
              consumeEoi(obj);
              return new _FallbackFragment(_guard4, [], true);
            }
            let inputs = consumeParams(obj);
            if (inputs.length) {
              assertArgument(inputs.length === 1 && inputs[0].type === "bytes", "invalid fallback inputs", "obj.inputs", inputs.map((i) => i.format("minimal")).join(", "));
            } else {
              inputs = [ParamType.from("bytes")];
            }
            const mutability = consumeMutability(obj);
            assertArgument(mutability === "nonpayable" || mutability === "payable", "fallback cannot be constants", "obj.stateMutability", mutability);
            if (consumeKeywords(obj, setify(["returns"])).has("returns")) {
              const outputs = consumeParams(obj);
              assertArgument(outputs.length === 1 && outputs[0].type === "bytes", "invalid fallback outputs", "obj.outputs", outputs.map((i) => i.format("minimal")).join(", "));
            }
            consumeEoi(obj);
            return new _FallbackFragment(_guard4, inputs, mutability === "payable");
          }
          if (obj.type === "receive") {
            return new _FallbackFragment(_guard4, [], true);
          }
          if (obj.type === "fallback") {
            const inputs = [ParamType.from("bytes")];
            const payable = obj.stateMutability === "payable";
            return new _FallbackFragment(_guard4, inputs, payable);
          }
          assertArgument(false, "invalid fallback description", "obj", obj);
        }
        /**
         *  Returns ``true`` and provides a type guard if %%value%% is a
         *  **FallbackFragment**.
         */
        static isFragment(value) {
          return value && value[internal] === FallbackFragmentInternal;
        }
      };
      FunctionFragment = class _FunctionFragment extends NamedFragment {
        /**
         *  @private
         */
        constructor(guard, name, stateMutability, inputs, outputs, gas) {
          super(guard, "function", name, inputs);
          /**
           *  If the function is constant (e.g. ``pure`` or ``view`` functions).
           */
          __publicField(this, "constant");
          /**
           *  The returned types for the result of calling this function.
           */
          __publicField(this, "outputs");
          /**
           *  The state mutability (e.g. ``payable``, ``nonpayable``, ``view``
           *  or ``pure``)
           */
          __publicField(this, "stateMutability");
          /**
           *  If the function can be sent value during invocation.
           */
          __publicField(this, "payable");
          /**
           *  The recommended gas limit to send when calling this function.
           */
          __publicField(this, "gas");
          Object.defineProperty(this, internal, { value: FunctionFragmentInternal });
          outputs = Object.freeze(outputs.slice());
          const constant = stateMutability === "view" || stateMutability === "pure";
          const payable = stateMutability === "payable";
          defineProperties(this, { constant, gas, outputs, payable, stateMutability });
        }
        /**
         *  The Function selector.
         */
        get selector() {
          return id(this.format("sighash")).substring(0, 10);
        }
        /**
         *  Returns a string representation of this function as %%format%%.
         */
        format(format) {
          if (format == null) {
            format = "sighash";
          }
          if (format === "json") {
            return JSON.stringify({
              type: "function",
              name: this.name,
              constant: this.constant,
              stateMutability: this.stateMutability !== "nonpayable" ? this.stateMutability : void 0,
              payable: this.payable,
              gas: this.gas != null ? this.gas : void 0,
              inputs: this.inputs.map((i) => JSON.parse(i.format(format))),
              outputs: this.outputs.map((o) => JSON.parse(o.format(format)))
            });
          }
          const result = [];
          if (format !== "sighash") {
            result.push("function");
          }
          result.push(this.name + joinParams(format, this.inputs));
          if (format !== "sighash") {
            if (this.stateMutability !== "nonpayable") {
              result.push(this.stateMutability);
            }
            if (this.outputs && this.outputs.length) {
              result.push("returns");
              result.push(joinParams(format, this.outputs));
            }
            if (this.gas != null) {
              result.push(`@${this.gas.toString()}`);
            }
          }
          return result.join(" ");
        }
        /**
         *  Return the selector for a function with %%name%% and %%params%%.
         */
        static getSelector(name, params) {
          params = (params || []).map((p) => ParamType.from(p));
          const fragment = new _FunctionFragment(_guard4, name, "view", params, [], null);
          return fragment.selector;
        }
        /**
         *  Returns a new **FunctionFragment** for %%obj%%.
         */
        static from(obj) {
          if (_FunctionFragment.isFragment(obj)) {
            return obj;
          }
          if (typeof obj === "string") {
            try {
              return _FunctionFragment.from(lex(obj));
            } catch (error) {
              assertArgument(false, "invalid function fragment", "obj", obj);
            }
          } else if (obj instanceof TokenString) {
            const name = consumeName("function", obj);
            const inputs = consumeParams(obj);
            const mutability = consumeMutability(obj);
            let outputs = [];
            if (consumeKeywords(obj, setify(["returns"])).has("returns")) {
              outputs = consumeParams(obj);
            }
            const gas = consumeGas(obj);
            consumeEoi(obj);
            return new _FunctionFragment(_guard4, name, mutability, inputs, outputs, gas);
          }
          let stateMutability = obj.stateMutability;
          if (stateMutability == null) {
            stateMutability = "payable";
            if (typeof obj.constant === "boolean") {
              stateMutability = "view";
              if (!obj.constant) {
                stateMutability = "payable";
                if (typeof obj.payable === "boolean" && !obj.payable) {
                  stateMutability = "nonpayable";
                }
              }
            } else if (typeof obj.payable === "boolean" && !obj.payable) {
              stateMutability = "nonpayable";
            }
          }
          return new _FunctionFragment(_guard4, obj.name, stateMutability, obj.inputs ? obj.inputs.map(ParamType.from) : [], obj.outputs ? obj.outputs.map(ParamType.from) : [], obj.gas != null ? obj.gas : null);
        }
        /**
         *  Returns ``true`` and provides a type guard if %%value%% is a
         *  **FunctionFragment**.
         */
        static isFragment(value) {
          return value && value[internal] === FunctionFragmentInternal;
        }
      };
      StructFragment = class _StructFragment extends NamedFragment {
        /**
         *  @private
         */
        constructor(guard, name, inputs) {
          super(guard, "struct", name, inputs);
          Object.defineProperty(this, internal, { value: StructFragmentInternal });
        }
        /**
         *  Returns a string representation of this struct as %%format%%.
         */
        format() {
          throw new Error("@TODO");
        }
        /**
         *  Returns a new **StructFragment** for %%obj%%.
         */
        static from(obj) {
          if (typeof obj === "string") {
            try {
              return _StructFragment.from(lex(obj));
            } catch (error) {
              assertArgument(false, "invalid struct fragment", "obj", obj);
            }
          } else if (obj instanceof TokenString) {
            const name = consumeName("struct", obj);
            const inputs = consumeParams(obj);
            consumeEoi(obj);
            return new _StructFragment(_guard4, name, inputs);
          }
          return new _StructFragment(_guard4, obj.name, obj.inputs ? obj.inputs.map(ParamType.from) : []);
        }
        // @TODO: fix this return type
        /**
         *  Returns ``true`` and provides a type guard if %%value%% is a
         *  **StructFragment**.
         */
        static isFragment(value) {
          return value && value[internal] === StructFragmentInternal;
        }
      };
    }
  });

  // node_modules/ethers/lib.esm/abi/abi-coder.js
  function getBuiltinCallException(action, tx, data, abiCoder) {
    let message = "missing revert data";
    let reason = null;
    const invocation = null;
    let revert = null;
    if (data) {
      message = "execution reverted";
      const bytes2 = getBytes(data);
      data = hexlify(data);
      if (bytes2.length === 0) {
        message += " (no data present; likely require(false) occurred";
        reason = "require(false)";
      } else if (bytes2.length % 32 !== 4) {
        message += " (could not decode reason; invalid data length)";
      } else if (hexlify(bytes2.slice(0, 4)) === "0x08c379a0") {
        try {
          reason = abiCoder.decode(["string"], bytes2.slice(4))[0];
          revert = {
            signature: "Error(string)",
            name: "Error",
            args: [reason]
          };
          message += `: ${JSON.stringify(reason)}`;
        } catch (error) {
          message += " (could not decode reason; invalid string data)";
        }
      } else if (hexlify(bytes2.slice(0, 4)) === "0x4e487b71") {
        try {
          const code = Number(abiCoder.decode(["uint256"], bytes2.slice(4))[0]);
          revert = {
            signature: "Panic(uint256)",
            name: "Panic",
            args: [code]
          };
          reason = `Panic due to ${PanicReasons.get(code) || "UNKNOWN"}(${code})`;
          message += `: ${reason}`;
        } catch (error) {
          message += " (could not decode panic code)";
        }
      } else {
        message += " (unknown custom error)";
      }
    }
    const transaction = {
      to: tx.to ? getAddress(tx.to) : null,
      data: tx.data || "0x"
    };
    if (tx.from) {
      transaction.from = getAddress(tx.from);
    }
    return makeError(message, "CALL_EXCEPTION", {
      action,
      data,
      reason,
      transaction,
      invocation,
      revert
    });
  }
  var PanicReasons, paramTypeBytes, paramTypeNumber, defaultCoder, defaultMaxInflation, _AbiCoder_instances, getCoder_fn, _AbiCoder, AbiCoder;
  var init_abi_coder = __esm({
    "node_modules/ethers/lib.esm/abi/abi-coder.js"() {
      init_utils();
      init_abstract_coder();
      init_address3();
      init_array();
      init_boolean();
      init_bytes();
      init_fixed_bytes();
      init_null();
      init_number();
      init_string();
      init_tuple();
      init_fragments();
      init_address2();
      init_utils();
      PanicReasons = /* @__PURE__ */ new Map();
      PanicReasons.set(0, "GENERIC_PANIC");
      PanicReasons.set(1, "ASSERT_FALSE");
      PanicReasons.set(17, "OVERFLOW");
      PanicReasons.set(18, "DIVIDE_BY_ZERO");
      PanicReasons.set(33, "ENUM_RANGE_ERROR");
      PanicReasons.set(34, "BAD_STORAGE_DATA");
      PanicReasons.set(49, "STACK_UNDERFLOW");
      PanicReasons.set(50, "ARRAY_RANGE_ERROR");
      PanicReasons.set(65, "OUT_OF_MEMORY");
      PanicReasons.set(81, "UNINITIALIZED_FUNCTION_CALL");
      paramTypeBytes = new RegExp(/^bytes([0-9]*)$/);
      paramTypeNumber = new RegExp(/^(u?int)([0-9]*)$/);
      defaultCoder = null;
      defaultMaxInflation = 1024;
      _AbiCoder = class _AbiCoder {
        constructor() {
          __privateAdd(this, _AbiCoder_instances);
        }
        /**
         *  Get the default values for the given %%types%%.
         *
         *  For example, a ``uint`` is by default ``0`` and ``bool``
         *  is by default ``false``.
         */
        getDefaultValue(types) {
          const coders = types.map((type) => __privateMethod(this, _AbiCoder_instances, getCoder_fn).call(this, ParamType.from(type)));
          const coder = new TupleCoder(coders, "_");
          return coder.defaultValue();
        }
        /**
         *  Encode the %%values%% as the %%types%% into ABI data.
         *
         *  @returns DataHexstring
         */
        encode(types, values) {
          assertArgumentCount(values.length, types.length, "types/values length mismatch");
          const coders = types.map((type) => __privateMethod(this, _AbiCoder_instances, getCoder_fn).call(this, ParamType.from(type)));
          const coder = new TupleCoder(coders, "_");
          const writer = new Writer();
          coder.encode(writer, values);
          return writer.data;
        }
        /**
         *  Decode the ABI %%data%% as the %%types%% into values.
         *
         *  If %%loose%% decoding is enabled, then strict padding is
         *  not enforced. Some older versions of Solidity incorrectly
         *  padded event data emitted from ``external`` functions.
         */
        decode(types, data, loose) {
          const coders = types.map((type) => __privateMethod(this, _AbiCoder_instances, getCoder_fn).call(this, ParamType.from(type)));
          const coder = new TupleCoder(coders, "_");
          return coder.decode(new Reader(data, loose, defaultMaxInflation));
        }
        static _setDefaultMaxInflation(value) {
          assertArgument(typeof value === "number" && Number.isInteger(value), "invalid defaultMaxInflation factor", "value", value);
          defaultMaxInflation = value;
        }
        /**
         *  Returns the shared singleton instance of a default [[AbiCoder]].
         *
         *  On the first call, the instance is created internally.
         */
        static defaultAbiCoder() {
          if (defaultCoder == null) {
            defaultCoder = new _AbiCoder();
          }
          return defaultCoder;
        }
        /**
         *  Returns an ethers-compatible [[CallExceptionError]] Error for the given
         *  result %%data%% for the [[CallExceptionAction]] %%action%% against
         *  the Transaction %%tx%%.
         */
        static getBuiltinCallException(action, tx, data) {
          return getBuiltinCallException(action, tx, data, _AbiCoder.defaultAbiCoder());
        }
      };
      _AbiCoder_instances = new WeakSet();
      getCoder_fn = function(param) {
        if (param.isArray()) {
          return new ArrayCoder(__privateMethod(this, _AbiCoder_instances, getCoder_fn).call(this, param.arrayChildren), param.arrayLength, param.name);
        }
        if (param.isTuple()) {
          return new TupleCoder(param.components.map((c) => __privateMethod(this, _AbiCoder_instances, getCoder_fn).call(this, c)), param.name);
        }
        switch (param.baseType) {
          case "address":
            return new AddressCoder(param.name);
          case "bool":
            return new BooleanCoder(param.name);
          case "string":
            return new StringCoder(param.name);
          case "bytes":
            return new BytesCoder(param.name);
          case "":
            return new NullCoder(param.name);
        }
        let match = param.type.match(paramTypeNumber);
        if (match) {
          let size5 = parseInt(match[2] || "256");
          assertArgument(size5 !== 0 && size5 <= 256 && size5 % 8 === 0, "invalid " + match[1] + " bit length", "param", param);
          return new NumberCoder(size5 / 8, match[1] === "int", param.name);
        }
        match = param.type.match(paramTypeBytes);
        if (match) {
          let size5 = parseInt(match[1]);
          assertArgument(size5 !== 0 && size5 <= 32, "invalid bytes length", "param", param);
          return new FixedBytesCoder(size5, param.name);
        }
        assertArgument(false, "invalid type", "type", param.type);
      };
      AbiCoder = _AbiCoder;
    }
  });

  // node_modules/ethers/lib.esm/abi/bytes32.js
  function encodeBytes32String(text) {
    const bytes2 = toUtf8Bytes(text);
    if (bytes2.length > 31) {
      throw new Error("bytes32 string must be less than 32 bytes");
    }
    return zeroPadBytes(bytes2, 32);
  }
  function decodeBytes32String(_bytes) {
    const data = getBytes(_bytes, "bytes");
    if (data.length !== 32) {
      throw new Error("invalid bytes32 - not 32 bytes long");
    }
    if (data[31] !== 0) {
      throw new Error("invalid bytes32 string - no null terminator");
    }
    let length = 31;
    while (data[length - 1] === 0) {
      length--;
    }
    return toUtf8String(data.slice(0, length));
  }
  var init_bytes32 = __esm({
    "node_modules/ethers/lib.esm/abi/bytes32.js"() {
      init_utils();
    }
  });

  // node_modules/ethers/lib.esm/abi/interface.js
  var LogDescription, TransactionDescription, ErrorDescription, Indexed, PanicReasons2, BuiltinErrors, _errors, _events, _functions, _abiCoder, _Interface_instances, getFunction_fn, getEvent_fn, _Interface, Interface;
  var init_interface = __esm({
    "node_modules/ethers/lib.esm/abi/interface.js"() {
      init_crypto2();
      init_hash();
      init_utils();
      init_abi_coder();
      init_abstract_coder();
      init_fragments();
      init_typed();
      LogDescription = class {
        /**
         *  @_ignore:
         */
        constructor(fragment, topic, args) {
          /**
           *  The matching fragment for the ``topic0``.
           */
          __publicField(this, "fragment");
          /**
           *  The name of the Event.
           */
          __publicField(this, "name");
          /**
           *  The full Event signature.
           */
          __publicField(this, "signature");
          /**
           *  The topic hash for the Event.
           */
          __publicField(this, "topic");
          /**
           *  The arguments passed into the Event with ``emit``.
           */
          __publicField(this, "args");
          const name = fragment.name, signature = fragment.format();
          defineProperties(this, {
            fragment,
            name,
            signature,
            topic,
            args
          });
        }
      };
      TransactionDescription = class {
        /**
         *  @_ignore:
         */
        constructor(fragment, selector, args, value) {
          /**
           *  The matching fragment from the transaction ``data``.
           */
          __publicField(this, "fragment");
          /**
           *  The name of the Function from the transaction ``data``.
           */
          __publicField(this, "name");
          /**
           *  The arguments passed to the Function from the transaction ``data``.
           */
          __publicField(this, "args");
          /**
           *  The full Function signature from the transaction ``data``.
           */
          __publicField(this, "signature");
          /**
           *  The selector for the Function from the transaction ``data``.
           */
          __publicField(this, "selector");
          /**
           *  The ``value`` (in wei) from the transaction.
           */
          __publicField(this, "value");
          const name = fragment.name, signature = fragment.format();
          defineProperties(this, {
            fragment,
            name,
            args,
            signature,
            selector,
            value
          });
        }
      };
      ErrorDescription = class {
        /**
         *  @_ignore:
         */
        constructor(fragment, selector, args) {
          /**
           *  The matching fragment.
           */
          __publicField(this, "fragment");
          /**
           *  The name of the Error.
           */
          __publicField(this, "name");
          /**
           *  The arguments passed to the Error with ``revert``.
           */
          __publicField(this, "args");
          /**
           *  The full Error signature.
           */
          __publicField(this, "signature");
          /**
           *  The selector for the Error.
           */
          __publicField(this, "selector");
          const name = fragment.name, signature = fragment.format();
          defineProperties(this, {
            fragment,
            name,
            args,
            signature,
            selector
          });
        }
      };
      Indexed = class {
        /**
         *  @_ignore:
         */
        constructor(hash3) {
          /**
           *  The ``keccak256`` of the value logged.
           */
          __publicField(this, "hash");
          /**
           *  @_ignore:
           */
          __publicField(this, "_isIndexed");
          defineProperties(this, { hash: hash3, _isIndexed: true });
        }
        /**
         *  Returns ``true`` if %%value%% is an **Indexed**.
         *
         *  This provides a Type Guard for property access.
         */
        static isIndexed(value) {
          return !!(value && value._isIndexed);
        }
      };
      PanicReasons2 = {
        "0": "generic panic",
        "1": "assert(false)",
        "17": "arithmetic overflow",
        "18": "division or modulo by zero",
        "33": "enum overflow",
        "34": "invalid encoded storage byte array accessed",
        "49": "out-of-bounds array access; popping on an empty array",
        "50": "out-of-bounds access of an array or bytesN",
        "65": "out of memory",
        "81": "uninitialized function"
      };
      BuiltinErrors = {
        "0x08c379a0": {
          signature: "Error(string)",
          name: "Error",
          inputs: ["string"],
          reason: (message) => {
            return `reverted with reason string ${JSON.stringify(message)}`;
          }
        },
        "0x4e487b71": {
          signature: "Panic(uint256)",
          name: "Panic",
          inputs: ["uint256"],
          reason: (code) => {
            let reason = "unknown panic code";
            if (code >= 0 && code <= 255 && PanicReasons2[code.toString()]) {
              reason = PanicReasons2[code.toString()];
            }
            return `reverted with panic code 0x${code.toString(16)} (${reason})`;
          }
        }
      };
      _Interface = class _Interface {
        /**
         *  Create a new Interface for the %%fragments%%.
         */
        constructor(fragments) {
          __privateAdd(this, _Interface_instances);
          /**
           *  All the Contract ABI members (i.e. methods, events, errors, etc).
           */
          __publicField(this, "fragments");
          /**
           *  The Contract constructor.
           */
          __publicField(this, "deploy");
          /**
           *  The Fallback method, if any.
           */
          __publicField(this, "fallback");
          /**
           *  If receiving ether is supported.
           */
          __publicField(this, "receive");
          __privateAdd(this, _errors);
          __privateAdd(this, _events);
          __privateAdd(this, _functions);
          //    #structs: Map<string, StructFragment>;
          __privateAdd(this, _abiCoder);
          let abi2 = [];
          if (typeof fragments === "string") {
            abi2 = JSON.parse(fragments);
          } else {
            abi2 = fragments;
          }
          __privateSet(this, _functions, /* @__PURE__ */ new Map());
          __privateSet(this, _errors, /* @__PURE__ */ new Map());
          __privateSet(this, _events, /* @__PURE__ */ new Map());
          const frags = [];
          for (const a of abi2) {
            try {
              frags.push(Fragment.from(a));
            } catch (error) {
              console.log(`[Warning] Invalid Fragment ${JSON.stringify(a)}:`, error.message);
            }
          }
          defineProperties(this, {
            fragments: Object.freeze(frags)
          });
          let fallback = null;
          let receive = false;
          __privateSet(this, _abiCoder, this.getAbiCoder());
          this.fragments.forEach((fragment, index2) => {
            let bucket;
            switch (fragment.type) {
              case "constructor":
                if (this.deploy) {
                  console.log("duplicate definition - constructor");
                  return;
                }
                defineProperties(this, { deploy: fragment });
                return;
              case "fallback":
                if (fragment.inputs.length === 0) {
                  receive = true;
                } else {
                  assertArgument(!fallback || fragment.payable !== fallback.payable, "conflicting fallback fragments", `fragments[${index2}]`, fragment);
                  fallback = fragment;
                  receive = fallback.payable;
                }
                return;
              case "function":
                bucket = __privateGet(this, _functions);
                break;
              case "event":
                bucket = __privateGet(this, _events);
                break;
              case "error":
                bucket = __privateGet(this, _errors);
                break;
              default:
                return;
            }
            const signature = fragment.format();
            if (bucket.has(signature)) {
              return;
            }
            bucket.set(signature, fragment);
          });
          if (!this.deploy) {
            defineProperties(this, {
              deploy: ConstructorFragment.from("constructor()")
            });
          }
          defineProperties(this, { fallback, receive });
        }
        /**
         *  Returns the entire Human-Readable ABI, as an array of
         *  signatures, optionally as %%minimal%% strings, which
         *  removes parameter names and unneceesary spaces.
         */
        format(minimal) {
          const format = minimal ? "minimal" : "full";
          const abi2 = this.fragments.map((f2) => f2.format(format));
          return abi2;
        }
        /**
         *  Return the JSON-encoded ABI. This is the format Solidiy
         *  returns.
         */
        formatJson() {
          const abi2 = this.fragments.map((f2) => f2.format("json"));
          return JSON.stringify(abi2.map((j) => JSON.parse(j)));
        }
        /**
         *  The ABI coder that will be used to encode and decode binary
         *  data.
         */
        getAbiCoder() {
          return AbiCoder.defaultAbiCoder();
        }
        /**
         *  Get the function name for %%key%%, which may be a function selector,
         *  function name or function signature that belongs to the ABI.
         */
        getFunctionName(key) {
          const fragment = __privateMethod(this, _Interface_instances, getFunction_fn).call(this, key, null, false);
          assertArgument(fragment, "no matching function", "key", key);
          return fragment.name;
        }
        /**
         *  Returns true if %%key%% (a function selector, function name or
         *  function signature) is present in the ABI.
         *
         *  In the case of a function name, the name may be ambiguous, so
         *  accessing the [[FunctionFragment]] may require refinement.
         */
        hasFunction(key) {
          return !!__privateMethod(this, _Interface_instances, getFunction_fn).call(this, key, null, false);
        }
        /**
         *  Get the [[FunctionFragment]] for %%key%%, which may be a function
         *  selector, function name or function signature that belongs to the ABI.
         *
         *  If %%values%% is provided, it will use the Typed API to handle
         *  ambiguous cases where multiple functions match by name.
         *
         *  If the %%key%% and %%values%% do not refine to a single function in
         *  the ABI, this will throw.
         */
        getFunction(key, values) {
          return __privateMethod(this, _Interface_instances, getFunction_fn).call(this, key, values || null, true);
        }
        /**
         *  Iterate over all functions, calling %%callback%%, sorted by their name.
         */
        forEachFunction(callback) {
          const names2 = Array.from(__privateGet(this, _functions).keys());
          names2.sort((a, b2) => a.localeCompare(b2));
          for (let i = 0; i < names2.length; i++) {
            const name = names2[i];
            callback(__privateGet(this, _functions).get(name), i);
          }
        }
        /**
         *  Get the event name for %%key%%, which may be a topic hash,
         *  event name or event signature that belongs to the ABI.
         */
        getEventName(key) {
          const fragment = __privateMethod(this, _Interface_instances, getEvent_fn).call(this, key, null, false);
          assertArgument(fragment, "no matching event", "key", key);
          return fragment.name;
        }
        /**
         *  Returns true if %%key%% (an event topic hash, event name or
         *  event signature) is present in the ABI.
         *
         *  In the case of an event name, the name may be ambiguous, so
         *  accessing the [[EventFragment]] may require refinement.
         */
        hasEvent(key) {
          return !!__privateMethod(this, _Interface_instances, getEvent_fn).call(this, key, null, false);
        }
        /**
         *  Get the [[EventFragment]] for %%key%%, which may be a topic hash,
         *  event name or event signature that belongs to the ABI.
         *
         *  If %%values%% is provided, it will use the Typed API to handle
         *  ambiguous cases where multiple events match by name.
         *
         *  If the %%key%% and %%values%% do not refine to a single event in
         *  the ABI, this will throw.
         */
        getEvent(key, values) {
          return __privateMethod(this, _Interface_instances, getEvent_fn).call(this, key, values || null, true);
        }
        /**
         *  Iterate over all events, calling %%callback%%, sorted by their name.
         */
        forEachEvent(callback) {
          const names2 = Array.from(__privateGet(this, _events).keys());
          names2.sort((a, b2) => a.localeCompare(b2));
          for (let i = 0; i < names2.length; i++) {
            const name = names2[i];
            callback(__privateGet(this, _events).get(name), i);
          }
        }
        /**
         *  Get the [[ErrorFragment]] for %%key%%, which may be an error
         *  selector, error name or error signature that belongs to the ABI.
         *
         *  If %%values%% is provided, it will use the Typed API to handle
         *  ambiguous cases where multiple errors match by name.
         *
         *  If the %%key%% and %%values%% do not refine to a single error in
         *  the ABI, this will throw.
         */
        getError(key, values) {
          if (isHexString(key)) {
            const selector = key.toLowerCase();
            if (BuiltinErrors[selector]) {
              return ErrorFragment.from(BuiltinErrors[selector].signature);
            }
            for (const fragment of __privateGet(this, _errors).values()) {
              if (selector === fragment.selector) {
                return fragment;
              }
            }
            return null;
          }
          if (key.indexOf("(") === -1) {
            const matching = [];
            for (const [name, fragment] of __privateGet(this, _errors)) {
              if (name.split(
                "("
                /* fix:) */
              )[0] === key) {
                matching.push(fragment);
              }
            }
            if (matching.length === 0) {
              if (key === "Error") {
                return ErrorFragment.from("error Error(string)");
              }
              if (key === "Panic") {
                return ErrorFragment.from("error Panic(uint256)");
              }
              return null;
            } else if (matching.length > 1) {
              const matchStr = matching.map((m) => JSON.stringify(m.format())).join(", ");
              assertArgument(false, `ambiguous error description (i.e. ${matchStr})`, "name", key);
            }
            return matching[0];
          }
          key = ErrorFragment.from(key).format();
          if (key === "Error(string)") {
            return ErrorFragment.from("error Error(string)");
          }
          if (key === "Panic(uint256)") {
            return ErrorFragment.from("error Panic(uint256)");
          }
          const result = __privateGet(this, _errors).get(key);
          if (result) {
            return result;
          }
          return null;
        }
        /**
         *  Iterate over all errors, calling %%callback%%, sorted by their name.
         */
        forEachError(callback) {
          const names2 = Array.from(__privateGet(this, _errors).keys());
          names2.sort((a, b2) => a.localeCompare(b2));
          for (let i = 0; i < names2.length; i++) {
            const name = names2[i];
            callback(__privateGet(this, _errors).get(name), i);
          }
        }
        // Get the 4-byte selector used by Solidity to identify a function
        /*
        getSelector(fragment: ErrorFragment | FunctionFragment): string {
            if (typeof(fragment) === "string") {
                const matches: Array<Fragment> = [ ];
        
                try { matches.push(this.getFunction(fragment)); } catch (error) { }
                try { matches.push(this.getError(<string>fragment)); } catch (_) { }
        
                if (matches.length === 0) {
                    logger.throwArgumentError("unknown fragment", "key", fragment);
                } else if (matches.length > 1) {
                    logger.throwArgumentError("ambiguous fragment matches function and error", "key", fragment);
                }
        
                fragment = matches[0];
            }
        
            return dataSlice(id(fragment.format()), 0, 4);
        }
            */
        // Get the 32-byte topic hash used by Solidity to identify an event
        /*
        getEventTopic(fragment: EventFragment): string {
            //if (typeof(fragment) === "string") { fragment = this.getEvent(eventFragment); }
            return id(fragment.format());
        }
        */
        _decodeParams(params, data) {
          return __privateGet(this, _abiCoder).decode(params, data);
        }
        _encodeParams(params, values) {
          return __privateGet(this, _abiCoder).encode(params, values);
        }
        /**
         *  Encodes a ``tx.data`` object for deploying the Contract with
         *  the %%values%% as the constructor arguments.
         */
        encodeDeploy(values) {
          return this._encodeParams(this.deploy.inputs, values || []);
        }
        /**
         *  Decodes the result %%data%% (e.g. from an ``eth_call``) for the
         *  specified error (see [[getError]] for valid values for
         *  %%key%%).
         *
         *  Most developers should prefer the [[parseCallResult]] method instead,
         *  which will automatically detect a ``CALL_EXCEPTION`` and throw the
         *  corresponding error.
         */
        decodeErrorResult(fragment, data) {
          if (typeof fragment === "string") {
            const f2 = this.getError(fragment);
            assertArgument(f2, "unknown error", "fragment", fragment);
            fragment = f2;
          }
          assertArgument(dataSlice(data, 0, 4) === fragment.selector, `data signature does not match error ${fragment.name}.`, "data", data);
          return this._decodeParams(fragment.inputs, dataSlice(data, 4));
        }
        /**
         *  Encodes the transaction revert data for a call result that
         *  reverted from the the Contract with the sepcified %%error%%
         *  (see [[getError]] for valid values for %%fragment%%) with the %%values%%.
         *
         *  This is generally not used by most developers, unless trying to mock
         *  a result from a Contract.
         */
        encodeErrorResult(fragment, values) {
          if (typeof fragment === "string") {
            const f2 = this.getError(fragment);
            assertArgument(f2, "unknown error", "fragment", fragment);
            fragment = f2;
          }
          return concat([
            fragment.selector,
            this._encodeParams(fragment.inputs, values || [])
          ]);
        }
        /**
         *  Decodes the %%data%% from a transaction ``tx.data`` for
         *  the function specified (see [[getFunction]] for valid values
         *  for %%fragment%%).
         *
         *  Most developers should prefer the [[parseTransaction]] method
         *  instead, which will automatically detect the fragment.
         */
        decodeFunctionData(fragment, data) {
          if (typeof fragment === "string") {
            const f2 = this.getFunction(fragment);
            assertArgument(f2, "unknown function", "fragment", fragment);
            fragment = f2;
          }
          assertArgument(dataSlice(data, 0, 4) === fragment.selector, `data signature does not match function ${fragment.name}.`, "data", data);
          return this._decodeParams(fragment.inputs, dataSlice(data, 4));
        }
        /**
         *  Encodes the ``tx.data`` for a transaction that calls the function
         *  specified (see [[getFunction]] for valid values for %%fragment%%) with
         *  the %%values%%.
         */
        encodeFunctionData(fragment, values) {
          if (typeof fragment === "string") {
            const f2 = this.getFunction(fragment);
            assertArgument(f2, "unknown function", "fragment", fragment);
            fragment = f2;
          }
          return concat([
            fragment.selector,
            this._encodeParams(fragment.inputs, values || [])
          ]);
        }
        /**
         *  Decodes the result %%data%% (e.g. from an ``eth_call``) for the
         *  specified function (see [[getFunction]] for valid values for
         *  %%key%%).
         *
         *  Most developers should prefer the [[parseCallResult]] method instead,
         *  which will automatically detect a ``CALL_EXCEPTION`` and throw the
         *  corresponding error.
         */
        decodeFunctionResult(fragment, data) {
          if (typeof fragment === "string") {
            const f2 = this.getFunction(fragment);
            assertArgument(f2, "unknown function", "fragment", fragment);
            fragment = f2;
          }
          let message = "invalid length for result data";
          const bytes2 = getBytesCopy(data);
          if (bytes2.length % 32 === 0) {
            try {
              return __privateGet(this, _abiCoder).decode(fragment.outputs, bytes2);
            } catch (error) {
              message = "could not decode result data";
            }
          }
          assert(false, message, "BAD_DATA", {
            value: hexlify(bytes2),
            info: { method: fragment.name, signature: fragment.format() }
          });
        }
        makeError(_data5, tx) {
          const data = getBytes(_data5, "data");
          const error = AbiCoder.getBuiltinCallException("call", tx, data);
          const customPrefix = "execution reverted (unknown custom error)";
          if (error.message.startsWith(customPrefix)) {
            const selector = hexlify(data.slice(0, 4));
            const ef = this.getError(selector);
            if (ef) {
              try {
                const args = __privateGet(this, _abiCoder).decode(ef.inputs, data.slice(4));
                error.revert = {
                  name: ef.name,
                  signature: ef.format(),
                  args
                };
                error.reason = error.revert.signature;
                error.message = `execution reverted: ${error.reason}`;
              } catch (e) {
                error.message = `execution reverted (coult not decode custom error)`;
              }
            }
          }
          const parsed = this.parseTransaction(tx);
          if (parsed) {
            error.invocation = {
              method: parsed.name,
              signature: parsed.signature,
              args: parsed.args
            };
          }
          return error;
        }
        /**
         *  Encodes the result data (e.g. from an ``eth_call``) for the
         *  specified function (see [[getFunction]] for valid values
         *  for %%fragment%%) with %%values%%.
         *
         *  This is generally not used by most developers, unless trying to mock
         *  a result from a Contract.
         */
        encodeFunctionResult(fragment, values) {
          if (typeof fragment === "string") {
            const f2 = this.getFunction(fragment);
            assertArgument(f2, "unknown function", "fragment", fragment);
            fragment = f2;
          }
          return hexlify(__privateGet(this, _abiCoder).encode(fragment.outputs, values || []));
        }
        /*
            spelunk(inputs: Array<ParamType>, values: ReadonlyArray<any>, processfunc: (type: string, value: any) => Promise<any>): Promise<Array<any>> {
                const promises: Array<Promise<>> = [ ];
                const process = function(type: ParamType, value: any): any {
                    if (type.baseType === "array") {
                        return descend(type.child
                    }
                    if (type. === "address") {
                    }
                };
        
                const descend = function (inputs: Array<ParamType>, values: ReadonlyArray<any>) {
                    if (inputs.length !== values.length) { throw new Error("length mismatch"); }
                    
                };
        
                const result: Array<any> = [ ];
                values.forEach((value, index) => {
                    if (value == null) {
                        topics.push(null);
                    } else if (param.baseType === "array" || param.baseType === "tuple") {
                        logger.throwArgumentError("filtering with tuples or arrays not supported", ("contract." + param.name), value);
                    } else if (Array.isArray(value)) {
                        topics.push(value.map((value) => encodeTopic(param, value)));
                    } else {
                        topics.push(encodeTopic(param, value));
                    }
                });
            }
        */
        // Create the filter for the event with search criteria (e.g. for eth_filterLog)
        encodeFilterTopics(fragment, values) {
          if (typeof fragment === "string") {
            const f2 = this.getEvent(fragment);
            assertArgument(f2, "unknown event", "eventFragment", fragment);
            fragment = f2;
          }
          assert(values.length <= fragment.inputs.length, `too many arguments for ${fragment.format()}`, "UNEXPECTED_ARGUMENT", { count: values.length, expectedCount: fragment.inputs.length });
          const topics = [];
          if (!fragment.anonymous) {
            topics.push(fragment.topicHash);
          }
          const encodeTopic = (param, value) => {
            if (param.type === "string") {
              return id(value);
            } else if (param.type === "bytes") {
              return keccak256(hexlify(value));
            }
            if (param.type === "bool" && typeof value === "boolean") {
              value = value ? "0x01" : "0x00";
            } else if (param.type.match(/^u?int/)) {
              value = toBeHex(value);
            } else if (param.type.match(/^bytes/)) {
              value = zeroPadBytes(value, 32);
            } else if (param.type === "address") {
              __privateGet(this, _abiCoder).encode(["address"], [value]);
            }
            return zeroPadValue(hexlify(value), 32);
          };
          values.forEach((value, index2) => {
            const param = fragment.inputs[index2];
            if (!param.indexed) {
              assertArgument(value == null, "cannot filter non-indexed parameters; must be null", "contract." + param.name, value);
              return;
            }
            if (value == null) {
              topics.push(null);
            } else if (param.baseType === "array" || param.baseType === "tuple") {
              assertArgument(false, "filtering with tuples or arrays not supported", "contract." + param.name, value);
            } else if (Array.isArray(value)) {
              topics.push(value.map((value2) => encodeTopic(param, value2)));
            } else {
              topics.push(encodeTopic(param, value));
            }
          });
          while (topics.length && topics[topics.length - 1] === null) {
            topics.pop();
          }
          return topics;
        }
        encodeEventLog(fragment, values) {
          if (typeof fragment === "string") {
            const f2 = this.getEvent(fragment);
            assertArgument(f2, "unknown event", "eventFragment", fragment);
            fragment = f2;
          }
          const topics = [];
          const dataTypes = [];
          const dataValues = [];
          if (!fragment.anonymous) {
            topics.push(fragment.topicHash);
          }
          assertArgument(values.length === fragment.inputs.length, "event arguments/values mismatch", "values", values);
          fragment.inputs.forEach((param, index2) => {
            const value = values[index2];
            if (param.indexed) {
              if (param.type === "string") {
                topics.push(id(value));
              } else if (param.type === "bytes") {
                topics.push(keccak256(value));
              } else if (param.baseType === "tuple" || param.baseType === "array") {
                throw new Error("not implemented");
              } else {
                topics.push(__privateGet(this, _abiCoder).encode([param.type], [value]));
              }
            } else {
              dataTypes.push(param);
              dataValues.push(value);
            }
          });
          return {
            data: __privateGet(this, _abiCoder).encode(dataTypes, dataValues),
            topics
          };
        }
        // Decode a filter for the event and the search criteria
        decodeEventLog(fragment, data, topics) {
          if (typeof fragment === "string") {
            const f2 = this.getEvent(fragment);
            assertArgument(f2, "unknown event", "eventFragment", fragment);
            fragment = f2;
          }
          if (topics != null && !fragment.anonymous) {
            const eventTopic = fragment.topicHash;
            assertArgument(isHexString(topics[0], 32) && topics[0].toLowerCase() === eventTopic, "fragment/topic mismatch", "topics[0]", topics[0]);
            topics = topics.slice(1);
          }
          const indexed = [];
          const nonIndexed = [];
          const dynamic = [];
          fragment.inputs.forEach((param, index2) => {
            if (param.indexed) {
              if (param.type === "string" || param.type === "bytes" || param.baseType === "tuple" || param.baseType === "array") {
                indexed.push(ParamType.from({ type: "bytes32", name: param.name }));
                dynamic.push(true);
              } else {
                indexed.push(param);
                dynamic.push(false);
              }
            } else {
              nonIndexed.push(param);
              dynamic.push(false);
            }
          });
          const resultIndexed = topics != null ? __privateGet(this, _abiCoder).decode(indexed, concat(topics)) : null;
          const resultNonIndexed = __privateGet(this, _abiCoder).decode(nonIndexed, data, true);
          const values = [];
          const keys = [];
          let nonIndexedIndex = 0, indexedIndex = 0;
          fragment.inputs.forEach((param, index2) => {
            let value = null;
            if (param.indexed) {
              if (resultIndexed == null) {
                value = new Indexed(null);
              } else if (dynamic[index2]) {
                value = new Indexed(resultIndexed[indexedIndex++]);
              } else {
                try {
                  value = resultIndexed[indexedIndex++];
                } catch (error) {
                  value = error;
                }
              }
            } else {
              try {
                value = resultNonIndexed[nonIndexedIndex++];
              } catch (error) {
                value = error;
              }
            }
            values.push(value);
            keys.push(param.name || null);
          });
          return Result.fromItems(values, keys);
        }
        /**
         *  Parses a transaction, finding the matching function and extracts
         *  the parameter values along with other useful function details.
         *
         *  If the matching function cannot be found, return null.
         */
        parseTransaction(tx) {
          const data = getBytes(tx.data, "tx.data");
          const value = getBigInt(tx.value != null ? tx.value : 0, "tx.value");
          const fragment = this.getFunction(hexlify(data.slice(0, 4)));
          if (!fragment) {
            return null;
          }
          const args = __privateGet(this, _abiCoder).decode(fragment.inputs, data.slice(4));
          return new TransactionDescription(fragment, fragment.selector, args, value);
        }
        parseCallResult(data) {
          throw new Error("@TODO");
        }
        /**
         *  Parses a receipt log, finding the matching event and extracts
         *  the parameter values along with other useful event details.
         *
         *  If the matching event cannot be found, returns null.
         */
        parseLog(log) {
          const fragment = this.getEvent(log.topics[0]);
          if (!fragment || fragment.anonymous) {
            return null;
          }
          return new LogDescription(fragment, fragment.topicHash, this.decodeEventLog(fragment, log.data, log.topics));
        }
        /**
         *  Parses a revert data, finding the matching error and extracts
         *  the parameter values along with other useful error details.
         *
         *  If the matching error cannot be found, returns null.
         */
        parseError(data) {
          const hexData = hexlify(data);
          const fragment = this.getError(dataSlice(hexData, 0, 4));
          if (!fragment) {
            return null;
          }
          const args = __privateGet(this, _abiCoder).decode(fragment.inputs, dataSlice(hexData, 4));
          return new ErrorDescription(fragment, fragment.selector, args);
        }
        /**
         *  Creates a new [[Interface]] from the ABI %%value%%.
         *
         *  The %%value%% may be provided as an existing [[Interface]] object,
         *  a JSON-encoded ABI or any Human-Readable ABI format.
         */
        static from(value) {
          if (value instanceof _Interface) {
            return value;
          }
          if (typeof value === "string") {
            return new _Interface(JSON.parse(value));
          }
          if (typeof value.formatJson === "function") {
            return new _Interface(value.formatJson());
          }
          if (typeof value.format === "function") {
            return new _Interface(value.format("json"));
          }
          return new _Interface(value);
        }
      };
      _errors = new WeakMap();
      _events = new WeakMap();
      _functions = new WeakMap();
      _abiCoder = new WeakMap();
      _Interface_instances = new WeakSet();
      // Find a function definition by any means necessary (unless it is ambiguous)
      getFunction_fn = function(key, values, forceUnique) {
        if (isHexString(key)) {
          const selector = key.toLowerCase();
          for (const fragment of __privateGet(this, _functions).values()) {
            if (selector === fragment.selector) {
              return fragment;
            }
          }
          return null;
        }
        if (key.indexOf("(") === -1) {
          const matching = [];
          for (const [name, fragment] of __privateGet(this, _functions)) {
            if (name.split(
              "("
              /* fix:) */
            )[0] === key) {
              matching.push(fragment);
            }
          }
          if (values) {
            const lastValue = values.length > 0 ? values[values.length - 1] : null;
            let valueLength = values.length;
            let allowOptions = true;
            if (Typed.isTyped(lastValue) && lastValue.type === "overrides") {
              allowOptions = false;
              valueLength--;
            }
            for (let i = matching.length - 1; i >= 0; i--) {
              const inputs = matching[i].inputs.length;
              if (inputs !== valueLength && (!allowOptions || inputs !== valueLength - 1)) {
                matching.splice(i, 1);
              }
            }
            for (let i = matching.length - 1; i >= 0; i--) {
              const inputs = matching[i].inputs;
              for (let j = 0; j < values.length; j++) {
                if (!Typed.isTyped(values[j])) {
                  continue;
                }
                if (j >= inputs.length) {
                  if (values[j].type === "overrides") {
                    continue;
                  }
                  matching.splice(i, 1);
                  break;
                }
                if (values[j].type !== inputs[j].baseType) {
                  matching.splice(i, 1);
                  break;
                }
              }
            }
          }
          if (matching.length === 1 && values && values.length !== matching[0].inputs.length) {
            const lastArg = values[values.length - 1];
            if (lastArg == null || Array.isArray(lastArg) || typeof lastArg !== "object") {
              matching.splice(0, 1);
            }
          }
          if (matching.length === 0) {
            return null;
          }
          if (matching.length > 1 && forceUnique) {
            const matchStr = matching.map((m) => JSON.stringify(m.format())).join(", ");
            assertArgument(false, `ambiguous function description (i.e. matches ${matchStr})`, "key", key);
          }
          return matching[0];
        }
        const result = __privateGet(this, _functions).get(FunctionFragment.from(key).format());
        if (result) {
          return result;
        }
        return null;
      };
      // Find an event definition by any means necessary (unless it is ambiguous)
      getEvent_fn = function(key, values, forceUnique) {
        if (isHexString(key)) {
          const eventTopic = key.toLowerCase();
          for (const fragment of __privateGet(this, _events).values()) {
            if (eventTopic === fragment.topicHash) {
              return fragment;
            }
          }
          return null;
        }
        if (key.indexOf("(") === -1) {
          const matching = [];
          for (const [name, fragment] of __privateGet(this, _events)) {
            if (name.split(
              "("
              /* fix:) */
            )[0] === key) {
              matching.push(fragment);
            }
          }
          if (values) {
            for (let i = matching.length - 1; i >= 0; i--) {
              if (matching[i].inputs.length < values.length) {
                matching.splice(i, 1);
              }
            }
            for (let i = matching.length - 1; i >= 0; i--) {
              const inputs = matching[i].inputs;
              for (let j = 0; j < values.length; j++) {
                if (!Typed.isTyped(values[j])) {
                  continue;
                }
                if (values[j].type !== inputs[j].baseType) {
                  matching.splice(i, 1);
                  break;
                }
              }
            }
          }
          if (matching.length === 0) {
            return null;
          }
          if (matching.length > 1 && forceUnique) {
            const matchStr = matching.map((m) => JSON.stringify(m.format())).join(", ");
            assertArgument(false, `ambiguous event description (i.e. matches ${matchStr})`, "key", key);
          }
          return matching[0];
        }
        const result = __privateGet(this, _events).get(EventFragment.from(key).format());
        if (result) {
          return result;
        }
        return null;
      };
      Interface = _Interface;
    }
  });

  // node_modules/ethers/lib.esm/abi/index.js
  var init_abi = __esm({
    "node_modules/ethers/lib.esm/abi/index.js"() {
      init_abi_coder();
      init_bytes32();
      init_fragments();
      init_interface();
      init_typed();
    }
  });

  // node_modules/ethers/lib.esm/providers/provider.js
  function getValue2(value) {
    if (value == null) {
      return null;
    }
    return value;
  }
  function toJson(value) {
    if (value == null) {
      return null;
    }
    return value.toString();
  }
  function copyRequest(req) {
    const result = {};
    if (req.to) {
      result.to = req.to;
    }
    if (req.from) {
      result.from = req.from;
    }
    if (req.data) {
      result.data = hexlify(req.data);
    }
    const bigIntKeys = "chainId,gasLimit,gasPrice,maxFeePerBlobGas,maxFeePerGas,maxPriorityFeePerGas,value".split(/,/);
    for (const key of bigIntKeys) {
      if (!(key in req) || req[key] == null) {
        continue;
      }
      result[key] = getBigInt(req[key], `request.${key}`);
    }
    const numberKeys = "type,nonce".split(/,/);
    for (const key of numberKeys) {
      if (!(key in req) || req[key] == null) {
        continue;
      }
      result[key] = getNumber(req[key], `request.${key}`);
    }
    if (req.accessList) {
      result.accessList = accessListify(req.accessList);
    }
    if (req.authorizationList) {
      result.authorizationList = req.authorizationList.slice();
    }
    if ("blockTag" in req) {
      result.blockTag = req.blockTag;
    }
    if ("enableCcipRead" in req) {
      result.enableCcipRead = !!req.enableCcipRead;
    }
    if ("customData" in req) {
      result.customData = req.customData;
    }
    if ("blobVersionedHashes" in req && req.blobVersionedHashes) {
      result.blobVersionedHashes = req.blobVersionedHashes.slice();
    }
    if ("kzg" in req) {
      result.kzg = req.kzg;
    }
    if ("blobs" in req && req.blobs) {
      result.blobs = req.blobs.map((b2) => {
        if (isBytesLike(b2)) {
          return hexlify(b2);
        }
        return Object.assign({}, b2);
      });
    }
    return result;
  }
  function createOrphanedBlockFilter(block) {
    return { orphan: "drop-block", hash: block.hash, number: block.number };
  }
  function createReorderedTransactionFilter(tx, other) {
    return { orphan: "reorder-transaction", tx, other };
  }
  function createRemovedTransactionFilter(tx) {
    return { orphan: "drop-transaction", tx };
  }
  function createRemovedLogFilter(log) {
    return { orphan: "drop-log", log: {
      transactionHash: log.transactionHash,
      blockHash: log.blockHash,
      blockNumber: log.blockNumber,
      address: log.address,
      data: log.data,
      topics: Object.freeze(log.topics.slice()),
      index: log.index
    } };
  }
  var BN_09, FeeData, _transactions, Block, Log, _logs, TransactionReceipt, _startBlock, _TransactionResponse, TransactionResponse;
  var init_provider = __esm({
    "node_modules/ethers/lib.esm/providers/provider.js"() {
      init_utils();
      init_transaction2();
      BN_09 = BigInt(0);
      FeeData = class {
        /**
         *  Creates a new FeeData for %%gasPrice%%, %%maxFeePerGas%% and
         *  %%maxPriorityFeePerGas%%.
         */
        constructor(gasPrice, maxFeePerGas, maxPriorityFeePerGas) {
          /**
           *  The gas price for legacy networks.
           */
          __publicField(this, "gasPrice");
          /**
           *  The maximum fee to pay per gas.
           *
           *  The base fee per gas is defined by the network and based on
           *  congestion, increasing the cost during times of heavy load
           *  and lowering when less busy.
           *
           *  The actual fee per gas will be the base fee for the block
           *  and the priority fee, up to the max fee per gas.
           *
           *  This will be ``null`` on legacy networks (i.e. [pre-EIP-1559](link-eip-1559))
           */
          __publicField(this, "maxFeePerGas");
          /**
           *  The additional amout to pay per gas to encourage a validator
           *  to include the transaction.
           *
           *  The purpose of this is to compensate the validator for the
           *  adjusted risk for including a given transaction.
           *
           *  This will be ``null`` on legacy networks (i.e. [pre-EIP-1559](link-eip-1559))
           */
          __publicField(this, "maxPriorityFeePerGas");
          defineProperties(this, {
            gasPrice: getValue2(gasPrice),
            maxFeePerGas: getValue2(maxFeePerGas),
            maxPriorityFeePerGas: getValue2(maxPriorityFeePerGas)
          });
        }
        /**
         *  Returns a JSON-friendly value.
         */
        toJSON() {
          const { gasPrice, maxFeePerGas, maxPriorityFeePerGas } = this;
          return {
            _type: "FeeData",
            gasPrice: toJson(gasPrice),
            maxFeePerGas: toJson(maxFeePerGas),
            maxPriorityFeePerGas: toJson(maxPriorityFeePerGas)
          };
        }
      };
      Block = class {
        /**
         *  Create a new **Block** object.
         *
         *  This should generally not be necessary as the unless implementing a
         *  low-level library.
         */
        constructor(block, provider) {
          /**
           *  The provider connected to the block used to fetch additional details
           *  if necessary.
           */
          __publicField(this, "provider");
          /**
           *  The block number, sometimes called the block height. This is a
           *  sequential number that is one higher than the parent block.
           */
          __publicField(this, "number");
          /**
           *  The block hash.
           *
           *  This hash includes all properties, so can be safely used to identify
           *  an exact set of block properties.
           */
          __publicField(this, "hash");
          /**
           *  The timestamp for this block, which is the number of seconds since
           *  epoch that this block was included.
           */
          __publicField(this, "timestamp");
          /**
           *  The block hash of the parent block.
           */
          __publicField(this, "parentHash");
          /**
           *  The hash tree root of the parent beacon block for the given
           *  execution block. See [[link-eip-4788]].
           */
          __publicField(this, "parentBeaconBlockRoot");
          /**
           *  The nonce.
           *
           *  On legacy networks, this is the random number inserted which
           *  permitted the difficulty target to be reached.
           */
          __publicField(this, "nonce");
          /**
           *  The difficulty target.
           *
           *  On legacy networks, this is the proof-of-work target required
           *  for a block to meet the protocol rules to be included.
           *
           *  On modern networks, this is a random number arrived at using
           *  randao.  @TODO: Find links?
           */
          __publicField(this, "difficulty");
          /**
           *  The total gas limit for this block.
           */
          __publicField(this, "gasLimit");
          /**
           *  The total gas used in this block.
           */
          __publicField(this, "gasUsed");
          /**
           *  The root hash for the global state after applying changes
           *  in this block.
           */
          __publicField(this, "stateRoot");
          /**
           *  The hash of the transaction receipts trie.
           */
          __publicField(this, "receiptsRoot");
          /**
           *  The total amount of blob gas consumed by the transactions
           *  within the block. See [[link-eip-4844]].
           */
          __publicField(this, "blobGasUsed");
          /**
           *  The running total of blob gas consumed in excess of the
           *  target, prior to the block. See [[link-eip-4844]].
           */
          __publicField(this, "excessBlobGas");
          /**
           *  The miner coinbase address, wihch receives any subsidies for
           *  including this block.
           */
          __publicField(this, "miner");
          /**
           *  The latest RANDAO mix of the post beacon state of
           *  the previous block.
           */
          __publicField(this, "prevRandao");
          /**
           *  Any extra data the validator wished to include.
           */
          __publicField(this, "extraData");
          /**
           *  The base fee per gas that all transactions in this block were
           *  charged.
           *
           *  This adjusts after each block, depending on how congested the network
           *  is.
           */
          __publicField(this, "baseFeePerGas");
          __privateAdd(this, _transactions);
          __privateSet(this, _transactions, block.transactions.map((tx) => {
            if (typeof tx !== "string") {
              return new TransactionResponse(tx, provider);
            }
            return tx;
          }));
          defineProperties(this, {
            provider,
            hash: getValue2(block.hash),
            number: block.number,
            timestamp: block.timestamp,
            parentHash: block.parentHash,
            parentBeaconBlockRoot: block.parentBeaconBlockRoot,
            nonce: block.nonce,
            difficulty: block.difficulty,
            gasLimit: block.gasLimit,
            gasUsed: block.gasUsed,
            blobGasUsed: block.blobGasUsed,
            excessBlobGas: block.excessBlobGas,
            miner: block.miner,
            prevRandao: getValue2(block.prevRandao),
            extraData: block.extraData,
            baseFeePerGas: getValue2(block.baseFeePerGas),
            stateRoot: block.stateRoot,
            receiptsRoot: block.receiptsRoot
          });
        }
        /**
         *  Returns the list of transaction hashes, in the order
         *  they were executed within the block.
         */
        get transactions() {
          return __privateGet(this, _transactions).map((tx) => {
            if (typeof tx === "string") {
              return tx;
            }
            return tx.hash;
          });
        }
        /**
         *  Returns the complete transactions, in the order they
         *  were executed within the block.
         *
         *  This is only available for blocks which prefetched
         *  transactions, by passing ``true`` to %%prefetchTxs%%
         *  into [[Provider-getBlock]].
         */
        get prefetchedTransactions() {
          const txs = __privateGet(this, _transactions).slice();
          if (txs.length === 0) {
            return [];
          }
          assert(typeof txs[0] === "object", "transactions were not prefetched with block request", "UNSUPPORTED_OPERATION", {
            operation: "transactionResponses()"
          });
          return txs;
        }
        /**
         *  Returns a JSON-friendly value.
         */
        toJSON() {
          const { baseFeePerGas, difficulty, extraData, gasLimit, gasUsed, hash: hash3, miner, prevRandao, nonce, number: number2, parentHash, parentBeaconBlockRoot, stateRoot, receiptsRoot, timestamp, transactions } = this;
          return {
            _type: "Block",
            baseFeePerGas: toJson(baseFeePerGas),
            difficulty: toJson(difficulty),
            extraData,
            gasLimit: toJson(gasLimit),
            gasUsed: toJson(gasUsed),
            blobGasUsed: toJson(this.blobGasUsed),
            excessBlobGas: toJson(this.excessBlobGas),
            hash: hash3,
            miner,
            prevRandao,
            nonce,
            number: number2,
            parentHash,
            timestamp,
            parentBeaconBlockRoot,
            stateRoot,
            receiptsRoot,
            transactions
          };
        }
        [Symbol.iterator]() {
          let index2 = 0;
          const txs = this.transactions;
          return {
            next: () => {
              if (index2 < this.length) {
                return {
                  value: txs[index2++],
                  done: false
                };
              }
              return { value: void 0, done: true };
            }
          };
        }
        /**
         *  The number of transactions in this block.
         */
        get length() {
          return __privateGet(this, _transactions).length;
        }
        /**
         *  The [[link-js-date]] this block was included at.
         */
        get date() {
          if (this.timestamp == null) {
            return null;
          }
          return new Date(this.timestamp * 1e3);
        }
        /**
         *  Get the transaction at %%indexe%% within this block.
         */
        async getTransaction(indexOrHash) {
          let tx = void 0;
          if (typeof indexOrHash === "number") {
            tx = __privateGet(this, _transactions)[indexOrHash];
          } else {
            const hash3 = indexOrHash.toLowerCase();
            for (const v of __privateGet(this, _transactions)) {
              if (typeof v === "string") {
                if (v !== hash3) {
                  continue;
                }
                tx = v;
                break;
              } else {
                if (v.hash !== hash3) {
                  continue;
                }
                tx = v;
                break;
              }
            }
          }
          if (tx == null) {
            throw new Error("no such tx");
          }
          if (typeof tx === "string") {
            return await this.provider.getTransaction(tx);
          } else {
            return tx;
          }
        }
        /**
         *  If a **Block** was fetched with a request to include the transactions
         *  this will allow synchronous access to those transactions.
         *
         *  If the transactions were not prefetched, this will throw.
         */
        getPrefetchedTransaction(indexOrHash) {
          const txs = this.prefetchedTransactions;
          if (typeof indexOrHash === "number") {
            return txs[indexOrHash];
          }
          indexOrHash = indexOrHash.toLowerCase();
          for (const tx of txs) {
            if (tx.hash === indexOrHash) {
              return tx;
            }
          }
          assertArgument(false, "no matching transaction", "indexOrHash", indexOrHash);
        }
        /**
         *  Returns true if this block been mined. This provides a type guard
         *  for all properties on a [[MinedBlock]].
         */
        isMined() {
          return !!this.hash;
        }
        /**
         *  Returns true if this block is an [[link-eip-2930]] block.
         */
        isLondon() {
          return !!this.baseFeePerGas;
        }
        /**
         *  @_ignore:
         */
        orphanedEvent() {
          if (!this.isMined()) {
            throw new Error("");
          }
          return createOrphanedBlockFilter(this);
        }
      };
      _transactions = new WeakMap();
      Log = class {
        /**
         *  @_ignore:
         */
        constructor(log, provider) {
          /**
           *  The provider connected to the log used to fetch additional details
           *  if necessary.
           */
          __publicField(this, "provider");
          /**
           *  The transaction hash of the transaction this log occurred in. Use the
           *  [[Log-getTransaction]] to get the [[TransactionResponse]].
           */
          __publicField(this, "transactionHash");
          /**
           *  The block hash of the block this log occurred in. Use the
           *  [[Log-getBlock]] to get the [[Block]].
           */
          __publicField(this, "blockHash");
          /**
           *  The block number of the block this log occurred in. It is preferred
           *  to use the [[Block-hash]] when fetching the related [[Block]],
           *  since in the case of an orphaned block, the block at that height may
           *  have changed.
           */
          __publicField(this, "blockNumber");
          /**
           *  If the **Log** represents a block that was removed due to an orphaned
           *  block, this will be true.
           *
           *  This can only happen within an orphan event listener.
           */
          __publicField(this, "removed");
          /**
           *  The address of the contract that emitted this log.
           */
          __publicField(this, "address");
          /**
           *  The data included in this log when it was emitted.
           */
          __publicField(this, "data");
          /**
           *  The indexed topics included in this log when it was emitted.
           *
           *  All topics are included in the bloom filters, so they can be
           *  efficiently filtered using the [[Provider-getLogs]] method.
           */
          __publicField(this, "topics");
          /**
           *  The index within the block this log occurred at. This is generally
           *  not useful to developers, but can be used with the various roots
           *  to proof inclusion within a block.
           */
          __publicField(this, "index");
          /**
           *  The index within the transaction of this log.
           */
          __publicField(this, "transactionIndex");
          this.provider = provider;
          const topics = Object.freeze(log.topics.slice());
          defineProperties(this, {
            transactionHash: log.transactionHash,
            blockHash: log.blockHash,
            blockNumber: log.blockNumber,
            removed: log.removed,
            address: log.address,
            data: log.data,
            topics,
            index: log.index,
            transactionIndex: log.transactionIndex
          });
        }
        /**
         *  Returns a JSON-compatible object.
         */
        toJSON() {
          const { address, blockHash, blockNumber, data, index: index2, removed, topics, transactionHash, transactionIndex } = this;
          return {
            _type: "log",
            address,
            blockHash,
            blockNumber,
            data,
            index: index2,
            removed,
            topics,
            transactionHash,
            transactionIndex
          };
        }
        /**
         *  Returns the block that this log occurred in.
         */
        async getBlock() {
          const block = await this.provider.getBlock(this.blockHash);
          assert(!!block, "failed to find transaction", "UNKNOWN_ERROR", {});
          return block;
        }
        /**
         *  Returns the transaction that this log occurred in.
         */
        async getTransaction() {
          const tx = await this.provider.getTransaction(this.transactionHash);
          assert(!!tx, "failed to find transaction", "UNKNOWN_ERROR", {});
          return tx;
        }
        /**
         *  Returns the transaction receipt fot the transaction that this
         *  log occurred in.
         */
        async getTransactionReceipt() {
          const receipt = await this.provider.getTransactionReceipt(this.transactionHash);
          assert(!!receipt, "failed to find transaction receipt", "UNKNOWN_ERROR", {});
          return receipt;
        }
        /**
         *  @_ignore:
         */
        removedEvent() {
          return createRemovedLogFilter(this);
        }
      };
      TransactionReceipt = class {
        /**
         *  @_ignore:
         */
        constructor(tx, provider) {
          /**
           *  The provider connected to the log used to fetch additional details
           *  if necessary.
           */
          __publicField(this, "provider");
          /**
           *  The address the transaction was sent to.
           */
          __publicField(this, "to");
          /**
           *  The sender of the transaction.
           */
          __publicField(this, "from");
          /**
           *  The address of the contract if the transaction was directly
           *  responsible for deploying one.
           *
           *  This is non-null **only** if the ``to`` is empty and the ``data``
           *  was successfully executed as initcode.
           */
          __publicField(this, "contractAddress");
          /**
           *  The transaction hash.
           */
          __publicField(this, "hash");
          /**
           *  The index of this transaction within the block transactions.
           */
          __publicField(this, "index");
          /**
           *  The block hash of the [[Block]] this transaction was included in.
           */
          __publicField(this, "blockHash");
          /**
           *  The block number of the [[Block]] this transaction was included in.
           */
          __publicField(this, "blockNumber");
          /**
           *  The bloom filter bytes that represent all logs that occurred within
           *  this transaction. This is generally not useful for most developers,
           *  but can be used to validate the included logs.
           */
          __publicField(this, "logsBloom");
          /**
           *  The actual amount of gas used by this transaction.
           *
           *  When creating a transaction, the amount of gas that will be used can
           *  only be approximated, but the sender must pay the gas fee for the
           *  entire gas limit. After the transaction, the difference is refunded.
           */
          __publicField(this, "gasUsed");
          /**
           *  The gas used for BLObs. See [[link-eip-4844]].
           */
          __publicField(this, "blobGasUsed");
          /**
           *  The amount of gas used by all transactions within the block for this
           *  and all transactions with a lower ``index``.
           *
           *  This is generally not useful for developers but can be used to
           *  validate certain aspects of execution.
           */
          __publicField(this, "cumulativeGasUsed");
          /**
           *  The actual gas price used during execution.
           *
           *  Due to the complexity of [[link-eip-1559]] this value can only
           *  be caluclated after the transaction has been mined, snce the base
           *  fee is protocol-enforced.
           */
          __publicField(this, "gasPrice");
          /**
           *  The price paid per BLOB in gas. See [[link-eip-4844]].
           */
          __publicField(this, "blobGasPrice");
          /**
           *  The [[link-eip-2718]] transaction type.
           */
          __publicField(this, "type");
          //readonly byzantium!: boolean;
          /**
           *  The status of this transaction, indicating success (i.e. ``1``) or
           *  a revert (i.e. ``0``).
           *
           *  This is available in post-byzantium blocks, but some backends may
           *  backfill this value.
           */
          __publicField(this, "status");
          /**
           *  The root hash of this transaction.
           *
           *  This is no present and was only included in pre-byzantium blocks, but
           *  could be used to validate certain parts of the receipt.
           */
          __publicField(this, "root");
          __privateAdd(this, _logs);
          __privateSet(this, _logs, Object.freeze(tx.logs.map((log) => {
            return new Log(log, provider);
          })));
          let gasPrice = BN_09;
          if (tx.effectiveGasPrice != null) {
            gasPrice = tx.effectiveGasPrice;
          } else if (tx.gasPrice != null) {
            gasPrice = tx.gasPrice;
          }
          defineProperties(this, {
            provider,
            to: tx.to,
            from: tx.from,
            contractAddress: tx.contractAddress,
            hash: tx.hash,
            index: tx.index,
            blockHash: tx.blockHash,
            blockNumber: tx.blockNumber,
            logsBloom: tx.logsBloom,
            gasUsed: tx.gasUsed,
            cumulativeGasUsed: tx.cumulativeGasUsed,
            blobGasUsed: tx.blobGasUsed,
            gasPrice,
            blobGasPrice: tx.blobGasPrice,
            type: tx.type,
            //byzantium: tx.byzantium,
            status: tx.status,
            root: tx.root
          });
        }
        /**
         *  The logs for this transaction.
         */
        get logs() {
          return __privateGet(this, _logs);
        }
        /**
         *  Returns a JSON-compatible representation.
         */
        toJSON() {
          const {
            to,
            from: from5,
            contractAddress,
            hash: hash3,
            index: index2,
            blockHash,
            blockNumber,
            logsBloom,
            logs,
            //byzantium, 
            status,
            root
          } = this;
          return {
            _type: "TransactionReceipt",
            blockHash,
            blockNumber,
            //byzantium, 
            contractAddress,
            cumulativeGasUsed: toJson(this.cumulativeGasUsed),
            from: from5,
            gasPrice: toJson(this.gasPrice),
            blobGasUsed: toJson(this.blobGasUsed),
            blobGasPrice: toJson(this.blobGasPrice),
            gasUsed: toJson(this.gasUsed),
            hash: hash3,
            index: index2,
            logs,
            logsBloom,
            root,
            status,
            to
          };
        }
        /**
         *  @_ignore:
         */
        get length() {
          return this.logs.length;
        }
        [Symbol.iterator]() {
          let index2 = 0;
          return {
            next: () => {
              if (index2 < this.length) {
                return { value: this.logs[index2++], done: false };
              }
              return { value: void 0, done: true };
            }
          };
        }
        /**
         *  The total fee for this transaction, in wei.
         */
        get fee() {
          return this.gasUsed * this.gasPrice;
        }
        /**
         *  Resolves to the block this transaction occurred in.
         */
        async getBlock() {
          const block = await this.provider.getBlock(this.blockHash);
          if (block == null) {
            throw new Error("TODO");
          }
          return block;
        }
        /**
         *  Resolves to the transaction this transaction occurred in.
         */
        async getTransaction() {
          const tx = await this.provider.getTransaction(this.hash);
          if (tx == null) {
            throw new Error("TODO");
          }
          return tx;
        }
        /**
         *  Resolves to the return value of the execution of this transaction.
         *
         *  Support for this feature is limited, as it requires an archive node
         *  with the ``debug_`` or ``trace_`` API enabled.
         */
        async getResult() {
          return await this.provider.getTransactionResult(this.hash);
        }
        /**
         *  Resolves to the number of confirmations this transaction has.
         */
        async confirmations() {
          return await this.provider.getBlockNumber() - this.blockNumber + 1;
        }
        /**
         *  @_ignore:
         */
        removedEvent() {
          return createRemovedTransactionFilter(this);
        }
        /**
         *  @_ignore:
         */
        reorderedEvent(other) {
          assert(!other || other.isMined(), "unmined 'other' transction cannot be orphaned", "UNSUPPORTED_OPERATION", { operation: "reorderedEvent(other)" });
          return createReorderedTransactionFilter(this, other);
        }
      };
      _logs = new WeakMap();
      _TransactionResponse = class _TransactionResponse {
        /**
         *  @_ignore:
         */
        constructor(tx, provider) {
          /**
           *  The provider this is connected to, which will influence how its
           *  methods will resolve its async inspection methods.
           */
          __publicField(this, "provider");
          /**
           *  The block number of the block that this transaction was included in.
           *
           *  This is ``null`` for pending transactions.
           */
          __publicField(this, "blockNumber");
          /**
           *  The blockHash of the block that this transaction was included in.
           *
           *  This is ``null`` for pending transactions.
           */
          __publicField(this, "blockHash");
          /**
           *  The index within the block that this transaction resides at.
           */
          __publicField(this, "index");
          /**
           *  The transaction hash.
           */
          __publicField(this, "hash");
          /**
           *  The [[link-eip-2718]] transaction envelope type. This is
           *  ``0`` for legacy transactions types.
           */
          __publicField(this, "type");
          /**
           *  The receiver of this transaction.
           *
           *  If ``null``, then the transaction is an initcode transaction.
           *  This means the result of executing the [[data]] will be deployed
           *  as a new contract on chain (assuming it does not revert) and the
           *  address may be computed using [[getCreateAddress]].
           */
          __publicField(this, "to");
          /**
           *  The sender of this transaction. It is implicitly computed
           *  from the transaction pre-image hash (as the digest) and the
           *  [[signature]] using ecrecover.
           */
          __publicField(this, "from");
          /**
           *  The nonce, which is used to prevent replay attacks and offer
           *  a method to ensure transactions from a given sender are explicitly
           *  ordered.
           *
           *  When sending a transaction, this must be equal to the number of
           *  transactions ever sent by [[from]].
           */
          __publicField(this, "nonce");
          /**
           *  The maximum units of gas this transaction can consume. If execution
           *  exceeds this, the entries transaction is reverted and the sender
           *  is charged for the full amount, despite not state changes being made.
           */
          __publicField(this, "gasLimit");
          /**
           *  The gas price can have various values, depending on the network.
           *
           *  In modern networks, for transactions that are included this is
           *  the //effective gas price// (the fee per gas that was actually
           *  charged), while for transactions that have not been included yet
           *  is the [[maxFeePerGas]].
           *
           *  For legacy transactions, or transactions on legacy networks, this
           *  is the fee that will be charged per unit of gas the transaction
           *  consumes.
           */
          __publicField(this, "gasPrice");
          /**
           *  The maximum priority fee (per unit of gas) to allow a
           *  validator to charge the sender. This is inclusive of the
           *  [[maxFeeFeePerGas]].
           */
          __publicField(this, "maxPriorityFeePerGas");
          /**
           *  The maximum fee (per unit of gas) to allow this transaction
           *  to charge the sender.
           */
          __publicField(this, "maxFeePerGas");
          /**
           *  The [[link-eip-4844]] max fee per BLOb gas.
           */
          __publicField(this, "maxFeePerBlobGas");
          /**
           *  The data.
           */
          __publicField(this, "data");
          /**
           *  The value, in wei. Use [[formatEther]] to format this value
           *  as ether.
           */
          __publicField(this, "value");
          /**
           *  The chain ID.
           */
          __publicField(this, "chainId");
          /**
           *  The signature.
           */
          __publicField(this, "signature");
          /**
           *  The [[link-eip-2930]] access list for transaction types that
           *  support it, otherwise ``null``.
           */
          __publicField(this, "accessList");
          /**
           *  The [[link-eip-4844]] BLOb versioned hashes.
           */
          __publicField(this, "blobVersionedHashes");
          /**
           *  The [[link-eip-7702]] authorizations (if any).
           */
          __publicField(this, "authorizationList");
          __privateAdd(this, _startBlock);
          this.provider = provider;
          this.blockNumber = tx.blockNumber != null ? tx.blockNumber : null;
          this.blockHash = tx.blockHash != null ? tx.blockHash : null;
          this.hash = tx.hash;
          this.index = tx.index;
          this.type = tx.type;
          this.from = tx.from;
          this.to = tx.to || null;
          this.gasLimit = tx.gasLimit;
          this.nonce = tx.nonce;
          this.data = tx.data;
          this.value = tx.value;
          this.gasPrice = tx.gasPrice;
          this.maxPriorityFeePerGas = tx.maxPriorityFeePerGas != null ? tx.maxPriorityFeePerGas : null;
          this.maxFeePerGas = tx.maxFeePerGas != null ? tx.maxFeePerGas : null;
          this.maxFeePerBlobGas = tx.maxFeePerBlobGas != null ? tx.maxFeePerBlobGas : null;
          this.chainId = tx.chainId;
          this.signature = tx.signature;
          this.accessList = tx.accessList != null ? tx.accessList : null;
          this.blobVersionedHashes = tx.blobVersionedHashes != null ? tx.blobVersionedHashes : null;
          this.authorizationList = tx.authorizationList != null ? tx.authorizationList : null;
          __privateSet(this, _startBlock, -1);
        }
        /**
         *  Returns a JSON-compatible representation of this transaction.
         */
        toJSON() {
          const { blockNumber, blockHash, index: index2, hash: hash3, type, to, from: from5, nonce, data, signature, accessList, blobVersionedHashes } = this;
          return {
            _type: "TransactionResponse",
            accessList,
            blockNumber,
            blockHash,
            blobVersionedHashes,
            chainId: toJson(this.chainId),
            data,
            from: from5,
            gasLimit: toJson(this.gasLimit),
            gasPrice: toJson(this.gasPrice),
            hash: hash3,
            maxFeePerGas: toJson(this.maxFeePerGas),
            maxPriorityFeePerGas: toJson(this.maxPriorityFeePerGas),
            maxFeePerBlobGas: toJson(this.maxFeePerBlobGas),
            nonce,
            signature,
            to,
            index: index2,
            type,
            value: toJson(this.value)
          };
        }
        /**
         *  Resolves to the Block that this transaction was included in.
         *
         *  This will return null if the transaction has not been included yet.
         */
        async getBlock() {
          let blockNumber = this.blockNumber;
          if (blockNumber == null) {
            const tx = await this.getTransaction();
            if (tx) {
              blockNumber = tx.blockNumber;
            }
          }
          if (blockNumber == null) {
            return null;
          }
          const block = this.provider.getBlock(blockNumber);
          if (block == null) {
            throw new Error("TODO");
          }
          return block;
        }
        /**
         *  Resolves to this transaction being re-requested from the
         *  provider. This can be used if you have an unmined transaction
         *  and wish to get an up-to-date populated instance.
         */
        async getTransaction() {
          return this.provider.getTransaction(this.hash);
        }
        /**
         *  Resolve to the number of confirmations this transaction has.
         */
        async confirmations() {
          if (this.blockNumber == null) {
            const { tx, blockNumber: blockNumber2 } = await resolveProperties({
              tx: this.getTransaction(),
              blockNumber: this.provider.getBlockNumber()
            });
            if (tx == null || tx.blockNumber == null) {
              return 0;
            }
            return blockNumber2 - tx.blockNumber + 1;
          }
          const blockNumber = await this.provider.getBlockNumber();
          return blockNumber - this.blockNumber + 1;
        }
        /**
         *  Resolves once this transaction has been mined and has
         *  %%confirms%% blocks including it (default: ``1``) with an
         *  optional %%timeout%%.
         *
         *  This can resolve to ``null`` only if %%confirms%% is ``0``
         *  and the transaction has not been mined, otherwise this will
         *  wait until enough confirmations have completed.
         */
        async wait(_confirms, _timeout2) {
          const confirms = _confirms == null ? 1 : _confirms;
          const timeout = _timeout2 == null ? 0 : _timeout2;
          let startBlock = __privateGet(this, _startBlock);
          let nextScan = -1;
          let stopScanning = startBlock === -1 ? true : false;
          const checkReplacement = async () => {
            if (stopScanning) {
              return null;
            }
            const { blockNumber, nonce } = await resolveProperties({
              blockNumber: this.provider.getBlockNumber(),
              nonce: this.provider.getTransactionCount(this.from)
            });
            if (nonce < this.nonce) {
              startBlock = blockNumber;
              return;
            }
            if (stopScanning) {
              return null;
            }
            const mined = await this.getTransaction();
            if (mined && mined.blockNumber != null) {
              return;
            }
            if (nextScan === -1) {
              nextScan = startBlock - 3;
              if (nextScan < __privateGet(this, _startBlock)) {
                nextScan = __privateGet(this, _startBlock);
              }
            }
            while (nextScan <= blockNumber) {
              if (stopScanning) {
                return null;
              }
              const block = await this.provider.getBlock(nextScan, true);
              if (block == null) {
                return;
              }
              for (const hash3 of block) {
                if (hash3 === this.hash) {
                  return;
                }
              }
              for (let i = 0; i < block.length; i++) {
                const tx = await block.getTransaction(i);
                if (tx.from === this.from && tx.nonce === this.nonce) {
                  if (stopScanning) {
                    return null;
                  }
                  const receipt2 = await this.provider.getTransactionReceipt(tx.hash);
                  if (receipt2 == null) {
                    return;
                  }
                  if (blockNumber - receipt2.blockNumber + 1 < confirms) {
                    return;
                  }
                  let reason = "replaced";
                  if (tx.data === this.data && tx.to === this.to && tx.value === this.value) {
                    reason = "repriced";
                  } else if (tx.data === "0x" && tx.from === tx.to && tx.value === BN_09) {
                    reason = "cancelled";
                  }
                  assert(false, "transaction was replaced", "TRANSACTION_REPLACED", {
                    cancelled: reason === "replaced" || reason === "cancelled",
                    reason,
                    replacement: tx.replaceableTransaction(startBlock),
                    hash: tx.hash,
                    receipt: receipt2
                  });
                }
              }
              nextScan++;
            }
            return;
          };
          const checkReceipt = (receipt2) => {
            if (receipt2 == null || receipt2.status !== 0) {
              return receipt2;
            }
            assert(false, "transaction execution reverted", "CALL_EXCEPTION", {
              action: "sendTransaction",
              data: null,
              reason: null,
              invocation: null,
              revert: null,
              transaction: {
                to: receipt2.to,
                from: receipt2.from,
                data: ""
                // @TODO: in v7, split out sendTransaction properties
              },
              receipt: receipt2
            });
          };
          const receipt = await this.provider.getTransactionReceipt(this.hash);
          if (confirms === 0) {
            return checkReceipt(receipt);
          }
          if (receipt) {
            if (confirms === 1 || await receipt.confirmations() >= confirms) {
              return checkReceipt(receipt);
            }
          } else {
            await checkReplacement();
            if (confirms === 0) {
              return null;
            }
          }
          const waiter = new Promise((resolve, reject) => {
            const cancellers = [];
            const cancel = () => {
              cancellers.forEach((c) => c());
            };
            cancellers.push(() => {
              stopScanning = true;
            });
            if (timeout > 0) {
              const timer = setTimeout(() => {
                cancel();
                reject(makeError("wait for transaction timeout", "TIMEOUT"));
              }, timeout);
              cancellers.push(() => {
                clearTimeout(timer);
              });
            }
            const txListener = async (receipt2) => {
              if (await receipt2.confirmations() >= confirms) {
                cancel();
                try {
                  resolve(checkReceipt(receipt2));
                } catch (error) {
                  reject(error);
                }
              }
            };
            cancellers.push(() => {
              this.provider.off(this.hash, txListener);
            });
            this.provider.on(this.hash, txListener);
            if (startBlock >= 0) {
              const replaceListener = async () => {
                try {
                  await checkReplacement();
                } catch (error) {
                  if (isError(error, "TRANSACTION_REPLACED")) {
                    cancel();
                    reject(error);
                    return;
                  }
                }
                if (!stopScanning) {
                  this.provider.once("block", replaceListener);
                }
              };
              cancellers.push(() => {
                this.provider.off("block", replaceListener);
              });
              this.provider.once("block", replaceListener);
            }
          });
          return await waiter;
        }
        /**
         *  Returns ``true`` if this transaction has been included.
         *
         *  This is effective only as of the time the TransactionResponse
         *  was instantiated. To get up-to-date information, use
         *  [[getTransaction]].
         *
         *  This provides a Type Guard that this transaction will have
         *  non-null property values for properties that are null for
         *  unmined transactions.
         */
        isMined() {
          return this.blockHash != null;
        }
        /**
         *  Returns true if the transaction is a legacy (i.e. ``type == 0``)
         *  transaction.
         *
         *  This provides a Type Guard that this transaction will have
         *  the ``null``-ness for hardfork-specific properties set correctly.
         */
        isLegacy() {
          return this.type === 0;
        }
        /**
         *  Returns true if the transaction is a Berlin (i.e. ``type == 1``)
         *  transaction. See [[link-eip-2070]].
         *
         *  This provides a Type Guard that this transaction will have
         *  the ``null``-ness for hardfork-specific properties set correctly.
         */
        isBerlin() {
          return this.type === 1;
        }
        /**
         *  Returns true if the transaction is a London (i.e. ``type == 2``)
         *  transaction. See [[link-eip-1559]].
         *
         *  This provides a Type Guard that this transaction will have
         *  the ``null``-ness for hardfork-specific properties set correctly.
         */
        isLondon() {
          return this.type === 2;
        }
        /**
         *  Returns true if hte transaction is a Cancun (i.e. ``type == 3``)
         *  transaction. See [[link-eip-4844]].
         */
        isCancun() {
          return this.type === 3;
        }
        /**
         *  Returns a filter which can be used to listen for orphan events
         *  that evict this transaction.
         */
        removedEvent() {
          assert(this.isMined(), "unmined transaction canot be orphaned", "UNSUPPORTED_OPERATION", { operation: "removeEvent()" });
          return createRemovedTransactionFilter(this);
        }
        /**
         *  Returns a filter which can be used to listen for orphan events
         *  that re-order this event against %%other%%.
         */
        reorderedEvent(other) {
          assert(this.isMined(), "unmined transaction canot be orphaned", "UNSUPPORTED_OPERATION", { operation: "removeEvent()" });
          assert(!other || other.isMined(), "unmined 'other' transaction canot be orphaned", "UNSUPPORTED_OPERATION", { operation: "removeEvent()" });
          return createReorderedTransactionFilter(this, other);
        }
        /**
         *  Returns a new TransactionResponse instance which has the ability to
         *  detect (and throw an error) if the transaction is replaced, which
         *  will begin scanning at %%startBlock%%.
         *
         *  This should generally not be used by developers and is intended
         *  primarily for internal use. Setting an incorrect %%startBlock%% can
         *  have devastating performance consequences if used incorrectly.
         */
        replaceableTransaction(startBlock) {
          assertArgument(Number.isInteger(startBlock) && startBlock >= 0, "invalid startBlock", "startBlock", startBlock);
          const tx = new _TransactionResponse(this, this.provider);
          __privateSet(tx, _startBlock, startBlock);
          return tx;
        }
      };
      _startBlock = new WeakMap();
      TransactionResponse = _TransactionResponse;
    }
  });

  // node_modules/ethers/lib.esm/contract/wrappers.js
  var EventLog, UndecodedEventLog, _iface, ContractTransactionReceipt, _iface2, ContractTransactionResponse, ContractUnknownEventPayload, ContractEventPayload;
  var init_wrappers = __esm({
    "node_modules/ethers/lib.esm/contract/wrappers.js"() {
      init_provider();
      init_utils();
      EventLog = class extends Log {
        /**
         * @_ignore:
         */
        constructor(log, iface, fragment) {
          super(log, log.provider);
          /**
           *  The Contract Interface.
           */
          __publicField(this, "interface");
          /**
           *  The matching event.
           */
          __publicField(this, "fragment");
          /**
           *  The parsed arguments passed to the event by ``emit``.
           */
          __publicField(this, "args");
          const args = iface.decodeEventLog(fragment, log.data, log.topics);
          defineProperties(this, { args, fragment, interface: iface });
        }
        /**
         *  The name of the event.
         */
        get eventName() {
          return this.fragment.name;
        }
        /**
         *  The signature of the event.
         */
        get eventSignature() {
          return this.fragment.format();
        }
      };
      UndecodedEventLog = class extends Log {
        /**
         * @_ignore:
         */
        constructor(log, error) {
          super(log, log.provider);
          /**
           *  The error encounted when trying to decode the log.
           */
          __publicField(this, "error");
          defineProperties(this, { error });
        }
      };
      ContractTransactionReceipt = class extends TransactionReceipt {
        /**
         *  @_ignore:
         */
        constructor(iface, provider, tx) {
          super(tx, provider);
          __privateAdd(this, _iface);
          __privateSet(this, _iface, iface);
        }
        /**
         *  The parsed logs for any [[Log]] which has a matching event in the
         *  Contract ABI.
         */
        get logs() {
          return super.logs.map((log) => {
            const fragment = log.topics.length ? __privateGet(this, _iface).getEvent(log.topics[0]) : null;
            if (fragment) {
              try {
                return new EventLog(log, __privateGet(this, _iface), fragment);
              } catch (error) {
                return new UndecodedEventLog(log, error);
              }
            }
            return log;
          });
        }
      };
      _iface = new WeakMap();
      ContractTransactionResponse = class extends TransactionResponse {
        /**
         *  @_ignore:
         */
        constructor(iface, provider, tx) {
          super(tx, provider);
          __privateAdd(this, _iface2);
          __privateSet(this, _iface2, iface);
        }
        /**
         *  Resolves once this transaction has been mined and has
         *  %%confirms%% blocks including it (default: ``1``) with an
         *  optional %%timeout%%.
         *
         *  This can resolve to ``null`` only if %%confirms%% is ``0``
         *  and the transaction has not been mined, otherwise this will
         *  wait until enough confirmations have completed.
         */
        async wait(confirms, timeout) {
          const receipt = await super.wait(confirms, timeout);
          if (receipt == null) {
            return null;
          }
          return new ContractTransactionReceipt(__privateGet(this, _iface2), this.provider, receipt);
        }
      };
      _iface2 = new WeakMap();
      ContractUnknownEventPayload = class extends EventPayload {
        /**
         *  @_event:
         */
        constructor(contract, listener, filter, log) {
          super(contract, listener, filter);
          /**
           *  The log with no matching events.
           */
          __publicField(this, "log");
          defineProperties(this, { log });
        }
        /**
         *  Resolves to the block the event occured in.
         */
        async getBlock() {
          return await this.log.getBlock();
        }
        /**
         *  Resolves to the transaction the event occured in.
         */
        async getTransaction() {
          return await this.log.getTransaction();
        }
        /**
         *  Resolves to the transaction receipt the event occured in.
         */
        async getTransactionReceipt() {
          return await this.log.getTransactionReceipt();
        }
      };
      ContractEventPayload = class extends ContractUnknownEventPayload {
        /**
         *  @_ignore:
         */
        constructor(contract, listener, filter, fragment, _log) {
          super(contract, listener, filter, new EventLog(_log, contract.interface, fragment));
          const args = contract.interface.decodeEventLog(fragment, this.log.data, this.log.topics);
          defineProperties(this, { args, fragment });
        }
        /**
         *  The event name.
         */
        get eventName() {
          return this.fragment.name;
        }
        /**
         *  The event signature.
         */
        get eventSignature() {
          return this.fragment.format();
        }
      };
    }
  });

  // node_modules/ethers/lib.esm/contract/contract.js
  function canCall(value) {
    return value && typeof value.call === "function";
  }
  function canEstimate(value) {
    return value && typeof value.estimateGas === "function";
  }
  function canResolve(value) {
    return value && typeof value.resolveName === "function";
  }
  function canSend(value) {
    return value && typeof value.sendTransaction === "function";
  }
  function getResolver(value) {
    if (value != null) {
      if (canResolve(value)) {
        return value;
      }
      if (value.provider) {
        return value.provider;
      }
    }
    return void 0;
  }
  function getRunner(value, feature) {
    if (value == null) {
      return null;
    }
    if (typeof value[feature] === "function") {
      return value;
    }
    if (value.provider && typeof value.provider[feature] === "function") {
      return value.provider;
    }
    return null;
  }
  function getProvider(value) {
    if (value == null) {
      return null;
    }
    return value.provider || null;
  }
  async function copyOverrides(arg, allowed) {
    const _overrides = Typed.dereference(arg, "overrides");
    assertArgument(typeof _overrides === "object", "invalid overrides parameter", "overrides", arg);
    const overrides = copyRequest(_overrides);
    assertArgument(overrides.to == null || (allowed || []).indexOf("to") >= 0, "cannot override to", "overrides.to", overrides.to);
    assertArgument(overrides.data == null || (allowed || []).indexOf("data") >= 0, "cannot override data", "overrides.data", overrides.data);
    if (overrides.from) {
      overrides.from = overrides.from;
    }
    return overrides;
  }
  async function resolveArgs(_runner, inputs, args) {
    const runner = getRunner(_runner, "resolveName");
    const resolver = canResolve(runner) ? runner : null;
    return await Promise.all(inputs.map((param, index2) => {
      return param.walkAsync(args[index2], (type, value) => {
        value = Typed.dereference(value, type);
        if (type === "address") {
          return resolveAddress(value, resolver);
        }
        return value;
      });
    }));
  }
  function buildWrappedFallback(contract) {
    const populateTransaction = async function(overrides) {
      const tx = await copyOverrides(overrides, ["data"]);
      tx.to = await contract.getAddress();
      if (tx.from) {
        tx.from = await resolveAddress(tx.from, getResolver(contract.runner));
      }
      const iface = contract.interface;
      const noValue = getBigInt(tx.value || BN_010, "overrides.value") === BN_010;
      const noData = (tx.data || "0x") === "0x";
      if (iface.fallback && !iface.fallback.payable && iface.receive && !noData && !noValue) {
        assertArgument(false, "cannot send data to receive or send value to non-payable fallback", "overrides", overrides);
      }
      assertArgument(iface.fallback || noData, "cannot send data to receive-only contract", "overrides.data", tx.data);
      const payable = iface.receive || iface.fallback && iface.fallback.payable;
      assertArgument(payable || noValue, "cannot send value to non-payable fallback", "overrides.value", tx.value);
      assertArgument(iface.fallback || noData, "cannot send data to receive-only contract", "overrides.data", tx.data);
      return tx;
    };
    const staticCall = async function(overrides) {
      const runner = getRunner(contract.runner, "call");
      assert(canCall(runner), "contract runner does not support calling", "UNSUPPORTED_OPERATION", { operation: "call" });
      const tx = await populateTransaction(overrides);
      try {
        return await runner.call(tx);
      } catch (error) {
        if (isCallException(error) && error.data) {
          throw contract.interface.makeError(error.data, tx);
        }
        throw error;
      }
    };
    const send = async function(overrides) {
      const runner = contract.runner;
      assert(canSend(runner), "contract runner does not support sending transactions", "UNSUPPORTED_OPERATION", { operation: "sendTransaction" });
      const tx = await runner.sendTransaction(await populateTransaction(overrides));
      const provider = getProvider(contract.runner);
      return new ContractTransactionResponse(contract.interface, provider, tx);
    };
    const estimateGas2 = async function(overrides) {
      const runner = getRunner(contract.runner, "estimateGas");
      assert(canEstimate(runner), "contract runner does not support gas estimation", "UNSUPPORTED_OPERATION", { operation: "estimateGas" });
      return await runner.estimateGas(await populateTransaction(overrides));
    };
    const method = async (overrides) => {
      return await send(overrides);
    };
    defineProperties(method, {
      _contract: contract,
      estimateGas: estimateGas2,
      populateTransaction,
      send,
      staticCall
    });
    return method;
  }
  function buildWrappedMethod(contract, key) {
    const getFragment = function(...args) {
      const fragment = contract.interface.getFunction(key, args);
      assert(fragment, "no matching fragment", "UNSUPPORTED_OPERATION", {
        operation: "fragment",
        info: { key, args }
      });
      return fragment;
    };
    const populateTransaction = async function(...args) {
      const fragment = getFragment(...args);
      let overrides = {};
      if (fragment.inputs.length + 1 === args.length) {
        overrides = await copyOverrides(args.pop());
        if (overrides.from) {
          overrides.from = await resolveAddress(overrides.from, getResolver(contract.runner));
        }
      }
      if (fragment.inputs.length !== args.length) {
        throw new Error("internal error: fragment inputs doesn't match arguments; should not happen");
      }
      const resolvedArgs = await resolveArgs(contract.runner, fragment.inputs, args);
      return Object.assign({}, overrides, await resolveProperties({
        to: contract.getAddress(),
        data: contract.interface.encodeFunctionData(fragment, resolvedArgs)
      }));
    };
    const staticCall = async function(...args) {
      const result = await staticCallResult(...args);
      if (result.length === 1) {
        return result[0];
      }
      return result;
    };
    const send = async function(...args) {
      const runner = contract.runner;
      assert(canSend(runner), "contract runner does not support sending transactions", "UNSUPPORTED_OPERATION", { operation: "sendTransaction" });
      const tx = await runner.sendTransaction(await populateTransaction(...args));
      const provider = getProvider(contract.runner);
      return new ContractTransactionResponse(contract.interface, provider, tx);
    };
    const estimateGas2 = async function(...args) {
      const runner = getRunner(contract.runner, "estimateGas");
      assert(canEstimate(runner), "contract runner does not support gas estimation", "UNSUPPORTED_OPERATION", { operation: "estimateGas" });
      return await runner.estimateGas(await populateTransaction(...args));
    };
    const staticCallResult = async function(...args) {
      const runner = getRunner(contract.runner, "call");
      assert(canCall(runner), "contract runner does not support calling", "UNSUPPORTED_OPERATION", { operation: "call" });
      const tx = await populateTransaction(...args);
      let result = "0x";
      try {
        result = await runner.call(tx);
      } catch (error) {
        if (isCallException(error) && error.data) {
          throw contract.interface.makeError(error.data, tx);
        }
        throw error;
      }
      const fragment = getFragment(...args);
      return contract.interface.decodeFunctionResult(fragment, result);
    };
    const method = async (...args) => {
      const fragment = getFragment(...args);
      if (fragment.constant) {
        return await staticCall(...args);
      }
      return await send(...args);
    };
    defineProperties(method, {
      name: contract.interface.getFunctionName(key),
      _contract: contract,
      _key: key,
      getFragment,
      estimateGas: estimateGas2,
      populateTransaction,
      send,
      staticCall,
      staticCallResult
    });
    Object.defineProperty(method, "fragment", {
      configurable: false,
      enumerable: true,
      get: () => {
        const fragment = contract.interface.getFunction(key);
        assert(fragment, "no matching fragment", "UNSUPPORTED_OPERATION", {
          operation: "fragment",
          info: { key }
        });
        return fragment;
      }
    });
    return method;
  }
  function buildWrappedEvent(contract, key) {
    const getFragment = function(...args) {
      const fragment = contract.interface.getEvent(key, args);
      assert(fragment, "no matching fragment", "UNSUPPORTED_OPERATION", {
        operation: "fragment",
        info: { key, args }
      });
      return fragment;
    };
    const method = function(...args) {
      return new PreparedTopicFilter(contract, getFragment(...args), args);
    };
    defineProperties(method, {
      name: contract.interface.getEventName(key),
      _contract: contract,
      _key: key,
      getFragment
    });
    Object.defineProperty(method, "fragment", {
      configurable: false,
      enumerable: true,
      get: () => {
        const fragment = contract.interface.getEvent(key);
        assert(fragment, "no matching fragment", "UNSUPPORTED_OPERATION", {
          operation: "fragment",
          info: { key }
        });
        return fragment;
      }
    });
    return method;
  }
  function setInternal(contract, values) {
    internalValues.set(contract[internal2], values);
  }
  function getInternal(contract) {
    return internalValues.get(contract[internal2]);
  }
  function isDeferred(value) {
    return value && typeof value === "object" && "getTopicFilter" in value && typeof value.getTopicFilter === "function" && value.fragment;
  }
  async function getSubInfo(contract, event) {
    let topics;
    let fragment = null;
    if (Array.isArray(event)) {
      const topicHashify = function(name) {
        if (isHexString(name, 32)) {
          return name;
        }
        const fragment2 = contract.interface.getEvent(name);
        assertArgument(fragment2, "unknown fragment", "name", name);
        return fragment2.topicHash;
      };
      topics = event.map((e) => {
        if (e == null) {
          return null;
        }
        if (Array.isArray(e)) {
          return e.map(topicHashify);
        }
        return topicHashify(e);
      });
    } else if (event === "*") {
      topics = [null];
    } else if (typeof event === "string") {
      if (isHexString(event, 32)) {
        topics = [event];
      } else {
        fragment = contract.interface.getEvent(event);
        assertArgument(fragment, "unknown fragment", "event", event);
        topics = [fragment.topicHash];
      }
    } else if (isDeferred(event)) {
      topics = await event.getTopicFilter();
    } else if ("fragment" in event) {
      fragment = event.fragment;
      topics = [fragment.topicHash];
    } else {
      assertArgument(false, "unknown event name", "event", event);
    }
    topics = topics.map((t) => {
      if (t == null) {
        return null;
      }
      if (Array.isArray(t)) {
        const items = Array.from(new Set(t.map((t2) => t2.toLowerCase())).values());
        if (items.length === 1) {
          return items[0];
        }
        items.sort();
        return items;
      }
      return t.toLowerCase();
    });
    const tag = topics.map((t) => {
      if (t == null) {
        return "null";
      }
      if (Array.isArray(t)) {
        return t.join("|");
      }
      return t;
    }).join("&");
    return { fragment, tag, topics };
  }
  async function hasSub(contract, event) {
    const { subs } = getInternal(contract);
    return subs.get((await getSubInfo(contract, event)).tag) || null;
  }
  async function getSub(contract, operation, event) {
    const provider = getProvider(contract.runner);
    assert(provider, "contract runner does not support subscribing", "UNSUPPORTED_OPERATION", { operation });
    const { fragment, tag, topics } = await getSubInfo(contract, event);
    const { addr, subs } = getInternal(contract);
    let sub = subs.get(tag);
    if (!sub) {
      const address = addr ? addr : contract;
      const filter = { address, topics };
      const listener = (log) => {
        let foundFragment = fragment;
        if (foundFragment == null) {
          try {
            foundFragment = contract.interface.getEvent(log.topics[0]);
          } catch (error) {
          }
        }
        if (foundFragment) {
          const _foundFragment = foundFragment;
          const args = fragment ? contract.interface.decodeEventLog(fragment, log.data, log.topics) : [];
          emit(contract, event, args, (listener2) => {
            return new ContractEventPayload(contract, listener2, event, _foundFragment, log);
          });
        } else {
          emit(contract, event, [], (listener2) => {
            return new ContractUnknownEventPayload(contract, listener2, event, log);
          });
        }
      };
      let starting = [];
      const start = () => {
        if (starting.length) {
          return;
        }
        starting.push(provider.on(filter, listener));
      };
      const stop = async () => {
        if (starting.length == 0) {
          return;
        }
        let started = starting;
        starting = [];
        await Promise.all(started);
        provider.off(filter, listener);
      };
      sub = { tag, listeners: [], start, stop };
      subs.set(tag, sub);
    }
    return sub;
  }
  async function _emit(contract, event, args, payloadFunc) {
    await lastEmit;
    const sub = await hasSub(contract, event);
    if (!sub) {
      return false;
    }
    const count = sub.listeners.length;
    sub.listeners = sub.listeners.filter(({ listener, once }) => {
      const passArgs = Array.from(args);
      if (payloadFunc) {
        passArgs.push(payloadFunc(once ? null : listener));
      }
      try {
        listener.call(contract, ...passArgs);
      } catch (error) {
      }
      return !once;
    });
    if (sub.listeners.length === 0) {
      sub.stop();
      getInternal(contract).subs.delete(sub.tag);
    }
    return count > 0;
  }
  async function emit(contract, event, args, payloadFunc) {
    try {
      await lastEmit;
    } catch (error) {
    }
    const resultPromise = _emit(contract, event, args, payloadFunc);
    lastEmit = resultPromise;
    return await resultPromise;
  }
  function _ContractBase() {
    return BaseContract;
  }
  var BN_010, _filter, PreparedTopicFilter, internal2, internalValues, lastEmit, passProperties2, _a, _BaseContract, BaseContract, Contract;
  var init_contract = __esm({
    "node_modules/ethers/lib.esm/contract/contract.js"() {
      init_abi();
      init_address2();
      init_provider();
      init_utils();
      init_wrappers();
      BN_010 = BigInt(0);
      PreparedTopicFilter = class {
        constructor(contract, fragment, args) {
          __privateAdd(this, _filter);
          __publicField(this, "fragment");
          defineProperties(this, { fragment });
          if (fragment.inputs.length < args.length) {
            throw new Error("too many arguments");
          }
          const runner = getRunner(contract.runner, "resolveName");
          const resolver = canResolve(runner) ? runner : null;
          __privateSet(this, _filter, async function() {
            const resolvedArgs = await Promise.all(fragment.inputs.map((param, index2) => {
              const arg = args[index2];
              if (arg == null) {
                return null;
              }
              return param.walkAsync(args[index2], (type, value) => {
                if (type === "address") {
                  if (Array.isArray(value)) {
                    return Promise.all(value.map((v) => resolveAddress(v, resolver)));
                  }
                  return resolveAddress(value, resolver);
                }
                return value;
              });
            }));
            return contract.interface.encodeFilterTopics(fragment, resolvedArgs);
          }());
        }
        getTopicFilter() {
          return __privateGet(this, _filter);
        }
      };
      _filter = new WeakMap();
      internal2 = Symbol.for("_ethersInternal_contract");
      internalValues = /* @__PURE__ */ new WeakMap();
      lastEmit = Promise.resolve();
      passProperties2 = ["then"];
      _a = internal2;
      _BaseContract = class _BaseContract {
        /**
         *  Creates a new contract connected to %%target%% with the %%abi%% and
         *  optionally connected to a %%runner%% to perform operations on behalf
         *  of.
         */
        constructor(target, abi2, runner, _deployTx) {
          /**
           *  The target to connect to.
           *
           *  This can be an address, ENS name or any [[Addressable]], such as
           *  another contract. To get the resovled address, use the ``getAddress``
           *  method.
           */
          __publicField(this, "target");
          /**
           *  The contract Interface.
           */
          __publicField(this, "interface");
          /**
           *  The connected runner. This is generally a [[Provider]] or a
           *  [[Signer]], which dictates what operations are supported.
           *
           *  For example, a **Contract** connected to a [[Provider]] may
           *  only execute read-only operations.
           */
          __publicField(this, "runner");
          /**
           *  All the Events available on this contract.
           */
          __publicField(this, "filters");
          /**
           *  @_ignore:
           */
          __publicField(this, _a);
          /**
           *  The fallback or receive function if any.
           */
          __publicField(this, "fallback");
          assertArgument(typeof target === "string" || isAddressable(target), "invalid value for Contract target", "target", target);
          if (runner == null) {
            runner = null;
          }
          const iface = Interface.from(abi2);
          defineProperties(this, { target, runner, interface: iface });
          Object.defineProperty(this, internal2, { value: {} });
          let addrPromise;
          let addr = null;
          let deployTx = null;
          if (_deployTx) {
            const provider = getProvider(runner);
            deployTx = new ContractTransactionResponse(this.interface, provider, _deployTx);
          }
          let subs = /* @__PURE__ */ new Map();
          if (typeof target === "string") {
            if (isHexString(target)) {
              addr = target;
              addrPromise = Promise.resolve(target);
            } else {
              const resolver = getRunner(runner, "resolveName");
              if (!canResolve(resolver)) {
                throw makeError("contract runner does not support name resolution", "UNSUPPORTED_OPERATION", {
                  operation: "resolveName"
                });
              }
              addrPromise = resolver.resolveName(target).then((addr2) => {
                if (addr2 == null) {
                  throw makeError("an ENS name used for a contract target must be correctly configured", "UNCONFIGURED_NAME", {
                    value: target
                  });
                }
                getInternal(this).addr = addr2;
                return addr2;
              });
            }
          } else {
            addrPromise = target.getAddress().then((addr2) => {
              if (addr2 == null) {
                throw new Error("TODO");
              }
              getInternal(this).addr = addr2;
              return addr2;
            });
          }
          setInternal(this, { addrPromise, addr, deployTx, subs });
          const filters = new Proxy({}, {
            get: (target2, prop, receiver) => {
              if (typeof prop === "symbol" || passProperties2.indexOf(prop) >= 0) {
                return Reflect.get(target2, prop, receiver);
              }
              try {
                return this.getEvent(prop);
              } catch (error) {
                if (!isError(error, "INVALID_ARGUMENT") || error.argument !== "key") {
                  throw error;
                }
              }
              return void 0;
            },
            has: (target2, prop) => {
              if (passProperties2.indexOf(prop) >= 0) {
                return Reflect.has(target2, prop);
              }
              return Reflect.has(target2, prop) || this.interface.hasEvent(String(prop));
            }
          });
          defineProperties(this, { filters });
          defineProperties(this, {
            fallback: iface.receive || iface.fallback ? buildWrappedFallback(this) : null
          });
          return new Proxy(this, {
            get: (target2, prop, receiver) => {
              if (typeof prop === "symbol" || prop in target2 || passProperties2.indexOf(prop) >= 0) {
                return Reflect.get(target2, prop, receiver);
              }
              try {
                return target2.getFunction(prop);
              } catch (error) {
                if (!isError(error, "INVALID_ARGUMENT") || error.argument !== "key") {
                  throw error;
                }
              }
              return void 0;
            },
            has: (target2, prop) => {
              if (typeof prop === "symbol" || prop in target2 || passProperties2.indexOf(prop) >= 0) {
                return Reflect.has(target2, prop);
              }
              return target2.interface.hasFunction(prop);
            }
          });
        }
        /**
         *  Return a new Contract instance with the same target and ABI, but
         *  a different %%runner%%.
         */
        connect(runner) {
          return new _BaseContract(this.target, this.interface, runner);
        }
        /**
         *  Return a new Contract instance with the same ABI and runner, but
         *  a different %%target%%.
         */
        attach(target) {
          return new _BaseContract(target, this.interface, this.runner);
        }
        /**
         *  Return the resolved address of this Contract.
         */
        async getAddress() {
          return await getInternal(this).addrPromise;
        }
        /**
         *  Return the deployed bytecode or null if no bytecode is found.
         */
        async getDeployedCode() {
          const provider = getProvider(this.runner);
          assert(provider, "runner does not support .provider", "UNSUPPORTED_OPERATION", { operation: "getDeployedCode" });
          const code = await provider.getCode(await this.getAddress());
          if (code === "0x") {
            return null;
          }
          return code;
        }
        /**
         *  Resolve to this Contract once the bytecode has been deployed, or
         *  resolve immediately if already deployed.
         */
        async waitForDeployment() {
          const deployTx = this.deploymentTransaction();
          if (deployTx) {
            await deployTx.wait();
            return this;
          }
          const code = await this.getDeployedCode();
          if (code != null) {
            return this;
          }
          const provider = getProvider(this.runner);
          assert(provider != null, "contract runner does not support .provider", "UNSUPPORTED_OPERATION", { operation: "waitForDeployment" });
          return new Promise((resolve, reject) => {
            const checkCode = async () => {
              try {
                const code2 = await this.getDeployedCode();
                if (code2 != null) {
                  return resolve(this);
                }
                provider.once("block", checkCode);
              } catch (error) {
                reject(error);
              }
            };
            checkCode();
          });
        }
        /**
         *  Return the transaction used to deploy this contract.
         *
         *  This is only available if this instance was returned from a
         *  [[ContractFactory]].
         */
        deploymentTransaction() {
          return getInternal(this).deployTx;
        }
        /**
         *  Return the function for a given name. This is useful when a contract
         *  method name conflicts with a JavaScript name such as ``prototype`` or
         *  when using a Contract programatically.
         */
        getFunction(key) {
          if (typeof key !== "string") {
            key = key.format();
          }
          const func = buildWrappedMethod(this, key);
          return func;
        }
        /**
         *  Return the event for a given name. This is useful when a contract
         *  event name conflicts with a JavaScript name such as ``prototype`` or
         *  when using a Contract programatically.
         */
        getEvent(key) {
          if (typeof key !== "string") {
            key = key.format();
          }
          return buildWrappedEvent(this, key);
        }
        /**
         *  @_ignore:
         */
        async queryTransaction(hash3) {
          throw new Error("@TODO");
        }
        /*
            // @TODO: this is a non-backwards compatible change, but will be added
            //        in v7 and in a potential SmartContract class in an upcoming
            //        v6 release
            async getTransactionReceipt(hash: string): Promise<null | ContractTransactionReceipt> {
                const provider = getProvider(this.runner);
                assert(provider, "contract runner does not have a provider",
                    "UNSUPPORTED_OPERATION", { operation: "queryTransaction" });
        
                const receipt = await provider.getTransactionReceipt(hash);
                if (receipt == null) { return null; }
        
                return new ContractTransactionReceipt(this.interface, provider, receipt);
            }
            */
        /**
         *  Provide historic access to event data for %%event%% in the range
         *  %%fromBlock%% (default: ``0``) to %%toBlock%% (default: ``"latest"``)
         *  inclusive.
         */
        async queryFilter(event, fromBlock, toBlock) {
          if (fromBlock == null) {
            fromBlock = 0;
          }
          if (toBlock == null) {
            toBlock = "latest";
          }
          const { addr, addrPromise } = getInternal(this);
          const address = addr ? addr : await addrPromise;
          const { fragment, topics } = await getSubInfo(this, event);
          const filter = { address, topics, fromBlock, toBlock };
          const provider = getProvider(this.runner);
          assert(provider, "contract runner does not have a provider", "UNSUPPORTED_OPERATION", { operation: "queryFilter" });
          return (await provider.getLogs(filter)).map((log) => {
            let foundFragment = fragment;
            if (foundFragment == null) {
              try {
                foundFragment = this.interface.getEvent(log.topics[0]);
              } catch (error) {
              }
            }
            if (foundFragment) {
              try {
                return new EventLog(log, this.interface, foundFragment);
              } catch (error) {
                return new UndecodedEventLog(log, error);
              }
            }
            return new Log(log, provider);
          });
        }
        /**
         *  Add an event %%listener%% for the %%event%%.
         */
        async on(event, listener) {
          const sub = await getSub(this, "on", event);
          sub.listeners.push({ listener, once: false });
          sub.start();
          return this;
        }
        /**
         *  Add an event %%listener%% for the %%event%%, but remove the listener
         *  after it is fired once.
         */
        async once(event, listener) {
          const sub = await getSub(this, "once", event);
          sub.listeners.push({ listener, once: true });
          sub.start();
          return this;
        }
        /**
         *  Emit an %%event%% calling all listeners with %%args%%.
         *
         *  Resolves to ``true`` if any listeners were called.
         */
        async emit(event, ...args) {
          return await emit(this, event, args, null);
        }
        /**
         *  Resolves to the number of listeners of %%event%% or the total number
         *  of listeners if unspecified.
         */
        async listenerCount(event) {
          if (event) {
            const sub = await hasSub(this, event);
            if (!sub) {
              return 0;
            }
            return sub.listeners.length;
          }
          const { subs } = getInternal(this);
          let total = 0;
          for (const { listeners } of subs.values()) {
            total += listeners.length;
          }
          return total;
        }
        /**
         *  Resolves to the listeners subscribed to %%event%% or all listeners
         *  if unspecified.
         */
        async listeners(event) {
          if (event) {
            const sub = await hasSub(this, event);
            if (!sub) {
              return [];
            }
            return sub.listeners.map(({ listener }) => listener);
          }
          const { subs } = getInternal(this);
          let result = [];
          for (const { listeners } of subs.values()) {
            result = result.concat(listeners.map(({ listener }) => listener));
          }
          return result;
        }
        /**
         *  Remove the %%listener%% from the listeners for %%event%% or remove
         *  all listeners if unspecified.
         */
        async off(event, listener) {
          const sub = await hasSub(this, event);
          if (!sub) {
            return this;
          }
          if (listener) {
            const index2 = sub.listeners.map(({ listener: listener2 }) => listener2).indexOf(listener);
            if (index2 >= 0) {
              sub.listeners.splice(index2, 1);
            }
          }
          if (listener == null || sub.listeners.length === 0) {
            sub.stop();
            getInternal(this).subs.delete(sub.tag);
          }
          return this;
        }
        /**
         *  Remove all the listeners for %%event%% or remove all listeners if
         *  unspecified.
         */
        async removeAllListeners(event) {
          if (event) {
            const sub = await hasSub(this, event);
            if (!sub) {
              return this;
            }
            sub.stop();
            getInternal(this).subs.delete(sub.tag);
          } else {
            const { subs } = getInternal(this);
            for (const { tag, stop } of subs.values()) {
              stop();
              subs.delete(tag);
            }
          }
          return this;
        }
        /**
         *  Alias for [on].
         */
        async addListener(event, listener) {
          return await this.on(event, listener);
        }
        /**
         *  Alias for [off].
         */
        async removeListener(event, listener) {
          return await this.off(event, listener);
        }
        /**
         *  Create a new Class for the %%abi%%.
         */
        static buildClass(abi2) {
          class CustomContract extends _BaseContract {
            constructor(address, runner = null) {
              super(address, abi2, runner);
            }
          }
          return CustomContract;
        }
        /**
         *  Create a new BaseContract with a specified Interface.
         */
        static from(target, abi2, runner) {
          if (runner == null) {
            runner = null;
          }
          const contract = new this(target, abi2, runner);
          return contract;
        }
      };
      BaseContract = _BaseContract;
      Contract = class extends _ContractBase() {
      };
    }
  });

  // node_modules/ethers/lib.esm/contract/factory.js
  var ContractFactory;
  var init_factory = __esm({
    "node_modules/ethers/lib.esm/contract/factory.js"() {
      init_abi();
      init_address2();
      init_utils();
      init_contract();
      ContractFactory = class _ContractFactory {
        /**
         *  Create a new **ContractFactory** with %%abi%% and %%bytecode%%,
         *  optionally connected to %%runner%%.
         *
         *  The %%bytecode%% may be the ``bytecode`` property within the
         *  standard Solidity JSON output.
         */
        constructor(abi2, bytecode, runner) {
          /**
           *  The Contract Interface.
           */
          __publicField(this, "interface");
          /**
           *  The Contract deployment bytecode. Often called the initcode.
           */
          __publicField(this, "bytecode");
          /**
           *  The ContractRunner to deploy the Contract as.
           */
          __publicField(this, "runner");
          const iface = Interface.from(abi2);
          if (bytecode instanceof Uint8Array) {
            bytecode = hexlify(getBytes(bytecode));
          } else {
            if (typeof bytecode === "object") {
              bytecode = bytecode.object;
            }
            if (!bytecode.startsWith("0x")) {
              bytecode = "0x" + bytecode;
            }
            bytecode = hexlify(getBytes(bytecode));
          }
          defineProperties(this, {
            bytecode,
            interface: iface,
            runner: runner || null
          });
        }
        attach(target) {
          return new BaseContract(target, this.interface, this.runner);
        }
        /**
         *  Resolves to the transaction to deploy the contract, passing %%args%%
         *  into the constructor.
         */
        async getDeployTransaction(...args) {
          let overrides = {};
          const fragment = this.interface.deploy;
          if (fragment.inputs.length + 1 === args.length) {
            overrides = await copyOverrides(args.pop());
          }
          if (fragment.inputs.length !== args.length) {
            throw new Error("incorrect number of arguments to constructor");
          }
          const resolvedArgs = await resolveArgs(this.runner, fragment.inputs, args);
          const data = concat([this.bytecode, this.interface.encodeDeploy(resolvedArgs)]);
          return Object.assign({}, overrides, { data });
        }
        /**
         *  Resolves to the Contract deployed by passing %%args%% into the
         *  constructor.
         *
         *  This will resolve to the Contract before it has been deployed to the
         *  network, so the [[BaseContract-waitForDeployment]] should be used before
         *  sending any transactions to it.
         */
        async deploy(...args) {
          const tx = await this.getDeployTransaction(...args);
          assert(this.runner && typeof this.runner.sendTransaction === "function", "factory runner does not support sending transactions", "UNSUPPORTED_OPERATION", {
            operation: "sendTransaction"
          });
          const sentTx = await this.runner.sendTransaction(tx);
          const address = getCreateAddress(sentTx);
          return new BaseContract(address, this.interface, this.runner, sentTx);
        }
        /**
         *  Return a new **ContractFactory** with the same ABI and bytecode,
         *  but connected to %%runner%%.
         */
        connect(runner) {
          return new _ContractFactory(this.interface, this.bytecode, runner);
        }
        /**
         *  Create a new **ContractFactory** from the standard Solidity JSON output.
         */
        static fromSolidity(output2, runner) {
          assertArgument(output2 != null, "bad compiler output", "output", output2);
          if (typeof output2 === "string") {
            output2 = JSON.parse(output2);
          }
          const abi2 = output2.abi;
          let bytecode = "";
          if (output2.bytecode) {
            bytecode = output2.bytecode;
          } else if (output2.evm && output2.evm.bytecode) {
            bytecode = output2.evm.bytecode;
          }
          return new this(abi2, bytecode, runner);
        }
      };
    }
  });

  // node_modules/ethers/lib.esm/contract/index.js
  var init_contract2 = __esm({
    "node_modules/ethers/lib.esm/contract/index.js"() {
      init_contract();
      init_factory();
      init_wrappers();
    }
  });

  // node_modules/ethers/lib.esm/providers/ens-resolver.js
  function getIpfsLink(link) {
    if (link.match(/^ipfs:\/\/ipfs\//i)) {
      link = link.substring(12);
    } else if (link.match(/^ipfs:\/\//i)) {
      link = link.substring(7);
    } else {
      assertArgument(false, "unsupported IPFS format", "link", link);
    }
    return `https://gateway.ipfs.io/ipfs/${link}`;
  }
  var MulticoinProviderPlugin, matcherIpfs, matchers, _supports2544, _resolver, _EnsResolver_instances, fetch_fn, _EnsResolver_static, getResolver_fn, _EnsResolver, EnsResolver;
  var init_ens_resolver = __esm({
    "node_modules/ethers/lib.esm/providers/ens-resolver.js"() {
      init_address2();
      init_constants();
      init_contract2();
      init_hash();
      init_utils();
      MulticoinProviderPlugin = class {
        /**
         *  Creates a new **MulticoinProviderPluing** for %%name%%.
         */
        constructor(name) {
          /**
           *  The name.
           */
          __publicField(this, "name");
          defineProperties(this, { name });
        }
        connect(proivder) {
          return this;
        }
        /**
         *  Returns ``true`` if %%coinType%% is supported by this plugin.
         */
        supportsCoinType(coinType) {
          return false;
        }
        /**
         *  Resolves to the encoded %%address%% for %%coinType%%.
         */
        async encodeAddress(coinType, address) {
          throw new Error("unsupported coin");
        }
        /**
         *  Resolves to the decoded %%data%% for %%coinType%%.
         */
        async decodeAddress(coinType, data) {
          throw new Error("unsupported coin");
        }
      };
      matcherIpfs = new RegExp("^(ipfs)://(.*)$", "i");
      matchers = [
        new RegExp("^(https)://(.*)$", "i"),
        new RegExp("^(data):(.*)$", "i"),
        matcherIpfs,
        new RegExp("^eip155:[0-9]+/(erc[0-9]+):(.*)$", "i")
      ];
      _EnsResolver = class _EnsResolver {
        constructor(provider, address, name) {
          __privateAdd(this, _EnsResolver_instances);
          /**
           *  The connected provider.
           */
          __publicField(this, "provider");
          /**
           *  The address of the resolver.
           */
          __publicField(this, "address");
          /**
           *  The name this resolver was resolved against.
           */
          __publicField(this, "name");
          // For EIP-2544 names, the ancestor that provided the resolver
          __privateAdd(this, _supports2544);
          __privateAdd(this, _resolver);
          defineProperties(this, { provider, address, name });
          __privateSet(this, _supports2544, null);
          __privateSet(this, _resolver, new Contract(address, [
            "function supportsInterface(bytes4) view returns (bool)",
            "function resolve(bytes, bytes) view returns (bytes)",
            "function addr(bytes32) view returns (address)",
            "function addr(bytes32, uint) view returns (bytes)",
            "function text(bytes32, string) view returns (string)",
            "function contenthash(bytes32) view returns (bytes)"
          ], provider));
        }
        /**
         *  Resolves to true if the resolver supports wildcard resolution.
         */
        async supportsWildcard() {
          if (__privateGet(this, _supports2544) == null) {
            __privateSet(this, _supports2544, (async () => {
              try {
                return await __privateGet(this, _resolver).supportsInterface("0x9061b923");
              } catch (error) {
                if (isError(error, "CALL_EXCEPTION")) {
                  return false;
                }
                __privateSet(this, _supports2544, null);
                throw error;
              }
            })());
          }
          return await __privateGet(this, _supports2544);
        }
        /**
         *  Resolves to the address for %%coinType%% or null if the
         *  provided %%coinType%% has not been configured.
         */
        async getAddress(coinType) {
          if (coinType == null) {
            coinType = 60;
          }
          if (coinType === 60) {
            try {
              const result = await __privateMethod(this, _EnsResolver_instances, fetch_fn).call(this, "addr(bytes32)");
              if (result == null || result === ZeroAddress) {
                return null;
              }
              return result;
            } catch (error) {
              if (isError(error, "CALL_EXCEPTION")) {
                return null;
              }
              throw error;
            }
          }
          if (coinType >= 0 && coinType < 2147483648) {
            let ethCoinType = coinType + 2147483648;
            const data2 = await __privateMethod(this, _EnsResolver_instances, fetch_fn).call(this, "addr(bytes32,uint)", [ethCoinType]);
            if (isHexString(data2, 20)) {
              return getAddress(data2);
            }
          }
          let coinPlugin = null;
          for (const plugin of this.provider.plugins) {
            if (!(plugin instanceof MulticoinProviderPlugin)) {
              continue;
            }
            if (plugin.supportsCoinType(coinType)) {
              coinPlugin = plugin;
              break;
            }
          }
          if (coinPlugin == null) {
            return null;
          }
          const data = await __privateMethod(this, _EnsResolver_instances, fetch_fn).call(this, "addr(bytes32,uint)", [coinType]);
          if (data == null || data === "0x") {
            return null;
          }
          const address = await coinPlugin.decodeAddress(coinType, data);
          if (address != null) {
            return address;
          }
          assert(false, `invalid coin data`, "UNSUPPORTED_OPERATION", {
            operation: `getAddress(${coinType})`,
            info: { coinType, data }
          });
        }
        /**
         *  Resolves to the EIP-634 text record for %%key%%, or ``null``
         *  if unconfigured.
         */
        async getText(key) {
          const data = await __privateMethod(this, _EnsResolver_instances, fetch_fn).call(this, "text(bytes32,string)", [key]);
          if (data == null || data === "0x") {
            return null;
          }
          return data;
        }
        /**
         *  Rsolves to the content-hash or ``null`` if unconfigured.
         */
        async getContentHash() {
          const data = await __privateMethod(this, _EnsResolver_instances, fetch_fn).call(this, "contenthash(bytes32)");
          if (data == null || data === "0x") {
            return null;
          }
          const ipfs = data.match(/^0x(e3010170|e5010172)(([0-9a-f][0-9a-f])([0-9a-f][0-9a-f])([0-9a-f]*))$/);
          if (ipfs) {
            const scheme = ipfs[1] === "e3010170" ? "ipfs" : "ipns";
            const length = parseInt(ipfs[4], 16);
            if (ipfs[5].length === length * 2) {
              return `${scheme}://${encodeBase58("0x" + ipfs[2])}`;
            }
          }
          const swarm = data.match(/^0xe40101fa011b20([0-9a-f]*)$/);
          if (swarm && swarm[1].length === 64) {
            return `bzz://${swarm[1]}`;
          }
          assert(false, `invalid or unsupported content hash data`, "UNSUPPORTED_OPERATION", {
            operation: "getContentHash()",
            info: { data }
          });
        }
        /**
         *  Resolves to the avatar url or ``null`` if the avatar is either
         *  unconfigured or incorrectly configured (e.g. references an NFT
         *  not owned by the address).
         *
         *  If diagnosing issues with configurations, the [[_getAvatar]]
         *  method may be useful.
         */
        async getAvatar() {
          const avatar = await this._getAvatar();
          return avatar.url;
        }
        /**
         *  When resolving an avatar, there are many steps involved, such
         *  fetching metadata and possibly validating ownership of an
         *  NFT.
         *
         *  This method can be used to examine each step and the value it
         *  was working from.
         */
        async _getAvatar() {
          const linkage = [{ type: "name", value: this.name }];
          try {
            const avatar = await this.getText("avatar");
            if (avatar == null) {
              linkage.push({ type: "!avatar", value: "" });
              return { url: null, linkage };
            }
            linkage.push({ type: "avatar", value: avatar });
            for (let i = 0; i < matchers.length; i++) {
              const match = avatar.match(matchers[i]);
              if (match == null) {
                continue;
              }
              const scheme = match[1].toLowerCase();
              switch (scheme) {
                case "https":
                case "data":
                  linkage.push({ type: "url", value: avatar });
                  return { linkage, url: avatar };
                case "ipfs": {
                  const url = getIpfsLink(avatar);
                  linkage.push({ type: "ipfs", value: avatar });
                  linkage.push({ type: "url", value: url });
                  return { linkage, url };
                }
                case "erc721":
                case "erc1155": {
                  const selector = scheme === "erc721" ? "tokenURI(uint256)" : "uri(uint256)";
                  linkage.push({ type: scheme, value: avatar });
                  const owner = await this.getAddress();
                  if (owner == null) {
                    linkage.push({ type: "!owner", value: "" });
                    return { url: null, linkage };
                  }
                  const comps = (match[2] || "").split("/");
                  if (comps.length !== 2) {
                    linkage.push({ type: `!${scheme}caip`, value: match[2] || "" });
                    return { url: null, linkage };
                  }
                  const tokenId = comps[1];
                  const contract = new Contract(comps[0], [
                    // ERC-721
                    "function tokenURI(uint) view returns (string)",
                    "function ownerOf(uint) view returns (address)",
                    // ERC-1155
                    "function uri(uint) view returns (string)",
                    "function balanceOf(address, uint256) view returns (uint)"
                  ], this.provider);
                  if (scheme === "erc721") {
                    const tokenOwner = await contract.ownerOf(tokenId);
                    if (owner !== tokenOwner) {
                      linkage.push({ type: "!owner", value: tokenOwner });
                      return { url: null, linkage };
                    }
                    linkage.push({ type: "owner", value: tokenOwner });
                  } else if (scheme === "erc1155") {
                    const balance = await contract.balanceOf(owner, tokenId);
                    if (!balance) {
                      linkage.push({ type: "!balance", value: "0" });
                      return { url: null, linkage };
                    }
                    linkage.push({ type: "balance", value: balance.toString() });
                  }
                  let metadataUrl = await contract[selector](tokenId);
                  if (metadataUrl == null || metadataUrl === "0x") {
                    linkage.push({ type: "!metadata-url", value: "" });
                    return { url: null, linkage };
                  }
                  linkage.push({ type: "metadata-url-base", value: metadataUrl });
                  if (scheme === "erc1155") {
                    metadataUrl = metadataUrl.replace("{id}", toBeHex(tokenId, 32).substring(2));
                    linkage.push({ type: "metadata-url-expanded", value: metadataUrl });
                  }
                  if (metadataUrl.match(/^ipfs:/i)) {
                    metadataUrl = getIpfsLink(metadataUrl);
                  }
                  linkage.push({ type: "metadata-url", value: metadataUrl });
                  let metadata = {};
                  const response = await new FetchRequest(metadataUrl).send();
                  response.assertOk();
                  try {
                    metadata = response.bodyJson;
                  } catch (error) {
                    try {
                      linkage.push({ type: "!metadata", value: response.bodyText });
                    } catch (error2) {
                      const bytes2 = response.body;
                      if (bytes2) {
                        linkage.push({ type: "!metadata", value: hexlify(bytes2) });
                      }
                      return { url: null, linkage };
                    }
                    return { url: null, linkage };
                  }
                  if (!metadata) {
                    linkage.push({ type: "!metadata", value: "" });
                    return { url: null, linkage };
                  }
                  linkage.push({ type: "metadata", value: JSON.stringify(metadata) });
                  let imageUrl = metadata.image;
                  if (typeof imageUrl !== "string") {
                    linkage.push({ type: "!imageUrl", value: "" });
                    return { url: null, linkage };
                  }
                  if (imageUrl.match(/^(https:\/\/|data:)/i)) {
                  } else {
                    const ipfs = imageUrl.match(matcherIpfs);
                    if (ipfs == null) {
                      linkage.push({ type: "!imageUrl-ipfs", value: imageUrl });
                      return { url: null, linkage };
                    }
                    linkage.push({ type: "imageUrl-ipfs", value: imageUrl });
                    imageUrl = getIpfsLink(imageUrl);
                  }
                  linkage.push({ type: "url", value: imageUrl });
                  return { linkage, url: imageUrl };
                }
              }
            }
          } catch (error) {
          }
          return { linkage, url: null };
        }
        static async getEnsAddress(provider) {
          const network = await provider.getNetwork();
          const ensPlugin = network.getPlugin("org.ethers.plugins.network.Ens");
          assert(ensPlugin, "network does not support ENS", "UNSUPPORTED_OPERATION", {
            operation: "getEnsAddress",
            info: { network }
          });
          return ensPlugin.address;
        }
        /**
         *  Resolve to the ENS resolver for %%name%% using %%provider%% or
         *  ``null`` if unconfigured.
         */
        static async fromName(provider, name) {
          var _a2;
          let currentName = name;
          while (true) {
            if (currentName === "" || currentName === ".") {
              return null;
            }
            if (name !== "eth" && currentName === "eth") {
              return null;
            }
            const addr = await __privateMethod(_a2 = _EnsResolver, _EnsResolver_static, getResolver_fn).call(_a2, provider, currentName);
            if (addr != null) {
              const resolver = new _EnsResolver(provider, addr, name);
              if (currentName !== name && !await resolver.supportsWildcard()) {
                return null;
              }
              return resolver;
            }
            currentName = currentName.split(".").slice(1).join(".");
          }
        }
      };
      _supports2544 = new WeakMap();
      _resolver = new WeakMap();
      _EnsResolver_instances = new WeakSet();
      fetch_fn = async function(funcName, params) {
        params = (params || []).slice();
        const iface = __privateGet(this, _resolver).interface;
        params.unshift(namehash(this.name));
        let fragment = null;
        if (await this.supportsWildcard()) {
          fragment = iface.getFunction(funcName);
          assert(fragment, "missing fragment", "UNKNOWN_ERROR", {
            info: { funcName }
          });
          params = [
            dnsEncode(this.name, 255),
            iface.encodeFunctionData(fragment, params)
          ];
          funcName = "resolve(bytes,bytes)";
        }
        params.push({
          enableCcipRead: true
        });
        try {
          const result = await __privateGet(this, _resolver)[funcName](...params);
          if (fragment) {
            return iface.decodeFunctionResult(fragment, result)[0];
          }
          return result;
        } catch (error) {
          if (!isError(error, "CALL_EXCEPTION")) {
            throw error;
          }
        }
        return null;
      };
      _EnsResolver_static = new WeakSet();
      getResolver_fn = async function(provider, name) {
        const ensAddr = await _EnsResolver.getEnsAddress(provider);
        try {
          const contract = new Contract(ensAddr, [
            "function resolver(bytes32) view returns (address)"
          ], provider);
          const addr = await contract.resolver(namehash(name), {
            enableCcipRead: true
          });
          if (addr === ZeroAddress) {
            return null;
          }
          return addr;
        } catch (error) {
          throw error;
        }
        return null;
      };
      __privateAdd(_EnsResolver, _EnsResolver_static);
      EnsResolver = _EnsResolver;
    }
  });

  // node_modules/ethers/lib.esm/providers/format.js
  function allowNull(format, nullValue) {
    return function(value) {
      if (value == null) {
        return nullValue;
      }
      return format(value);
    };
  }
  function arrayOf(format, allowNull2) {
    return (array) => {
      if (allowNull2 && array == null) {
        return null;
      }
      if (!Array.isArray(array)) {
        throw new Error("not an array");
      }
      return array.map((i) => format(i));
    };
  }
  function object(format, altNames) {
    return (value) => {
      const result = {};
      for (const key in format) {
        let srcKey = key;
        if (altNames && key in altNames && !(srcKey in value)) {
          for (const altKey of altNames[key]) {
            if (altKey in value) {
              srcKey = altKey;
              break;
            }
          }
        }
        try {
          const nv = format[key](value[srcKey]);
          if (nv !== void 0) {
            result[key] = nv;
          }
        } catch (error) {
          const message = error instanceof Error ? error.message : "not-an-error";
          assert(false, `invalid value for value.${key} (${message})`, "BAD_DATA", { value });
        }
      }
      return result;
    };
  }
  function formatBoolean(value) {
    switch (value) {
      case true:
      case "true":
        return true;
      case false:
      case "false":
        return false;
    }
    assertArgument(false, `invalid boolean; ${JSON.stringify(value)}`, "value", value);
  }
  function formatData(value) {
    assertArgument(isHexString(value, true), "invalid data", "value", value);
    return value;
  }
  function formatHash(value) {
    assertArgument(isHexString(value, 32), "invalid hash", "value", value);
    return value;
  }
  function formatLog(value) {
    return _formatLog(value);
  }
  function formatBlock(value) {
    const result = _formatBlock(value);
    result.transactions = value.transactions.map((tx) => {
      if (typeof tx === "string") {
        return tx;
      }
      return formatTransactionResponse(tx);
    });
    return result;
  }
  function formatReceiptLog(value) {
    return _formatReceiptLog(value);
  }
  function formatTransactionReceipt(value) {
    return _formatTransactionReceipt(value);
  }
  function formatTransactionResponse(value) {
    if (value.to && getBigInt(value.to) === BN_011) {
      value.to = "0x0000000000000000000000000000000000000000";
    }
    const result = object({
      hash: formatHash,
      // Some nodes do not return this, usually test nodes (like Ganache)
      index: allowNull(getNumber, void 0),
      type: (value2) => {
        if (value2 === "0x" || value2 == null) {
          return 0;
        }
        return getNumber(value2);
      },
      accessList: allowNull(accessListify, null),
      blobVersionedHashes: allowNull(arrayOf(formatHash, true), null),
      authorizationList: allowNull(arrayOf((v) => {
        let sig;
        if (v.signature) {
          sig = v.signature;
        } else {
          let yParity = v.yParity;
          if (yParity === "0x1b") {
            yParity = 0;
          } else if (yParity === "0x1c") {
            yParity = 1;
          }
          sig = Object.assign({}, v, { yParity });
        }
        return {
          address: getAddress(v.address),
          chainId: getBigInt(v.chainId),
          nonce: getBigInt(v.nonce),
          signature: Signature.from(sig)
        };
      }, false), null),
      blockHash: allowNull(formatHash, null),
      blockNumber: allowNull(getNumber, null),
      transactionIndex: allowNull(getNumber, null),
      from: getAddress,
      // either (gasPrice) or (maxPriorityFeePerGas + maxFeePerGas) must be set
      gasPrice: allowNull(getBigInt),
      maxPriorityFeePerGas: allowNull(getBigInt),
      maxFeePerGas: allowNull(getBigInt),
      maxFeePerBlobGas: allowNull(getBigInt, null),
      gasLimit: getBigInt,
      to: allowNull(getAddress, null),
      value: getBigInt,
      nonce: getNumber,
      data: formatData,
      creates: allowNull(getAddress, null),
      chainId: allowNull(getBigInt, null)
    }, {
      data: ["input"],
      gasLimit: ["gas"],
      index: ["transactionIndex"]
    })(value);
    if (result.to == null && result.creates == null) {
      result.creates = getCreateAddress(result);
    }
    if ((value.type === 1 || value.type === 2) && value.accessList == null) {
      result.accessList = [];
    }
    if (value.signature) {
      result.signature = Signature.from(value.signature);
    } else {
      result.signature = Signature.from(value);
    }
    if (result.chainId == null) {
      const chainId = result.signature.legacyChainId;
      if (chainId != null) {
        result.chainId = chainId;
      }
    }
    if (result.blockHash && getBigInt(result.blockHash) === BN_011) {
      result.blockHash = null;
    }
    return result;
  }
  var BN_011, _formatLog, _formatBlock, _formatReceiptLog, _formatTransactionReceipt;
  var init_format = __esm({
    "node_modules/ethers/lib.esm/providers/format.js"() {
      init_address2();
      init_crypto2();
      init_transaction2();
      init_utils();
      BN_011 = BigInt(0);
      _formatLog = object({
        address: getAddress,
        blockHash: formatHash,
        blockNumber: getNumber,
        data: formatData,
        index: getNumber,
        removed: allowNull(formatBoolean, false),
        topics: arrayOf(formatHash),
        transactionHash: formatHash,
        transactionIndex: getNumber
      }, {
        index: ["logIndex"]
      });
      _formatBlock = object({
        hash: allowNull(formatHash),
        parentHash: formatHash,
        parentBeaconBlockRoot: allowNull(formatHash, null),
        number: getNumber,
        timestamp: getNumber,
        nonce: allowNull(formatData),
        difficulty: getBigInt,
        gasLimit: getBigInt,
        gasUsed: getBigInt,
        stateRoot: allowNull(formatHash, null),
        receiptsRoot: allowNull(formatHash, null),
        blobGasUsed: allowNull(getBigInt, null),
        excessBlobGas: allowNull(getBigInt, null),
        miner: allowNull(getAddress),
        prevRandao: allowNull(formatHash, null),
        extraData: formatData,
        baseFeePerGas: allowNull(getBigInt)
      }, {
        prevRandao: ["mixHash"]
      });
      _formatReceiptLog = object({
        transactionIndex: getNumber,
        blockNumber: getNumber,
        transactionHash: formatHash,
        address: getAddress,
        topics: arrayOf(formatHash),
        data: formatData,
        index: getNumber,
        blockHash: formatHash
      }, {
        index: ["logIndex"]
      });
      _formatTransactionReceipt = object({
        to: allowNull(getAddress, null),
        from: allowNull(getAddress, null),
        contractAddress: allowNull(getAddress, null),
        // should be allowNull(hash), but broken-EIP-658 support is handled in receipt
        index: getNumber,
        root: allowNull(hexlify),
        gasUsed: getBigInt,
        blobGasUsed: allowNull(getBigInt, null),
        logsBloom: allowNull(formatData),
        blockHash: formatHash,
        hash: formatHash,
        logs: arrayOf(formatReceiptLog),
        blockNumber: getNumber,
        //confirmations: allowNull(getNumber, null),
        cumulativeGasUsed: getBigInt,
        effectiveGasPrice: allowNull(getBigInt),
        blobGasPrice: allowNull(getBigInt, null),
        status: allowNull(getNumber),
        type: allowNull(getNumber, 0)
      }, {
        effectiveGasPrice: ["gasPrice"],
        hash: ["transactionHash"],
        index: ["transactionIndex"]
      });
    }
  });

  // node_modules/ethers/lib.esm/providers/plugins-network.js
  var EnsAddress, NetworkPlugin, GasCostPlugin, EnsPlugin, _feeDataFunc, _FeeDataNetworkPlugin, FeeDataNetworkPlugin, _url2, _processFunc, FetchUrlFeeDataNetworkPlugin;
  var init_plugins_network = __esm({
    "node_modules/ethers/lib.esm/providers/plugins-network.js"() {
      init_properties();
      init_utils();
      EnsAddress = "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e";
      NetworkPlugin = class _NetworkPlugin {
        /**
         *  Creates a new **NetworkPlugin**.
         */
        constructor(name) {
          /**
           *  The name of the plugin.
           *
           *  It is recommended to use reverse-domain-notation, which permits
           *  unique names with a known authority as well as hierarchal entries.
           */
          __publicField(this, "name");
          defineProperties(this, { name });
        }
        /**
         *  Creates a copy of this plugin.
         */
        clone() {
          return new _NetworkPlugin(this.name);
        }
      };
      GasCostPlugin = class _GasCostPlugin extends NetworkPlugin {
        /**
         *  Creates a new GasCostPlugin from %%effectiveBlock%% until the
         *  latest block or another GasCostPlugin supercedes that block number,
         *  with the associated %%costs%%.
         */
        constructor(effectiveBlock, costs) {
          if (effectiveBlock == null) {
            effectiveBlock = 0;
          }
          super(`org.ethers.network.plugins.GasCost#${effectiveBlock || 0}`);
          /**
           *  The block number to treat these values as valid from.
           *
           *  This allows a hardfork to have updated values included as well as
           *  mulutiple hardforks to be supported.
           */
          __publicField(this, "effectiveBlock");
          /**
           *  The transactions base fee.
           */
          __publicField(this, "txBase");
          /**
           *  The fee for creating a new account.
           */
          __publicField(this, "txCreate");
          /**
           *  The fee per zero-byte in the data.
           */
          __publicField(this, "txDataZero");
          /**
           *  The fee per non-zero-byte in the data.
           */
          __publicField(this, "txDataNonzero");
          /**
           *  The fee per storage key in the [[link-eip-2930]] access list.
           */
          __publicField(this, "txAccessListStorageKey");
          /**
           *  The fee per address in the [[link-eip-2930]] access list.
           */
          __publicField(this, "txAccessListAddress");
          const props = { effectiveBlock };
          function set(name, nullish) {
            let value = (costs || {})[name];
            if (value == null) {
              value = nullish;
            }
            assertArgument(typeof value === "number", `invalud value for ${name}`, "costs", costs);
            props[name] = value;
          }
          set("txBase", 21e3);
          set("txCreate", 32e3);
          set("txDataZero", 4);
          set("txDataNonzero", 16);
          set("txAccessListStorageKey", 1900);
          set("txAccessListAddress", 2400);
          defineProperties(this, props);
        }
        clone() {
          return new _GasCostPlugin(this.effectiveBlock, this);
        }
      };
      EnsPlugin = class _EnsPlugin extends NetworkPlugin {
        /**
         *  Creates a new **EnsPlugin** connected to %%address%% on the
         *  %%targetNetwork%%. The default ENS address and mainnet is used
         *  if unspecified.
         */
        constructor(address, targetNetwork) {
          super("org.ethers.plugins.network.Ens");
          /**
           *  The ENS Registrty Contract address.
           */
          __publicField(this, "address");
          /**
           *  The chain ID that the ENS contract lives on.
           */
          __publicField(this, "targetNetwork");
          defineProperties(this, {
            address: address || EnsAddress,
            targetNetwork: targetNetwork == null ? 1 : targetNetwork
          });
        }
        clone() {
          return new _EnsPlugin(this.address, this.targetNetwork);
        }
      };
      _FeeDataNetworkPlugin = class _FeeDataNetworkPlugin extends NetworkPlugin {
        /**
         *  Creates a new **FeeDataNetworkPlugin**.
         */
        constructor(feeDataFunc) {
          super("org.ethers.plugins.network.FeeData");
          __privateAdd(this, _feeDataFunc);
          __privateSet(this, _feeDataFunc, feeDataFunc);
        }
        /**
         *  The fee data function provided to the constructor.
         */
        get feeDataFunc() {
          return __privateGet(this, _feeDataFunc);
        }
        /**
         *  Resolves to the fee data.
         */
        async getFeeData(provider) {
          return await __privateGet(this, _feeDataFunc).call(this, provider);
        }
        clone() {
          return new _FeeDataNetworkPlugin(__privateGet(this, _feeDataFunc));
        }
      };
      _feeDataFunc = new WeakMap();
      FeeDataNetworkPlugin = _FeeDataNetworkPlugin;
      FetchUrlFeeDataNetworkPlugin = class extends NetworkPlugin {
        /**
         *  Creates a new **FetchUrlFeeDataNetworkPlugin** which will
         *  be used when computing the fee data for the network.
         */
        constructor(url, processFunc) {
          super("org.ethers.plugins.network.FetchUrlFeeDataPlugin");
          __privateAdd(this, _url2);
          __privateAdd(this, _processFunc);
          __privateSet(this, _url2, url);
          __privateSet(this, _processFunc, processFunc);
        }
        /**
         *  The URL to initialize the FetchRequest with in %%processFunc%%.
         */
        get url() {
          return __privateGet(this, _url2);
        }
        /**
         *  The callback to use when computing the FeeData.
         */
        get processFunc() {
          return __privateGet(this, _processFunc);
        }
        // We are immutable, so we can serve as our own clone
        clone() {
          return this;
        }
      };
      _url2 = new WeakMap();
      _processFunc = new WeakMap();
    }
  });

  // node_modules/ethers/lib.esm/providers/network.js
  function parseUnits2(_value2, decimals) {
    const value = String(_value2);
    if (!value.match(/^[0-9.]+$/)) {
      throw new Error(`invalid gwei value: ${_value2}`);
    }
    const comps = value.split(".");
    if (comps.length === 1) {
      comps.push("");
    }
    if (comps.length !== 2) {
      throw new Error(`invalid gwei value: ${_value2}`);
    }
    while (comps[1].length < decimals) {
      comps[1] += "0";
    }
    if (comps[1].length > 9) {
      let frac = BigInt(comps[1].substring(0, 9));
      if (!comps[1].substring(9).match(/^0+$/)) {
        frac++;
      }
      comps[1] = frac.toString();
    }
    return BigInt(comps[0] + comps[1]);
  }
  function getGasStationPlugin(url) {
    return new FetchUrlFeeDataNetworkPlugin(url, async (fetchFeeData, provider, request) => {
      request.setHeader("User-Agent", "ethers");
      let response;
      try {
        const [_response, _feeData] = await Promise.all([
          request.send(),
          fetchFeeData()
        ]);
        response = _response;
        const payload = response.bodyJson.standard;
        const feeData = {
          gasPrice: _feeData.gasPrice,
          maxFeePerGas: parseUnits2(payload.maxFee, 9),
          maxPriorityFeePerGas: parseUnits2(payload.maxPriorityFee, 9)
        };
        return feeData;
      } catch (error) {
        assert(false, `error encountered with polygon gas station (${JSON.stringify(request.url)})`, "SERVER_ERROR", { request, response, error });
      }
    });
  }
  function injectCommonNetworks() {
    if (injected) {
      return;
    }
    injected = true;
    function registerEth(name, chainId, options) {
      const func = function() {
        const network = new Network(name, chainId);
        if (options.ensNetwork != null) {
          network.attachPlugin(new EnsPlugin(null, options.ensNetwork));
        }
        network.attachPlugin(new GasCostPlugin());
        (options.plugins || []).forEach((plugin) => {
          network.attachPlugin(plugin);
        });
        return network;
      };
      Network.register(name, func);
      Network.register(chainId, func);
      if (options.altNames) {
        options.altNames.forEach((name2) => {
          Network.register(name2, func);
        });
      }
    }
    registerEth("mainnet", 1, { ensNetwork: 1, altNames: ["homestead"] });
    registerEth("ropsten", 3, { ensNetwork: 3 });
    registerEth("rinkeby", 4, { ensNetwork: 4 });
    registerEth("goerli", 5, { ensNetwork: 5 });
    registerEth("kovan", 42, { ensNetwork: 42 });
    registerEth("sepolia", 11155111, { ensNetwork: 11155111 });
    registerEth("holesky", 17e3, { ensNetwork: 17e3 });
    registerEth("classic", 61, {});
    registerEth("classicKotti", 6, {});
    registerEth("arbitrum", 42161, {
      ensNetwork: 1
    });
    registerEth("arbitrum-goerli", 421613, {});
    registerEth("arbitrum-sepolia", 421614, {});
    registerEth("base", 8453, { ensNetwork: 1 });
    registerEth("base-goerli", 84531, {});
    registerEth("base-sepolia", 84532, {});
    registerEth("bnb", 56, { ensNetwork: 1 });
    registerEth("bnbt", 97, {});
    registerEth("linea", 59144, { ensNetwork: 1 });
    registerEth("linea-goerli", 59140, {});
    registerEth("linea-sepolia", 59141, {});
    registerEth("matic", 137, {
      ensNetwork: 1,
      plugins: [
        getGasStationPlugin("https://gasstation.polygon.technology/v2")
      ]
    });
    registerEth("matic-amoy", 80002, {});
    registerEth("matic-mumbai", 80001, {
      altNames: ["maticMumbai", "maticmum"],
      plugins: [
        getGasStationPlugin("https://gasstation-testnet.polygon.technology/v2")
      ]
    });
    registerEth("optimism", 10, {
      ensNetwork: 1,
      plugins: []
    });
    registerEth("optimism-goerli", 420, {});
    registerEth("optimism-sepolia", 11155420, {});
    registerEth("xdai", 100, { ensNetwork: 1 });
  }
  var Networks, _name, _chainId2, _plugins, _Network, Network, injected;
  var init_network = __esm({
    "node_modules/ethers/lib.esm/providers/network.js"() {
      init_transaction2();
      init_utils();
      init_plugins_network();
      Networks = /* @__PURE__ */ new Map();
      _Network = class _Network {
        /**
         *  Creates a new **Network** for %%name%% and %%chainId%%.
         */
        constructor(name, chainId) {
          __privateAdd(this, _name);
          __privateAdd(this, _chainId2);
          __privateAdd(this, _plugins);
          __privateSet(this, _name, name);
          __privateSet(this, _chainId2, getBigInt(chainId));
          __privateSet(this, _plugins, /* @__PURE__ */ new Map());
        }
        /**
         *  Returns a JSON-compatible representation of a Network.
         */
        toJSON() {
          return { name: this.name, chainId: String(this.chainId) };
        }
        /**
         *  The network common name.
         *
         *  This is the canonical name, as networks migh have multiple
         *  names.
         */
        get name() {
          return __privateGet(this, _name);
        }
        set name(value) {
          __privateSet(this, _name, value);
        }
        /**
         *  The network chain ID.
         */
        get chainId() {
          return __privateGet(this, _chainId2);
        }
        set chainId(value) {
          __privateSet(this, _chainId2, getBigInt(value, "chainId"));
        }
        /**
         *  Returns true if %%other%% matches this network. Any chain ID
         *  must match, and if no chain ID is present, the name must match.
         *
         *  This method does not currently check for additional properties,
         *  such as ENS address or plug-in compatibility.
         */
        matches(other) {
          if (other == null) {
            return false;
          }
          if (typeof other === "string") {
            try {
              return this.chainId === getBigInt(other);
            } catch (error) {
            }
            return this.name === other;
          }
          if (typeof other === "number" || typeof other === "bigint") {
            try {
              return this.chainId === getBigInt(other);
            } catch (error) {
            }
            return false;
          }
          if (typeof other === "object") {
            if (other.chainId != null) {
              try {
                return this.chainId === getBigInt(other.chainId);
              } catch (error) {
              }
              return false;
            }
            if (other.name != null) {
              return this.name === other.name;
            }
            return false;
          }
          return false;
        }
        /**
         *  Returns the list of plugins currently attached to this Network.
         */
        get plugins() {
          return Array.from(__privateGet(this, _plugins).values());
        }
        /**
         *  Attach a new %%plugin%% to this Network. The network name
         *  must be unique, excluding any fragment.
         */
        attachPlugin(plugin) {
          if (__privateGet(this, _plugins).get(plugin.name)) {
            throw new Error(`cannot replace existing plugin: ${plugin.name} `);
          }
          __privateGet(this, _plugins).set(plugin.name, plugin.clone());
          return this;
        }
        /**
         *  Return the plugin, if any, matching %%name%% exactly. Plugins
         *  with fragments will not be returned unless %%name%% includes
         *  a fragment.
         */
        getPlugin(name) {
          return __privateGet(this, _plugins).get(name) || null;
        }
        /**
         *  Gets a list of all plugins that match %%name%%, with otr without
         *  a fragment.
         */
        getPlugins(basename) {
          return this.plugins.filter((p) => p.name.split("#")[0] === basename);
        }
        /**
         *  Create a copy of this Network.
         */
        clone() {
          const clone = new _Network(this.name, this.chainId);
          this.plugins.forEach((plugin) => {
            clone.attachPlugin(plugin.clone());
          });
          return clone;
        }
        /**
         *  Compute the intrinsic gas required for a transaction.
         *
         *  A GasCostPlugin can be attached to override the default
         *  values.
         */
        computeIntrinsicGas(tx) {
          const costs = this.getPlugin("org.ethers.plugins.network.GasCost") || new GasCostPlugin();
          let gas = costs.txBase;
          if (tx.to == null) {
            gas += costs.txCreate;
          }
          if (tx.data) {
            for (let i = 2; i < tx.data.length; i += 2) {
              if (tx.data.substring(i, i + 2) === "00") {
                gas += costs.txDataZero;
              } else {
                gas += costs.txDataNonzero;
              }
            }
          }
          if (tx.accessList) {
            const accessList = accessListify(tx.accessList);
            for (const addr in accessList) {
              gas += costs.txAccessListAddress + costs.txAccessListStorageKey * accessList[addr].storageKeys.length;
            }
          }
          return gas;
        }
        /**
         *  Returns a new Network for the %%network%% name or chainId.
         */
        static from(network) {
          injectCommonNetworks();
          if (network == null) {
            return _Network.from("mainnet");
          }
          if (typeof network === "number") {
            network = BigInt(network);
          }
          if (typeof network === "string" || typeof network === "bigint") {
            const networkFunc = Networks.get(network);
            if (networkFunc) {
              return networkFunc();
            }
            if (typeof network === "bigint") {
              return new _Network("unknown", network);
            }
            assertArgument(false, "unknown network", "network", network);
          }
          if (typeof network.clone === "function") {
            const clone = network.clone();
            return clone;
          }
          if (typeof network === "object") {
            assertArgument(typeof network.name === "string" && typeof network.chainId === "number", "invalid network object name or chainId", "network", network);
            const custom = new _Network(network.name, network.chainId);
            if (network.ensAddress || network.ensNetwork != null) {
              custom.attachPlugin(new EnsPlugin(network.ensAddress, network.ensNetwork));
            }
            return custom;
          }
          assertArgument(false, "invalid network", "network", network);
        }
        /**
         *  Register %%nameOrChainId%% with a function which returns
         *  an instance of a Network representing that chain.
         */
        static register(nameOrChainId, networkFunc) {
          if (typeof nameOrChainId === "number") {
            nameOrChainId = BigInt(nameOrChainId);
          }
          const existing = Networks.get(nameOrChainId);
          if (existing) {
            assertArgument(false, `conflicting network for ${JSON.stringify(existing.name)}`, "nameOrChainId", nameOrChainId);
          }
          Networks.set(nameOrChainId, networkFunc);
        }
      };
      _name = new WeakMap();
      _chainId2 = new WeakMap();
      _plugins = new WeakMap();
      Network = _Network;
      injected = false;
    }
  });

  // node_modules/ethers/lib.esm/providers/subscriber-polling.js
  function copy(obj) {
    return JSON.parse(JSON.stringify(obj));
  }
  var _provider, _poller, _interval, _blockNumber, _PollingBlockSubscriber_instances, poll_fn, PollingBlockSubscriber, _provider2, _poll, _running, OnBlockSubscriber, _tag, _lastBlock, PollingBlockTagSubscriber, _filter2, PollingOrphanSubscriber, _hash, PollingTransactionSubscriber, _provider3, _filter3, _poller2, _running2, _blockNumber2, _PollingEventSubscriber_instances, poll_fn2, PollingEventSubscriber;
  var init_subscriber_polling = __esm({
    "node_modules/ethers/lib.esm/providers/subscriber-polling.js"() {
      PollingBlockSubscriber = class {
        /**
         *  Create a new **PollingBlockSubscriber** attached to %%provider%%.
         */
        constructor(provider) {
          __privateAdd(this, _PollingBlockSubscriber_instances);
          __privateAdd(this, _provider);
          __privateAdd(this, _poller);
          __privateAdd(this, _interval);
          // The most recent block we have scanned for events. The value -2
          // indicates we still need to fetch an initial block number
          __privateAdd(this, _blockNumber);
          __privateSet(this, _provider, provider);
          __privateSet(this, _poller, null);
          __privateSet(this, _interval, 4e3);
          __privateSet(this, _blockNumber, -2);
        }
        /**
         *  The polling interval.
         */
        get pollingInterval() {
          return __privateGet(this, _interval);
        }
        set pollingInterval(value) {
          __privateSet(this, _interval, value);
        }
        start() {
          if (__privateGet(this, _poller)) {
            return;
          }
          __privateSet(this, _poller, __privateGet(this, _provider)._setTimeout(__privateMethod(this, _PollingBlockSubscriber_instances, poll_fn).bind(this), __privateGet(this, _interval)));
          __privateMethod(this, _PollingBlockSubscriber_instances, poll_fn).call(this);
        }
        stop() {
          if (!__privateGet(this, _poller)) {
            return;
          }
          __privateGet(this, _provider)._clearTimeout(__privateGet(this, _poller));
          __privateSet(this, _poller, null);
        }
        pause(dropWhilePaused) {
          this.stop();
          if (dropWhilePaused) {
            __privateSet(this, _blockNumber, -2);
          }
        }
        resume() {
          this.start();
        }
      };
      _provider = new WeakMap();
      _poller = new WeakMap();
      _interval = new WeakMap();
      _blockNumber = new WeakMap();
      _PollingBlockSubscriber_instances = new WeakSet();
      poll_fn = async function() {
        try {
          const blockNumber = await __privateGet(this, _provider).getBlockNumber();
          if (__privateGet(this, _blockNumber) === -2) {
            __privateSet(this, _blockNumber, blockNumber);
            return;
          }
          if (blockNumber !== __privateGet(this, _blockNumber)) {
            for (let b2 = __privateGet(this, _blockNumber) + 1; b2 <= blockNumber; b2++) {
              if (__privateGet(this, _poller) == null) {
                return;
              }
              await __privateGet(this, _provider).emit("block", b2);
            }
            __privateSet(this, _blockNumber, blockNumber);
          }
        } catch (error) {
        }
        if (__privateGet(this, _poller) == null) {
          return;
        }
        __privateSet(this, _poller, __privateGet(this, _provider)._setTimeout(__privateMethod(this, _PollingBlockSubscriber_instances, poll_fn).bind(this), __privateGet(this, _interval)));
      };
      OnBlockSubscriber = class {
        /**
         *  Create a new **OnBlockSubscriber** attached to %%provider%%.
         */
        constructor(provider) {
          __privateAdd(this, _provider2);
          __privateAdd(this, _poll);
          __privateAdd(this, _running);
          __privateSet(this, _provider2, provider);
          __privateSet(this, _running, false);
          __privateSet(this, _poll, (blockNumber) => {
            this._poll(blockNumber, __privateGet(this, _provider2));
          });
        }
        /**
         *  Called on every new block.
         */
        async _poll(blockNumber, provider) {
          throw new Error("sub-classes must override this");
        }
        start() {
          if (__privateGet(this, _running)) {
            return;
          }
          __privateSet(this, _running, true);
          __privateGet(this, _poll).call(this, -2);
          __privateGet(this, _provider2).on("block", __privateGet(this, _poll));
        }
        stop() {
          if (!__privateGet(this, _running)) {
            return;
          }
          __privateSet(this, _running, false);
          __privateGet(this, _provider2).off("block", __privateGet(this, _poll));
        }
        pause(dropWhilePaused) {
          this.stop();
        }
        resume() {
          this.start();
        }
      };
      _provider2 = new WeakMap();
      _poll = new WeakMap();
      _running = new WeakMap();
      PollingBlockTagSubscriber = class extends OnBlockSubscriber {
        constructor(provider, tag) {
          super(provider);
          __privateAdd(this, _tag);
          __privateAdd(this, _lastBlock);
          __privateSet(this, _tag, tag);
          __privateSet(this, _lastBlock, -2);
        }
        pause(dropWhilePaused) {
          if (dropWhilePaused) {
            __privateSet(this, _lastBlock, -2);
          }
          super.pause(dropWhilePaused);
        }
        async _poll(blockNumber, provider) {
          const block = await provider.getBlock(__privateGet(this, _tag));
          if (block == null) {
            return;
          }
          if (__privateGet(this, _lastBlock) === -2) {
            __privateSet(this, _lastBlock, block.number);
          } else if (block.number > __privateGet(this, _lastBlock)) {
            provider.emit(__privateGet(this, _tag), block.number);
            __privateSet(this, _lastBlock, block.number);
          }
        }
      };
      _tag = new WeakMap();
      _lastBlock = new WeakMap();
      PollingOrphanSubscriber = class extends OnBlockSubscriber {
        constructor(provider, filter) {
          super(provider);
          __privateAdd(this, _filter2);
          __privateSet(this, _filter2, copy(filter));
        }
        async _poll(blockNumber, provider) {
          throw new Error("@TODO");
          console.log(__privateGet(this, _filter2));
        }
      };
      _filter2 = new WeakMap();
      PollingTransactionSubscriber = class extends OnBlockSubscriber {
        /**
         *  Create a new **PollingTransactionSubscriber** attached to
         *  %%provider%%, listening for %%hash%%.
         */
        constructor(provider, hash3) {
          super(provider);
          __privateAdd(this, _hash);
          __privateSet(this, _hash, hash3);
        }
        async _poll(blockNumber, provider) {
          const tx = await provider.getTransactionReceipt(__privateGet(this, _hash));
          if (tx) {
            provider.emit(__privateGet(this, _hash), tx);
          }
        }
      };
      _hash = new WeakMap();
      PollingEventSubscriber = class {
        /**
         *  Create a new **PollingTransactionSubscriber** attached to
         *  %%provider%%, listening for %%filter%%.
         */
        constructor(provider, filter) {
          __privateAdd(this, _PollingEventSubscriber_instances);
          __privateAdd(this, _provider3);
          __privateAdd(this, _filter3);
          __privateAdd(this, _poller2);
          __privateAdd(this, _running2);
          // The most recent block we have scanned for events. The value -2
          // indicates we still need to fetch an initial block number
          __privateAdd(this, _blockNumber2);
          __privateSet(this, _provider3, provider);
          __privateSet(this, _filter3, copy(filter));
          __privateSet(this, _poller2, __privateMethod(this, _PollingEventSubscriber_instances, poll_fn2).bind(this));
          __privateSet(this, _running2, false);
          __privateSet(this, _blockNumber2, -2);
        }
        start() {
          if (__privateGet(this, _running2)) {
            return;
          }
          __privateSet(this, _running2, true);
          if (__privateGet(this, _blockNumber2) === -2) {
            __privateGet(this, _provider3).getBlockNumber().then((blockNumber) => {
              __privateSet(this, _blockNumber2, blockNumber);
            });
          }
          __privateGet(this, _provider3).on("block", __privateGet(this, _poller2));
        }
        stop() {
          if (!__privateGet(this, _running2)) {
            return;
          }
          __privateSet(this, _running2, false);
          __privateGet(this, _provider3).off("block", __privateGet(this, _poller2));
        }
        pause(dropWhilePaused) {
          this.stop();
          if (dropWhilePaused) {
            __privateSet(this, _blockNumber2, -2);
          }
        }
        resume() {
          this.start();
        }
      };
      _provider3 = new WeakMap();
      _filter3 = new WeakMap();
      _poller2 = new WeakMap();
      _running2 = new WeakMap();
      _blockNumber2 = new WeakMap();
      _PollingEventSubscriber_instances = new WeakSet();
      poll_fn2 = async function(blockNumber) {
        if (__privateGet(this, _blockNumber2) === -2) {
          return;
        }
        const filter = copy(__privateGet(this, _filter3));
        filter.fromBlock = __privateGet(this, _blockNumber2) + 1;
        filter.toBlock = blockNumber;
        const logs = await __privateGet(this, _provider3).getLogs(filter);
        if (logs.length === 0) {
          if (__privateGet(this, _blockNumber2) < blockNumber - 60) {
            __privateSet(this, _blockNumber2, blockNumber - 60);
          }
          return;
        }
        for (const log of logs) {
          __privateGet(this, _provider3).emit(__privateGet(this, _filter3), log);
          __privateSet(this, _blockNumber2, log.blockNumber);
        }
      };
    }
  });

  // node_modules/ethers/lib.esm/providers/abstract-provider.js
  function isPromise(value) {
    return value && typeof value.then === "function";
  }
  function getTag(prefix, value) {
    return prefix + ":" + JSON.stringify(value, (k, v) => {
      if (v == null) {
        return "null";
      }
      if (typeof v === "bigint") {
        return `bigint:${v.toString()}`;
      }
      if (typeof v === "string") {
        return v.toLowerCase();
      }
      if (typeof v === "object" && !Array.isArray(v)) {
        const keys = Object.keys(v);
        keys.sort();
        return keys.reduce((accum, key) => {
          accum[key] = v[key];
          return accum;
        }, {});
      }
      return v;
    });
  }
  function copy2(value) {
    return JSON.parse(JSON.stringify(value));
  }
  function concisify(items) {
    items = Array.from(new Set(items).values());
    items.sort();
    return items;
  }
  async function getSubscription(_event2, provider) {
    if (_event2 == null) {
      throw new Error("invalid event");
    }
    if (Array.isArray(_event2)) {
      _event2 = { topics: _event2 };
    }
    if (typeof _event2 === "string") {
      switch (_event2) {
        case "block":
        case "debug":
        case "error":
        case "finalized":
        case "network":
        case "pending":
        case "safe": {
          return { type: _event2, tag: _event2 };
        }
      }
    }
    if (isHexString(_event2, 32)) {
      const hash3 = _event2.toLowerCase();
      return { type: "transaction", tag: getTag("tx", { hash: hash3 }), hash: hash3 };
    }
    if (_event2.orphan) {
      const event = _event2;
      return { type: "orphan", tag: getTag("orphan", event), filter: copy2(event) };
    }
    if (_event2.address || _event2.topics) {
      const event = _event2;
      const filter = {
        topics: (event.topics || []).map((t) => {
          if (t == null) {
            return null;
          }
          if (Array.isArray(t)) {
            return concisify(t.map((t2) => t2.toLowerCase()));
          }
          return t.toLowerCase();
        })
      };
      if (event.address) {
        const addresses = [];
        const promises = [];
        const addAddress = (addr) => {
          if (isHexString(addr)) {
            addresses.push(addr);
          } else {
            promises.push((async () => {
              addresses.push(await resolveAddress(addr, provider));
            })());
          }
        };
        if (Array.isArray(event.address)) {
          event.address.forEach(addAddress);
        } else {
          addAddress(event.address);
        }
        if (promises.length) {
          await Promise.all(promises);
        }
        filter.address = concisify(addresses.map((a) => a.toLowerCase()));
      }
      return { filter, tag: getTag("event", filter), type: "event" };
    }
    assertArgument(false, "unknown ProviderEvent", "event", _event2);
  }
  function getTime2() {
    return (/* @__PURE__ */ new Date()).getTime();
  }
  function _parseString(result, start) {
    try {
      const bytes2 = _parseBytes(result, start);
      if (bytes2) {
        return toUtf8String(bytes2);
      }
    } catch (error) {
    }
    return null;
  }
  function _parseBytes(result, start) {
    if (result === "0x") {
      return null;
    }
    try {
      const offset = getNumber(dataSlice(result, start, start + 32));
      const length = getNumber(dataSlice(result, offset, offset + 32));
      return dataSlice(result, offset + 32, offset + 32 + length);
    } catch (error) {
    }
    return null;
  }
  function numPad(value) {
    const result = toBeArray(value);
    if (result.length > 32) {
      throw new Error("internal; should not happen");
    }
    const padded = new Uint8Array(32);
    padded.set(result, 32 - result.length);
    return padded;
  }
  function bytesPad(value) {
    if (value.length % 32 === 0) {
      return value;
    }
    const result = new Uint8Array(Math.ceil(value.length / 32) * 32);
    result.set(value);
    return result;
  }
  function encodeBytes(datas) {
    const result = [];
    let byteCount = 0;
    for (let i = 0; i < datas.length; i++) {
      result.push(empty);
      byteCount += 32;
    }
    for (let i = 0; i < datas.length; i++) {
      const data = getBytes(datas[i]);
      result[i] = numPad(byteCount);
      result.push(numPad(data.length));
      result.push(bytesPad(data));
      byteCount += 32 + Math.ceil(data.length / 32) * 32;
    }
    return concat(result);
  }
  function parseOffchainLookup(data) {
    const result = {
      sender: "",
      urls: [],
      calldata: "",
      selector: "",
      extraData: "",
      errorArgs: []
    };
    assert(dataLength(data) >= 5 * 32, "insufficient OffchainLookup data", "OFFCHAIN_FAULT", {
      reason: "insufficient OffchainLookup data"
    });
    const sender = dataSlice(data, 0, 32);
    assert(dataSlice(sender, 0, 12) === dataSlice(zeros, 0, 12), "corrupt OffchainLookup sender", "OFFCHAIN_FAULT", {
      reason: "corrupt OffchainLookup sender"
    });
    result.sender = dataSlice(sender, 12);
    try {
      const urls = [];
      const urlsOffset = getNumber(dataSlice(data, 32, 64));
      const urlsLength = getNumber(dataSlice(data, urlsOffset, urlsOffset + 32));
      const urlsData = dataSlice(data, urlsOffset + 32);
      for (let u = 0; u < urlsLength; u++) {
        const url = _parseString(urlsData, u * 32);
        if (url == null) {
          throw new Error("abort");
        }
        urls.push(url);
      }
      result.urls = urls;
    } catch (error) {
      assert(false, "corrupt OffchainLookup urls", "OFFCHAIN_FAULT", {
        reason: "corrupt OffchainLookup urls"
      });
    }
    try {
      const calldata = _parseBytes(data, 64);
      if (calldata == null) {
        throw new Error("abort");
      }
      result.calldata = calldata;
    } catch (error) {
      assert(false, "corrupt OffchainLookup calldata", "OFFCHAIN_FAULT", {
        reason: "corrupt OffchainLookup calldata"
      });
    }
    assert(dataSlice(data, 100, 128) === dataSlice(zeros, 0, 28), "corrupt OffchainLookup callbaackSelector", "OFFCHAIN_FAULT", {
      reason: "corrupt OffchainLookup callbaackSelector"
    });
    result.selector = dataSlice(data, 96, 100);
    try {
      const extraData = _parseBytes(data, 128);
      if (extraData == null) {
        throw new Error("abort");
      }
      result.extraData = extraData;
    } catch (error) {
      assert(false, "corrupt OffchainLookup extraData", "OFFCHAIN_FAULT", {
        reason: "corrupt OffchainLookup extraData"
      });
    }
    result.errorArgs = "sender,urls,calldata,selector,extraData".split(/,/).map((k) => result[k]);
    return result;
  }
  var BN_23, MAX_CCIP_REDIRECTS, UnmanagedSubscriber, defaultOptions, _subs, _plugins2, _pausedState, _destroyed, _networkPromise, _anyNetwork, _performCache, _lastBlockNumber, _nextTimer, _timers, _disableCcipRead, _options2, _AbstractProvider_instances, perform_fn, call_fn, checkNetwork_fn, getAccountValue_fn, getBlock_fn, hasSub_fn, getSub_fn, AbstractProvider, empty, zeros;
  var init_abstract_provider = __esm({
    "node_modules/ethers/lib.esm/providers/abstract-provider.js"() {
      init_address2();
      init_constants();
      init_contract2();
      init_hash();
      init_transaction2();
      init_utils();
      init_ens_resolver();
      init_format();
      init_network();
      init_provider();
      init_subscriber_polling();
      BN_23 = BigInt(2);
      MAX_CCIP_REDIRECTS = 10;
      UnmanagedSubscriber = class {
        /**
         *  Create a new UnmanagedSubscriber with %%name%%.
         */
        constructor(name) {
          /**
           *  The name fof the event.
           */
          __publicField(this, "name");
          defineProperties(this, { name });
        }
        start() {
        }
        stop() {
        }
        pause(dropWhilePaused) {
        }
        resume() {
        }
      };
      defaultOptions = {
        cacheTimeout: 250,
        pollingInterval: 4e3
      };
      AbstractProvider = class {
        /**
         *  Create a new **AbstractProvider** connected to %%network%%, or
         *  use the various network detection capabilities to discover the
         *  [[Network]] if necessary.
         */
        constructor(_network3, options) {
          __privateAdd(this, _AbstractProvider_instances);
          __privateAdd(this, _subs);
          __privateAdd(this, _plugins2);
          // null=unpaused, true=paused+dropWhilePaused, false=paused
          __privateAdd(this, _pausedState);
          __privateAdd(this, _destroyed);
          __privateAdd(this, _networkPromise);
          __privateAdd(this, _anyNetwork);
          __privateAdd(this, _performCache);
          // The most recent block number if running an event or -1 if no "block" event
          __privateAdd(this, _lastBlockNumber);
          __privateAdd(this, _nextTimer);
          __privateAdd(this, _timers);
          __privateAdd(this, _disableCcipRead);
          __privateAdd(this, _options2);
          __privateSet(this, _options2, Object.assign({}, defaultOptions, options || {}));
          if (_network3 === "any") {
            __privateSet(this, _anyNetwork, true);
            __privateSet(this, _networkPromise, null);
          } else if (_network3) {
            const network = Network.from(_network3);
            __privateSet(this, _anyNetwork, false);
            __privateSet(this, _networkPromise, Promise.resolve(network));
            setTimeout(() => {
              this.emit("network", network, null);
            }, 0);
          } else {
            __privateSet(this, _anyNetwork, false);
            __privateSet(this, _networkPromise, null);
          }
          __privateSet(this, _lastBlockNumber, -1);
          __privateSet(this, _performCache, /* @__PURE__ */ new Map());
          __privateSet(this, _subs, /* @__PURE__ */ new Map());
          __privateSet(this, _plugins2, /* @__PURE__ */ new Map());
          __privateSet(this, _pausedState, null);
          __privateSet(this, _destroyed, false);
          __privateSet(this, _nextTimer, 1);
          __privateSet(this, _timers, /* @__PURE__ */ new Map());
          __privateSet(this, _disableCcipRead, false);
        }
        get pollingInterval() {
          return __privateGet(this, _options2).pollingInterval;
        }
        /**
         *  Returns ``this``, to allow an **AbstractProvider** to implement
         *  the [[ContractRunner]] interface.
         */
        get provider() {
          return this;
        }
        /**
         *  Returns all the registered plug-ins.
         */
        get plugins() {
          return Array.from(__privateGet(this, _plugins2).values());
        }
        /**
         *  Attach a new plug-in.
         */
        attachPlugin(plugin) {
          if (__privateGet(this, _plugins2).get(plugin.name)) {
            throw new Error(`cannot replace existing plugin: ${plugin.name} `);
          }
          __privateGet(this, _plugins2).set(plugin.name, plugin.connect(this));
          return this;
        }
        /**
         *  Get a plugin by name.
         */
        getPlugin(name) {
          return __privateGet(this, _plugins2).get(name) || null;
        }
        /**
         *  Prevent any CCIP-read operation, regardless of whether requested
         *  in a [[call]] using ``enableCcipRead``.
         */
        get disableCcipRead() {
          return __privateGet(this, _disableCcipRead);
        }
        set disableCcipRead(value) {
          __privateSet(this, _disableCcipRead, !!value);
        }
        /**
         *  Resolves to the data for executing the CCIP-read operations.
         */
        async ccipReadFetch(tx, calldata, urls) {
          if (this.disableCcipRead || urls.length === 0 || tx.to == null) {
            return null;
          }
          const sender = tx.to.toLowerCase();
          const data = calldata.toLowerCase();
          const errorMessages = [];
          for (let i = 0; i < urls.length; i++) {
            const url = urls[i];
            const href = url.replace("{sender}", sender).replace("{data}", data);
            const request = new FetchRequest(href);
            if (url.indexOf("{data}") === -1) {
              request.body = { data, sender };
            }
            this.emit("debug", { action: "sendCcipReadFetchRequest", request, index: i, urls });
            let errorMessage = "unknown error";
            let resp;
            try {
              resp = await request.send();
            } catch (error) {
              errorMessages.push(error.message);
              this.emit("debug", { action: "receiveCcipReadFetchError", request, result: { error } });
              continue;
            }
            try {
              const result = resp.bodyJson;
              if (result.data) {
                this.emit("debug", { action: "receiveCcipReadFetchResult", request, result });
                return result.data;
              }
              if (result.message) {
                errorMessage = result.message;
              }
              this.emit("debug", { action: "receiveCcipReadFetchError", request, result });
            } catch (error) {
            }
            assert(resp.statusCode < 400 || resp.statusCode >= 500, `response not found during CCIP fetch: ${errorMessage}`, "OFFCHAIN_FAULT", { reason: "404_MISSING_RESOURCE", transaction: tx, info: { url, errorMessage } });
            errorMessages.push(errorMessage);
          }
          assert(false, `error encountered during CCIP fetch: ${errorMessages.map((m) => JSON.stringify(m)).join(", ")}`, "OFFCHAIN_FAULT", {
            reason: "500_SERVER_ERROR",
            transaction: tx,
            info: { urls, errorMessages }
          });
        }
        /**
         *  Provides the opportunity for a sub-class to wrap a block before
         *  returning it, to add additional properties or an alternate
         *  sub-class of [[Block]].
         */
        _wrapBlock(value, network) {
          return new Block(formatBlock(value), this);
        }
        /**
         *  Provides the opportunity for a sub-class to wrap a log before
         *  returning it, to add additional properties or an alternate
         *  sub-class of [[Log]].
         */
        _wrapLog(value, network) {
          return new Log(formatLog(value), this);
        }
        /**
         *  Provides the opportunity for a sub-class to wrap a transaction
         *  receipt before returning it, to add additional properties or an
         *  alternate sub-class of [[TransactionReceipt]].
         */
        _wrapTransactionReceipt(value, network) {
          return new TransactionReceipt(formatTransactionReceipt(value), this);
        }
        /**
         *  Provides the opportunity for a sub-class to wrap a transaction
         *  response before returning it, to add additional properties or an
         *  alternate sub-class of [[TransactionResponse]].
         */
        _wrapTransactionResponse(tx, network) {
          return new TransactionResponse(formatTransactionResponse(tx), this);
        }
        /**
         *  Resolves to the Network, forcing a network detection using whatever
         *  technique the sub-class requires.
         *
         *  Sub-classes **must** override this.
         */
        _detectNetwork() {
          assert(false, "sub-classes must implement this", "UNSUPPORTED_OPERATION", {
            operation: "_detectNetwork"
          });
        }
        /**
         *  Sub-classes should use this to perform all built-in operations. All
         *  methods sanitizes and normalizes the values passed into this.
         *
         *  Sub-classes **must** override this.
         */
        async _perform(req) {
          assert(false, `unsupported method: ${req.method}`, "UNSUPPORTED_OPERATION", {
            operation: req.method,
            info: req
          });
        }
        // State
        async getBlockNumber() {
          const blockNumber = getNumber(await __privateMethod(this, _AbstractProvider_instances, perform_fn).call(this, { method: "getBlockNumber" }), "%response");
          if (__privateGet(this, _lastBlockNumber) >= 0) {
            __privateSet(this, _lastBlockNumber, blockNumber);
          }
          return blockNumber;
        }
        /**
         *  Returns or resolves to the address for %%address%%, resolving ENS
         *  names and [[Addressable]] objects and returning if already an
         *  address.
         */
        _getAddress(address) {
          return resolveAddress(address, this);
        }
        /**
         *  Returns or resolves to a valid block tag for %%blockTag%%, resolving
         *  negative values and returning if already a valid block tag.
         */
        _getBlockTag(blockTag) {
          if (blockTag == null) {
            return "latest";
          }
          switch (blockTag) {
            case "earliest":
              return "0x0";
            case "finalized":
            case "latest":
            case "pending":
            case "safe":
              return blockTag;
          }
          if (isHexString(blockTag)) {
            if (isHexString(blockTag, 32)) {
              return blockTag;
            }
            return toQuantity(blockTag);
          }
          if (typeof blockTag === "bigint") {
            blockTag = getNumber(blockTag, "blockTag");
          }
          if (typeof blockTag === "number") {
            if (blockTag >= 0) {
              return toQuantity(blockTag);
            }
            if (__privateGet(this, _lastBlockNumber) >= 0) {
              return toQuantity(__privateGet(this, _lastBlockNumber) + blockTag);
            }
            return this.getBlockNumber().then((b2) => toQuantity(b2 + blockTag));
          }
          assertArgument(false, "invalid blockTag", "blockTag", blockTag);
        }
        /**
         *  Returns or resolves to a filter for %%filter%%, resolving any ENS
         *  names or [[Addressable]] object and returning if already a valid
         *  filter.
         */
        _getFilter(filter) {
          const topics = (filter.topics || []).map((t) => {
            if (t == null) {
              return null;
            }
            if (Array.isArray(t)) {
              return concisify(t.map((t2) => t2.toLowerCase()));
            }
            return t.toLowerCase();
          });
          const blockHash = "blockHash" in filter ? filter.blockHash : void 0;
          const resolve = (_address, fromBlock2, toBlock2) => {
            let address2 = void 0;
            switch (_address.length) {
              case 0:
                break;
              case 1:
                address2 = _address[0];
                break;
              default:
                _address.sort();
                address2 = _address;
            }
            if (blockHash) {
              if (fromBlock2 != null || toBlock2 != null) {
                throw new Error("invalid filter");
              }
            }
            const filter2 = {};
            if (address2) {
              filter2.address = address2;
            }
            if (topics.length) {
              filter2.topics = topics;
            }
            if (fromBlock2) {
              filter2.fromBlock = fromBlock2;
            }
            if (toBlock2) {
              filter2.toBlock = toBlock2;
            }
            if (blockHash) {
              filter2.blockHash = blockHash;
            }
            return filter2;
          };
          let address = [];
          if (filter.address) {
            if (Array.isArray(filter.address)) {
              for (const addr of filter.address) {
                address.push(this._getAddress(addr));
              }
            } else {
              address.push(this._getAddress(filter.address));
            }
          }
          let fromBlock = void 0;
          if ("fromBlock" in filter) {
            fromBlock = this._getBlockTag(filter.fromBlock);
          }
          let toBlock = void 0;
          if ("toBlock" in filter) {
            toBlock = this._getBlockTag(filter.toBlock);
          }
          if (address.filter((a) => typeof a !== "string").length || fromBlock != null && typeof fromBlock !== "string" || toBlock != null && typeof toBlock !== "string") {
            return Promise.all([Promise.all(address), fromBlock, toBlock]).then((result) => {
              return resolve(result[0], result[1], result[2]);
            });
          }
          return resolve(address, fromBlock, toBlock);
        }
        /**
         *  Returns or resolves to a transaction for %%request%%, resolving
         *  any ENS names or [[Addressable]] and returning if already a valid
         *  transaction.
         */
        _getTransactionRequest(_request3) {
          const request = copyRequest(_request3);
          const promises = [];
          ["to", "from"].forEach((key) => {
            if (request[key] == null) {
              return;
            }
            const addr = resolveAddress(request[key], this);
            if (isPromise(addr)) {
              promises.push(async function() {
                request[key] = await addr;
              }());
            } else {
              request[key] = addr;
            }
          });
          if (request.blockTag != null) {
            const blockTag = this._getBlockTag(request.blockTag);
            if (isPromise(blockTag)) {
              promises.push(async function() {
                request.blockTag = await blockTag;
              }());
            } else {
              request.blockTag = blockTag;
            }
          }
          if (promises.length) {
            return async function() {
              await Promise.all(promises);
              return request;
            }();
          }
          return request;
        }
        async getNetwork() {
          if (__privateGet(this, _networkPromise) == null) {
            const detectNetwork = (async () => {
              try {
                const network = await this._detectNetwork();
                this.emit("network", network, null);
                return network;
              } catch (error) {
                if (__privateGet(this, _networkPromise) === detectNetwork) {
                  __privateSet(this, _networkPromise, null);
                }
                throw error;
              }
            })();
            __privateSet(this, _networkPromise, detectNetwork);
            return (await detectNetwork).clone();
          }
          const networkPromise = __privateGet(this, _networkPromise);
          const [expected, actual] = await Promise.all([
            networkPromise,
            this._detectNetwork()
            // The actual connected network
          ]);
          if (expected.chainId !== actual.chainId) {
            if (__privateGet(this, _anyNetwork)) {
              this.emit("network", actual, expected);
              if (__privateGet(this, _networkPromise) === networkPromise) {
                __privateSet(this, _networkPromise, Promise.resolve(actual));
              }
            } else {
              assert(false, `network changed: ${expected.chainId} => ${actual.chainId} `, "NETWORK_ERROR", {
                event: "changed"
              });
            }
          }
          return expected.clone();
        }
        async getFeeData() {
          const network = await this.getNetwork();
          const getFeeDataFunc = async () => {
            const { _block, gasPrice, priorityFee } = await resolveProperties({
              _block: __privateMethod(this, _AbstractProvider_instances, getBlock_fn).call(this, "latest", false),
              gasPrice: (async () => {
                try {
                  const value = await __privateMethod(this, _AbstractProvider_instances, perform_fn).call(this, { method: "getGasPrice" });
                  return getBigInt(value, "%response");
                } catch (error) {
                }
                return null;
              })(),
              priorityFee: (async () => {
                try {
                  const value = await __privateMethod(this, _AbstractProvider_instances, perform_fn).call(this, { method: "getPriorityFee" });
                  return getBigInt(value, "%response");
                } catch (error) {
                }
                return null;
              })()
            });
            let maxFeePerGas = null;
            let maxPriorityFeePerGas = null;
            const block = this._wrapBlock(_block, network);
            if (block && block.baseFeePerGas) {
              maxPriorityFeePerGas = priorityFee != null ? priorityFee : BigInt("1000000000");
              maxFeePerGas = block.baseFeePerGas * BN_23 + maxPriorityFeePerGas;
            }
            return new FeeData(gasPrice, maxFeePerGas, maxPriorityFeePerGas);
          };
          const plugin = network.getPlugin("org.ethers.plugins.network.FetchUrlFeeDataPlugin");
          if (plugin) {
            const req = new FetchRequest(plugin.url);
            const feeData = await plugin.processFunc(getFeeDataFunc, this, req);
            return new FeeData(feeData.gasPrice, feeData.maxFeePerGas, feeData.maxPriorityFeePerGas);
          }
          return await getFeeDataFunc();
        }
        async estimateGas(_tx) {
          let tx = this._getTransactionRequest(_tx);
          if (isPromise(tx)) {
            tx = await tx;
          }
          return getBigInt(await __privateMethod(this, _AbstractProvider_instances, perform_fn).call(this, {
            method: "estimateGas",
            transaction: tx
          }), "%response");
        }
        async call(_tx) {
          const { tx, blockTag } = await resolveProperties({
            tx: this._getTransactionRequest(_tx),
            blockTag: this._getBlockTag(_tx.blockTag)
          });
          return await __privateMethod(this, _AbstractProvider_instances, checkNetwork_fn).call(this, __privateMethod(this, _AbstractProvider_instances, call_fn).call(this, tx, blockTag, _tx.enableCcipRead ? 0 : -1));
        }
        async getBalance(address, blockTag) {
          return getBigInt(await __privateMethod(this, _AbstractProvider_instances, getAccountValue_fn).call(this, { method: "getBalance" }, address, blockTag), "%response");
        }
        async getTransactionCount(address, blockTag) {
          return getNumber(await __privateMethod(this, _AbstractProvider_instances, getAccountValue_fn).call(this, { method: "getTransactionCount" }, address, blockTag), "%response");
        }
        async getCode(address, blockTag) {
          return hexlify(await __privateMethod(this, _AbstractProvider_instances, getAccountValue_fn).call(this, { method: "getCode" }, address, blockTag));
        }
        async getStorage(address, _position, blockTag) {
          const position = getBigInt(_position, "position");
          return hexlify(await __privateMethod(this, _AbstractProvider_instances, getAccountValue_fn).call(this, { method: "getStorage", position }, address, blockTag));
        }
        // Write
        async broadcastTransaction(signedTx) {
          const { blockNumber, hash: hash3, network } = await resolveProperties({
            blockNumber: this.getBlockNumber(),
            hash: this._perform({
              method: "broadcastTransaction",
              signedTransaction: signedTx
            }),
            network: this.getNetwork()
          });
          const tx = Transaction.from(signedTx);
          if (tx.hash !== hash3) {
            throw new Error("@TODO: the returned hash did not match");
          }
          return this._wrapTransactionResponse(tx, network).replaceableTransaction(blockNumber);
        }
        // Queries
        async getBlock(block, prefetchTxs) {
          const { network, params } = await resolveProperties({
            network: this.getNetwork(),
            params: __privateMethod(this, _AbstractProvider_instances, getBlock_fn).call(this, block, !!prefetchTxs)
          });
          if (params == null) {
            return null;
          }
          return this._wrapBlock(params, network);
        }
        async getTransaction(hash3) {
          const { network, params } = await resolveProperties({
            network: this.getNetwork(),
            params: __privateMethod(this, _AbstractProvider_instances, perform_fn).call(this, { method: "getTransaction", hash: hash3 })
          });
          if (params == null) {
            return null;
          }
          return this._wrapTransactionResponse(params, network);
        }
        async getTransactionReceipt(hash3) {
          const { network, params } = await resolveProperties({
            network: this.getNetwork(),
            params: __privateMethod(this, _AbstractProvider_instances, perform_fn).call(this, { method: "getTransactionReceipt", hash: hash3 })
          });
          if (params == null) {
            return null;
          }
          if (params.gasPrice == null && params.effectiveGasPrice == null) {
            const tx = await __privateMethod(this, _AbstractProvider_instances, perform_fn).call(this, { method: "getTransaction", hash: hash3 });
            if (tx == null) {
              throw new Error("report this; could not find tx or effectiveGasPrice");
            }
            params.effectiveGasPrice = tx.gasPrice;
          }
          return this._wrapTransactionReceipt(params, network);
        }
        async getTransactionResult(hash3) {
          const { result } = await resolveProperties({
            network: this.getNetwork(),
            result: __privateMethod(this, _AbstractProvider_instances, perform_fn).call(this, { method: "getTransactionResult", hash: hash3 })
          });
          if (result == null) {
            return null;
          }
          return hexlify(result);
        }
        // Bloom-filter Queries
        async getLogs(_filter5) {
          let filter = this._getFilter(_filter5);
          if (isPromise(filter)) {
            filter = await filter;
          }
          const { network, params } = await resolveProperties({
            network: this.getNetwork(),
            params: __privateMethod(this, _AbstractProvider_instances, perform_fn).call(this, { method: "getLogs", filter })
          });
          return params.map((p) => this._wrapLog(p, network));
        }
        // ENS
        _getProvider(chainId) {
          assert(false, "provider cannot connect to target network", "UNSUPPORTED_OPERATION", {
            operation: "_getProvider()"
          });
        }
        async getResolver(name) {
          return await EnsResolver.fromName(this, name);
        }
        async getAvatar(name) {
          const resolver = await this.getResolver(name);
          if (resolver) {
            return await resolver.getAvatar();
          }
          return null;
        }
        async resolveName(name) {
          const resolver = await this.getResolver(name);
          if (resolver) {
            return await resolver.getAddress();
          }
          return null;
        }
        async lookupAddress(address) {
          address = getAddress(address);
          const node = namehash(address.substring(2).toLowerCase() + ".addr.reverse");
          try {
            const ensAddr = await EnsResolver.getEnsAddress(this);
            const ensContract = new Contract(ensAddr, [
              "function resolver(bytes32) view returns (address)"
            ], this);
            const resolver = await ensContract.resolver(node);
            if (resolver == null || resolver === ZeroAddress) {
              return null;
            }
            const resolverContract = new Contract(resolver, [
              "function name(bytes32) view returns (string)"
            ], this);
            const name = await resolverContract.name(node);
            const check = await this.resolveName(name);
            if (check !== address) {
              return null;
            }
            return name;
          } catch (error) {
            if (isError(error, "BAD_DATA") && error.value === "0x") {
              return null;
            }
            if (isError(error, "CALL_EXCEPTION")) {
              return null;
            }
            throw error;
          }
          return null;
        }
        async waitForTransaction(hash3, _confirms, timeout) {
          const confirms = _confirms != null ? _confirms : 1;
          if (confirms === 0) {
            return this.getTransactionReceipt(hash3);
          }
          return new Promise(async (resolve, reject) => {
            let timer = null;
            const listener = async (blockNumber) => {
              try {
                const receipt = await this.getTransactionReceipt(hash3);
                if (receipt != null) {
                  if (blockNumber - receipt.blockNumber + 1 >= confirms) {
                    resolve(receipt);
                    if (timer) {
                      clearTimeout(timer);
                      timer = null;
                    }
                    return;
                  }
                }
              } catch (error) {
                console.log("EEE", error);
              }
              this.once("block", listener);
            };
            if (timeout != null) {
              timer = setTimeout(() => {
                if (timer == null) {
                  return;
                }
                timer = null;
                this.off("block", listener);
                reject(makeError("timeout", "TIMEOUT", { reason: "timeout" }));
              }, timeout);
            }
            listener(await this.getBlockNumber());
          });
        }
        async waitForBlock(blockTag) {
          assert(false, "not implemented yet", "NOT_IMPLEMENTED", {
            operation: "waitForBlock"
          });
        }
        /**
         *  Clear a timer created using the [[_setTimeout]] method.
         */
        _clearTimeout(timerId) {
          const timer = __privateGet(this, _timers).get(timerId);
          if (!timer) {
            return;
          }
          if (timer.timer) {
            clearTimeout(timer.timer);
          }
          __privateGet(this, _timers).delete(timerId);
        }
        /**
         *  Create a timer that will execute %%func%% after at least %%timeout%%
         *  (in ms). If %%timeout%% is unspecified, then %%func%% will execute
         *  in the next event loop.
         *
         *  [Pausing](AbstractProvider-paused) the provider will pause any
         *  associated timers.
         */
        _setTimeout(_func, timeout) {
          if (timeout == null) {
            timeout = 0;
          }
          const timerId = __privateWrapper(this, _nextTimer)._++;
          const func = () => {
            __privateGet(this, _timers).delete(timerId);
            _func();
          };
          if (this.paused) {
            __privateGet(this, _timers).set(timerId, { timer: null, func, time: timeout });
          } else {
            const timer = setTimeout(func, timeout);
            __privateGet(this, _timers).set(timerId, { timer, func, time: getTime2() });
          }
          return timerId;
        }
        /**
         *  Perform %%func%% on each subscriber.
         */
        _forEachSubscriber(func) {
          for (const sub of __privateGet(this, _subs).values()) {
            func(sub.subscriber);
          }
        }
        /**
         *  Sub-classes may override this to customize subscription
         *  implementations.
         */
        _getSubscriber(sub) {
          switch (sub.type) {
            case "debug":
            case "error":
            case "network":
              return new UnmanagedSubscriber(sub.type);
            case "block": {
              const subscriber = new PollingBlockSubscriber(this);
              subscriber.pollingInterval = this.pollingInterval;
              return subscriber;
            }
            case "safe":
            case "finalized":
              return new PollingBlockTagSubscriber(this, sub.type);
            case "event":
              return new PollingEventSubscriber(this, sub.filter);
            case "transaction":
              return new PollingTransactionSubscriber(this, sub.hash);
            case "orphan":
              return new PollingOrphanSubscriber(this, sub.filter);
          }
          throw new Error(`unsupported event: ${sub.type}`);
        }
        /**
         *  If a [[Subscriber]] fails and needs to replace itself, this
         *  method may be used.
         *
         *  For example, this is used for providers when using the
         *  ``eth_getFilterChanges`` method, which can return null if state
         *  filters are not supported by the backend, allowing the Subscriber
         *  to swap in a [[PollingEventSubscriber]].
         */
        _recoverSubscriber(oldSub, newSub) {
          for (const sub of __privateGet(this, _subs).values()) {
            if (sub.subscriber === oldSub) {
              if (sub.started) {
                sub.subscriber.stop();
              }
              sub.subscriber = newSub;
              if (sub.started) {
                newSub.start();
              }
              if (__privateGet(this, _pausedState) != null) {
                newSub.pause(__privateGet(this, _pausedState));
              }
              break;
            }
          }
        }
        async on(event, listener) {
          const sub = await __privateMethod(this, _AbstractProvider_instances, getSub_fn).call(this, event);
          sub.listeners.push({ listener, once: false });
          if (!sub.started) {
            sub.subscriber.start();
            sub.started = true;
            if (__privateGet(this, _pausedState) != null) {
              sub.subscriber.pause(__privateGet(this, _pausedState));
            }
          }
          return this;
        }
        async once(event, listener) {
          const sub = await __privateMethod(this, _AbstractProvider_instances, getSub_fn).call(this, event);
          sub.listeners.push({ listener, once: true });
          if (!sub.started) {
            sub.subscriber.start();
            sub.started = true;
            if (__privateGet(this, _pausedState) != null) {
              sub.subscriber.pause(__privateGet(this, _pausedState));
            }
          }
          return this;
        }
        async emit(event, ...args) {
          const sub = await __privateMethod(this, _AbstractProvider_instances, hasSub_fn).call(this, event, args);
          if (!sub || sub.listeners.length === 0) {
            return false;
          }
          ;
          const count = sub.listeners.length;
          sub.listeners = sub.listeners.filter(({ listener, once }) => {
            const payload = new EventPayload(this, once ? null : listener, event);
            try {
              listener.call(this, ...args, payload);
            } catch (error) {
            }
            return !once;
          });
          if (sub.listeners.length === 0) {
            if (sub.started) {
              sub.subscriber.stop();
            }
            __privateGet(this, _subs).delete(sub.tag);
          }
          return count > 0;
        }
        async listenerCount(event) {
          if (event) {
            const sub = await __privateMethod(this, _AbstractProvider_instances, hasSub_fn).call(this, event);
            if (!sub) {
              return 0;
            }
            return sub.listeners.length;
          }
          let total = 0;
          for (const { listeners } of __privateGet(this, _subs).values()) {
            total += listeners.length;
          }
          return total;
        }
        async listeners(event) {
          if (event) {
            const sub = await __privateMethod(this, _AbstractProvider_instances, hasSub_fn).call(this, event);
            if (!sub) {
              return [];
            }
            return sub.listeners.map(({ listener }) => listener);
          }
          let result = [];
          for (const { listeners } of __privateGet(this, _subs).values()) {
            result = result.concat(listeners.map(({ listener }) => listener));
          }
          return result;
        }
        async off(event, listener) {
          const sub = await __privateMethod(this, _AbstractProvider_instances, hasSub_fn).call(this, event);
          if (!sub) {
            return this;
          }
          if (listener) {
            const index2 = sub.listeners.map(({ listener: listener2 }) => listener2).indexOf(listener);
            if (index2 >= 0) {
              sub.listeners.splice(index2, 1);
            }
          }
          if (!listener || sub.listeners.length === 0) {
            if (sub.started) {
              sub.subscriber.stop();
            }
            __privateGet(this, _subs).delete(sub.tag);
          }
          return this;
        }
        async removeAllListeners(event) {
          if (event) {
            const { tag, started, subscriber } = await __privateMethod(this, _AbstractProvider_instances, getSub_fn).call(this, event);
            if (started) {
              subscriber.stop();
            }
            __privateGet(this, _subs).delete(tag);
          } else {
            for (const [tag, { started, subscriber }] of __privateGet(this, _subs)) {
              if (started) {
                subscriber.stop();
              }
              __privateGet(this, _subs).delete(tag);
            }
          }
          return this;
        }
        // Alias for "on"
        async addListener(event, listener) {
          return await this.on(event, listener);
        }
        // Alias for "off"
        async removeListener(event, listener) {
          return this.off(event, listener);
        }
        /**
         *  If this provider has been destroyed using the [[destroy]] method.
         *
         *  Once destroyed, all resources are reclaimed, internal event loops
         *  and timers are cleaned up and no further requests may be sent to
         *  the provider.
         */
        get destroyed() {
          return __privateGet(this, _destroyed);
        }
        /**
         *  Sub-classes may use this to shutdown any sockets or release their
         *  resources and reject any pending requests.
         *
         *  Sub-classes **must** call ``super.destroy()``.
         */
        destroy() {
          this.removeAllListeners();
          for (const timerId of __privateGet(this, _timers).keys()) {
            this._clearTimeout(timerId);
          }
          __privateSet(this, _destroyed, true);
        }
        /**
         *  Whether the provider is currently paused.
         *
         *  A paused provider will not emit any events, and generally should
         *  not make any requests to the network, but that is up to sub-classes
         *  to manage.
         *
         *  Setting ``paused = true`` is identical to calling ``.pause(false)``,
         *  which will buffer any events that occur while paused until the
         *  provider is unpaused.
         */
        get paused() {
          return __privateGet(this, _pausedState) != null;
        }
        set paused(pause) {
          if (!!pause === this.paused) {
            return;
          }
          if (this.paused) {
            this.resume();
          } else {
            this.pause(false);
          }
        }
        /**
         *  Pause the provider. If %%dropWhilePaused%%, any events that occur
         *  while paused are dropped, otherwise all events will be emitted once
         *  the provider is unpaused.
         */
        pause(dropWhilePaused) {
          __privateSet(this, _lastBlockNumber, -1);
          if (__privateGet(this, _pausedState) != null) {
            if (__privateGet(this, _pausedState) == !!dropWhilePaused) {
              return;
            }
            assert(false, "cannot change pause type; resume first", "UNSUPPORTED_OPERATION", {
              operation: "pause"
            });
          }
          this._forEachSubscriber((s) => s.pause(dropWhilePaused));
          __privateSet(this, _pausedState, !!dropWhilePaused);
          for (const timer of __privateGet(this, _timers).values()) {
            if (timer.timer) {
              clearTimeout(timer.timer);
            }
            timer.time = getTime2() - timer.time;
          }
        }
        /**
         *  Resume the provider.
         */
        resume() {
          if (__privateGet(this, _pausedState) == null) {
            return;
          }
          this._forEachSubscriber((s) => s.resume());
          __privateSet(this, _pausedState, null);
          for (const timer of __privateGet(this, _timers).values()) {
            let timeout = timer.time;
            if (timeout < 0) {
              timeout = 0;
            }
            timer.time = getTime2();
            setTimeout(timer.func, timeout);
          }
        }
      };
      _subs = new WeakMap();
      _plugins2 = new WeakMap();
      _pausedState = new WeakMap();
      _destroyed = new WeakMap();
      _networkPromise = new WeakMap();
      _anyNetwork = new WeakMap();
      _performCache = new WeakMap();
      _lastBlockNumber = new WeakMap();
      _nextTimer = new WeakMap();
      _timers = new WeakMap();
      _disableCcipRead = new WeakMap();
      _options2 = new WeakMap();
      _AbstractProvider_instances = new WeakSet();
      perform_fn = async function(req) {
        const timeout = __privateGet(this, _options2).cacheTimeout;
        if (timeout < 0) {
          return await this._perform(req);
        }
        const tag = getTag(req.method, req);
        let perform = __privateGet(this, _performCache).get(tag);
        if (!perform) {
          perform = this._perform(req);
          __privateGet(this, _performCache).set(tag, perform);
          setTimeout(() => {
            if (__privateGet(this, _performCache).get(tag) === perform) {
              __privateGet(this, _performCache).delete(tag);
            }
          }, timeout);
        }
        return await perform;
      };
      call_fn = async function(tx, blockTag, attempt) {
        assert(attempt < MAX_CCIP_REDIRECTS, "CCIP read exceeded maximum redirections", "OFFCHAIN_FAULT", {
          reason: "TOO_MANY_REDIRECTS",
          transaction: Object.assign({}, tx, { blockTag, enableCcipRead: true })
        });
        const transaction = copyRequest(tx);
        try {
          return hexlify(await this._perform({ method: "call", transaction, blockTag }));
        } catch (error) {
          if (!this.disableCcipRead && isCallException(error) && error.data && attempt >= 0 && blockTag === "latest" && transaction.to != null && dataSlice(error.data, 0, 4) === "0x556f1830") {
            const data = error.data;
            const txSender = await resolveAddress(transaction.to, this);
            let ccipArgs;
            try {
              ccipArgs = parseOffchainLookup(dataSlice(error.data, 4));
            } catch (error2) {
              assert(false, error2.message, "OFFCHAIN_FAULT", {
                reason: "BAD_DATA",
                transaction,
                info: { data }
              });
            }
            assert(ccipArgs.sender.toLowerCase() === txSender.toLowerCase(), "CCIP Read sender mismatch", "CALL_EXCEPTION", {
              action: "call",
              data,
              reason: "OffchainLookup",
              transaction,
              invocation: null,
              revert: {
                signature: "OffchainLookup(address,string[],bytes,bytes4,bytes)",
                name: "OffchainLookup",
                args: ccipArgs.errorArgs
              }
            });
            const ccipResult = await this.ccipReadFetch(transaction, ccipArgs.calldata, ccipArgs.urls);
            assert(ccipResult != null, "CCIP Read failed to fetch data", "OFFCHAIN_FAULT", {
              reason: "FETCH_FAILED",
              transaction,
              info: { data: error.data, errorArgs: ccipArgs.errorArgs }
            });
            const tx2 = {
              to: txSender,
              data: concat([ccipArgs.selector, encodeBytes([ccipResult, ccipArgs.extraData])])
            };
            this.emit("debug", { action: "sendCcipReadCall", transaction: tx2 });
            try {
              const result = await __privateMethod(this, _AbstractProvider_instances, call_fn).call(this, tx2, blockTag, attempt + 1);
              this.emit("debug", { action: "receiveCcipReadCallResult", transaction: Object.assign({}, tx2), result });
              return result;
            } catch (error2) {
              this.emit("debug", { action: "receiveCcipReadCallError", transaction: Object.assign({}, tx2), error: error2 });
              throw error2;
            }
          }
          throw error;
        }
      };
      checkNetwork_fn = async function(promise) {
        const { value } = await resolveProperties({
          network: this.getNetwork(),
          value: promise
        });
        return value;
      };
      getAccountValue_fn = async function(request, _address, _blockTag) {
        let address = this._getAddress(_address);
        let blockTag = this._getBlockTag(_blockTag);
        if (typeof address !== "string" || typeof blockTag !== "string") {
          [address, blockTag] = await Promise.all([address, blockTag]);
        }
        return await __privateMethod(this, _AbstractProvider_instances, checkNetwork_fn).call(this, __privateMethod(this, _AbstractProvider_instances, perform_fn).call(this, Object.assign(request, { address, blockTag })));
      };
      getBlock_fn = async function(block, includeTransactions) {
        if (isHexString(block, 32)) {
          return await __privateMethod(this, _AbstractProvider_instances, perform_fn).call(this, {
            method: "getBlock",
            blockHash: block,
            includeTransactions
          });
        }
        let blockTag = this._getBlockTag(block);
        if (typeof blockTag !== "string") {
          blockTag = await blockTag;
        }
        return await __privateMethod(this, _AbstractProvider_instances, perform_fn).call(this, {
          method: "getBlock",
          blockTag,
          includeTransactions
        });
      };
      hasSub_fn = async function(event, emitArgs) {
        let sub = await getSubscription(event, this);
        if (sub.type === "event" && emitArgs && emitArgs.length > 0 && emitArgs[0].removed === true) {
          sub = await getSubscription({ orphan: "drop-log", log: emitArgs[0] }, this);
        }
        return __privateGet(this, _subs).get(sub.tag) || null;
      };
      getSub_fn = async function(event) {
        const subscription = await getSubscription(event, this);
        const tag = subscription.tag;
        let sub = __privateGet(this, _subs).get(tag);
        if (!sub) {
          const subscriber = this._getSubscriber(subscription);
          const addressableMap = /* @__PURE__ */ new WeakMap();
          const nameMap = /* @__PURE__ */ new Map();
          sub = { subscriber, tag, addressableMap, nameMap, started: false, listeners: [] };
          __privateGet(this, _subs).set(tag, sub);
        }
        return sub;
      };
      empty = new Uint8Array([]);
      zeros = "0x0000000000000000000000000000000000000000000000000000000000000000";
    }
  });

  // node_modules/ethers/lib.esm/providers/abstract-signer.js
  function checkProvider(signer, operation) {
    if (signer.provider) {
      return signer.provider;
    }
    assert(false, "missing provider", "UNSUPPORTED_OPERATION", { operation });
  }
  async function populate(signer, tx) {
    let pop = copyRequest(tx);
    if (pop.to != null) {
      pop.to = resolveAddress(pop.to, signer);
    }
    if (pop.from != null) {
      const from5 = pop.from;
      pop.from = Promise.all([
        signer.getAddress(),
        resolveAddress(from5, signer)
      ]).then(([address, from6]) => {
        assertArgument(address.toLowerCase() === from6.toLowerCase(), "transaction from mismatch", "tx.from", from6);
        return address;
      });
    } else {
      pop.from = signer.getAddress();
    }
    return await resolveProperties(pop);
  }
  var AbstractSigner, _VoidSigner_instances, throwUnsupported_fn, _VoidSigner, VoidSigner;
  var init_abstract_signer = __esm({
    "node_modules/ethers/lib.esm/providers/abstract-signer.js"() {
      init_address2();
      init_transaction2();
      init_utils();
      init_provider();
      AbstractSigner = class {
        /**
         *  Creates a new Signer connected to %%provider%%.
         */
        constructor(provider) {
          /**
           *  The provider this signer is connected to.
           */
          __publicField(this, "provider");
          defineProperties(this, { provider: provider || null });
        }
        async getNonce(blockTag) {
          return checkProvider(this, "getTransactionCount").getTransactionCount(await this.getAddress(), blockTag);
        }
        async populateCall(tx) {
          const pop = await populate(this, tx);
          return pop;
        }
        async populateTransaction(tx) {
          const provider = checkProvider(this, "populateTransaction");
          const pop = await populate(this, tx);
          if (pop.nonce == null) {
            pop.nonce = await this.getNonce("pending");
          }
          if (pop.gasLimit == null) {
            pop.gasLimit = await this.estimateGas(pop);
          }
          const network = await this.provider.getNetwork();
          if (pop.chainId != null) {
            const chainId = getBigInt(pop.chainId);
            assertArgument(chainId === network.chainId, "transaction chainId mismatch", "tx.chainId", tx.chainId);
          } else {
            pop.chainId = network.chainId;
          }
          const hasEip1559 = pop.maxFeePerGas != null || pop.maxPriorityFeePerGas != null;
          if (pop.gasPrice != null && (pop.type === 2 || hasEip1559)) {
            assertArgument(false, "eip-1559 transaction do not support gasPrice", "tx", tx);
          } else if ((pop.type === 0 || pop.type === 1) && hasEip1559) {
            assertArgument(false, "pre-eip-1559 transaction do not support maxFeePerGas/maxPriorityFeePerGas", "tx", tx);
          }
          if ((pop.type === 2 || pop.type == null) && (pop.maxFeePerGas != null && pop.maxPriorityFeePerGas != null)) {
            pop.type = 2;
          } else if (pop.type === 0 || pop.type === 1) {
            const feeData = await provider.getFeeData();
            assert(feeData.gasPrice != null, "network does not support gasPrice", "UNSUPPORTED_OPERATION", {
              operation: "getGasPrice"
            });
            if (pop.gasPrice == null) {
              pop.gasPrice = feeData.gasPrice;
            }
          } else {
            const feeData = await provider.getFeeData();
            if (pop.type == null) {
              if (feeData.maxFeePerGas != null && feeData.maxPriorityFeePerGas != null) {
                if (pop.authorizationList && pop.authorizationList.length) {
                  pop.type = 4;
                } else {
                  pop.type = 2;
                }
                if (pop.gasPrice != null) {
                  const gasPrice = pop.gasPrice;
                  delete pop.gasPrice;
                  pop.maxFeePerGas = gasPrice;
                  pop.maxPriorityFeePerGas = gasPrice;
                } else {
                  if (pop.maxFeePerGas == null) {
                    pop.maxFeePerGas = feeData.maxFeePerGas;
                  }
                  if (pop.maxPriorityFeePerGas == null) {
                    pop.maxPriorityFeePerGas = feeData.maxPriorityFeePerGas;
                  }
                }
              } else if (feeData.gasPrice != null) {
                assert(!hasEip1559, "network does not support EIP-1559", "UNSUPPORTED_OPERATION", {
                  operation: "populateTransaction"
                });
                if (pop.gasPrice == null) {
                  pop.gasPrice = feeData.gasPrice;
                }
                pop.type = 0;
              } else {
                assert(false, "failed to get consistent fee data", "UNSUPPORTED_OPERATION", {
                  operation: "signer.getFeeData"
                });
              }
            } else if (pop.type === 2 || pop.type === 3 || pop.type === 4) {
              if (pop.maxFeePerGas == null) {
                pop.maxFeePerGas = feeData.maxFeePerGas;
              }
              if (pop.maxPriorityFeePerGas == null) {
                pop.maxPriorityFeePerGas = feeData.maxPriorityFeePerGas;
              }
            }
          }
          return await resolveProperties(pop);
        }
        async populateAuthorization(_auth) {
          const auth = Object.assign({}, _auth);
          if (auth.chainId == null) {
            auth.chainId = (await checkProvider(this, "getNetwork").getNetwork()).chainId;
          }
          if (auth.nonce == null) {
            auth.nonce = await this.getNonce();
          }
          return auth;
        }
        async estimateGas(tx) {
          return checkProvider(this, "estimateGas").estimateGas(await this.populateCall(tx));
        }
        async call(tx) {
          return checkProvider(this, "call").call(await this.populateCall(tx));
        }
        async resolveName(name) {
          const provider = checkProvider(this, "resolveName");
          return await provider.resolveName(name);
        }
        async sendTransaction(tx) {
          const provider = checkProvider(this, "sendTransaction");
          const pop = await this.populateTransaction(tx);
          delete pop.from;
          const txObj = Transaction.from(pop);
          return await provider.broadcastTransaction(await this.signTransaction(txObj));
        }
        // @TODO: in v7 move this to be abstract
        authorize(authorization) {
          assert(false, "authorization not implemented for this signer", "UNSUPPORTED_OPERATION", { operation: "authorize" });
        }
      };
      _VoidSigner = class _VoidSigner extends AbstractSigner {
        /**
         *  Creates a new **VoidSigner** with %%address%% attached to
         *  %%provider%%.
         */
        constructor(address, provider) {
          super(provider);
          __privateAdd(this, _VoidSigner_instances);
          /**
           *  The signer address.
           */
          __publicField(this, "address");
          defineProperties(this, { address });
        }
        async getAddress() {
          return this.address;
        }
        connect(provider) {
          return new _VoidSigner(this.address, provider);
        }
        async signTransaction(tx) {
          __privateMethod(this, _VoidSigner_instances, throwUnsupported_fn).call(this, "transactions", "signTransaction");
        }
        async signMessage(message) {
          __privateMethod(this, _VoidSigner_instances, throwUnsupported_fn).call(this, "messages", "signMessage");
        }
        async signTypedData(domain, types, value) {
          __privateMethod(this, _VoidSigner_instances, throwUnsupported_fn).call(this, "typed-data", "signTypedData");
        }
      };
      _VoidSigner_instances = new WeakSet();
      throwUnsupported_fn = function(suffix, operation) {
        assert(false, `VoidSigner cannot sign ${suffix}`, "UNSUPPORTED_OPERATION", { operation });
      };
      VoidSigner = _VoidSigner;
    }
  });

  // node_modules/ethers/lib.esm/providers/community.js
  function showThrottleMessage(service) {
    if (shown.has(service)) {
      return;
    }
    shown.add(service);
    console.log("========= NOTICE =========");
    console.log(`Request-Rate Exceeded for ${service} (this message will not be repeated)`);
    console.log("");
    console.log("The default API keys for each service are provided as a highly-throttled,");
    console.log("community resource for low-traffic projects and early prototyping.");
    console.log("");
    console.log("While your application will continue to function, we highly recommended");
    console.log("signing up for your own API keys to improve performance, increase your");
    console.log("request rate/limit and enable other perks, such as metrics and advanced APIs.");
    console.log("");
    console.log("For more details: https://docs.ethers.org/api-keys/");
    console.log("==========================");
  }
  var shown;
  var init_community = __esm({
    "node_modules/ethers/lib.esm/providers/community.js"() {
      shown = /* @__PURE__ */ new Set();
    }
  });

  // node_modules/ethers/lib.esm/providers/subscriber-filterid.js
  function copy3(obj) {
    return JSON.parse(JSON.stringify(obj));
  }
  var _provider4, _filterIdPromise, _poller3, _running3, _network, _hault, _FilterIdSubscriber_instances, poll_fn3, teardown_fn, FilterIdSubscriber, _event, FilterIdEventSubscriber, FilterIdPendingSubscriber;
  var init_subscriber_filterid = __esm({
    "node_modules/ethers/lib.esm/providers/subscriber-filterid.js"() {
      init_utils();
      init_subscriber_polling();
      FilterIdSubscriber = class {
        /**
         *  Creates a new **FilterIdSubscriber** which will used [[_subscribe]]
         *  and [[_emitResults]] to setup the subscription and provide the event
         *  to the %%provider%%.
         */
        constructor(provider) {
          __privateAdd(this, _FilterIdSubscriber_instances);
          __privateAdd(this, _provider4);
          __privateAdd(this, _filterIdPromise);
          __privateAdd(this, _poller3);
          __privateAdd(this, _running3);
          __privateAdd(this, _network);
          __privateAdd(this, _hault);
          __privateSet(this, _provider4, provider);
          __privateSet(this, _filterIdPromise, null);
          __privateSet(this, _poller3, __privateMethod(this, _FilterIdSubscriber_instances, poll_fn3).bind(this));
          __privateSet(this, _running3, false);
          __privateSet(this, _network, null);
          __privateSet(this, _hault, false);
        }
        /**
         *  Sub-classes **must** override this to begin the subscription.
         */
        _subscribe(provider) {
          throw new Error("subclasses must override this");
        }
        /**
         *  Sub-classes **must** override this handle the events.
         */
        _emitResults(provider, result) {
          throw new Error("subclasses must override this");
        }
        /**
         *  Sub-classes **must** override this handle recovery on errors.
         */
        _recover(provider) {
          throw new Error("subclasses must override this");
        }
        start() {
          if (__privateGet(this, _running3)) {
            return;
          }
          __privateSet(this, _running3, true);
          __privateMethod(this, _FilterIdSubscriber_instances, poll_fn3).call(this, -2);
        }
        stop() {
          if (!__privateGet(this, _running3)) {
            return;
          }
          __privateSet(this, _running3, false);
          __privateSet(this, _hault, true);
          __privateMethod(this, _FilterIdSubscriber_instances, teardown_fn).call(this);
          __privateGet(this, _provider4).off("block", __privateGet(this, _poller3));
        }
        pause(dropWhilePaused) {
          if (dropWhilePaused) {
            __privateMethod(this, _FilterIdSubscriber_instances, teardown_fn).call(this);
          }
          __privateGet(this, _provider4).off("block", __privateGet(this, _poller3));
        }
        resume() {
          this.start();
        }
      };
      _provider4 = new WeakMap();
      _filterIdPromise = new WeakMap();
      _poller3 = new WeakMap();
      _running3 = new WeakMap();
      _network = new WeakMap();
      _hault = new WeakMap();
      _FilterIdSubscriber_instances = new WeakSet();
      poll_fn3 = async function(blockNumber) {
        try {
          if (__privateGet(this, _filterIdPromise) == null) {
            __privateSet(this, _filterIdPromise, this._subscribe(__privateGet(this, _provider4)));
          }
          let filterId = null;
          try {
            filterId = await __privateGet(this, _filterIdPromise);
          } catch (error) {
            if (!isError(error, "UNSUPPORTED_OPERATION") || error.operation !== "eth_newFilter") {
              throw error;
            }
          }
          if (filterId == null) {
            __privateSet(this, _filterIdPromise, null);
            __privateGet(this, _provider4)._recoverSubscriber(this, this._recover(__privateGet(this, _provider4)));
            return;
          }
          const network = await __privateGet(this, _provider4).getNetwork();
          if (!__privateGet(this, _network)) {
            __privateSet(this, _network, network);
          }
          if (__privateGet(this, _network).chainId !== network.chainId) {
            throw new Error("chaid changed");
          }
          if (__privateGet(this, _hault)) {
            return;
          }
          const result = await __privateGet(this, _provider4).send("eth_getFilterChanges", [filterId]);
          await this._emitResults(__privateGet(this, _provider4), result);
        } catch (error) {
          console.log("@TODO", error);
        }
        __privateGet(this, _provider4).once("block", __privateGet(this, _poller3));
      };
      teardown_fn = function() {
        const filterIdPromise = __privateGet(this, _filterIdPromise);
        if (filterIdPromise) {
          __privateSet(this, _filterIdPromise, null);
          filterIdPromise.then((filterId) => {
            if (__privateGet(this, _provider4).destroyed) {
              return;
            }
            __privateGet(this, _provider4).send("eth_uninstallFilter", [filterId]);
          });
        }
      };
      FilterIdEventSubscriber = class extends FilterIdSubscriber {
        /**
         *  Creates a new **FilterIdEventSubscriber** attached to %%provider%%
         *  listening for %%filter%%.
         */
        constructor(provider, filter) {
          super(provider);
          __privateAdd(this, _event);
          __privateSet(this, _event, copy3(filter));
        }
        _recover(provider) {
          return new PollingEventSubscriber(provider, __privateGet(this, _event));
        }
        async _subscribe(provider) {
          const filterId = await provider.send("eth_newFilter", [__privateGet(this, _event)]);
          return filterId;
        }
        async _emitResults(provider, results) {
          for (const result of results) {
            provider.emit(__privateGet(this, _event), provider._wrapLog(result, provider._network));
          }
        }
      };
      _event = new WeakMap();
      FilterIdPendingSubscriber = class extends FilterIdSubscriber {
        async _subscribe(provider) {
          return await provider.send("eth_newPendingTransactionFilter", []);
        }
        async _emitResults(provider, results) {
          for (const result of results) {
            provider.emit("pending", result);
          }
        }
      };
    }
  });

  // node_modules/ethers/lib.esm/providers/provider-jsonrpc.js
  function deepCopy(value) {
    if (value == null || Primitive.indexOf(typeof value) >= 0) {
      return value;
    }
    if (typeof value.getAddress === "function") {
      return value;
    }
    if (Array.isArray(value)) {
      return value.map(deepCopy);
    }
    if (typeof value === "object") {
      return Object.keys(value).reduce((accum, key) => {
        accum[key] = value[key];
        return accum;
      }, {});
    }
    throw new Error(`should not happen: ${value} (${typeof value})`);
  }
  function stall(duration) {
    return new Promise((resolve) => {
      setTimeout(resolve, duration);
    });
  }
  function getLowerCase(value) {
    if (value) {
      return value.toLowerCase();
    }
    return value;
  }
  function isPollable(value) {
    return value && typeof value.pollingInterval === "number";
  }
  function spelunkData(value) {
    if (value == null) {
      return null;
    }
    if (typeof value.message === "string" && value.message.match(/revert/i) && isHexString(value.data)) {
      return { message: value.message, data: value.data };
    }
    if (typeof value === "object") {
      for (const key in value) {
        const result = spelunkData(value[key]);
        if (result) {
          return result;
        }
      }
      return null;
    }
    if (typeof value === "string") {
      try {
        return spelunkData(JSON.parse(value));
      } catch (error) {
      }
    }
    return null;
  }
  function _spelunkMessage(value, result) {
    if (value == null) {
      return;
    }
    if (typeof value.message === "string") {
      result.push(value.message);
    }
    if (typeof value === "object") {
      for (const key in value) {
        _spelunkMessage(value[key], result);
      }
    }
    if (typeof value === "string") {
      try {
        return _spelunkMessage(JSON.parse(value), result);
      } catch (error) {
      }
    }
  }
  function spelunkMessage(value) {
    const result = [];
    _spelunkMessage(value, result);
    return result;
  }
  var Primitive, defaultOptions2, JsonRpcSigner, _options3, _nextId, _payloads, _drainTimer, _notReady, _network2, _pendingDetectNetwork, _JsonRpcApiProvider_instances, scheduleDrain_fn, JsonRpcApiProvider, _pollingInterval, JsonRpcApiPollingProvider, _connect, JsonRpcProvider;
  var init_provider_jsonrpc = __esm({
    "node_modules/ethers/lib.esm/providers/provider-jsonrpc.js"() {
      init_abi();
      init_address2();
      init_hash();
      init_transaction2();
      init_utils();
      init_abstract_provider();
      init_abstract_signer();
      init_network();
      init_subscriber_filterid();
      init_subscriber_polling();
      Primitive = "bigint,boolean,function,number,string,symbol".split(/,/g);
      defaultOptions2 = {
        polling: false,
        staticNetwork: null,
        batchStallTime: 10,
        batchMaxSize: 1 << 20,
        batchMaxCount: 100,
        cacheTimeout: 250,
        pollingInterval: 4e3
      };
      JsonRpcSigner = class extends AbstractSigner {
        constructor(provider, address) {
          super(provider);
          __publicField(this, "address");
          address = getAddress(address);
          defineProperties(this, { address });
        }
        connect(provider) {
          assert(false, "cannot reconnect JsonRpcSigner", "UNSUPPORTED_OPERATION", {
            operation: "signer.connect"
          });
        }
        async getAddress() {
          return this.address;
        }
        // JSON-RPC will automatially fill in nonce, etc. so we just check from
        async populateTransaction(tx) {
          return await this.populateCall(tx);
        }
        // Returns just the hash of the transaction after sent, which is what
        // the bare JSON-RPC API does;
        async sendUncheckedTransaction(_tx) {
          const tx = deepCopy(_tx);
          const promises = [];
          if (tx.from) {
            const _from = tx.from;
            promises.push((async () => {
              const from5 = await resolveAddress(_from, this.provider);
              assertArgument(from5 != null && from5.toLowerCase() === this.address.toLowerCase(), "from address mismatch", "transaction", _tx);
              tx.from = from5;
            })());
          } else {
            tx.from = this.address;
          }
          if (tx.gasLimit == null) {
            promises.push((async () => {
              tx.gasLimit = await this.provider.estimateGas({ ...tx, from: this.address });
            })());
          }
          if (tx.to != null) {
            const _to2 = tx.to;
            promises.push((async () => {
              tx.to = await resolveAddress(_to2, this.provider);
            })());
          }
          if (promises.length) {
            await Promise.all(promises);
          }
          const hexTx = this.provider.getRpcTransaction(tx);
          return this.provider.send("eth_sendTransaction", [hexTx]);
        }
        async sendTransaction(tx) {
          const blockNumber = await this.provider.getBlockNumber();
          const hash3 = await this.sendUncheckedTransaction(tx);
          return await new Promise((resolve, reject) => {
            const timeouts = [1e3, 100];
            let invalids = 0;
            const checkTx = async () => {
              try {
                const tx2 = await this.provider.getTransaction(hash3);
                if (tx2 != null) {
                  resolve(tx2.replaceableTransaction(blockNumber));
                  return;
                }
              } catch (error) {
                if (isError(error, "CANCELLED") || isError(error, "BAD_DATA") || isError(error, "NETWORK_ERROR") || isError(error, "UNSUPPORTED_OPERATION")) {
                  if (error.info == null) {
                    error.info = {};
                  }
                  error.info.sendTransactionHash = hash3;
                  reject(error);
                  return;
                }
                if (isError(error, "INVALID_ARGUMENT")) {
                  invalids++;
                  if (error.info == null) {
                    error.info = {};
                  }
                  error.info.sendTransactionHash = hash3;
                  if (invalids > 10) {
                    reject(error);
                    return;
                  }
                }
                this.provider.emit("error", makeError("failed to fetch transation after sending (will try again)", "UNKNOWN_ERROR", { error }));
              }
              this.provider._setTimeout(() => {
                checkTx();
              }, timeouts.pop() || 4e3);
            };
            checkTx();
          });
        }
        async signTransaction(_tx) {
          const tx = deepCopy(_tx);
          if (tx.from) {
            const from5 = await resolveAddress(tx.from, this.provider);
            assertArgument(from5 != null && from5.toLowerCase() === this.address.toLowerCase(), "from address mismatch", "transaction", _tx);
            tx.from = from5;
          } else {
            tx.from = this.address;
          }
          const hexTx = this.provider.getRpcTransaction(tx);
          return await this.provider.send("eth_signTransaction", [hexTx]);
        }
        async signMessage(_message) {
          const message = typeof _message === "string" ? toUtf8Bytes(_message) : _message;
          return await this.provider.send("personal_sign", [
            hexlify(message),
            this.address.toLowerCase()
          ]);
        }
        async signTypedData(domain, types, _value2) {
          const value = deepCopy(_value2);
          const populated = await TypedDataEncoder.resolveNames(domain, types, value, async (value2) => {
            const address = await resolveAddress(value2);
            assertArgument(address != null, "TypedData does not support null address", "value", value2);
            return address;
          });
          return await this.provider.send("eth_signTypedData_v4", [
            this.address.toLowerCase(),
            JSON.stringify(TypedDataEncoder.getPayload(populated.domain, types, populated.value))
          ]);
        }
        async unlock(password) {
          return this.provider.send("personal_unlockAccount", [
            this.address.toLowerCase(),
            password,
            null
          ]);
        }
        // https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_sign
        async _legacySignMessage(_message) {
          const message = typeof _message === "string" ? toUtf8Bytes(_message) : _message;
          return await this.provider.send("eth_sign", [
            this.address.toLowerCase(),
            hexlify(message)
          ]);
        }
      };
      JsonRpcApiProvider = class extends AbstractProvider {
        constructor(network, options) {
          super(network, options);
          __privateAdd(this, _JsonRpcApiProvider_instances);
          __privateAdd(this, _options3);
          // The next ID to use for the JSON-RPC ID field
          __privateAdd(this, _nextId);
          // Payloads are queued and triggered in batches using the drainTimer
          __privateAdd(this, _payloads);
          __privateAdd(this, _drainTimer);
          __privateAdd(this, _notReady);
          __privateAdd(this, _network2);
          __privateAdd(this, _pendingDetectNetwork);
          __privateSet(this, _nextId, 1);
          __privateSet(this, _options3, Object.assign({}, defaultOptions2, options || {}));
          __privateSet(this, _payloads, []);
          __privateSet(this, _drainTimer, null);
          __privateSet(this, _network2, null);
          __privateSet(this, _pendingDetectNetwork, null);
          {
            let resolve = null;
            const promise = new Promise((_resolve) => {
              resolve = _resolve;
            });
            __privateSet(this, _notReady, { promise, resolve });
          }
          const staticNetwork = this._getOption("staticNetwork");
          if (typeof staticNetwork === "boolean") {
            assertArgument(!staticNetwork || network !== "any", "staticNetwork cannot be used on special network 'any'", "options", options);
            if (staticNetwork && network != null) {
              __privateSet(this, _network2, Network.from(network));
            }
          } else if (staticNetwork) {
            assertArgument(network == null || staticNetwork.matches(network), "staticNetwork MUST match network object", "options", options);
            __privateSet(this, _network2, staticNetwork);
          }
        }
        /**
         *  Returns the value associated with the option %%key%%.
         *
         *  Sub-classes can use this to inquire about configuration options.
         */
        _getOption(key) {
          return __privateGet(this, _options3)[key];
        }
        /**
         *  Gets the [[Network]] this provider has committed to. On each call, the network
         *  is detected, and if it has changed, the call will reject.
         */
        get _network() {
          assert(__privateGet(this, _network2), "network is not available yet", "NETWORK_ERROR");
          return __privateGet(this, _network2);
        }
        /**
         *  Resolves to the non-normalized value by performing %%req%%.
         *
         *  Sub-classes may override this to modify behavior of actions,
         *  and should generally call ``super._perform`` as a fallback.
         */
        async _perform(req) {
          if (req.method === "call" || req.method === "estimateGas") {
            let tx = req.transaction;
            if (tx && tx.type != null && getBigInt(tx.type)) {
              if (tx.maxFeePerGas == null && tx.maxPriorityFeePerGas == null) {
                const feeData = await this.getFeeData();
                if (feeData.maxFeePerGas == null && feeData.maxPriorityFeePerGas == null) {
                  req = Object.assign({}, req, {
                    transaction: Object.assign({}, tx, { type: void 0 })
                  });
                }
              }
            }
          }
          const request = this.getRpcRequest(req);
          if (request != null) {
            return await this.send(request.method, request.args);
          }
          return super._perform(req);
        }
        /**
         *  Sub-classes may override this; it detects the *actual* network that
         *  we are **currently** connected to.
         *
         *  Keep in mind that [[send]] may only be used once [[ready]], otherwise the
         *  _send primitive must be used instead.
         */
        async _detectNetwork() {
          const network = this._getOption("staticNetwork");
          if (network) {
            if (network === true) {
              if (__privateGet(this, _network2)) {
                return __privateGet(this, _network2);
              }
            } else {
              return network;
            }
          }
          if (__privateGet(this, _pendingDetectNetwork)) {
            return await __privateGet(this, _pendingDetectNetwork);
          }
          if (this.ready) {
            __privateSet(this, _pendingDetectNetwork, (async () => {
              try {
                const result = Network.from(getBigInt(await this.send("eth_chainId", [])));
                __privateSet(this, _pendingDetectNetwork, null);
                return result;
              } catch (error) {
                __privateSet(this, _pendingDetectNetwork, null);
                throw error;
              }
            })());
            return await __privateGet(this, _pendingDetectNetwork);
          }
          __privateSet(this, _pendingDetectNetwork, (async () => {
            const payload = {
              id: __privateWrapper(this, _nextId)._++,
              method: "eth_chainId",
              params: [],
              jsonrpc: "2.0"
            };
            this.emit("debug", { action: "sendRpcPayload", payload });
            let result;
            try {
              result = (await this._send(payload))[0];
              __privateSet(this, _pendingDetectNetwork, null);
            } catch (error) {
              __privateSet(this, _pendingDetectNetwork, null);
              this.emit("debug", { action: "receiveRpcError", error });
              throw error;
            }
            this.emit("debug", { action: "receiveRpcResult", result });
            if ("result" in result) {
              return Network.from(getBigInt(result.result));
            }
            throw this.getRpcError(payload, result);
          })());
          return await __privateGet(this, _pendingDetectNetwork);
        }
        /**
         *  Sub-classes **MUST** call this. Until [[_start]] has been called, no calls
         *  will be passed to [[_send]] from [[send]]. If it is overridden, then
         *  ``super._start()`` **MUST** be called.
         *
         *  Calling it multiple times is safe and has no effect.
         */
        _start() {
          if (__privateGet(this, _notReady) == null || __privateGet(this, _notReady).resolve == null) {
            return;
          }
          __privateGet(this, _notReady).resolve();
          __privateSet(this, _notReady, null);
          (async () => {
            while (__privateGet(this, _network2) == null && !this.destroyed) {
              try {
                __privateSet(this, _network2, await this._detectNetwork());
              } catch (error) {
                if (this.destroyed) {
                  break;
                }
                console.log("JsonRpcProvider failed to detect network and cannot start up; retry in 1s (perhaps the URL is wrong or the node is not started)");
                this.emit("error", makeError("failed to bootstrap network detection", "NETWORK_ERROR", { event: "initial-network-discovery", info: { error } }));
                await stall(1e3);
              }
            }
            __privateMethod(this, _JsonRpcApiProvider_instances, scheduleDrain_fn).call(this);
          })();
        }
        /**
         *  Resolves once the [[_start]] has been called. This can be used in
         *  sub-classes to defer sending data until the connection has been
         *  established.
         */
        async _waitUntilReady() {
          if (__privateGet(this, _notReady) == null) {
            return;
          }
          return await __privateGet(this, _notReady).promise;
        }
        /**
         *  Return a Subscriber that will manage the %%sub%%.
         *
         *  Sub-classes may override this to modify the behavior of
         *  subscription management.
         */
        _getSubscriber(sub) {
          if (sub.type === "pending") {
            return new FilterIdPendingSubscriber(this);
          }
          if (sub.type === "event") {
            if (this._getOption("polling")) {
              return new PollingEventSubscriber(this, sub.filter);
            }
            return new FilterIdEventSubscriber(this, sub.filter);
          }
          if (sub.type === "orphan" && sub.filter.orphan === "drop-log") {
            return new UnmanagedSubscriber("orphan");
          }
          return super._getSubscriber(sub);
        }
        /**
         *  Returns true only if the [[_start]] has been called.
         */
        get ready() {
          return __privateGet(this, _notReady) == null;
        }
        /**
         *  Returns %%tx%% as a normalized JSON-RPC transaction request,
         *  which has all values hexlified and any numeric values converted
         *  to Quantity values.
         */
        getRpcTransaction(tx) {
          const result = {};
          ["chainId", "gasLimit", "gasPrice", "type", "maxFeePerGas", "maxPriorityFeePerGas", "nonce", "value"].forEach((key) => {
            if (tx[key] == null) {
              return;
            }
            let dstKey = key;
            if (key === "gasLimit") {
              dstKey = "gas";
            }
            result[dstKey] = toQuantity(getBigInt(tx[key], `tx.${key}`));
          });
          ["from", "to", "data"].forEach((key) => {
            if (tx[key] == null) {
              return;
            }
            result[key] = hexlify(tx[key]);
          });
          if (tx.accessList) {
            result["accessList"] = accessListify(tx.accessList);
          }
          if (tx.blobVersionedHashes) {
            result["blobVersionedHashes"] = tx.blobVersionedHashes.map((h) => h.toLowerCase());
          }
          if (tx.authorizationList) {
            result["authorizationList"] = tx.authorizationList.map((_a2) => {
              const a = authorizationify(_a2);
              return {
                address: a.address,
                nonce: toQuantity(a.nonce),
                chainId: toQuantity(a.chainId),
                yParity: toQuantity(a.signature.yParity),
                r: toQuantity(a.signature.r),
                s: toQuantity(a.signature.s)
              };
            });
          }
          return result;
        }
        /**
         *  Returns the request method and arguments required to perform
         *  %%req%%.
         */
        getRpcRequest(req) {
          switch (req.method) {
            case "chainId":
              return { method: "eth_chainId", args: [] };
            case "getBlockNumber":
              return { method: "eth_blockNumber", args: [] };
            case "getGasPrice":
              return { method: "eth_gasPrice", args: [] };
            case "getPriorityFee":
              return { method: "eth_maxPriorityFeePerGas", args: [] };
            case "getBalance":
              return {
                method: "eth_getBalance",
                args: [getLowerCase(req.address), req.blockTag]
              };
            case "getTransactionCount":
              return {
                method: "eth_getTransactionCount",
                args: [getLowerCase(req.address), req.blockTag]
              };
            case "getCode":
              return {
                method: "eth_getCode",
                args: [getLowerCase(req.address), req.blockTag]
              };
            case "getStorage":
              return {
                method: "eth_getStorageAt",
                args: [
                  getLowerCase(req.address),
                  "0x" + req.position.toString(16),
                  req.blockTag
                ]
              };
            case "broadcastTransaction":
              return {
                method: "eth_sendRawTransaction",
                args: [req.signedTransaction]
              };
            case "getBlock":
              if ("blockTag" in req) {
                return {
                  method: "eth_getBlockByNumber",
                  args: [req.blockTag, !!req.includeTransactions]
                };
              } else if ("blockHash" in req) {
                return {
                  method: "eth_getBlockByHash",
                  args: [req.blockHash, !!req.includeTransactions]
                };
              }
              break;
            case "getTransaction":
              return {
                method: "eth_getTransactionByHash",
                args: [req.hash]
              };
            case "getTransactionReceipt":
              return {
                method: "eth_getTransactionReceipt",
                args: [req.hash]
              };
            case "call":
              return {
                method: "eth_call",
                args: [this.getRpcTransaction(req.transaction), req.blockTag]
              };
            case "estimateGas": {
              return {
                method: "eth_estimateGas",
                args: [this.getRpcTransaction(req.transaction)]
              };
            }
            case "getLogs":
              if (req.filter && req.filter.address != null) {
                if (Array.isArray(req.filter.address)) {
                  req.filter.address = req.filter.address.map(getLowerCase);
                } else {
                  req.filter.address = getLowerCase(req.filter.address);
                }
              }
              return { method: "eth_getLogs", args: [req.filter] };
          }
          return null;
        }
        /**
         *  Returns an ethers-style Error for the given JSON-RPC error
         *  %%payload%%, coalescing the various strings and error shapes
         *  that different nodes return, coercing them into a machine-readable
         *  standardized error.
         */
        getRpcError(payload, _error2) {
          const { method } = payload;
          const { error } = _error2;
          if (method === "eth_estimateGas" && error.message) {
            const msg = error.message;
            if (!msg.match(/revert/i) && msg.match(/insufficient funds/i)) {
              return makeError("insufficient funds", "INSUFFICIENT_FUNDS", {
                transaction: payload.params[0],
                info: { payload, error }
              });
            } else if (msg.match(/nonce/i) && msg.match(/too low/i)) {
              return makeError("nonce has already been used", "NONCE_EXPIRED", {
                transaction: payload.params[0],
                info: { payload, error }
              });
            }
          }
          if (method === "eth_call" || method === "eth_estimateGas") {
            const result = spelunkData(error);
            const e = AbiCoder.getBuiltinCallException(method === "eth_call" ? "call" : "estimateGas", payload.params[0], result ? result.data : null);
            e.info = { error, payload };
            return e;
          }
          const message = JSON.stringify(spelunkMessage(error));
          if (typeof error.message === "string" && error.message.match(/user denied|ethers-user-denied/i)) {
            const actionMap = {
              eth_sign: "signMessage",
              personal_sign: "signMessage",
              eth_signTypedData_v4: "signTypedData",
              eth_signTransaction: "signTransaction",
              eth_sendTransaction: "sendTransaction",
              eth_requestAccounts: "requestAccess",
              wallet_requestAccounts: "requestAccess"
            };
            return makeError(`user rejected action`, "ACTION_REJECTED", {
              action: actionMap[method] || "unknown",
              reason: "rejected",
              info: { payload, error }
            });
          }
          if (method === "eth_sendRawTransaction" || method === "eth_sendTransaction") {
            const transaction = payload.params[0];
            if (message.match(/insufficient funds|base fee exceeds gas limit/i)) {
              return makeError("insufficient funds for intrinsic transaction cost", "INSUFFICIENT_FUNDS", {
                transaction,
                info: { error }
              });
            }
            if (message.match(/nonce/i) && message.match(/too low/i)) {
              return makeError("nonce has already been used", "NONCE_EXPIRED", { transaction, info: { error } });
            }
            if (message.match(/replacement transaction/i) && message.match(/underpriced/i)) {
              return makeError("replacement fee too low", "REPLACEMENT_UNDERPRICED", { transaction, info: { error } });
            }
            if (message.match(/only replay-protected/i)) {
              return makeError("legacy pre-eip-155 transactions not supported", "UNSUPPORTED_OPERATION", {
                operation: method,
                info: { transaction, info: { error } }
              });
            }
          }
          let unsupported = !!message.match(/the method .* does not exist/i);
          if (!unsupported) {
            if (error && error.details && error.details.startsWith("Unauthorized method:")) {
              unsupported = true;
            }
          }
          if (unsupported) {
            return makeError("unsupported operation", "UNSUPPORTED_OPERATION", {
              operation: payload.method,
              info: { error, payload }
            });
          }
          return makeError("could not coalesce error", "UNKNOWN_ERROR", { error, payload });
        }
        /**
         *  Requests the %%method%% with %%params%% via the JSON-RPC protocol
         *  over the underlying channel. This can be used to call methods
         *  on the backend that do not have a high-level API within the Provider
         *  API.
         *
         *  This method queues requests according to the batch constraints
         *  in the options, assigns the request a unique ID.
         *
         *  **Do NOT override** this method in sub-classes; instead
         *  override [[_send]] or force the options values in the
         *  call to the constructor to modify this method's behavior.
         */
        send(method, params) {
          if (this.destroyed) {
            return Promise.reject(makeError("provider destroyed; cancelled request", "UNSUPPORTED_OPERATION", { operation: method }));
          }
          const id2 = __privateWrapper(this, _nextId)._++;
          const promise = new Promise((resolve, reject) => {
            __privateGet(this, _payloads).push({
              resolve,
              reject,
              payload: { method, params, id: id2, jsonrpc: "2.0" }
            });
          });
          __privateMethod(this, _JsonRpcApiProvider_instances, scheduleDrain_fn).call(this);
          return promise;
        }
        /**
         *  Resolves to the [[Signer]] account for  %%address%% managed by
         *  the client.
         *
         *  If the %%address%% is a number, it is used as an index in the
         *  the accounts from [[listAccounts]].
         *
         *  This can only be used on clients which manage accounts (such as
         *  Geth with imported account or MetaMask).
         *
         *  Throws if the account doesn't exist.
         */
        async getSigner(address) {
          if (address == null) {
            address = 0;
          }
          const accountsPromise = this.send("eth_accounts", []);
          if (typeof address === "number") {
            const accounts2 = await accountsPromise;
            if (address >= accounts2.length) {
              throw new Error("no such account");
            }
            return new JsonRpcSigner(this, accounts2[address]);
          }
          const { accounts } = await resolveProperties({
            network: this.getNetwork(),
            accounts: accountsPromise
          });
          address = getAddress(address);
          for (const account of accounts) {
            if (getAddress(account) === address) {
              return new JsonRpcSigner(this, address);
            }
          }
          throw new Error("invalid account");
        }
        async listAccounts() {
          const accounts = await this.send("eth_accounts", []);
          return accounts.map((a) => new JsonRpcSigner(this, a));
        }
        destroy() {
          if (__privateGet(this, _drainTimer)) {
            clearTimeout(__privateGet(this, _drainTimer));
            __privateSet(this, _drainTimer, null);
          }
          for (const { payload, reject } of __privateGet(this, _payloads)) {
            reject(makeError("provider destroyed; cancelled request", "UNSUPPORTED_OPERATION", { operation: payload.method }));
          }
          __privateSet(this, _payloads, []);
          super.destroy();
        }
      };
      _options3 = new WeakMap();
      _nextId = new WeakMap();
      _payloads = new WeakMap();
      _drainTimer = new WeakMap();
      _notReady = new WeakMap();
      _network2 = new WeakMap();
      _pendingDetectNetwork = new WeakMap();
      _JsonRpcApiProvider_instances = new WeakSet();
      scheduleDrain_fn = function() {
        if (__privateGet(this, _drainTimer)) {
          return;
        }
        const stallTime = this._getOption("batchMaxCount") === 1 ? 0 : this._getOption("batchStallTime");
        __privateSet(this, _drainTimer, setTimeout(() => {
          __privateSet(this, _drainTimer, null);
          const payloads = __privateGet(this, _payloads);
          __privateSet(this, _payloads, []);
          while (payloads.length) {
            const batch = [payloads.shift()];
            while (payloads.length) {
              if (batch.length === __privateGet(this, _options3).batchMaxCount) {
                break;
              }
              batch.push(payloads.shift());
              const bytes2 = JSON.stringify(batch.map((p) => p.payload));
              if (bytes2.length > __privateGet(this, _options3).batchMaxSize) {
                payloads.unshift(batch.pop());
                break;
              }
            }
            (async () => {
              const payload = batch.length === 1 ? batch[0].payload : batch.map((p) => p.payload);
              this.emit("debug", { action: "sendRpcPayload", payload });
              try {
                const result = await this._send(payload);
                this.emit("debug", { action: "receiveRpcResult", result });
                for (const { resolve, reject, payload: payload2 } of batch) {
                  if (this.destroyed) {
                    reject(makeError("provider destroyed; cancelled request", "UNSUPPORTED_OPERATION", { operation: payload2.method }));
                    continue;
                  }
                  const resp = result.filter((r) => r.id === payload2.id)[0];
                  if (resp == null) {
                    const error = makeError("missing response for request", "BAD_DATA", {
                      value: result,
                      info: { payload: payload2 }
                    });
                    this.emit("error", error);
                    reject(error);
                    continue;
                  }
                  if ("error" in resp) {
                    reject(this.getRpcError(payload2, resp));
                    continue;
                  }
                  resolve(resp.result);
                }
              } catch (error) {
                this.emit("debug", { action: "receiveRpcError", error });
                for (const { reject } of batch) {
                  reject(error);
                }
              }
            })();
          }
        }, stallTime));
      };
      JsonRpcApiPollingProvider = class extends JsonRpcApiProvider {
        constructor(network, options) {
          super(network, options);
          __privateAdd(this, _pollingInterval);
          let pollingInterval = this._getOption("pollingInterval");
          if (pollingInterval == null) {
            pollingInterval = defaultOptions2.pollingInterval;
          }
          __privateSet(this, _pollingInterval, pollingInterval);
        }
        _getSubscriber(sub) {
          const subscriber = super._getSubscriber(sub);
          if (isPollable(subscriber)) {
            subscriber.pollingInterval = __privateGet(this, _pollingInterval);
          }
          return subscriber;
        }
        /**
         *  The polling interval (default: 4000 ms)
         */
        get pollingInterval() {
          return __privateGet(this, _pollingInterval);
        }
        set pollingInterval(value) {
          if (!Number.isInteger(value) || value < 0) {
            throw new Error("invalid interval");
          }
          __privateSet(this, _pollingInterval, value);
          this._forEachSubscriber((sub) => {
            if (isPollable(sub)) {
              sub.pollingInterval = __privateGet(this, _pollingInterval);
            }
          });
        }
      };
      _pollingInterval = new WeakMap();
      JsonRpcProvider = class extends JsonRpcApiPollingProvider {
        constructor(url, network, options) {
          if (url == null) {
            url = "http://localhost:8545";
          }
          super(network, options);
          __privateAdd(this, _connect);
          if (typeof url === "string") {
            __privateSet(this, _connect, new FetchRequest(url));
          } else {
            __privateSet(this, _connect, url.clone());
          }
        }
        _getConnection() {
          return __privateGet(this, _connect).clone();
        }
        async send(method, params) {
          await this._start();
          return await super.send(method, params);
        }
        async _send(payload) {
          const request = this._getConnection();
          request.body = JSON.stringify(payload);
          request.setHeader("content-type", "application/json");
          const response = await request.send();
          response.assertOk();
          let resp = response.bodyJson;
          if (!Array.isArray(resp)) {
            resp = [resp];
          }
          return resp;
        }
      };
      _connect = new WeakMap();
    }
  });

  // node_modules/ethers/lib.esm/providers/provider-ankr.js
  function getHost(name) {
    switch (name) {
      case "mainnet":
        return "rpc.ankr.com/eth";
      case "goerli":
        return "rpc.ankr.com/eth_goerli";
      case "sepolia":
        return "rpc.ankr.com/eth_sepolia";
      case "arbitrum":
        return "rpc.ankr.com/arbitrum";
      case "base":
        return "rpc.ankr.com/base";
      case "base-goerli":
        return "rpc.ankr.com/base_goerli";
      case "base-sepolia":
        return "rpc.ankr.com/base_sepolia";
      case "bnb":
        return "rpc.ankr.com/bsc";
      case "bnbt":
        return "rpc.ankr.com/bsc_testnet_chapel";
      case "matic":
        return "rpc.ankr.com/polygon";
      case "matic-mumbai":
        return "rpc.ankr.com/polygon_mumbai";
      case "optimism":
        return "rpc.ankr.com/optimism";
      case "optimism-goerli":
        return "rpc.ankr.com/optimism_testnet";
      case "optimism-sepolia":
        return "rpc.ankr.com/optimism_sepolia";
    }
    assertArgument(false, "unsupported network", "network", name);
  }
  var defaultApiKey, AnkrProvider;
  var init_provider_ankr = __esm({
    "node_modules/ethers/lib.esm/providers/provider-ankr.js"() {
      init_utils();
      init_community();
      init_network();
      init_provider_jsonrpc();
      defaultApiKey = "9f7d929b018cdffb338517efa06f58359e86ff1ffd350bc889738523659e7972";
      AnkrProvider = class _AnkrProvider extends JsonRpcProvider {
        /**
         *  Create a new **AnkrProvider**.
         *
         *  By default connecting to ``mainnet`` with a highly throttled
         *  API key.
         */
        constructor(_network3, apiKey) {
          if (_network3 == null) {
            _network3 = "mainnet";
          }
          const network = Network.from(_network3);
          if (apiKey == null) {
            apiKey = defaultApiKey;
          }
          const options = { polling: true, staticNetwork: network };
          const request = _AnkrProvider.getRequest(network, apiKey);
          super(request, network, options);
          /**
           *  The API key for the Ankr connection.
           */
          __publicField(this, "apiKey");
          defineProperties(this, { apiKey });
        }
        _getProvider(chainId) {
          try {
            return new _AnkrProvider(chainId, this.apiKey);
          } catch (error) {
          }
          return super._getProvider(chainId);
        }
        /**
         *  Returns a prepared request for connecting to %%network%% with
         *  %%apiKey%%.
         */
        static getRequest(network, apiKey) {
          if (apiKey == null) {
            apiKey = defaultApiKey;
          }
          const request = new FetchRequest(`https://${getHost(network.name)}/${apiKey}`);
          request.allowGzip = true;
          if (apiKey === defaultApiKey) {
            request.retryFunc = async (request2, response, attempt) => {
              showThrottleMessage("AnkrProvider");
              return true;
            };
          }
          return request;
        }
        getRpcError(payload, error) {
          if (payload.method === "eth_sendRawTransaction") {
            if (error && error.error && error.error.message === "INTERNAL_ERROR: could not replace existing tx") {
              error.error.message = "replacement transaction underpriced";
            }
          }
          return super.getRpcError(payload, error);
        }
        isCommunityResource() {
          return this.apiKey === defaultApiKey;
        }
      };
    }
  });

  // node_modules/ethers/lib.esm/providers/provider-alchemy.js
  function getHost2(name) {
    switch (name) {
      case "mainnet":
        return "eth-mainnet.alchemyapi.io";
      case "goerli":
        return "eth-goerli.g.alchemy.com";
      case "sepolia":
        return "eth-sepolia.g.alchemy.com";
      case "arbitrum":
        return "arb-mainnet.g.alchemy.com";
      case "arbitrum-goerli":
        return "arb-goerli.g.alchemy.com";
      case "arbitrum-sepolia":
        return "arb-sepolia.g.alchemy.com";
      case "base":
        return "base-mainnet.g.alchemy.com";
      case "base-goerli":
        return "base-goerli.g.alchemy.com";
      case "base-sepolia":
        return "base-sepolia.g.alchemy.com";
      case "matic":
        return "polygon-mainnet.g.alchemy.com";
      case "matic-amoy":
        return "polygon-amoy.g.alchemy.com";
      case "matic-mumbai":
        return "polygon-mumbai.g.alchemy.com";
      case "optimism":
        return "opt-mainnet.g.alchemy.com";
      case "optimism-goerli":
        return "opt-goerli.g.alchemy.com";
      case "optimism-sepolia":
        return "opt-sepolia.g.alchemy.com";
    }
    assertArgument(false, "unsupported network", "network", name);
  }
  var defaultApiKey2, AlchemyProvider;
  var init_provider_alchemy = __esm({
    "node_modules/ethers/lib.esm/providers/provider-alchemy.js"() {
      init_utils();
      init_community();
      init_network();
      init_provider_jsonrpc();
      defaultApiKey2 = "_gg7wSSi0KMBsdKnGVfHDueq6xMB9EkC";
      AlchemyProvider = class _AlchemyProvider extends JsonRpcProvider {
        constructor(_network3, apiKey) {
          if (_network3 == null) {
            _network3 = "mainnet";
          }
          const network = Network.from(_network3);
          if (apiKey == null) {
            apiKey = defaultApiKey2;
          }
          const request = _AlchemyProvider.getRequest(network, apiKey);
          super(request, network, { staticNetwork: network });
          __publicField(this, "apiKey");
          defineProperties(this, { apiKey });
        }
        _getProvider(chainId) {
          try {
            return new _AlchemyProvider(chainId, this.apiKey);
          } catch (error) {
          }
          return super._getProvider(chainId);
        }
        async _perform(req) {
          if (req.method === "getTransactionResult") {
            const { trace, tx } = await resolveProperties({
              trace: this.send("trace_transaction", [req.hash]),
              tx: this.getTransaction(req.hash)
            });
            if (trace == null || tx == null) {
              return null;
            }
            let data;
            let error = false;
            try {
              data = trace[0].result.output;
              error = trace[0].error === "Reverted";
            } catch (error2) {
            }
            if (data) {
              assert(!error, "an error occurred during transaction executions", "CALL_EXCEPTION", {
                action: "getTransactionResult",
                data,
                reason: null,
                transaction: tx,
                invocation: null,
                revert: null
                // @TODO
              });
              return data;
            }
            assert(false, "could not parse trace result", "BAD_DATA", { value: trace });
          }
          return await super._perform(req);
        }
        isCommunityResource() {
          return this.apiKey === defaultApiKey2;
        }
        static getRequest(network, apiKey) {
          if (apiKey == null) {
            apiKey = defaultApiKey2;
          }
          const request = new FetchRequest(`https://${getHost2(network.name)}/v2/${apiKey}`);
          request.allowGzip = true;
          if (apiKey === defaultApiKey2) {
            request.retryFunc = async (request2, response, attempt) => {
              showThrottleMessage("alchemy");
              return true;
            };
          }
          return request;
        }
      };
    }
  });

  // node_modules/ethers/lib.esm/providers/provider-chainstack.js
  function getApiKey(name) {
    switch (name) {
      case "mainnet":
        return "39f1d67cedf8b7831010a665328c9197";
      case "arbitrum":
        return "0550c209db33c3abf4cc927e1e18cea1";
      case "bnb":
        return "98b5a77e531614387366f6fc5da097f8";
      case "matic":
        return "cd9d4d70377471aa7c142ec4a4205249";
    }
    assertArgument(false, "unsupported network", "network", name);
  }
  function getHost3(name) {
    switch (name) {
      case "mainnet":
        return "ethereum-mainnet.core.chainstack.com";
      case "arbitrum":
        return "arbitrum-mainnet.core.chainstack.com";
      case "bnb":
        return "bsc-mainnet.core.chainstack.com";
      case "matic":
        return "polygon-mainnet.core.chainstack.com";
    }
    assertArgument(false, "unsupported network", "network", name);
  }
  var ChainstackProvider;
  var init_provider_chainstack = __esm({
    "node_modules/ethers/lib.esm/providers/provider-chainstack.js"() {
      init_utils();
      init_community();
      init_network();
      init_provider_jsonrpc();
      ChainstackProvider = class _ChainstackProvider extends JsonRpcProvider {
        /**
         *  Creates a new **ChainstackProvider**.
         */
        constructor(_network3, apiKey) {
          if (_network3 == null) {
            _network3 = "mainnet";
          }
          const network = Network.from(_network3);
          if (apiKey == null) {
            apiKey = getApiKey(network.name);
          }
          const request = _ChainstackProvider.getRequest(network, apiKey);
          super(request, network, { staticNetwork: network });
          /**
           *  The API key for the Chainstack connection.
           */
          __publicField(this, "apiKey");
          defineProperties(this, { apiKey });
        }
        _getProvider(chainId) {
          try {
            return new _ChainstackProvider(chainId, this.apiKey);
          } catch (error) {
          }
          return super._getProvider(chainId);
        }
        isCommunityResource() {
          return this.apiKey === getApiKey(this._network.name);
        }
        /**
         *  Returns a prepared request for connecting to %%network%%
         *  with %%apiKey%% and %%projectSecret%%.
         */
        static getRequest(network, apiKey) {
          if (apiKey == null) {
            apiKey = getApiKey(network.name);
          }
          const request = new FetchRequest(`https://${getHost3(network.name)}/${apiKey}`);
          request.allowGzip = true;
          if (apiKey === getApiKey(network.name)) {
            request.retryFunc = async (request2, response, attempt) => {
              showThrottleMessage("ChainstackProvider");
              return true;
            };
          }
          return request;
        }
      };
    }
  });

  // node_modules/ethers/lib.esm/providers/provider-cloudflare.js
  var CloudflareProvider;
  var init_provider_cloudflare = __esm({
    "node_modules/ethers/lib.esm/providers/provider-cloudflare.js"() {
      init_utils();
      init_network();
      init_provider_jsonrpc();
      CloudflareProvider = class extends JsonRpcProvider {
        constructor(_network3) {
          if (_network3 == null) {
            _network3 = "mainnet";
          }
          const network = Network.from(_network3);
          assertArgument(network.name === "mainnet", "unsupported network", "network", _network3);
          super("https://cloudflare-eth.com/", network, { staticNetwork: network });
        }
      };
    }
  });

  // node_modules/ethers/lib.esm/providers/provider-etherscan.js
  function isPromise2(value) {
    return value && typeof value.then === "function";
  }
  var THROTTLE, EtherscanPluginId, EtherscanPlugin, skipKeys, nextId, _plugin, EtherscanProvider;
  var init_provider_etherscan = __esm({
    "node_modules/ethers/lib.esm/providers/provider-etherscan.js"() {
      init_abi();
      init_contract2();
      init_transaction2();
      init_utils();
      init_abstract_provider();
      init_network();
      init_plugins_network();
      init_community();
      THROTTLE = 2e3;
      EtherscanPluginId = "org.ethers.plugins.provider.Etherscan";
      EtherscanPlugin = class _EtherscanPlugin extends NetworkPlugin {
        /**
         *  Creates a new **EtherscanProvider** which will use
         *  %%baseUrl%%.
         */
        constructor(baseUrl) {
          super(EtherscanPluginId);
          /**
           *  The Etherscan API base URL.
           */
          __publicField(this, "baseUrl");
          defineProperties(this, { baseUrl });
        }
        clone() {
          return new _EtherscanPlugin(this.baseUrl);
        }
      };
      skipKeys = ["enableCcipRead"];
      nextId = 1;
      EtherscanProvider = class extends AbstractProvider {
        /**
         *  Creates a new **EtherscanBaseProvider**.
         */
        constructor(_network3, _apiKey) {
          const apiKey = _apiKey != null ? _apiKey : null;
          super();
          /**
           *  The connected network.
           */
          __publicField(this, "network");
          /**
           *  The API key or null if using the community provided bandwidth.
           */
          __publicField(this, "apiKey");
          __privateAdd(this, _plugin);
          const network = Network.from(_network3);
          __privateSet(this, _plugin, network.getPlugin(EtherscanPluginId));
          defineProperties(this, { apiKey, network });
        }
        /**
         *  Returns the base URL.
         *
         *  If an [[EtherscanPlugin]] is configured on the
         *  [[EtherscanBaseProvider_network]], returns the plugin's
         *  baseUrl.
         *
         *  Deprecated; for Etherscan v2 the base is no longer a simply
         *  host, but instead a URL including a chainId parameter. Changing
         *  this to return a URL prefix could break some libraries, so it
         *  is left intact but will be removed in the future as it is unused.
         */
        getBaseUrl() {
          if (__privateGet(this, _plugin)) {
            return __privateGet(this, _plugin).baseUrl;
          }
          switch (this.network.name) {
            case "mainnet":
              return "https://api.etherscan.io";
            case "goerli":
              return "https://api-goerli.etherscan.io";
            case "sepolia":
              return "https://api-sepolia.etherscan.io";
            case "holesky":
              return "https://api-holesky.etherscan.io";
            case "arbitrum":
              return "https://api.arbiscan.io";
            case "arbitrum-goerli":
              return "https://api-goerli.arbiscan.io";
            case "base":
              return "https://api.basescan.org";
            case "base-sepolia":
              return "https://api-sepolia.basescan.org";
            case "bnb":
              return "https://api.bscscan.com";
            case "bnbt":
              return "https://api-testnet.bscscan.com";
            case "matic":
              return "https://api.polygonscan.com";
            case "matic-amoy":
              return "https://api-amoy.polygonscan.com";
            case "matic-mumbai":
              return "https://api-testnet.polygonscan.com";
            case "optimism":
              return "https://api-optimistic.etherscan.io";
            case "optimism-goerli":
              return "https://api-goerli-optimistic.etherscan.io";
            default:
          }
          assertArgument(false, "unsupported network", "network", this.network);
        }
        /**
         *  Returns the URL for the %%module%% and %%params%%.
         */
        getUrl(module, params) {
          let query = Object.keys(params).reduce((accum, key) => {
            const value = params[key];
            if (value != null) {
              accum += `&${key}=${value}`;
            }
            return accum;
          }, "");
          if (this.apiKey) {
            query += `&apikey=${this.apiKey}`;
          }
          return `https://api.etherscan.io/v2/api?chainid=${this.network.chainId}&module=${module}${query}`;
        }
        /**
         *  Returns the URL for using POST requests.
         */
        getPostUrl() {
          return `https://api.etherscan.io/v2/api?chainid=${this.network.chainId}`;
        }
        /**
         *  Returns the parameters for using POST requests.
         */
        getPostData(module, params) {
          params.module = module;
          params.apikey = this.apiKey;
          params.chainid = this.network.chainId;
          return params;
        }
        async detectNetwork() {
          return this.network;
        }
        /**
         *  Resolves to the result of calling %%module%% with %%params%%.
         *
         *  If %%post%%, the request is made as a POST request.
         */
        async fetch(module, params, post) {
          const id2 = nextId++;
          const url = post ? this.getPostUrl() : this.getUrl(module, params);
          const payload = post ? this.getPostData(module, params) : null;
          this.emit("debug", { action: "sendRequest", id: id2, url, payload });
          const request = new FetchRequest(url);
          request.setThrottleParams({ slotInterval: 1e3 });
          request.retryFunc = (req, resp, attempt) => {
            if (this.isCommunityResource()) {
              showThrottleMessage("Etherscan");
            }
            return Promise.resolve(true);
          };
          request.processFunc = async (request2, response2) => {
            const result2 = response2.hasBody() ? JSON.parse(toUtf8String(response2.body)) : {};
            const throttle = (typeof result2.result === "string" ? result2.result : "").toLowerCase().indexOf("rate limit") >= 0;
            if (module === "proxy") {
              if (result2 && result2.status == 0 && result2.message == "NOTOK" && throttle) {
                this.emit("debug", { action: "receiveError", id: id2, reason: "proxy-NOTOK", error: result2 });
                response2.throwThrottleError(result2.result, THROTTLE);
              }
            } else {
              if (throttle) {
                this.emit("debug", { action: "receiveError", id: id2, reason: "null result", error: result2.result });
                response2.throwThrottleError(result2.result, THROTTLE);
              }
            }
            return response2;
          };
          if (payload) {
            request.setHeader("content-type", "application/x-www-form-urlencoded; charset=UTF-8");
            request.body = Object.keys(payload).map((k) => `${k}=${payload[k]}`).join("&");
          }
          const response = await request.send();
          try {
            response.assertOk();
          } catch (error) {
            this.emit("debug", { action: "receiveError", id: id2, error, reason: "assertOk" });
            assert(false, "response error", "SERVER_ERROR", { request, response });
          }
          if (!response.hasBody()) {
            this.emit("debug", { action: "receiveError", id: id2, error: "missing body", reason: "null body" });
            assert(false, "missing response", "SERVER_ERROR", { request, response });
          }
          const result = JSON.parse(toUtf8String(response.body));
          if (module === "proxy") {
            if (result.jsonrpc != "2.0") {
              this.emit("debug", { action: "receiveError", id: id2, result, reason: "invalid JSON-RPC" });
              assert(false, "invalid JSON-RPC response (missing jsonrpc='2.0')", "SERVER_ERROR", { request, response, info: { result } });
            }
            if (result.error) {
              this.emit("debug", { action: "receiveError", id: id2, result, reason: "JSON-RPC error" });
              assert(false, "error response", "SERVER_ERROR", { request, response, info: { result } });
            }
            this.emit("debug", { action: "receiveRequest", id: id2, result });
            return result.result;
          } else {
            if (result.status == 0 && (result.message === "No records found" || result.message === "No transactions found")) {
              this.emit("debug", { action: "receiveRequest", id: id2, result });
              return result.result;
            }
            if (result.status != 1 || typeof result.message === "string" && !result.message.match(/^OK/)) {
              this.emit("debug", { action: "receiveError", id: id2, result });
              assert(false, "error response", "SERVER_ERROR", { request, response, info: { result } });
            }
            this.emit("debug", { action: "receiveRequest", id: id2, result });
            return result.result;
          }
        }
        /**
         *  Returns %%transaction%% normalized for the Etherscan API.
         */
        _getTransactionPostData(transaction) {
          const result = {};
          for (let key in transaction) {
            if (skipKeys.indexOf(key) >= 0) {
              continue;
            }
            if (transaction[key] == null) {
              continue;
            }
            let value = transaction[key];
            if (key === "type" && value === 0) {
              continue;
            }
            if (key === "blockTag" && value === "latest") {
              continue;
            }
            if ({ type: true, gasLimit: true, gasPrice: true, maxFeePerGs: true, maxPriorityFeePerGas: true, nonce: true, value: true }[key]) {
              value = toQuantity(value);
            } else if (key === "accessList") {
              value = "[" + accessListify(value).map((set) => {
                return `{address:"${set.address}",storageKeys:["${set.storageKeys.join('","')}"]}`;
              }).join(",") + "]";
            } else if (key === "blobVersionedHashes") {
              if (value.length === 0) {
                continue;
              }
              assert(false, "Etherscan API does not support blobVersionedHashes", "UNSUPPORTED_OPERATION", {
                operation: "_getTransactionPostData",
                info: { transaction }
              });
            } else {
              value = hexlify(value);
            }
            result[key] = value;
          }
          return result;
        }
        /**
         *  Throws the normalized Etherscan error.
         */
        _checkError(req, error, transaction) {
          let message = "";
          if (isError(error, "SERVER_ERROR")) {
            try {
              message = error.info.result.error.message;
            } catch (e) {
            }
            if (!message) {
              try {
                message = error.info.message;
              } catch (e) {
              }
            }
          }
          if (req.method === "estimateGas") {
            if (!message.match(/revert/i) && message.match(/insufficient funds/i)) {
              assert(false, "insufficient funds", "INSUFFICIENT_FUNDS", {
                transaction: req.transaction
              });
            }
          }
          if (req.method === "call" || req.method === "estimateGas") {
            if (message.match(/execution reverted/i)) {
              let data = "";
              try {
                data = error.info.result.error.data;
              } catch (error2) {
              }
              const e = AbiCoder.getBuiltinCallException(req.method, req.transaction, data);
              e.info = { request: req, error };
              throw e;
            }
          }
          if (message) {
            if (req.method === "broadcastTransaction") {
              const transaction2 = Transaction.from(req.signedTransaction);
              if (message.match(/replacement/i) && message.match(/underpriced/i)) {
                assert(false, "replacement fee too low", "REPLACEMENT_UNDERPRICED", {
                  transaction: transaction2
                });
              }
              if (message.match(/insufficient funds/)) {
                assert(false, "insufficient funds for intrinsic transaction cost", "INSUFFICIENT_FUNDS", {
                  transaction: transaction2
                });
              }
              if (message.match(/same hash was already imported|transaction nonce is too low|nonce too low/)) {
                assert(false, "nonce has already been used", "NONCE_EXPIRED", {
                  transaction: transaction2
                });
              }
            }
          }
          throw error;
        }
        async _detectNetwork() {
          return this.network;
        }
        async _perform(req) {
          switch (req.method) {
            case "chainId":
              return this.network.chainId;
            case "getBlockNumber":
              return this.fetch("proxy", { action: "eth_blockNumber" });
            case "getGasPrice":
              return this.fetch("proxy", { action: "eth_gasPrice" });
            case "getPriorityFee":
              if (this.network.name === "mainnet") {
                return "1000000000";
              } else if (this.network.name === "optimism") {
                return "1000000";
              } else {
                throw new Error("fallback onto the AbstractProvider default");
              }
            /* Working with Etherscan to get this added:
            try {
                const test = await this.fetch("proxy", {
                    action: "eth_maxPriorityFeePerGas"
                });
                console.log(test);
                return test;
            } catch (e) {
                console.log("DEBUG", e);
                throw e;
            }
            */
            /* This might be safe; but due to rounding neither myself
               or Etherscan are necessarily comfortable with this. :)
            try {
                const result = await this.fetch("gastracker", { action: "gasoracle" });
                console.log(result);
                const gasPrice = parseUnits(result.SafeGasPrice, "gwei");
                const baseFee = parseUnits(result.suggestBaseFee, "gwei");
                const priorityFee = gasPrice - baseFee;
                if (priorityFee < 0) { throw new Error("negative priority fee; defer to abstract provider default"); }
                return priorityFee;
            } catch (error) {
                console.log("DEBUG", error);
                throw error;
            }
            */
            case "getBalance":
              return this.fetch("account", {
                action: "balance",
                address: req.address,
                tag: req.blockTag
              });
            case "getTransactionCount":
              return this.fetch("proxy", {
                action: "eth_getTransactionCount",
                address: req.address,
                tag: req.blockTag
              });
            case "getCode":
              return this.fetch("proxy", {
                action: "eth_getCode",
                address: req.address,
                tag: req.blockTag
              });
            case "getStorage":
              return this.fetch("proxy", {
                action: "eth_getStorageAt",
                address: req.address,
                position: req.position,
                tag: req.blockTag
              });
            case "broadcastTransaction":
              return this.fetch("proxy", {
                action: "eth_sendRawTransaction",
                hex: req.signedTransaction
              }, true).catch((error) => {
                return this._checkError(req, error, req.signedTransaction);
              });
            case "getBlock":
              if ("blockTag" in req) {
                return this.fetch("proxy", {
                  action: "eth_getBlockByNumber",
                  tag: req.blockTag,
                  boolean: req.includeTransactions ? "true" : "false"
                });
              }
              assert(false, "getBlock by blockHash not supported by Etherscan", "UNSUPPORTED_OPERATION", {
                operation: "getBlock(blockHash)"
              });
            case "getTransaction":
              return this.fetch("proxy", {
                action: "eth_getTransactionByHash",
                txhash: req.hash
              });
            case "getTransactionReceipt":
              return this.fetch("proxy", {
                action: "eth_getTransactionReceipt",
                txhash: req.hash
              });
            case "call": {
              if (req.blockTag !== "latest") {
                throw new Error("EtherscanProvider does not support blockTag for call");
              }
              const postData = this._getTransactionPostData(req.transaction);
              postData.module = "proxy";
              postData.action = "eth_call";
              try {
                return await this.fetch("proxy", postData, true);
              } catch (error) {
                return this._checkError(req, error, req.transaction);
              }
            }
            case "estimateGas": {
              const postData = this._getTransactionPostData(req.transaction);
              postData.module = "proxy";
              postData.action = "eth_estimateGas";
              try {
                return await this.fetch("proxy", postData, true);
              } catch (error) {
                return this._checkError(req, error, req.transaction);
              }
            }
            /*
                        case "getLogs": {
                            // Needs to complain if more than one address is passed in
                            const args: Record<string, any> = { action: "getLogs" }
            
                            if (params.filter.fromBlock) {
                                args.fromBlock = checkLogTag(params.filter.fromBlock);
                            }
            
                            if (params.filter.toBlock) {
                                args.toBlock = checkLogTag(params.filter.toBlock);
                            }
            
                            if (params.filter.address) {
                                args.address = params.filter.address;
                            }
            
                            // @TODO: We can handle slightly more complicated logs using the logs API
                            if (params.filter.topics && params.filter.topics.length > 0) {
                                if (params.filter.topics.length > 1) {
                                    logger.throwError("unsupported topic count", Logger.Errors.UNSUPPORTED_OPERATION, { topics: params.filter.topics });
                                }
                                if (params.filter.topics.length === 1) {
                                    const topic0 = params.filter.topics[0];
                                    if (typeof(topic0) !== "string" || topic0.length !== 66) {
                                        logger.throwError("unsupported topic format", Logger.Errors.UNSUPPORTED_OPERATION, { topic0: topic0 });
                                    }
                                    args.topic0 = topic0;
                                }
                            }
            
                            const logs: Array<any> = await this.fetch("logs", args);
            
                            // Cache txHash => blockHash
                            let blocks: { [tag: string]: string } = {};
            
                            // Add any missing blockHash to the logs
                            for (let i = 0; i < logs.length; i++) {
                                const log = logs[i];
                                if (log.blockHash != null) { continue; }
                                if (blocks[log.blockNumber] == null) {
                                    const block = await this.getBlock(log.blockNumber);
                                    if (block) {
                                        blocks[log.blockNumber] = block.hash;
                                    }
                                }
            
                                log.blockHash = blocks[log.blockNumber];
                            }
            
                            return logs;
                        }
            */
            default:
              break;
          }
          return super._perform(req);
        }
        async getNetwork() {
          return this.network;
        }
        /**
         *  Resolves to the current price of ether.
         *
         *  This returns ``0`` on any network other than ``mainnet``.
         */
        async getEtherPrice() {
          if (this.network.name !== "mainnet") {
            return 0;
          }
          return parseFloat((await this.fetch("stats", { action: "ethprice" })).ethusd);
        }
        /**
         *  Resolves to a [Contract]] for %%address%%, using the
         *  Etherscan API to retreive the Contract ABI.
         */
        async getContract(_address) {
          let address = this._getAddress(_address);
          if (isPromise2(address)) {
            address = await address;
          }
          try {
            const resp = await this.fetch("contract", {
              action: "getabi",
              address
            });
            const abi2 = JSON.parse(resp);
            return new Contract(address, abi2, this);
          } catch (error) {
            return null;
          }
        }
        isCommunityResource() {
          return this.apiKey == null;
        }
      };
      _plugin = new WeakMap();
    }
  });

  // node_modules/ethers/lib.esm/providers/ws-browser.js
  function getGlobal2() {
    if (typeof self !== "undefined") {
      return self;
    }
    if (typeof window !== "undefined") {
      return window;
    }
    if (typeof global !== "undefined") {
      return global;
    }
    throw new Error("unable to locate global object");
  }
  var _WebSocket;
  var init_ws_browser = __esm({
    "node_modules/ethers/lib.esm/providers/ws-browser.js"() {
      _WebSocket = getGlobal2().WebSocket;
    }
  });

  // node_modules/ethers/lib.esm/providers/provider-socket.js
  var _provider5, _filter4, _filterId, _paused, _emitPromise, SocketSubscriber, SocketBlockSubscriber, SocketPendingSubscriber, _logFilter, SocketEventSubscriber, _callbacks, _subs2, _pending, SocketProvider;
  var init_provider_socket = __esm({
    "node_modules/ethers/lib.esm/providers/provider-socket.js"() {
      init_abstract_provider();
      init_utils();
      init_provider_jsonrpc();
      SocketSubscriber = class {
        /**
         *  Creates a new **SocketSubscriber** attached to %%provider%% listening
         *  to %%filter%%.
         */
        constructor(provider, filter) {
          __privateAdd(this, _provider5);
          __privateAdd(this, _filter4);
          __privateAdd(this, _filterId);
          __privateAdd(this, _paused);
          __privateAdd(this, _emitPromise);
          __privateSet(this, _provider5, provider);
          __privateSet(this, _filter4, JSON.stringify(filter));
          __privateSet(this, _filterId, null);
          __privateSet(this, _paused, null);
          __privateSet(this, _emitPromise, null);
        }
        /**
         *  The filter.
         */
        get filter() {
          return JSON.parse(__privateGet(this, _filter4));
        }
        start() {
          __privateSet(this, _filterId, __privateGet(this, _provider5).send("eth_subscribe", this.filter).then((filterId) => {
            ;
            __privateGet(this, _provider5)._register(filterId, this);
            return filterId;
          }));
        }
        stop() {
          __privateGet(this, _filterId).then((filterId) => {
            if (__privateGet(this, _provider5).destroyed) {
              return;
            }
            __privateGet(this, _provider5).send("eth_unsubscribe", [filterId]);
          });
          __privateSet(this, _filterId, null);
        }
        // @TODO: pause should trap the current blockNumber, unsub, and on resume use getLogs
        //        and resume
        pause(dropWhilePaused) {
          assert(dropWhilePaused, "preserve logs while paused not supported by SocketSubscriber yet", "UNSUPPORTED_OPERATION", { operation: "pause(false)" });
          __privateSet(this, _paused, !!dropWhilePaused);
        }
        resume() {
          __privateSet(this, _paused, null);
        }
        /**
         *  @_ignore:
         */
        _handleMessage(message) {
          if (__privateGet(this, _filterId) == null) {
            return;
          }
          if (__privateGet(this, _paused) === null) {
            let emitPromise = __privateGet(this, _emitPromise);
            if (emitPromise == null) {
              emitPromise = this._emit(__privateGet(this, _provider5), message);
            } else {
              emitPromise = emitPromise.then(async () => {
                await this._emit(__privateGet(this, _provider5), message);
              });
            }
            __privateSet(this, _emitPromise, emitPromise.then(() => {
              if (__privateGet(this, _emitPromise) === emitPromise) {
                __privateSet(this, _emitPromise, null);
              }
            }));
          }
        }
        /**
         *  Sub-classes **must** override this to emit the events on the
         *  provider.
         */
        async _emit(provider, message) {
          throw new Error("sub-classes must implemente this; _emit");
        }
      };
      _provider5 = new WeakMap();
      _filter4 = new WeakMap();
      _filterId = new WeakMap();
      _paused = new WeakMap();
      _emitPromise = new WeakMap();
      SocketBlockSubscriber = class extends SocketSubscriber {
        /**
         *  @_ignore:
         */
        constructor(provider) {
          super(provider, ["newHeads"]);
        }
        async _emit(provider, message) {
          provider.emit("block", parseInt(message.number));
        }
      };
      SocketPendingSubscriber = class extends SocketSubscriber {
        /**
         *  @_ignore:
         */
        constructor(provider) {
          super(provider, ["newPendingTransactions"]);
        }
        async _emit(provider, message) {
          provider.emit("pending", message);
        }
      };
      SocketEventSubscriber = class extends SocketSubscriber {
        /**
         *  @_ignore:
         */
        constructor(provider, filter) {
          super(provider, ["logs", filter]);
          __privateAdd(this, _logFilter);
          __privateSet(this, _logFilter, JSON.stringify(filter));
        }
        /**
         *  The filter.
         */
        get logFilter() {
          return JSON.parse(__privateGet(this, _logFilter));
        }
        async _emit(provider, message) {
          provider.emit(this.logFilter, provider._wrapLog(message, provider._network));
        }
      };
      _logFilter = new WeakMap();
      SocketProvider = class extends JsonRpcApiProvider {
        /**
         *  Creates a new **SocketProvider** connected to %%network%%.
         *
         *  If unspecified, the network will be discovered.
         */
        constructor(network, _options4) {
          const options = Object.assign({}, _options4 != null ? _options4 : {});
          assertArgument(options.batchMaxCount == null || options.batchMaxCount === 1, "sockets-based providers do not support batches", "options.batchMaxCount", _options4);
          options.batchMaxCount = 1;
          if (options.staticNetwork == null) {
            options.staticNetwork = true;
          }
          super(network, options);
          __privateAdd(this, _callbacks);
          // Maps each filterId to its subscriber
          __privateAdd(this, _subs2);
          // If any events come in before a subscriber has finished
          // registering, queue them
          __privateAdd(this, _pending);
          __privateSet(this, _callbacks, /* @__PURE__ */ new Map());
          __privateSet(this, _subs2, /* @__PURE__ */ new Map());
          __privateSet(this, _pending, /* @__PURE__ */ new Map());
        }
        // This value is only valid after _start has been called
        /*
        get _network(): Network {
            if (this.#network == null) {
                throw new Error("this shouldn't happen");
            }
            return this.#network.clone();
        }
        */
        _getSubscriber(sub) {
          switch (sub.type) {
            case "close":
              return new UnmanagedSubscriber("close");
            case "block":
              return new SocketBlockSubscriber(this);
            case "pending":
              return new SocketPendingSubscriber(this);
            case "event":
              return new SocketEventSubscriber(this, sub.filter);
            case "orphan":
              if (sub.filter.orphan === "drop-log") {
                return new UnmanagedSubscriber("drop-log");
              }
          }
          return super._getSubscriber(sub);
        }
        /**
         *  Register a new subscriber. This is used internalled by Subscribers
         *  and generally is unecessary unless extending capabilities.
         */
        _register(filterId, subscriber) {
          __privateGet(this, _subs2).set(filterId, subscriber);
          const pending = __privateGet(this, _pending).get(filterId);
          if (pending) {
            for (const message of pending) {
              subscriber._handleMessage(message);
            }
            __privateGet(this, _pending).delete(filterId);
          }
        }
        async _send(payload) {
          assertArgument(!Array.isArray(payload), "WebSocket does not support batch send", "payload", payload);
          const promise = new Promise((resolve, reject) => {
            __privateGet(this, _callbacks).set(payload.id, { payload, resolve, reject });
          });
          await this._waitUntilReady();
          await this._write(JSON.stringify(payload));
          return [await promise];
        }
        // Sub-classes must call this once they are connected
        /*
            async _start(): Promise<void> {
                if (this.#ready) { return; }
        
                for (const { payload } of this.#callbacks.values()) {
                    await this._write(JSON.stringify(payload));
                }
        
                this.#ready = (async function() {
                    await super._start();
                })();
            }
            */
        /**
         *  Sub-classes **must** call this with messages received over their
         *  transport to be processed and dispatched.
         */
        async _processMessage(message) {
          const result = JSON.parse(message);
          if (result && typeof result === "object" && "id" in result) {
            const callback = __privateGet(this, _callbacks).get(result.id);
            if (callback == null) {
              this.emit("error", makeError("received result for unknown id", "UNKNOWN_ERROR", {
                reasonCode: "UNKNOWN_ID",
                result
              }));
              return;
            }
            __privateGet(this, _callbacks).delete(result.id);
            callback.resolve(result);
          } else if (result && result.method === "eth_subscription") {
            const filterId = result.params.subscription;
            const subscriber = __privateGet(this, _subs2).get(filterId);
            if (subscriber) {
              subscriber._handleMessage(result.params.result);
            } else {
              let pending = __privateGet(this, _pending).get(filterId);
              if (pending == null) {
                pending = [];
                __privateGet(this, _pending).set(filterId, pending);
              }
              pending.push(result.params.result);
            }
          } else {
            this.emit("error", makeError("received unexpected message", "UNKNOWN_ERROR", {
              reasonCode: "UNEXPECTED_MESSAGE",
              result
            }));
            return;
          }
        }
        /**
         *  Sub-classes **must** override this to send %%message%% over their
         *  transport.
         */
        async _write(message) {
          throw new Error("sub-classes must override this");
        }
      };
      _callbacks = new WeakMap();
      _subs2 = new WeakMap();
      _pending = new WeakMap();
    }
  });

  // node_modules/ethers/lib.esm/providers/provider-websocket.js
  var _connect2, _websocket, WebSocketProvider;
  var init_provider_websocket = __esm({
    "node_modules/ethers/lib.esm/providers/provider-websocket.js"() {
      init_ws_browser();
      init_provider_socket();
      WebSocketProvider = class extends SocketProvider {
        constructor(url, network, options) {
          super(network, options);
          __privateAdd(this, _connect2);
          __privateAdd(this, _websocket);
          if (typeof url === "string") {
            __privateSet(this, _connect2, () => {
              return new _WebSocket(url);
            });
            __privateSet(this, _websocket, __privateGet(this, _connect2).call(this));
          } else if (typeof url === "function") {
            __privateSet(this, _connect2, url);
            __privateSet(this, _websocket, url());
          } else {
            __privateSet(this, _connect2, null);
            __privateSet(this, _websocket, url);
          }
          this.websocket.onopen = async () => {
            try {
              await this._start();
              this.resume();
            } catch (error) {
              console.log("failed to start WebsocketProvider", error);
            }
          };
          this.websocket.onmessage = (message) => {
            this._processMessage(message.data);
          };
        }
        get websocket() {
          if (__privateGet(this, _websocket) == null) {
            throw new Error("websocket closed");
          }
          return __privateGet(this, _websocket);
        }
        async _write(message) {
          this.websocket.send(message);
        }
        async destroy() {
          if (__privateGet(this, _websocket) != null) {
            __privateGet(this, _websocket).close();
            __privateSet(this, _websocket, null);
          }
          super.destroy();
        }
      };
      _connect2 = new WeakMap();
      _websocket = new WeakMap();
    }
  });

  // node_modules/ethers/lib.esm/providers/provider-infura.js
  function getHost4(name) {
    switch (name) {
      case "mainnet":
        return "mainnet.infura.io";
      case "goerli":
        return "goerli.infura.io";
      case "sepolia":
        return "sepolia.infura.io";
      case "arbitrum":
        return "arbitrum-mainnet.infura.io";
      case "arbitrum-goerli":
        return "arbitrum-goerli.infura.io";
      case "arbitrum-sepolia":
        return "arbitrum-sepolia.infura.io";
      case "base":
        return "base-mainnet.infura.io";
      case "base-goerlia":
      // @TODO: Remove this typo in the future!
      case "base-goerli":
        return "base-goerli.infura.io";
      case "base-sepolia":
        return "base-sepolia.infura.io";
      case "bnb":
        return "bsc-mainnet.infura.io";
      case "bnbt":
        return "bsc-testnet.infura.io";
      case "linea":
        return "linea-mainnet.infura.io";
      case "linea-goerli":
        return "linea-goerli.infura.io";
      case "linea-sepolia":
        return "linea-sepolia.infura.io";
      case "matic":
        return "polygon-mainnet.infura.io";
      case "matic-amoy":
        return "polygon-amoy.infura.io";
      case "matic-mumbai":
        return "polygon-mumbai.infura.io";
      case "optimism":
        return "optimism-mainnet.infura.io";
      case "optimism-goerli":
        return "optimism-goerli.infura.io";
      case "optimism-sepolia":
        return "optimism-sepolia.infura.io";
    }
    assertArgument(false, "unsupported network", "network", name);
  }
  var defaultProjectId, InfuraWebSocketProvider, InfuraProvider;
  var init_provider_infura = __esm({
    "node_modules/ethers/lib.esm/providers/provider-infura.js"() {
      init_utils();
      init_community();
      init_network();
      init_provider_jsonrpc();
      init_provider_websocket();
      defaultProjectId = "84842078b09946638c03157f83405213";
      InfuraWebSocketProvider = class extends WebSocketProvider {
        /**
         *  Creates a new **InfuraWebSocketProvider**.
         */
        constructor(network, projectId) {
          const provider = new InfuraProvider(network, projectId);
          const req = provider._getConnection();
          assert(!req.credentials, "INFURA WebSocket project secrets unsupported", "UNSUPPORTED_OPERATION", { operation: "InfuraProvider.getWebSocketProvider()" });
          const url = req.url.replace(/^http/i, "ws").replace("/v3/", "/ws/v3/");
          super(url, provider._network);
          /**
           *  The Project ID for the INFURA connection.
           */
          __publicField(this, "projectId");
          /**
           *  The Project Secret.
           *
           *  If null, no authenticated requests are made. This should not
           *  be used outside of private contexts.
           */
          __publicField(this, "projectSecret");
          defineProperties(this, {
            projectId: provider.projectId,
            projectSecret: provider.projectSecret
          });
        }
        isCommunityResource() {
          return this.projectId === defaultProjectId;
        }
      };
      InfuraProvider = class _InfuraProvider extends JsonRpcProvider {
        /**
         *  Creates a new **InfuraProvider**.
         */
        constructor(_network3, projectId, projectSecret) {
          if (_network3 == null) {
            _network3 = "mainnet";
          }
          const network = Network.from(_network3);
          if (projectId == null) {
            projectId = defaultProjectId;
          }
          if (projectSecret == null) {
            projectSecret = null;
          }
          const request = _InfuraProvider.getRequest(network, projectId, projectSecret);
          super(request, network, { staticNetwork: network });
          /**
           *  The Project ID for the INFURA connection.
           */
          __publicField(this, "projectId");
          /**
           *  The Project Secret.
           *
           *  If null, no authenticated requests are made. This should not
           *  be used outside of private contexts.
           */
          __publicField(this, "projectSecret");
          defineProperties(this, { projectId, projectSecret });
        }
        _getProvider(chainId) {
          try {
            return new _InfuraProvider(chainId, this.projectId, this.projectSecret);
          } catch (error) {
          }
          return super._getProvider(chainId);
        }
        isCommunityResource() {
          return this.projectId === defaultProjectId;
        }
        /**
         *  Creates a new **InfuraWebSocketProvider**.
         */
        static getWebSocketProvider(network, projectId) {
          return new InfuraWebSocketProvider(network, projectId);
        }
        /**
         *  Returns a prepared request for connecting to %%network%%
         *  with %%projectId%% and %%projectSecret%%.
         */
        static getRequest(network, projectId, projectSecret) {
          if (projectId == null) {
            projectId = defaultProjectId;
          }
          if (projectSecret == null) {
            projectSecret = null;
          }
          const request = new FetchRequest(`https://${getHost4(network.name)}/v3/${projectId}`);
          request.allowGzip = true;
          if (projectSecret) {
            request.setCredentials("", projectSecret);
          }
          if (projectId === defaultProjectId) {
            request.retryFunc = async (request2, response, attempt) => {
              showThrottleMessage("InfuraProvider");
              return true;
            };
          }
          return request;
        }
      };
    }
  });

  // node_modules/ethers/lib.esm/providers/provider-quicknode.js
  function getHost5(name) {
    switch (name) {
      case "mainnet":
        return "ethers.quiknode.pro";
      case "goerli":
        return "ethers.ethereum-goerli.quiknode.pro";
      case "sepolia":
        return "ethers.ethereum-sepolia.quiknode.pro";
      case "holesky":
        return "ethers.ethereum-holesky.quiknode.pro";
      case "arbitrum":
        return "ethers.arbitrum-mainnet.quiknode.pro";
      case "arbitrum-goerli":
        return "ethers.arbitrum-goerli.quiknode.pro";
      case "arbitrum-sepolia":
        return "ethers.arbitrum-sepolia.quiknode.pro";
      case "base":
        return "ethers.base-mainnet.quiknode.pro";
      case "base-goerli":
        return "ethers.base-goerli.quiknode.pro";
      case "base-spolia":
        return "ethers.base-sepolia.quiknode.pro";
      case "bnb":
        return "ethers.bsc.quiknode.pro";
      case "bnbt":
        return "ethers.bsc-testnet.quiknode.pro";
      case "matic":
        return "ethers.matic.quiknode.pro";
      case "matic-mumbai":
        return "ethers.matic-testnet.quiknode.pro";
      case "optimism":
        return "ethers.optimism.quiknode.pro";
      case "optimism-goerli":
        return "ethers.optimism-goerli.quiknode.pro";
      case "optimism-sepolia":
        return "ethers.optimism-sepolia.quiknode.pro";
      case "xdai":
        return "ethers.xdai.quiknode.pro";
    }
    assertArgument(false, "unsupported network", "network", name);
  }
  var defaultToken, QuickNodeProvider;
  var init_provider_quicknode = __esm({
    "node_modules/ethers/lib.esm/providers/provider-quicknode.js"() {
      init_utils();
      init_community();
      init_network();
      init_provider_jsonrpc();
      defaultToken = "919b412a057b5e9c9b6dce193c5a60242d6efadb";
      QuickNodeProvider = class _QuickNodeProvider extends JsonRpcProvider {
        /**
         *  Creates a new **QuickNodeProvider**.
         */
        constructor(_network3, token) {
          if (_network3 == null) {
            _network3 = "mainnet";
          }
          const network = Network.from(_network3);
          if (token == null) {
            token = defaultToken;
          }
          const request = _QuickNodeProvider.getRequest(network, token);
          super(request, network, { staticNetwork: network });
          /**
           *  The API token.
           */
          __publicField(this, "token");
          defineProperties(this, { token });
        }
        _getProvider(chainId) {
          try {
            return new _QuickNodeProvider(chainId, this.token);
          } catch (error) {
          }
          return super._getProvider(chainId);
        }
        isCommunityResource() {
          return this.token === defaultToken;
        }
        /**
         *  Returns a new request prepared for %%network%% and the
         *  %%token%%.
         */
        static getRequest(network, token) {
          if (token == null) {
            token = defaultToken;
          }
          const request = new FetchRequest(`https://${getHost5(network.name)}/${token}`);
          request.allowGzip = true;
          if (token === defaultToken) {
            request.retryFunc = async (request2, response, attempt) => {
              showThrottleMessage("QuickNodeProvider");
              return true;
            };
          }
          return request;
        }
      };
    }
  });

  // node_modules/ethers/lib.esm/providers/provider-fallback.js
  function shuffle(array) {
    for (let i = array.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      const tmp = array[i];
      array[i] = array[j];
      array[j] = tmp;
    }
  }
  function stall2(duration) {
    return new Promise((resolve) => {
      setTimeout(resolve, duration);
    });
  }
  function getTime3() {
    return (/* @__PURE__ */ new Date()).getTime();
  }
  function stringify2(value) {
    return JSON.stringify(value, (key, value2) => {
      if (typeof value2 === "bigint") {
        return { type: "bigint", value: value2.toString() };
      }
      return value2;
    });
  }
  async function waitForSync(config, blockNumber) {
    while (config.blockNumber < 0 || config.blockNumber < blockNumber) {
      if (!config._updateNumber) {
        config._updateNumber = (async () => {
          try {
            const blockNumber2 = await config.provider.getBlockNumber();
            if (blockNumber2 > config.blockNumber) {
              config.blockNumber = blockNumber2;
            }
          } catch (error) {
            config.blockNumber = -2;
            config._lastFatalError = error;
            config._lastFatalErrorTimestamp = getTime3();
          }
          config._updateNumber = null;
        })();
      }
      await config._updateNumber;
      config.outOfSync++;
      if (config._lastFatalError) {
        break;
      }
    }
  }
  function _normalize(value) {
    if (value == null) {
      return "null";
    }
    if (Array.isArray(value)) {
      return "[" + value.map(_normalize).join(",") + "]";
    }
    if (typeof value === "object" && typeof value.toJSON === "function") {
      return _normalize(value.toJSON());
    }
    switch (typeof value) {
      case "boolean":
      case "symbol":
        return value.toString();
      case "bigint":
      case "number":
        return BigInt(value).toString();
      case "string":
        return JSON.stringify(value);
      case "object": {
        const keys = Object.keys(value);
        keys.sort();
        return "{" + keys.map((k) => `${JSON.stringify(k)}:${_normalize(value[k])}`).join(",") + "}";
      }
    }
    console.log("Could not serialize", value);
    throw new Error("Hmm...");
  }
  function normalizeResult(method, value) {
    if ("error" in value) {
      const error = value.error;
      let tag;
      if (isError(error, "CALL_EXCEPTION")) {
        tag = _normalize(Object.assign({}, error, {
          shortMessage: void 0,
          reason: void 0,
          info: void 0
        }));
      } else {
        tag = _normalize(error);
      }
      return { tag, value: error };
    }
    const result = value.result;
    return { tag: _normalize(result), value: result };
  }
  function checkQuorum(quorum, results) {
    const tally = /* @__PURE__ */ new Map();
    for (const { value, tag, weight } of results) {
      const t = tally.get(tag) || { value, weight: 0 };
      t.weight += weight;
      tally.set(tag, t);
    }
    let best = null;
    for (const r of tally.values()) {
      if (r.weight >= quorum && (!best || r.weight > best.weight)) {
        best = r;
      }
    }
    if (best) {
      return best.value;
    }
    return void 0;
  }
  function getMedian(quorum, results) {
    let resultWeight = 0;
    const errorMap = /* @__PURE__ */ new Map();
    let bestError = null;
    const values = [];
    for (const { value, tag, weight } of results) {
      if (value instanceof Error) {
        const e = errorMap.get(tag) || { value, weight: 0 };
        e.weight += weight;
        errorMap.set(tag, e);
        if (bestError == null || e.weight > bestError.weight) {
          bestError = e;
        }
      } else {
        values.push(BigInt(value));
        resultWeight += weight;
      }
    }
    if (resultWeight < quorum) {
      if (bestError && bestError.weight >= quorum) {
        return bestError.value;
      }
      return void 0;
    }
    values.sort((a, b2) => a < b2 ? -1 : b2 > a ? 1 : 0);
    const mid = Math.floor(values.length / 2);
    if (values.length % 2) {
      return values[mid];
    }
    return (values[mid - 1] + values[mid] + BN_16) / BN_24;
  }
  function getAnyResult(quorum, results) {
    const result = checkQuorum(quorum, results);
    if (result !== void 0) {
      return result;
    }
    for (const r of results) {
      if (r.value) {
        return r.value;
      }
    }
    return void 0;
  }
  function getFuzzyMode(quorum, results) {
    if (quorum === 1) {
      return getNumber(getMedian(quorum, results), "%internal");
    }
    const tally = /* @__PURE__ */ new Map();
    const add2 = (result, weight) => {
      const t = tally.get(result) || { result, weight: 0 };
      t.weight += weight;
      tally.set(result, t);
    };
    for (const { weight, value } of results) {
      const r = getNumber(value);
      add2(r - 1, weight);
      add2(r, weight);
      add2(r + 1, weight);
    }
    let bestWeight = 0;
    let bestResult = void 0;
    for (const { weight, result } of tally.values()) {
      if (weight >= quorum && (weight > bestWeight || bestResult != null && weight === bestWeight && result > bestResult)) {
        bestWeight = weight;
        bestResult = result;
      }
    }
    return bestResult;
  }
  var BN_16, BN_24, defaultConfig, defaultState, _configs, _height, _initialSyncPromise, _FallbackProvider_instances, getNextConfig_fn, addRunner_fn, initialSync_fn, checkQuorum_fn, waitForQuorum_fn, FallbackProvider;
  var init_provider_fallback = __esm({
    "node_modules/ethers/lib.esm/providers/provider-fallback.js"() {
      init_utils();
      init_abstract_provider();
      init_network();
      BN_16 = BigInt("1");
      BN_24 = BigInt("2");
      defaultConfig = { stallTimeout: 400, priority: 1, weight: 1 };
      defaultState = {
        blockNumber: -2,
        requests: 0,
        lateResponses: 0,
        errorResponses: 0,
        outOfSync: -1,
        unsupportedEvents: 0,
        rollingDuration: 0,
        score: 0,
        _network: null,
        _updateNumber: null,
        _totalTime: 0,
        _lastFatalError: null,
        _lastFatalErrorTimestamp: 0
      };
      FallbackProvider = class extends AbstractProvider {
        /**
         *  Creates a new **FallbackProvider** with %%providers%% connected to
         *  %%network%%.
         *
         *  If a [[Provider]] is included in %%providers%%, defaults are used
         *  for the configuration.
         */
        constructor(providers, network, options) {
          super(network, options);
          __privateAdd(this, _FallbackProvider_instances);
          /**
           *  The number of backends that must agree on a value before it is
           *  accpeted.
           */
          __publicField(this, "quorum");
          /**
           *  @_ignore:
           */
          __publicField(this, "eventQuorum");
          /**
           *  @_ignore:
           */
          __publicField(this, "eventWorkers");
          __privateAdd(this, _configs);
          __privateAdd(this, _height);
          __privateAdd(this, _initialSyncPromise);
          __privateSet(this, _configs, providers.map((p) => {
            if (p instanceof AbstractProvider) {
              return Object.assign({ provider: p }, defaultConfig, defaultState);
            } else {
              return Object.assign({}, defaultConfig, p, defaultState);
            }
          }));
          __privateSet(this, _height, -2);
          __privateSet(this, _initialSyncPromise, null);
          if (options && options.quorum != null) {
            this.quorum = options.quorum;
          } else {
            this.quorum = Math.ceil(__privateGet(this, _configs).reduce((accum, config) => {
              accum += config.weight;
              return accum;
            }, 0) / 2);
          }
          this.eventQuorum = 1;
          this.eventWorkers = 1;
          assertArgument(this.quorum <= __privateGet(this, _configs).reduce((a, c) => a + c.weight, 0), "quorum exceed provider weight", "quorum", this.quorum);
        }
        get providerConfigs() {
          return __privateGet(this, _configs).map((c) => {
            const result = Object.assign({}, c);
            for (const key in result) {
              if (key[0] === "_") {
                delete result[key];
              }
            }
            return result;
          });
        }
        async _detectNetwork() {
          return Network.from(getBigInt(await this._perform({ method: "chainId" })));
        }
        // @TODO: Add support to select providers to be the event subscriber
        //_getSubscriber(sub: Subscription): Subscriber {
        //    throw new Error("@TODO");
        //}
        /**
         *  Transforms a %%req%% into the correct method call on %%provider%%.
         */
        async _translatePerform(provider, req) {
          switch (req.method) {
            case "broadcastTransaction":
              return await provider.broadcastTransaction(req.signedTransaction);
            case "call":
              return await provider.call(Object.assign({}, req.transaction, { blockTag: req.blockTag }));
            case "chainId":
              return (await provider.getNetwork()).chainId;
            case "estimateGas":
              return await provider.estimateGas(req.transaction);
            case "getBalance":
              return await provider.getBalance(req.address, req.blockTag);
            case "getBlock": {
              const block = "blockHash" in req ? req.blockHash : req.blockTag;
              return await provider.getBlock(block, req.includeTransactions);
            }
            case "getBlockNumber":
              return await provider.getBlockNumber();
            case "getCode":
              return await provider.getCode(req.address, req.blockTag);
            case "getGasPrice":
              return (await provider.getFeeData()).gasPrice;
            case "getPriorityFee":
              return (await provider.getFeeData()).maxPriorityFeePerGas;
            case "getLogs":
              return await provider.getLogs(req.filter);
            case "getStorage":
              return await provider.getStorage(req.address, req.position, req.blockTag);
            case "getTransaction":
              return await provider.getTransaction(req.hash);
            case "getTransactionCount":
              return await provider.getTransactionCount(req.address, req.blockTag);
            case "getTransactionReceipt":
              return await provider.getTransactionReceipt(req.hash);
            case "getTransactionResult":
              return await provider.getTransactionResult(req.hash);
          }
        }
        async _perform(req) {
          if (req.method === "broadcastTransaction") {
            const results = __privateGet(this, _configs).map((c) => null);
            const broadcasts = __privateGet(this, _configs).map(async ({ provider, weight }, index2) => {
              try {
                const result3 = await provider._perform(req);
                results[index2] = Object.assign(normalizeResult(req.method, { result: result3 }), { weight });
              } catch (error) {
                results[index2] = Object.assign(normalizeResult(req.method, { error }), { weight });
              }
            });
            while (true) {
              const done = results.filter((r) => r != null);
              for (const { value } of done) {
                if (!(value instanceof Error)) {
                  return value;
                }
              }
              const result3 = checkQuorum(this.quorum, results.filter((r) => r != null));
              if (isError(result3, "INSUFFICIENT_FUNDS")) {
                throw result3;
              }
              const waiting = broadcasts.filter((b2, i) => results[i] == null);
              if (waiting.length === 0) {
                break;
              }
              await Promise.race(waiting);
            }
            const result2 = getAnyResult(this.quorum, results);
            assert(result2 !== void 0, "problem multi-broadcasting", "SERVER_ERROR", {
              request: "%sub-requests",
              info: { request: req, results: results.map(stringify2) }
            });
            if (result2 instanceof Error) {
              throw result2;
            }
            return result2;
          }
          await __privateMethod(this, _FallbackProvider_instances, initialSync_fn).call(this);
          const running = /* @__PURE__ */ new Set();
          let inflightQuorum = 0;
          while (true) {
            const runner = __privateMethod(this, _FallbackProvider_instances, addRunner_fn).call(this, running, req);
            if (runner == null) {
              break;
            }
            inflightQuorum += runner.config.weight;
            if (inflightQuorum >= this.quorum) {
              break;
            }
          }
          const result = await __privateMethod(this, _FallbackProvider_instances, waitForQuorum_fn).call(this, running, req);
          for (const runner of running) {
            if (runner.perform && runner.result == null) {
              runner.config.lateResponses++;
            }
          }
          return result;
        }
        async destroy() {
          for (const { provider } of __privateGet(this, _configs)) {
            provider.destroy();
          }
          super.destroy();
        }
      };
      _configs = new WeakMap();
      _height = new WeakMap();
      _initialSyncPromise = new WeakMap();
      _FallbackProvider_instances = new WeakSet();
      // Grab the next (random) config that is not already part of
      // the running set
      getNextConfig_fn = function(running) {
        const configs = Array.from(running).map((r) => r.config);
        const allConfigs = __privateGet(this, _configs).slice();
        shuffle(allConfigs);
        allConfigs.sort((a, b2) => a.priority - b2.priority);
        for (const config of allConfigs) {
          if (config._lastFatalError) {
            continue;
          }
          if (configs.indexOf(config) === -1) {
            return config;
          }
        }
        return null;
      };
      // Adds a new runner (if available) to running.
      addRunner_fn = function(running, req) {
        const config = __privateMethod(this, _FallbackProvider_instances, getNextConfig_fn).call(this, running);
        if (config == null) {
          return null;
        }
        const runner = {
          config,
          result: null,
          didBump: false,
          perform: null,
          staller: null
        };
        const now = getTime3();
        runner.perform = (async () => {
          try {
            config.requests++;
            const result = await this._translatePerform(config.provider, req);
            runner.result = { result };
          } catch (error) {
            config.errorResponses++;
            runner.result = { error };
          }
          const dt = getTime3() - now;
          config._totalTime += dt;
          config.rollingDuration = 0.95 * config.rollingDuration + 0.05 * dt;
          runner.perform = null;
        })();
        runner.staller = (async () => {
          await stall2(config.stallTimeout);
          runner.staller = null;
        })();
        running.add(runner);
        return runner;
      };
      initialSync_fn = async function() {
        let initialSync = __privateGet(this, _initialSyncPromise);
        if (!initialSync) {
          const promises = [];
          __privateGet(this, _configs).forEach((config) => {
            promises.push((async () => {
              await waitForSync(config, 0);
              if (!config._lastFatalError) {
                config._network = await config.provider.getNetwork();
              }
            })());
          });
          __privateSet(this, _initialSyncPromise, initialSync = (async () => {
            await Promise.all(promises);
            let chainId = null;
            for (const config of __privateGet(this, _configs)) {
              if (config._lastFatalError) {
                continue;
              }
              const network = config._network;
              if (chainId == null) {
                chainId = network.chainId;
              } else if (network.chainId !== chainId) {
                assert(false, "cannot mix providers on different networks", "UNSUPPORTED_OPERATION", {
                  operation: "new FallbackProvider"
                });
              }
            }
          })());
        }
        await initialSync;
      };
      checkQuorum_fn = async function(running, req) {
        const results = [];
        for (const runner of running) {
          if (runner.result != null) {
            const { tag, value } = normalizeResult(req.method, runner.result);
            results.push({ tag, value, weight: runner.config.weight });
          }
        }
        if (results.reduce((a, r) => a + r.weight, 0) < this.quorum) {
          return void 0;
        }
        switch (req.method) {
          case "getBlockNumber": {
            if (__privateGet(this, _height) === -2) {
              __privateSet(this, _height, Math.ceil(getNumber(getMedian(this.quorum, __privateGet(this, _configs).filter((c) => !c._lastFatalError).map((c) => ({
                value: c.blockNumber,
                tag: getNumber(c.blockNumber).toString(),
                weight: c.weight
              }))))));
            }
            const mode = getFuzzyMode(this.quorum, results);
            if (mode === void 0) {
              return void 0;
            }
            if (mode > __privateGet(this, _height)) {
              __privateSet(this, _height, mode);
            }
            return __privateGet(this, _height);
          }
          case "getGasPrice":
          case "getPriorityFee":
          case "estimateGas":
            return getMedian(this.quorum, results);
          case "getBlock":
            if ("blockTag" in req && req.blockTag === "pending") {
              return getAnyResult(this.quorum, results);
            }
            return checkQuorum(this.quorum, results);
          case "call":
          case "chainId":
          case "getBalance":
          case "getTransactionCount":
          case "getCode":
          case "getStorage":
          case "getTransaction":
          case "getTransactionReceipt":
          case "getLogs":
            return checkQuorum(this.quorum, results);
          case "broadcastTransaction":
            return getAnyResult(this.quorum, results);
        }
        assert(false, "unsupported method", "UNSUPPORTED_OPERATION", {
          operation: `_perform(${stringify2(req.method)})`
        });
      };
      waitForQuorum_fn = async function(running, req) {
        if (running.size === 0) {
          throw new Error("no runners?!");
        }
        const interesting = [];
        let newRunners = 0;
        for (const runner of running) {
          if (runner.perform) {
            interesting.push(runner.perform);
          }
          if (runner.staller) {
            interesting.push(runner.staller);
            continue;
          }
          if (runner.didBump) {
            continue;
          }
          runner.didBump = true;
          newRunners++;
        }
        const value = await __privateMethod(this, _FallbackProvider_instances, checkQuorum_fn).call(this, running, req);
        if (value !== void 0) {
          if (value instanceof Error) {
            throw value;
          }
          return value;
        }
        for (let i = 0; i < newRunners; i++) {
          __privateMethod(this, _FallbackProvider_instances, addRunner_fn).call(this, running, req);
        }
        assert(interesting.length > 0, "quorum not met", "SERVER_ERROR", {
          request: "%sub-requests",
          info: { request: req, results: Array.from(running).map((r) => stringify2(r.result)) }
        });
        await Promise.race(interesting);
        return await __privateMethod(this, _FallbackProvider_instances, waitForQuorum_fn).call(this, running, req);
      };
    }
  });

  // node_modules/ethers/lib.esm/providers/default-provider.js
  function isWebSocketLike(value) {
    return value && typeof value.send === "function" && typeof value.close === "function";
  }
  function getDefaultProvider(network, options) {
    if (options == null) {
      options = {};
    }
    const allowService = (name) => {
      if (options[name] === "-") {
        return false;
      }
      if (typeof options.exclusive === "string") {
        return name === options.exclusive;
      }
      if (Array.isArray(options.exclusive)) {
        return options.exclusive.indexOf(name) !== -1;
      }
      return true;
    };
    if (typeof network === "string" && network.match(/^https?:/)) {
      return new JsonRpcProvider(network);
    }
    if (typeof network === "string" && network.match(/^wss?:/) || isWebSocketLike(network)) {
      return new WebSocketProvider(network);
    }
    let staticNetwork = null;
    try {
      staticNetwork = Network.from(network);
    } catch (error) {
    }
    const providers = [];
    if (allowService("publicPolygon") && staticNetwork) {
      if (staticNetwork.name === "matic") {
        providers.push(new JsonRpcProvider("https://polygon-rpc.com/", staticNetwork, { staticNetwork }));
      } else if (staticNetwork.name === "matic-amoy") {
        providers.push(new JsonRpcProvider("https://rpc-amoy.polygon.technology/", staticNetwork, { staticNetwork }));
      }
    }
    if (allowService("alchemy")) {
      try {
        providers.push(new AlchemyProvider(network, options.alchemy));
      } catch (error) {
      }
    }
    if (allowService("ankr") && options.ankr != null) {
      try {
        providers.push(new AnkrProvider(network, options.ankr));
      } catch (error) {
      }
    }
    if (allowService("chainstack")) {
      try {
        providers.push(new ChainstackProvider(network, options.chainstack));
      } catch (error) {
      }
    }
    if (allowService("cloudflare")) {
      try {
        providers.push(new CloudflareProvider(network));
      } catch (error) {
      }
    }
    if (allowService("etherscan")) {
      try {
        providers.push(new EtherscanProvider(network, options.etherscan));
      } catch (error) {
      }
    }
    if (allowService("infura")) {
      try {
        let projectId = options.infura;
        let projectSecret = void 0;
        if (typeof projectId === "object") {
          projectSecret = projectId.projectSecret;
          projectId = projectId.projectId;
        }
        providers.push(new InfuraProvider(network, projectId, projectSecret));
      } catch (error) {
      }
    }
    if (allowService("quicknode")) {
      try {
        let token = options.quicknode;
        providers.push(new QuickNodeProvider(network, token));
      } catch (error) {
      }
    }
    assert(providers.length, "unsupported default network", "UNSUPPORTED_OPERATION", {
      operation: "getDefaultProvider"
    });
    if (providers.length === 1) {
      return providers[0];
    }
    let quorum = Math.floor(providers.length / 2);
    if (quorum > 2) {
      quorum = 2;
    }
    if (staticNetwork && Testnets.indexOf(staticNetwork.name) !== -1) {
      quorum = 1;
    }
    if (options && options.quorum) {
      quorum = options.quorum;
    }
    return new FallbackProvider(providers, void 0, { quorum });
  }
  var Testnets;
  var init_default_provider = __esm({
    "node_modules/ethers/lib.esm/providers/default-provider.js"() {
      init_utils();
      init_provider_ankr();
      init_provider_alchemy();
      init_provider_chainstack();
      init_provider_cloudflare();
      init_provider_etherscan();
      init_provider_infura();
      init_provider_quicknode();
      init_provider_fallback();
      init_provider_jsonrpc();
      init_network();
      init_provider_websocket();
      Testnets = "goerli kovan sepolia classicKotti optimism-goerli arbitrum-goerli matic-mumbai bnbt".split(" ");
    }
  });

  // node_modules/ethers/lib.esm/providers/signer-noncemanager.js
  var _noncePromise, _delta, _NonceManager, NonceManager;
  var init_signer_noncemanager = __esm({
    "node_modules/ethers/lib.esm/providers/signer-noncemanager.js"() {
      init_utils();
      init_abstract_signer();
      _NonceManager = class _NonceManager extends AbstractSigner {
        /**
         *  Creates a new **NonceManager** to manage %%signer%%.
         */
        constructor(signer) {
          super(signer.provider);
          /**
           *  The Signer being managed.
           */
          __publicField(this, "signer");
          __privateAdd(this, _noncePromise);
          __privateAdd(this, _delta);
          defineProperties(this, { signer });
          __privateSet(this, _noncePromise, null);
          __privateSet(this, _delta, 0);
        }
        async getAddress() {
          return this.signer.getAddress();
        }
        connect(provider) {
          return new _NonceManager(this.signer.connect(provider));
        }
        async getNonce(blockTag) {
          if (blockTag === "pending") {
            if (__privateGet(this, _noncePromise) == null) {
              __privateSet(this, _noncePromise, super.getNonce("pending"));
            }
            const delta = __privateGet(this, _delta);
            return await __privateGet(this, _noncePromise) + delta;
          }
          return super.getNonce(blockTag);
        }
        /**
         *  Manually increment the nonce. This may be useful when managng
         *  offline transactions.
         */
        increment() {
          __privateWrapper(this, _delta)._++;
        }
        /**
         *  Resets the nonce, causing the **NonceManager** to reload the current
         *  nonce from the blockchain on the next transaction.
         */
        reset() {
          __privateSet(this, _delta, 0);
          __privateSet(this, _noncePromise, null);
        }
        async sendTransaction(tx) {
          const noncePromise = this.getNonce("pending");
          this.increment();
          tx = await this.signer.populateTransaction(tx);
          tx.nonce = await noncePromise;
          return await this.signer.sendTransaction(tx);
        }
        signTransaction(tx) {
          return this.signer.signTransaction(tx);
        }
        signMessage(message) {
          return this.signer.signMessage(message);
        }
        signTypedData(domain, types, value) {
          return this.signer.signTypedData(domain, types, value);
        }
      };
      _noncePromise = new WeakMap();
      _delta = new WeakMap();
      NonceManager = _NonceManager;
    }
  });

  // node_modules/ethers/lib.esm/providers/provider-browser.js
  var _request2, _providerInfo, _BrowserProvider, BrowserProvider;
  var init_provider_browser = __esm({
    "node_modules/ethers/lib.esm/providers/provider-browser.js"() {
      init_utils();
      init_provider_jsonrpc();
      _BrowserProvider = class _BrowserProvider extends JsonRpcApiPollingProvider {
        /**
         *  Connect to the %%ethereum%% provider, optionally forcing the
         *  %%network%%.
         */
        constructor(ethereum, network, _options4) {
          const options = Object.assign({}, _options4 != null ? _options4 : {}, { batchMaxCount: 1 });
          assertArgument(ethereum && ethereum.request, "invalid EIP-1193 provider", "ethereum", ethereum);
          super(network, options);
          __privateAdd(this, _request2);
          __privateAdd(this, _providerInfo);
          __privateSet(this, _providerInfo, null);
          if (_options4 && _options4.providerInfo) {
            __privateSet(this, _providerInfo, _options4.providerInfo);
          }
          __privateSet(this, _request2, async (method, params) => {
            const payload = { method, params };
            this.emit("debug", { action: "sendEip1193Request", payload });
            try {
              const result = await ethereum.request(payload);
              this.emit("debug", { action: "receiveEip1193Result", result });
              return result;
            } catch (e) {
              const error = new Error(e.message);
              error.code = e.code;
              error.data = e.data;
              error.payload = payload;
              this.emit("debug", { action: "receiveEip1193Error", error });
              throw error;
            }
          });
        }
        get providerInfo() {
          return __privateGet(this, _providerInfo);
        }
        async send(method, params) {
          await this._start();
          return await super.send(method, params);
        }
        async _send(payload) {
          assertArgument(!Array.isArray(payload), "EIP-1193 does not support batch request", "payload", payload);
          try {
            const result = await __privateGet(this, _request2).call(this, payload.method, payload.params || []);
            return [{ id: payload.id, result }];
          } catch (e) {
            return [{
              id: payload.id,
              error: { code: e.code, data: e.data, message: e.message }
            }];
          }
        }
        getRpcError(payload, error) {
          error = JSON.parse(JSON.stringify(error));
          switch (error.error.code || -1) {
            case 4001:
              error.error.message = `ethers-user-denied: ${error.error.message}`;
              break;
            case 4200:
              error.error.message = `ethers-unsupported: ${error.error.message}`;
              break;
          }
          return super.getRpcError(payload, error);
        }
        /**
         *  Resolves to ``true`` if the provider manages the %%address%%.
         */
        async hasSigner(address) {
          if (address == null) {
            address = 0;
          }
          const accounts = await this.send("eth_accounts", []);
          if (typeof address === "number") {
            return accounts.length > address;
          }
          address = address.toLowerCase();
          return accounts.filter((a) => a.toLowerCase() === address).length !== 0;
        }
        async getSigner(address) {
          if (address == null) {
            address = 0;
          }
          if (!await this.hasSigner(address)) {
            try {
              await __privateGet(this, _request2).call(this, "eth_requestAccounts", []);
            } catch (error) {
              const payload = error.payload;
              throw this.getRpcError(payload, { id: payload.id, error });
            }
          }
          return await super.getSigner(address);
        }
        /**
         *  Discover and connect to a Provider in the Browser using the
         *  [[link-eip-6963]] discovery mechanism. If no providers are
         *  present, ``null`` is resolved.
         */
        static async discover(options) {
          if (options == null) {
            options = {};
          }
          if (options.provider) {
            return new _BrowserProvider(options.provider);
          }
          const context = options.window ? options.window : typeof window !== "undefined" ? window : null;
          if (context == null) {
            return null;
          }
          const anyProvider = options.anyProvider;
          if (anyProvider && context.ethereum) {
            return new _BrowserProvider(context.ethereum);
          }
          if (!("addEventListener" in context && "dispatchEvent" in context && "removeEventListener" in context)) {
            return null;
          }
          const timeout = options.timeout ? options.timeout : 300;
          if (timeout === 0) {
            return null;
          }
          return await new Promise((resolve, reject) => {
            let found = [];
            const addProvider = (event) => {
              found.push(event.detail);
              if (anyProvider) {
                finalize();
              }
            };
            const finalize = () => {
              clearTimeout(timer);
              if (found.length) {
                if (options && options.filter) {
                  const filtered = options.filter(found.map((i) => Object.assign({}, i.info)));
                  if (filtered == null) {
                    resolve(null);
                  } else if (filtered instanceof _BrowserProvider) {
                    resolve(filtered);
                  } else {
                    let match = null;
                    if (filtered.uuid) {
                      const matches = found.filter((f2) => filtered.uuid === f2.info.uuid);
                      match = matches[0];
                    }
                    if (match) {
                      const { provider, info } = match;
                      resolve(new _BrowserProvider(provider, void 0, {
                        providerInfo: info
                      }));
                    } else {
                      reject(makeError("filter returned unknown info", "UNSUPPORTED_OPERATION", {
                        value: filtered
                      }));
                    }
                  }
                } else {
                  const { provider, info } = found[0];
                  resolve(new _BrowserProvider(provider, void 0, {
                    providerInfo: info
                  }));
                }
              } else {
                resolve(null);
              }
              context.removeEventListener("eip6963:announceProvider", addProvider);
            };
            const timer = setTimeout(() => {
              finalize();
            }, timeout);
            context.addEventListener("eip6963:announceProvider", addProvider);
            context.dispatchEvent(new Event("eip6963:requestProvider"));
          });
        }
      };
      _request2 = new WeakMap();
      _providerInfo = new WeakMap();
      BrowserProvider = _BrowserProvider;
    }
  });

  // node_modules/ethers/lib.esm/providers/provider-blockscout.js
  function getUrl(name) {
    switch (name) {
      case "mainnet":
        return "https://eth.blockscout.com/api/eth-rpc";
      case "sepolia":
        return "https://eth-sepolia.blockscout.com/api/eth-rpc";
      case "holesky":
        return "https://eth-holesky.blockscout.com/api/eth-rpc";
      case "classic":
        return "https://etc.blockscout.com/api/eth-rpc";
      case "arbitrum":
        return "https://arbitrum.blockscout.com/api/eth-rpc";
      case "base":
        return "https://base.blockscout.com/api/eth-rpc";
      case "base-sepolia":
        return "https://base-sepolia.blockscout.com/api/eth-rpc";
      case "matic":
        return "https://polygon.blockscout.com/api/eth-rpc";
      case "optimism":
        return "https://optimism.blockscout.com/api/eth-rpc";
      case "optimism-sepolia":
        return "https://optimism-sepolia.blockscout.com/api/eth-rpc";
      case "xdai":
        return "https://gnosis.blockscout.com/api/eth-rpc";
    }
    assertArgument(false, "unsupported network", "network", name);
  }
  var BlockscoutProvider;
  var init_provider_blockscout = __esm({
    "node_modules/ethers/lib.esm/providers/provider-blockscout.js"() {
      init_utils();
      init_network();
      init_provider_jsonrpc();
      BlockscoutProvider = class _BlockscoutProvider extends JsonRpcProvider {
        /**
         *  Creates a new **BlockscoutProvider**.
         */
        constructor(_network3, apiKey) {
          if (_network3 == null) {
            _network3 = "mainnet";
          }
          const network = Network.from(_network3);
          if (apiKey == null) {
            apiKey = null;
          }
          const request = _BlockscoutProvider.getRequest(network);
          super(request, network, { staticNetwork: network });
          /**
           *  The API key.
           */
          __publicField(this, "apiKey");
          defineProperties(this, { apiKey });
        }
        _getProvider(chainId) {
          try {
            return new _BlockscoutProvider(chainId, this.apiKey);
          } catch (error) {
          }
          return super._getProvider(chainId);
        }
        isCommunityResource() {
          return this.apiKey === null;
        }
        getRpcRequest(req) {
          const resp = super.getRpcRequest(req);
          if (resp && resp.method === "eth_estimateGas" && resp.args.length == 1) {
            resp.args = resp.args.slice();
            resp.args.push("latest");
          }
          return resp;
        }
        getRpcError(payload, _error2) {
          const error = _error2 ? _error2.error : null;
          if (error && error.code === -32015 && !isHexString(error.data || "", true)) {
            const panicCodes = {
              "assert(false)": "01",
              "arithmetic underflow or overflow": "11",
              "division or modulo by zero": "12",
              "out-of-bounds array access; popping on an empty array": "31",
              "out-of-bounds access of an array or bytesN": "32"
            };
            let panicCode = "";
            if (error.message === "VM execution error.") {
              panicCode = panicCodes[error.data] || "";
            } else if (panicCodes[error.message || ""]) {
              panicCode = panicCodes[error.message || ""];
            }
            if (panicCode) {
              error.message += ` (reverted: ${error.data})`;
              error.data = "0x4e487b7100000000000000000000000000000000000000000000000000000000000000" + panicCode;
            }
          } else if (error && error.code === -32e3) {
            if (error.message === "wrong transaction nonce") {
              error.message += " (nonce too low)";
            }
          }
          return super.getRpcError(payload, _error2);
        }
        /**
         *  Returns a prepared request for connecting to %%network%%
         *  with %%apiKey%%.
         */
        static getRequest(network) {
          const request = new FetchRequest(getUrl(network.name));
          request.allowGzip = true;
          return request;
        }
      };
    }
  });

  // node_modules/ethers/lib.esm/providers/provider-pocket.js
  function getHost6(name) {
    switch (name) {
      case "mainnet":
        return "eth-mainnet.gateway.pokt.network";
      case "goerli":
        return "eth-goerli.gateway.pokt.network";
      case "matic":
        return "poly-mainnet.gateway.pokt.network";
      case "matic-mumbai":
        return "polygon-mumbai-rpc.gateway.pokt.network";
    }
    assertArgument(false, "unsupported network", "network", name);
  }
  var defaultApplicationId, PocketProvider;
  var init_provider_pocket = __esm({
    "node_modules/ethers/lib.esm/providers/provider-pocket.js"() {
      init_utils();
      init_community();
      init_network();
      init_provider_jsonrpc();
      defaultApplicationId = "62e1ad51b37b8e00394bda3b";
      PocketProvider = class _PocketProvider extends JsonRpcProvider {
        /**
         *  Create a new **PocketProvider**.
         *
         *  By default connecting to ``mainnet`` with a highly throttled
         *  API key.
         */
        constructor(_network3, applicationId, applicationSecret) {
          if (_network3 == null) {
            _network3 = "mainnet";
          }
          const network = Network.from(_network3);
          if (applicationId == null) {
            applicationId = defaultApplicationId;
          }
          if (applicationSecret == null) {
            applicationSecret = null;
          }
          const options = { staticNetwork: network };
          const request = _PocketProvider.getRequest(network, applicationId, applicationSecret);
          super(request, network, options);
          /**
           *  The Application ID for the Pocket connection.
           */
          __publicField(this, "applicationId");
          /**
           *  The Application Secret for making authenticated requests
           *  to the Pocket connection.
           */
          __publicField(this, "applicationSecret");
          defineProperties(this, { applicationId, applicationSecret });
        }
        _getProvider(chainId) {
          try {
            return new _PocketProvider(chainId, this.applicationId, this.applicationSecret);
          } catch (error) {
          }
          return super._getProvider(chainId);
        }
        /**
         *  Returns a prepared request for connecting to %%network%% with
         *  %%applicationId%%.
         */
        static getRequest(network, applicationId, applicationSecret) {
          if (applicationId == null) {
            applicationId = defaultApplicationId;
          }
          const request = new FetchRequest(`https://${getHost6(network.name)}/v1/lb/${applicationId}`);
          request.allowGzip = true;
          if (applicationSecret) {
            request.setCredentials("", applicationSecret);
          }
          if (applicationId === defaultApplicationId) {
            request.retryFunc = async (request2, response, attempt) => {
              showThrottleMessage("PocketProvider");
              return true;
            };
          }
          return request;
        }
        isCommunityResource() {
          return this.applicationId === defaultApplicationId;
        }
      };
    }
  });

  // node_modules/ethers/lib.esm/providers/provider-ipcsocket-browser.js
  var IpcSocketProvider;
  var init_provider_ipcsocket_browser = __esm({
    "node_modules/ethers/lib.esm/providers/provider-ipcsocket-browser.js"() {
      IpcSocketProvider = void 0;
    }
  });

  // node_modules/ethers/lib.esm/providers/index.js
  var init_providers = __esm({
    "node_modules/ethers/lib.esm/providers/index.js"() {
      init_abstract_provider();
      init_abstract_signer();
      init_community();
      init_default_provider();
      init_ens_resolver();
      init_network();
      init_signer_noncemanager();
      init_plugins_network();
      init_provider();
      init_provider_fallback();
      init_provider_jsonrpc();
      init_provider_browser();
      init_provider_alchemy();
      init_provider_blockscout();
      init_provider_ankr();
      init_provider_cloudflare();
      init_provider_chainstack();
      init_provider_etherscan();
      init_provider_infura();
      init_provider_pocket();
      init_provider_quicknode();
      init_provider_ipcsocket_browser();
      init_provider_socket();
      init_provider_websocket();
      init_provider_socket();
    }
  });

  // node_modules/ethers/lib.esm/wallet/base-wallet.js
  var _signingKey, _BaseWallet, BaseWallet;
  var init_base_wallet = __esm({
    "node_modules/ethers/lib.esm/wallet/base-wallet.js"() {
      init_address2();
      init_hash();
      init_providers();
      init_transaction2();
      init_utils();
      _BaseWallet = class _BaseWallet extends AbstractSigner {
        /**
         *  Creates a new BaseWallet for %%privateKey%%, optionally
         *  connected to %%provider%%.
         *
         *  If %%provider%% is not specified, only offline methods can
         *  be used.
         */
        constructor(privateKey, provider) {
          super(provider);
          /**
           *  The wallet address.
           */
          __publicField(this, "address");
          __privateAdd(this, _signingKey);
          assertArgument(privateKey && typeof privateKey.sign === "function", "invalid private key", "privateKey", "[ REDACTED ]");
          __privateSet(this, _signingKey, privateKey);
          const address = computeAddress(this.signingKey.publicKey);
          defineProperties(this, { address });
        }
        // Store private values behind getters to reduce visibility
        // in console.log
        /**
         *  The [[SigningKey]] used for signing payloads.
         */
        get signingKey() {
          return __privateGet(this, _signingKey);
        }
        /**
         *  The private key for this wallet.
         */
        get privateKey() {
          return this.signingKey.privateKey;
        }
        async getAddress() {
          return this.address;
        }
        connect(provider) {
          return new _BaseWallet(__privateGet(this, _signingKey), provider);
        }
        async signTransaction(tx) {
          tx = copyRequest(tx);
          const { to, from: from5 } = await resolveProperties({
            to: tx.to ? resolveAddress(tx.to, this) : void 0,
            from: tx.from ? resolveAddress(tx.from, this) : void 0
          });
          if (to != null) {
            tx.to = to;
          }
          if (from5 != null) {
            tx.from = from5;
          }
          if (tx.from != null) {
            assertArgument(getAddress(tx.from) === this.address, "transaction from address mismatch", "tx.from", tx.from);
            delete tx.from;
          }
          const btx = Transaction.from(tx);
          btx.signature = this.signingKey.sign(btx.unsignedHash);
          return btx.serialized;
        }
        async signMessage(message) {
          return this.signMessageSync(message);
        }
        // @TODO: Add a secialized signTx and signTyped sync that enforces
        // all parameters are known?
        /**
         *  Returns the signature for %%message%% signed with this wallet.
         */
        signMessageSync(message) {
          return this.signingKey.sign(hashMessage(message)).serialized;
        }
        /**
         *  Returns the Authorization for %%auth%%.
         */
        authorizeSync(auth) {
          assertArgument(typeof auth.address === "string", "invalid address for authorizeSync", "auth.address", auth);
          const signature = this.signingKey.sign(hashAuthorization(auth));
          return Object.assign({}, {
            address: getAddress(auth.address),
            nonce: getBigInt(auth.nonce || 0),
            chainId: getBigInt(auth.chainId || 0)
          }, { signature });
        }
        /**
         *  Resolves to the Authorization for %%auth%%.
         */
        async authorize(auth) {
          auth = Object.assign({}, auth, {
            address: await resolveAddress(auth.address, this)
          });
          return this.authorizeSync(await this.populateAuthorization(auth));
        }
        async signTypedData(domain, types, value) {
          const populated = await TypedDataEncoder.resolveNames(domain, types, value, async (name) => {
            assert(this.provider != null, "cannot resolve ENS names without a provider", "UNSUPPORTED_OPERATION", {
              operation: "resolveName",
              info: { name }
            });
            const address = await this.provider.resolveName(name);
            assert(address != null, "unconfigured ENS name", "UNCONFIGURED_NAME", {
              value: name
            });
            return address;
          });
          return this.signingKey.sign(TypedDataEncoder.hash(populated.domain, types, populated.value)).serialized;
        }
      };
      _signingKey = new WeakMap();
      BaseWallet = _BaseWallet;
    }
  });

  // node_modules/ethers/lib.esm/wordlists/decode-owl.js
  function unfold(words2, sep) {
    let initial = 97;
    return words2.reduce((accum, word) => {
      if (word === sep) {
        initial++;
      } else if (word.match(Word)) {
        accum.push(String.fromCharCode(initial) + word);
      } else {
        initial = 97;
        accum.push(word);
      }
      return accum;
    }, []);
  }
  function decode(data, subs) {
    for (let i = subsChrs.length - 1; i >= 0; i--) {
      data = data.split(subsChrs[i]).join(subs.substring(2 * i, 2 * i + 2));
    }
    const clumps = [];
    const leftover = data.replace(/(:|([0-9])|([A-Z][a-z]*))/g, (all, item, semi, word) => {
      if (semi) {
        for (let i = parseInt(semi); i >= 0; i--) {
          clumps.push(";");
        }
      } else {
        clumps.push(item.toLowerCase());
      }
      return "";
    });
    if (leftover) {
      throw new Error(`leftovers: ${JSON.stringify(leftover)}`);
    }
    return unfold(unfold(clumps, ";"), ":");
  }
  function decodeOwl(data) {
    assertArgument(data[0] === "0", "unsupported auwl data", "data", data);
    return decode(data.substring(1 + 2 * subsChrs.length), data.substring(1, 1 + 2 * subsChrs.length));
  }
  var subsChrs, Word;
  var init_decode_owl = __esm({
    "node_modules/ethers/lib.esm/wordlists/decode-owl.js"() {
      init_utils();
      subsChrs = " !#$%&'()*+,-./<=>?@[]^_`{|}~";
      Word = /^[a-z]*$/i;
    }
  });

  // node_modules/ethers/lib.esm/wordlists/wordlist.js
  var Wordlist;
  var init_wordlist = __esm({
    "node_modules/ethers/lib.esm/wordlists/wordlist.js"() {
      init_utils();
      Wordlist = class {
        /**
         *  Creates a new Wordlist instance.
         *
         *  Sub-classes MUST call this if they provide their own constructor,
         *  passing in the locale string of the language.
         *
         *  Generally there is no need to create instances of a Wordlist,
         *  since each language-specific Wordlist creates an instance and
         *  there is no state kept internally, so they are safe to share.
         */
        constructor(locale) {
          __publicField(this, "locale");
          defineProperties(this, { locale });
        }
        /**
         *  Sub-classes may override this to provide a language-specific
         *  method for spliting %%phrase%% into individual words.
         *
         *  By default, %%phrase%% is split using any sequences of
         *  white-space as defined by regular expressions (i.e. ``/\s+/``).
         */
        split(phrase) {
          return phrase.toLowerCase().split(/\s+/g);
        }
        /**
         *  Sub-classes may override this to provider a language-specific
         *  method for joining %%words%% into a phrase.
         *
         *  By default, %%words%% are joined by a single space.
         */
        join(words2) {
          return words2.join(" ");
        }
      };
    }
  });

  // node_modules/ethers/lib.esm/wordlists/wordlist-owl.js
  var _data4, _checksum, _words, _WordlistOwl_instances, loadWords_fn, WordlistOwl;
  var init_wordlist_owl = __esm({
    "node_modules/ethers/lib.esm/wordlists/wordlist-owl.js"() {
      init_hash();
      init_utils();
      init_decode_owl();
      init_wordlist();
      WordlistOwl = class extends Wordlist {
        /**
         *  Creates a new Wordlist for %%locale%% using the OWL %%data%%
         *  and validated against the %%checksum%%.
         */
        constructor(locale, data, checksum4) {
          super(locale);
          __privateAdd(this, _WordlistOwl_instances);
          __privateAdd(this, _data4);
          __privateAdd(this, _checksum);
          __privateAdd(this, _words);
          __privateSet(this, _data4, data);
          __privateSet(this, _checksum, checksum4);
          __privateSet(this, _words, null);
        }
        /**
         *  The OWL-encoded data.
         */
        get _data() {
          return __privateGet(this, _data4);
        }
        /**
         *  Decode all the words for the wordlist.
         */
        _decodeWords() {
          return decodeOwl(__privateGet(this, _data4));
        }
        getWord(index2) {
          const words2 = __privateMethod(this, _WordlistOwl_instances, loadWords_fn).call(this);
          assertArgument(index2 >= 0 && index2 < words2.length, `invalid word index: ${index2}`, "index", index2);
          return words2[index2];
        }
        getWordIndex(word) {
          return __privateMethod(this, _WordlistOwl_instances, loadWords_fn).call(this).indexOf(word);
        }
      };
      _data4 = new WeakMap();
      _checksum = new WeakMap();
      _words = new WeakMap();
      _WordlistOwl_instances = new WeakSet();
      loadWords_fn = function() {
        if (__privateGet(this, _words) == null) {
          const words2 = this._decodeWords();
          const checksum4 = id(words2.join("\n") + "\n");
          if (checksum4 !== __privateGet(this, _checksum)) {
            throw new Error(`BIP39 Wordlist for ${this.locale} FAILED`);
          }
          __privateSet(this, _words, words2);
        }
        return __privateGet(this, _words);
      };
    }
  });

  // node_modules/ethers/lib.esm/wordlists/lang-en.js
  var words, checksum, wordlist, LangEn;
  var init_lang_en = __esm({
    "node_modules/ethers/lib.esm/wordlists/lang-en.js"() {
      init_wordlist_owl();
      words = "0erleonalorenseinceregesticitStanvetearctssi#ch2Athck&tneLl0And#Il.yLeOutO=S|S%b/ra@SurdU'0Ce[Cid|CountCu'Hie=IdOu,-Qui*Ro[TT]T%T*[Tu$0AptDD-tD*[Ju,M.UltV<)Vi)0Rob-0FairF%dRaid0A(EEntRee0Ead0MRRp%tS!_rmBumCoholErtI&LLeyLowMo,O}PhaReadySoT Ways0A>urAz(gOngOuntU'd0Aly,Ch%Ci|G G!GryIm$K!Noun)Nu$O` Sw T&naTiqueXietyY1ArtOlogyPe?P!Pro=Ril1ChCt-EaEnaGueMMedM%MyOundR<+Re,Ri=RowTTefa@Ti,Tw%k0KPe@SaultSetSi,SumeThma0H!>OmTa{T&dT.udeTra@0Ct]D.Gu,NtTh%ToTumn0Era+OcadoOid0AkeA*AyEsomeFulKw?d0Is:ByChel%C#D+GL<)Lc#y~MbooN<aNn RRelyRga(R*lSeS-SketTt!3A^AnAutyCau'ComeEfF%eG(Ha=H(dLie=LowLtN^Nef./TrayTt Twe&Y#d3Cyc!DKeNdOlogyRdR`Tt _{AdeAmeAnketA,EakE[IndOodO[omOu'UeUrUsh_rdAtDyIlMbNeNusOkO,Rd R(gRrowSsTtomUn)XY_{etA(AndA[A=EadEezeI{Id+IefIghtIngIskOccoliOk&OnzeOomO` OwnUsh2Bb!DdyD+tFf$oIldLbLkL!tNd!Nk Rd&Rg R,SS(e[SyTt Y Zz:Bba+B(B!CtusGeKe~LmM aMpNN$N)lNdyNn#NoeNvasNy#Pab!P.$Pta(RRb#RdRgoRpetRryRtSeShS(o/!Su$TT$ogT^Teg%yTt!UghtU'Ut]Ve3Il(gL yM|NsusNturyRe$Rta(_irAlkAmp]An+AosApt Ar+A'AtEapE{Ee'EfErryE,I{&IefIldIm}yOi)Oo'R#-U{!UnkUrn0G?Nnam#Rc!Tiz&TyVil_imApArifyAwAyE<ErkEv I{I|IffImbIn-IpO{OgO'O`OudOwnUbUmpU, Ut^_^A,C#utDeFfeeIlInL!@L%LumnMb(eMeMf%tM-Mm#Mp<yNc tNdu@NfirmNg*[N}@Nsid NtrolNv()OkOlPp PyR$ReRnR*@/Tt#U^UntryUp!Ur'Us(V Yo>_{Ad!AftAmA}AshAt AwlAzyEamEd.EekEwI{etImeIspIt-OpO[Ou^OwdUci$UelUi'Umb!Un^UshYY,$2BeLtu*PPbo?dRiousRr|Rta(R=Sh]/omTe3C!:DMa+MpN)Ng R(gShUght WnY3AlBa>BrisCadeCemb CideCl(eC%a>C*a'ErF&'F(eFyG*eLayLiv M<dMi'Ni$Nti,NyP?tP&dPos.P`PutyRi=ScribeS tSignSkSpair/royTailTe@VelopVi)Vo>3AgramAlAm#dAryCeE'lEtFf G.$Gn.yLemmaNn NosaurRe@RtSag*eScov Sea'ShSmi[S%d Splay/<)V tVideV%)Zzy5Ct%Cum|G~Lph(Ma(Na>NkeyN%OrSeUb!Ve_ftAg#AmaA,-AwEamE[IftIllInkIpI=OpUmY2CkMbNeR(g/T^Ty1Arf1Nam-:G G!RlyRnR`Sily/Sy1HoOlogyOnomy0GeItUca>1F%t0G1GhtTh 2BowD E@r-Eg<tEm|Eph<tEvat%I>Se0B?kBodyBra)Er+Ot]PloyPow Pty0Ab!A@DD![D%'EmyErgyF%)Ga+G(eH<)JoyLi,OughR-hRollSu*T Ti*TryVelope1Isode0U$Uip0AA'OdeOs]R%Upt0CapeSayS&)Ta>0Ern$H-s1Id&)IlOkeOl=1A@Amp!Ce[Ch<+C.eCludeCu'Ecu>Erci'Hau,Hib.I!I,ItOt-P<dPe@Pi*Pla(Po'P*[T&dTra0EEbrow:Br-CeCultyDeIntI`~L'MeMilyMousNNcyNtasyRmSh]TT$Th TigueUltV%.e3Atu*Bru?yD $EEdElMa!N)/iv$T^V W3B Ct]EldGu*LeLmLt N$NdNeNg NishReRmR,Sc$ShTT}[X_gAmeAshAtAv%EeIghtIpOatO{O%Ow UidUshY_mCusGIlLd~owOdOtR)Re,R+tRkRtu}RumRw?dSsil/ UndX_gi!AmeEqu|EshI&dIn+OgOntO,OwnOz&U.2ElNNnyRna)RyTu*:D+tInLaxy~ yMePRa+Rba+Rd&Rl-Rm|SSpTeTh U+Ze3N $NiusN*Nt!Nu(e/u*2O,0AntFtGg!Ng RaffeRlVe_dAn)A*A[IdeImp'ObeOomOryO=OwUe_tDde[LdOdO'RillaSpelSsipV nWn_bA)A(AntApeA[Av.yEatE&IdIefItOc yOupOwUnt_rdE[IdeIltIt?N3M:B.IrLfMm M, NdPpyRb%RdRshR=,TVeWkZ?d3AdAl`ArtAvyD+hogIght~oLmetLpNRo3Dd&Gh~NtPRe/%y5BbyCkeyLdLeLiday~owMeNeyOdPeRnRr%R'Sp.$/TelUrV 5BGeM<Mb!M%Nd*dNgryNtRd!RryRtSb<d3Brid:1EOn0EaEntifyLe2N%e4LLeg$L}[0A+Ita>M&'Mu}Pa@Po'Pro=Pul'0ChCludeComeC*a'DexD-a>Do%Du,ryF<tFl-tF%mHa!H .Iti$Je@JuryMa>N Noc|PutQuiryS<eSe@SideSpi*/$lTa@T e,ToVe,V.eVol=3On0L<dOla>Sue0Em1Ory:CketGu?RZz3AlousAns~yWel9BInKeUr}yY5D+I)MpNg!Ni%Nk/:Ng?oo3EnEpT^upY3CkDD}yNdNgdomSsTT^&TeTt&Wi4EeIfeO{Ow:BBelB%Dd DyKeMpNgua+PtopR+T T(UghUndryVaWWnWsu.Y Zy3Ad AfArnA=Ctu*FtGG$G&dIsu*M#NdNg`NsOp?dSs#Tt Vel3ArB tyBr?yC&'FeFtGhtKeMbM.NkOnQuid/Tt!VeZ?d5AdAnB, C$CkG-NelyNgOpTt yUdUn+VeY$5CkyGga+Mb N?N^Xury3R-s:Ch(eDG-G}tIdIlInJ%KeMm$NNa+Nda>NgoNs]Nu$P!Rb!R^Rg(R(eRketRria+SkSs/ T^T i$ThTrixTt XimumZe3AdowAnAsu*AtCh<-D$DiaLodyLtMb M%yNt]NuRcyR+R.RryShSsa+T$Thod3Dd!DnightLk~]M-NdNimumN%Nu>Rac!Rr%S ySs/akeXXedXtu*5Bi!DelDifyMM|N.%NkeyN, N`OnR$ReRn(gSqu.oTh T]T%Unta(U'VeVie5ChFf(LeLtiplySc!SeumShroomS-/Tu$3Self/ yTh:I=MePk(Rrow/yT]Tu*3ArCkEdGati=G!@I` PhewR=/TTw%kUtr$V WsXt3CeGht5B!I'M(eeOd!Rm$R`SeTab!TeTh(gTi)VelW5C!?Mb R'T:K0EyJe@Li+Scu*S =Ta(Vious0CurE<Tob 0Or1FF Fi)T&2L1Ay0DI=Ymp-0It0CeEI#L(eLy1EnEraIn]Po'T]1An+B.Ch?dD D(?yG<I|Ig($Ph<0Tr-h0H 0Tdo%T TputTside0AlEnEr0NN 0Yg&0/ 0O}:CtDd!GeIrLa)LmNdaNelN-N` P RadeR|RkRrotRtySsT^ThTi|TrolTt nU'VeYm|3A)AnutArAs<tL-<NN$tyNcilOp!Pp Rfe@Rm.Rs#T2O}OtoRa'Ys-$0AnoCn-Ctu*E)GGe#~LotNkO} Pe/olT^Zza_)A}tA,-A>AyEa'Ed+U{UgUn+2EmEtIntL?LeLi)NdNyOlPul?Rt]S.]Ssib!/TatoTt yV tyWd W _@i)Ai'Ed-tEf Epa*Es|EttyEv|I)IdeIm?yIntI%.yIs#Iva>IzeOb!mO)[Odu)Of.OgramOje@Omo>OofOp tyOsp O>@OudOvide2Bl-Dd(g~LpL'Mpk(N^PilPpyR^a'R.yRpo'R'ShTZz!3Ramid:99Al.yAntumArt E,]I{ItIzO>:Bb.Cco#CeCkD?DioIlInI'~yMpN^NdomN+PidReTeTh V&WZ%3AdyAlAs#BelBuildC$lCei=CipeC%dCyc!Du)F!@F%mFu'G]G*tGul?Je@LaxLea'LiefLyMa(Memb M(dMo=Nd NewNtOp&PairPeatPla)P%tQui*ScueSemb!Si,Sour)Sp#'SultTi*T*atTurnUn]Ve$ViewW?d2Y`m0BBb#CeChDeD+F!GhtGidNgOtPp!SkTu$V$V 5AdA,BotBu,CketM<)OfOkieOmSeTa>UghUndU>Y$5Bb DeGLeNNwayR$:DDd!D}[FeIlLadLm#L#LtLu>MeMp!NdTisfyToshiU)Usa+VeY1A!AnA*Att E}HemeHoolI&)I[%sOrp]OutRapRe&RiptRub1AAr^As#AtC#dC*tCt]Cur.yEdEkGm|Le@~M(?Ni%N'Nt&)RiesRvi)Ss]Tt!TupV&_dowAftAllowA*EdEllEriffIeldIftI}IpIv O{OeOotOpOrtOuld O=RimpRugUff!Y0Bl(gCkDeE+GhtGnL|Lk~yLv Mil?Mp!N)NgR&/ Tua>XZe1A>Et^IIllInIrtUll0AbAmEepEnd I)IdeIghtImOg<OtOwUsh0AllArtI!OkeOo`0A{AkeApIffOw0ApCc Ci$CkDaFtL?Ldi LidLut]L=Me#eNgOnRryRtUlUndUpUr)U`0A)A*Ati$AwnEakEci$EedEllEndH eI)Id IkeInIr.L.OilOns%O#OrtOtRayReadR(gY0Ua*UeezeUir*l_b!AdiumAffA+AirsAmpAndArtA>AyEakEelEmEpE*oI{IllIngO{Oma^O}OolOryO=Ra>gyReetRikeR#gRugg!Ud|UffUmb!Y!0Bje@Bm.BwayC)[ChDd&Ff G?G+,ItMm NNnyN'tP PplyP*meReRfa)R+Rpri'RroundR=ySpe@/a(1AllowAmpApArmE?EetIftImIngIt^Ord1MbolMptomRup/em:B!Ck!GIlL|LkNkPeR+tSk/eTtooXi3A^Am~NN<tNnisNtRm/Xt_nkAtEmeEnE%yE*EyIngIsOughtReeRi=RowUmbUnd 0CketDeG LtMb MeNyPRedSsueT!5A,BaccoDayDdl EGe` I!tK&MatoM%rowNeNgueNightOlO`PP-Pp!R^RnadoRtoi'SsT$Uri,W?dW WnY_{AdeAff-Ag-A(Ansf ApAshA=lAyEatEeEndI$IbeI{Igg ImIpOphyOub!U{UeUlyUmpetU,U`Y2BeIt]Mb!NaN}lRkeyRnRt!1El=EntyI)InI,O1PeP-$:5Ly5B*lla0Ab!Awa*C!Cov D DoFairFoldHappyIf%mIqueItIv 'KnownLo{TilUsu$Veil1Da>GradeHoldOnP Set1B<Ge0A+EEdEfulE![U$0Il.y:C<tCuumGueLidL!yL=NNishP%Rious/Ult3H-!L=tNd%Ntu*NueRbRifyRs]RyS'lT <3Ab!Br<tCiousCt%yDeoEw~a+Nta+Ol(Rtu$RusSaS.Su$T$Vid5C$I)IdLc<oLumeTeYa+:GeG#ItLk~LnutNtRfa*RmRri%ShSp/eT VeY3Al`Ap#ArA'lA` BDd(gEk&dIrdLcome/T_!AtEatEelEnE*IpIsp 0DeD`FeLd~NNdowNeNgNkNn Nt ReSdomSeShT}[5LfM<Nd OdOlRdRkRldRryR`_pE{E,!I,I>Ong::Rd3Ar~ow9UUngU`:3BraRo9NeO";
      checksum = "0x3c8acc1e7b08d8e76f9fda015ef48dc8c710a73cb7e0f77b2c18a9b5a7adde60";
      wordlist = null;
      LangEn = class _LangEn extends WordlistOwl {
        /**
         *  Creates a new instance of the English language Wordlist.
         *
         *  This should be unnecessary most of the time as the exported
         *  [[langEn]] should suffice.
         *
         *  @_ignore:
         */
        constructor() {
          super("en", words, checksum);
        }
        /**
         *  Returns a singleton instance of a ``LangEn``, creating it
         *  if this is the first time being called.
         */
        static wordlist() {
          if (wordlist == null) {
            wordlist = new _LangEn();
          }
          return wordlist;
        }
      };
    }
  });

  // node_modules/ethers/lib.esm/wallet/mnemonic.js
  function getUpperMask(bits) {
    return (1 << bits) - 1 << 8 - bits & 255;
  }
  function getLowerMask(bits) {
    return (1 << bits) - 1 & 255;
  }
  function mnemonicToEntropy(mnemonic, wordlist2) {
    assertNormalize("NFKD");
    if (wordlist2 == null) {
      wordlist2 = LangEn.wordlist();
    }
    const words2 = wordlist2.split(mnemonic);
    assertArgument(words2.length % 3 === 0 && words2.length >= 12 && words2.length <= 24, "invalid mnemonic length", "mnemonic", "[ REDACTED ]");
    const entropy = new Uint8Array(Math.ceil(11 * words2.length / 8));
    let offset = 0;
    for (let i = 0; i < words2.length; i++) {
      let index2 = wordlist2.getWordIndex(words2[i].normalize("NFKD"));
      assertArgument(index2 >= 0, `invalid mnemonic word at index ${i}`, "mnemonic", "[ REDACTED ]");
      for (let bit = 0; bit < 11; bit++) {
        if (index2 & 1 << 10 - bit) {
          entropy[offset >> 3] |= 1 << 7 - offset % 8;
        }
        offset++;
      }
    }
    const entropyBits = 32 * words2.length / 3;
    const checksumBits = words2.length / 3;
    const checksumMask = getUpperMask(checksumBits);
    const checksum4 = getBytes(sha2562(entropy.slice(0, entropyBits / 8)))[0] & checksumMask;
    assertArgument(checksum4 === (entropy[entropy.length - 1] & checksumMask), "invalid mnemonic checksum", "mnemonic", "[ REDACTED ]");
    return hexlify(entropy.slice(0, entropyBits / 8));
  }
  function entropyToMnemonic(entropy, wordlist2) {
    assertArgument(entropy.length % 4 === 0 && entropy.length >= 16 && entropy.length <= 32, "invalid entropy size", "entropy", "[ REDACTED ]");
    if (wordlist2 == null) {
      wordlist2 = LangEn.wordlist();
    }
    const indices = [0];
    let remainingBits = 11;
    for (let i = 0; i < entropy.length; i++) {
      if (remainingBits > 8) {
        indices[indices.length - 1] <<= 8;
        indices[indices.length - 1] |= entropy[i];
        remainingBits -= 8;
      } else {
        indices[indices.length - 1] <<= remainingBits;
        indices[indices.length - 1] |= entropy[i] >> 8 - remainingBits;
        indices.push(entropy[i] & getLowerMask(8 - remainingBits));
        remainingBits += 3;
      }
    }
    const checksumBits = entropy.length / 4;
    const checksum4 = parseInt(sha2562(entropy).substring(2, 4), 16) & getUpperMask(checksumBits);
    indices[indices.length - 1] <<= checksumBits;
    indices[indices.length - 1] |= checksum4 >> 8 - checksumBits;
    return wordlist2.join(indices.map((index2) => wordlist2.getWord(index2)));
  }
  var _guard5, Mnemonic;
  var init_mnemonic = __esm({
    "node_modules/ethers/lib.esm/wallet/mnemonic.js"() {
      init_crypto2();
      init_utils();
      init_lang_en();
      _guard5 = {};
      Mnemonic = class _Mnemonic {
        /**
         *  @private
         */
        constructor(guard, entropy, phrase, password, wordlist2) {
          /**
           *  The mnemonic phrase of 12, 15, 18, 21 or 24 words.
           *
           *  Use the [[wordlist]] ``split`` method to get the individual words.
           */
          __publicField(this, "phrase");
          /**
           *  The password used for this mnemonic. If no password is used this
           *  is the empty string (i.e. ``""``) as per the specification.
           */
          __publicField(this, "password");
          /**
           *  The wordlist for this mnemonic.
           */
          __publicField(this, "wordlist");
          /**
           *  The underlying entropy which the mnemonic encodes.
           */
          __publicField(this, "entropy");
          if (password == null) {
            password = "";
          }
          if (wordlist2 == null) {
            wordlist2 = LangEn.wordlist();
          }
          assertPrivate(guard, _guard5, "Mnemonic");
          defineProperties(this, { phrase, password, wordlist: wordlist2, entropy });
        }
        /**
         *  Returns the seed for the mnemonic.
         */
        computeSeed() {
          const salt = toUtf8Bytes("mnemonic" + this.password, "NFKD");
          return pbkdf22(toUtf8Bytes(this.phrase, "NFKD"), salt, 2048, 64, "sha512");
        }
        /**
         *  Creates a new Mnemonic for the %%phrase%%.
         *
         *  The default %%password%% is the empty string and the default
         *  wordlist is the [English wordlists](LangEn).
         */
        static fromPhrase(phrase, password, wordlist2) {
          const entropy = mnemonicToEntropy(phrase, wordlist2);
          phrase = entropyToMnemonic(getBytes(entropy), wordlist2);
          return new _Mnemonic(_guard5, entropy, phrase, password, wordlist2);
        }
        /**
         *  Create a new **Mnemonic** from the %%entropy%%.
         *
         *  The default %%password%% is the empty string and the default
         *  wordlist is the [English wordlists](LangEn).
         */
        static fromEntropy(_entropy, password, wordlist2) {
          const entropy = getBytes(_entropy, "entropy");
          const phrase = entropyToMnemonic(entropy, wordlist2);
          return new _Mnemonic(_guard5, hexlify(entropy), phrase, password, wordlist2);
        }
        /**
         *  Returns the phrase for %%mnemonic%%.
         */
        static entropyToPhrase(_entropy, wordlist2) {
          const entropy = getBytes(_entropy, "entropy");
          return entropyToMnemonic(entropy, wordlist2);
        }
        /**
         *  Returns the entropy for %%phrase%%.
         */
        static phraseToEntropy(phrase, wordlist2) {
          return mnemonicToEntropy(phrase, wordlist2);
        }
        /**
         *  Returns true if %%phrase%% is a valid [[link-bip-39]] phrase.
         *
         *  This checks all the provided words belong to the %%wordlist%%,
         *  that the length is valid and the checksum is correct.
         */
        static isValidMnemonic(phrase, wordlist2) {
          try {
            mnemonicToEntropy(phrase, wordlist2);
            return true;
          } catch (error) {
          }
          return false;
        }
      };
    }
  });

  // node_modules/aes-js/lib.esm/aes.js
  function convertToInt32(bytes2) {
    const result = [];
    for (let i = 0; i < bytes2.length; i += 4) {
      result.push(bytes2[i] << 24 | bytes2[i + 1] << 16 | bytes2[i + 2] << 8 | bytes2[i + 3]);
    }
    return result;
  }
  var __classPrivateFieldGet, __classPrivateFieldSet, _AES_key, _AES_Kd, _AES_Ke, numberOfRounds, rcon, S, Si, T12, T2, T3, T4, T5, T6, T7, T8, U1, U2, U3, U4, AES;
  var init_aes = __esm({
    "node_modules/aes-js/lib.esm/aes.js"() {
      __classPrivateFieldGet = function(receiver, state, kind, f2) {
        if (kind === "a" && !f2) throw new TypeError("Private accessor was defined without a getter");
        if (typeof state === "function" ? receiver !== state || !f2 : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return kind === "m" ? f2 : kind === "a" ? f2.call(receiver) : f2 ? f2.value : state.get(receiver);
      };
      __classPrivateFieldSet = function(receiver, state, value, kind, f2) {
        if (kind === "m") throw new TypeError("Private method is not writable");
        if (kind === "a" && !f2) throw new TypeError("Private accessor was defined without a setter");
        if (typeof state === "function" ? receiver !== state || !f2 : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
        return kind === "a" ? f2.call(receiver, value) : f2 ? f2.value = value : state.set(receiver, value), value;
      };
      numberOfRounds = { 16: 10, 24: 12, 32: 14 };
      rcon = [1, 2, 4, 8, 16, 32, 64, 128, 27, 54, 108, 216, 171, 77, 154, 47, 94, 188, 99, 198, 151, 53, 106, 212, 179, 125, 250, 239, 197, 145];
      S = [99, 124, 119, 123, 242, 107, 111, 197, 48, 1, 103, 43, 254, 215, 171, 118, 202, 130, 201, 125, 250, 89, 71, 240, 173, 212, 162, 175, 156, 164, 114, 192, 183, 253, 147, 38, 54, 63, 247, 204, 52, 165, 229, 241, 113, 216, 49, 21, 4, 199, 35, 195, 24, 150, 5, 154, 7, 18, 128, 226, 235, 39, 178, 117, 9, 131, 44, 26, 27, 110, 90, 160, 82, 59, 214, 179, 41, 227, 47, 132, 83, 209, 0, 237, 32, 252, 177, 91, 106, 203, 190, 57, 74, 76, 88, 207, 208, 239, 170, 251, 67, 77, 51, 133, 69, 249, 2, 127, 80, 60, 159, 168, 81, 163, 64, 143, 146, 157, 56, 245, 188, 182, 218, 33, 16, 255, 243, 210, 205, 12, 19, 236, 95, 151, 68, 23, 196, 167, 126, 61, 100, 93, 25, 115, 96, 129, 79, 220, 34, 42, 144, 136, 70, 238, 184, 20, 222, 94, 11, 219, 224, 50, 58, 10, 73, 6, 36, 92, 194, 211, 172, 98, 145, 149, 228, 121, 231, 200, 55, 109, 141, 213, 78, 169, 108, 86, 244, 234, 101, 122, 174, 8, 186, 120, 37, 46, 28, 166, 180, 198, 232, 221, 116, 31, 75, 189, 139, 138, 112, 62, 181, 102, 72, 3, 246, 14, 97, 53, 87, 185, 134, 193, 29, 158, 225, 248, 152, 17, 105, 217, 142, 148, 155, 30, 135, 233, 206, 85, 40, 223, 140, 161, 137, 13, 191, 230, 66, 104, 65, 153, 45, 15, 176, 84, 187, 22];
      Si = [82, 9, 106, 213, 48, 54, 165, 56, 191, 64, 163, 158, 129, 243, 215, 251, 124, 227, 57, 130, 155, 47, 255, 135, 52, 142, 67, 68, 196, 222, 233, 203, 84, 123, 148, 50, 166, 194, 35, 61, 238, 76, 149, 11, 66, 250, 195, 78, 8, 46, 161, 102, 40, 217, 36, 178, 118, 91, 162, 73, 109, 139, 209, 37, 114, 248, 246, 100, 134, 104, 152, 22, 212, 164, 92, 204, 93, 101, 182, 146, 108, 112, 72, 80, 253, 237, 185, 218, 94, 21, 70, 87, 167, 141, 157, 132, 144, 216, 171, 0, 140, 188, 211, 10, 247, 228, 88, 5, 184, 179, 69, 6, 208, 44, 30, 143, 202, 63, 15, 2, 193, 175, 189, 3, 1, 19, 138, 107, 58, 145, 17, 65, 79, 103, 220, 234, 151, 242, 207, 206, 240, 180, 230, 115, 150, 172, 116, 34, 231, 173, 53, 133, 226, 249, 55, 232, 28, 117, 223, 110, 71, 241, 26, 113, 29, 41, 197, 137, 111, 183, 98, 14, 170, 24, 190, 27, 252, 86, 62, 75, 198, 210, 121, 32, 154, 219, 192, 254, 120, 205, 90, 244, 31, 221, 168, 51, 136, 7, 199, 49, 177, 18, 16, 89, 39, 128, 236, 95, 96, 81, 127, 169, 25, 181, 74, 13, 45, 229, 122, 159, 147, 201, 156, 239, 160, 224, 59, 77, 174, 42, 245, 176, 200, 235, 187, 60, 131, 83, 153, 97, 23, 43, 4, 126, 186, 119, 214, 38, 225, 105, 20, 99, 85, 33, 12, 125];
      T12 = [3328402341, 4168907908, 4000806809, 4135287693, 4294111757, 3597364157, 3731845041, 2445657428, 1613770832, 33620227, 3462883241, 1445669757, 3892248089, 3050821474, 1303096294, 3967186586, 2412431941, 528646813, 2311702848, 4202528135, 4026202645, 2992200171, 2387036105, 4226871307, 1101901292, 3017069671, 1604494077, 1169141738, 597466303, 1403299063, 3832705686, 2613100635, 1974974402, 3791519004, 1033081774, 1277568618, 1815492186, 2118074177, 4126668546, 2211236943, 1748251740, 1369810420, 3521504564, 4193382664, 3799085459, 2883115123, 1647391059, 706024767, 134480908, 2512897874, 1176707941, 2646852446, 806885416, 932615841, 168101135, 798661301, 235341577, 605164086, 461406363, 3756188221, 3454790438, 1311188841, 2142417613, 3933566367, 302582043, 495158174, 1479289972, 874125870, 907746093, 3698224818, 3025820398, 1537253627, 2756858614, 1983593293, 3084310113, 2108928974, 1378429307, 3722699582, 1580150641, 327451799, 2790478837, 3117535592, 0, 3253595436, 1075847264, 3825007647, 2041688520, 3059440621, 3563743934, 2378943302, 1740553945, 1916352843, 2487896798, 2555137236, 2958579944, 2244988746, 3151024235, 3320835882, 1336584933, 3992714006, 2252555205, 2588757463, 1714631509, 293963156, 2319795663, 3925473552, 67240454, 4269768577, 2689618160, 2017213508, 631218106, 1269344483, 2723238387, 1571005438, 2151694528, 93294474, 1066570413, 563977660, 1882732616, 4059428100, 1673313503, 2008463041, 2950355573, 1109467491, 537923632, 3858759450, 4260623118, 3218264685, 2177748300, 403442708, 638784309, 3287084079, 3193921505, 899127202, 2286175436, 773265209, 2479146071, 1437050866, 4236148354, 2050833735, 3362022572, 3126681063, 840505643, 3866325909, 3227541664, 427917720, 2655997905, 2749160575, 1143087718, 1412049534, 999329963, 193497219, 2353415882, 3354324521, 1807268051, 672404540, 2816401017, 3160301282, 369822493, 2916866934, 3688947771, 1681011286, 1949973070, 336202270, 2454276571, 201721354, 1210328172, 3093060836, 2680341085, 3184776046, 1135389935, 3294782118, 965841320, 831886756, 3554993207, 4068047243, 3588745010, 2345191491, 1849112409, 3664604599, 26054028, 2983581028, 2622377682, 1235855840, 3630984372, 2891339514, 4092916743, 3488279077, 3395642799, 4101667470, 1202630377, 268961816, 1874508501, 4034427016, 1243948399, 1546530418, 941366308, 1470539505, 1941222599, 2546386513, 3421038627, 2715671932, 3899946140, 1042226977, 2521517021, 1639824860, 227249030, 260737669, 3765465232, 2084453954, 1907733956, 3429263018, 2420656344, 100860677, 4160157185, 470683154, 3261161891, 1781871967, 2924959737, 1773779408, 394692241, 2579611992, 974986535, 664706745, 3655459128, 3958962195, 731420851, 571543859, 3530123707, 2849626480, 126783113, 865375399, 765172662, 1008606754, 361203602, 3387549984, 2278477385, 2857719295, 1344809080, 2782912378, 59542671, 1503764984, 160008576, 437062935, 1707065306, 3622233649, 2218934982, 3496503480, 2185314755, 697932208, 1512910199, 504303377, 2075177163, 2824099068, 1841019862, 739644986];
      T2 = [2781242211, 2230877308, 2582542199, 2381740923, 234877682, 3184946027, 2984144751, 1418839493, 1348481072, 50462977, 2848876391, 2102799147, 434634494, 1656084439, 3863849899, 2599188086, 1167051466, 2636087938, 1082771913, 2281340285, 368048890, 3954334041, 3381544775, 201060592, 3963727277, 1739838676, 4250903202, 3930435503, 3206782108, 4149453988, 2531553906, 1536934080, 3262494647, 484572669, 2923271059, 1783375398, 1517041206, 1098792767, 49674231, 1334037708, 1550332980, 4098991525, 886171109, 150598129, 2481090929, 1940642008, 1398944049, 1059722517, 201851908, 1385547719, 1699095331, 1587397571, 674240536, 2704774806, 252314885, 3039795866, 151914247, 908333586, 2602270848, 1038082786, 651029483, 1766729511, 3447698098, 2682942837, 454166793, 2652734339, 1951935532, 775166490, 758520603, 3000790638, 4004797018, 4217086112, 4137964114, 1299594043, 1639438038, 3464344499, 2068982057, 1054729187, 1901997871, 2534638724, 4121318227, 1757008337, 0, 750906861, 1614815264, 535035132, 3363418545, 3988151131, 3201591914, 1183697867, 3647454910, 1265776953, 3734260298, 3566750796, 3903871064, 1250283471, 1807470800, 717615087, 3847203498, 384695291, 3313910595, 3617213773, 1432761139, 2484176261, 3481945413, 283769337, 100925954, 2180939647, 4037038160, 1148730428, 3123027871, 3813386408, 4087501137, 4267549603, 3229630528, 2315620239, 2906624658, 3156319645, 1215313976, 82966005, 3747855548, 3245848246, 1974459098, 1665278241, 807407632, 451280895, 251524083, 1841287890, 1283575245, 337120268, 891687699, 801369324, 3787349855, 2721421207, 3431482436, 959321879, 1469301956, 4065699751, 2197585534, 1199193405, 2898814052, 3887750493, 724703513, 2514908019, 2696962144, 2551808385, 3516813135, 2141445340, 1715741218, 2119445034, 2872807568, 2198571144, 3398190662, 700968686, 3547052216, 1009259540, 2041044702, 3803995742, 487983883, 1991105499, 1004265696, 1449407026, 1316239930, 504629770, 3683797321, 168560134, 1816667172, 3837287516, 1570751170, 1857934291, 4014189740, 2797888098, 2822345105, 2754712981, 936633572, 2347923833, 852879335, 1133234376, 1500395319, 3084545389, 2348912013, 1689376213, 3533459022, 3762923945, 3034082412, 4205598294, 133428468, 634383082, 2949277029, 2398386810, 3913789102, 403703816, 3580869306, 2297460856, 1867130149, 1918643758, 607656988, 4049053350, 3346248884, 1368901318, 600565992, 2090982877, 2632479860, 557719327, 3717614411, 3697393085, 2249034635, 2232388234, 2430627952, 1115438654, 3295786421, 2865522278, 3633334344, 84280067, 33027830, 303828494, 2747425121, 1600795957, 4188952407, 3496589753, 2434238086, 1486471617, 658119965, 3106381470, 953803233, 334231800, 3005978776, 857870609, 3151128937, 1890179545, 2298973838, 2805175444, 3056442267, 574365214, 2450884487, 550103529, 1233637070, 4289353045, 2018519080, 2057691103, 2399374476, 4166623649, 2148108681, 387583245, 3664101311, 836232934, 3330556482, 3100665960, 3280093505, 2955516313, 2002398509, 287182607, 3413881008, 4238890068, 3597515707, 975967766];
      T3 = [1671808611, 2089089148, 2006576759, 2072901243, 4061003762, 1807603307, 1873927791, 3310653893, 810573872, 16974337, 1739181671, 729634347, 4263110654, 3613570519, 2883997099, 1989864566, 3393556426, 2191335298, 3376449993, 2106063485, 4195741690, 1508618841, 1204391495, 4027317232, 2917941677, 3563566036, 2734514082, 2951366063, 2629772188, 2767672228, 1922491506, 3227229120, 3082974647, 4246528509, 2477669779, 644500518, 911895606, 1061256767, 4144166391, 3427763148, 878471220, 2784252325, 3845444069, 4043897329, 1905517169, 3631459288, 827548209, 356461077, 67897348, 3344078279, 593839651, 3277757891, 405286936, 2527147926, 84871685, 2595565466, 118033927, 305538066, 2157648768, 3795705826, 3945188843, 661212711, 2999812018, 1973414517, 152769033, 2208177539, 745822252, 439235610, 455947803, 1857215598, 1525593178, 2700827552, 1391895634, 994932283, 3596728278, 3016654259, 695947817, 3812548067, 795958831, 2224493444, 1408607827, 3513301457, 0, 3979133421, 543178784, 4229948412, 2982705585, 1542305371, 1790891114, 3410398667, 3201918910, 961245753, 1256100938, 1289001036, 1491644504, 3477767631, 3496721360, 4012557807, 2867154858, 4212583931, 1137018435, 1305975373, 861234739, 2241073541, 1171229253, 4178635257, 33948674, 2139225727, 1357946960, 1011120188, 2679776671, 2833468328, 1374921297, 2751356323, 1086357568, 2408187279, 2460827538, 2646352285, 944271416, 4110742005, 3168756668, 3066132406, 3665145818, 560153121, 271589392, 4279952895, 4077846003, 3530407890, 3444343245, 202643468, 322250259, 3962553324, 1608629855, 2543990167, 1154254916, 389623319, 3294073796, 2817676711, 2122513534, 1028094525, 1689045092, 1575467613, 422261273, 1939203699, 1621147744, 2174228865, 1339137615, 3699352540, 577127458, 712922154, 2427141008, 2290289544, 1187679302, 3995715566, 3100863416, 339486740, 3732514782, 1591917662, 186455563, 3681988059, 3762019296, 844522546, 978220090, 169743370, 1239126601, 101321734, 611076132, 1558493276, 3260915650, 3547250131, 2901361580, 1655096418, 2443721105, 2510565781, 3828863972, 2039214713, 3878868455, 3359869896, 928607799, 1840765549, 2374762893, 3580146133, 1322425422, 2850048425, 1823791212, 1459268694, 4094161908, 3928346602, 1706019429, 2056189050, 2934523822, 135794696, 3134549946, 2022240376, 628050469, 779246638, 472135708, 2800834470, 3032970164, 3327236038, 3894660072, 3715932637, 1956440180, 522272287, 1272813131, 3185336765, 2340818315, 2323976074, 1888542832, 1044544574, 3049550261, 1722469478, 1222152264, 50660867, 4127324150, 236067854, 1638122081, 895445557, 1475980887, 3117443513, 2257655686, 3243809217, 489110045, 2662934430, 3778599393, 4162055160, 2561878936, 288563729, 1773916777, 3648039385, 2391345038, 2493985684, 2612407707, 505560094, 2274497927, 3911240169, 3460925390, 1442818645, 678973480, 3749357023, 2358182796, 2717407649, 2306869641, 219617805, 3218761151, 3862026214, 1120306242, 1756942440, 1103331905, 2578459033, 762796589, 252780047, 2966125488, 1425844308, 3151392187, 372911126];
      T4 = [1667474886, 2088535288, 2004326894, 2071694838, 4075949567, 1802223062, 1869591006, 3318043793, 808472672, 16843522, 1734846926, 724270422, 4278065639, 3621216949, 2880169549, 1987484396, 3402253711, 2189597983, 3385409673, 2105378810, 4210693615, 1499065266, 1195886990, 4042263547, 2913856577, 3570689971, 2728590687, 2947541573, 2627518243, 2762274643, 1920112356, 3233831835, 3082273397, 4261223649, 2475929149, 640051788, 909531756, 1061110142, 4160160501, 3435941763, 875846760, 2779116625, 3857003729, 4059105529, 1903268834, 3638064043, 825316194, 353713962, 67374088, 3351728789, 589522246, 3284360861, 404236336, 2526454071, 84217610, 2593830191, 117901582, 303183396, 2155911963, 3806477791, 3958056653, 656894286, 2998062463, 1970642922, 151591698, 2206440989, 741110872, 437923380, 454765878, 1852748508, 1515908788, 2694904667, 1381168804, 993742198, 3604373943, 3014905469, 690584402, 3823320797, 791638366, 2223281939, 1398011302, 3520161977, 0, 3991743681, 538992704, 4244381667, 2981218425, 1532751286, 1785380564, 3419096717, 3200178535, 960056178, 1246420628, 1280103576, 1482221744, 3486468741, 3503319995, 4025428677, 2863326543, 4227536621, 1128514950, 1296947098, 859002214, 2240123921, 1162203018, 4193849577, 33687044, 2139062782, 1347481760, 1010582648, 2678045221, 2829640523, 1364325282, 2745433693, 1077985408, 2408548869, 2459086143, 2644360225, 943212656, 4126475505, 3166494563, 3065430391, 3671750063, 555836226, 269496352, 4294908645, 4092792573, 3537006015, 3452783745, 202118168, 320025894, 3974901699, 1600119230, 2543297077, 1145359496, 387397934, 3301201811, 2812801621, 2122220284, 1027426170, 1684319432, 1566435258, 421079858, 1936954854, 1616945344, 2172753945, 1330631070, 3705438115, 572679748, 707427924, 2425400123, 2290647819, 1179044492, 4008585671, 3099120491, 336870440, 3739122087, 1583276732, 185277718, 3688593069, 3772791771, 842159716, 976899700, 168435220, 1229577106, 101059084, 606366792, 1549591736, 3267517855, 3553849021, 2897014595, 1650632388, 2442242105, 2509612081, 3840161747, 2038008818, 3890688725, 3368567691, 926374254, 1835907034, 2374863873, 3587531953, 1313788572, 2846482505, 1819063512, 1448540844, 4109633523, 3941213647, 1701162954, 2054852340, 2930698567, 134748176, 3132806511, 2021165296, 623210314, 774795868, 471606328, 2795958615, 3031746419, 3334885783, 3907527627, 3722280097, 1953799400, 522133822, 1263263126, 3183336545, 2341176845, 2324333839, 1886425312, 1044267644, 3048588401, 1718004428, 1212733584, 50529542, 4143317495, 235803164, 1633788866, 892690282, 1465383342, 3115962473, 2256965911, 3250673817, 488449850, 2661202215, 3789633753, 4177007595, 2560144171, 286339874, 1768537042, 3654906025, 2391705863, 2492770099, 2610673197, 505291324, 2273808917, 3924369609, 3469625735, 1431699370, 673740880, 3755965093, 2358021891, 2711746649, 2307489801, 218961690, 3217021541, 3873845719, 1111672452, 1751693520, 1094828930, 2576986153, 757954394, 252645662, 2964376443, 1414855848, 3149649517, 370555436];
      T5 = [1374988112, 2118214995, 437757123, 975658646, 1001089995, 530400753, 2902087851, 1273168787, 540080725, 2910219766, 2295101073, 4110568485, 1340463100, 3307916247, 641025152, 3043140495, 3736164937, 632953703, 1172967064, 1576976609, 3274667266, 2169303058, 2370213795, 1809054150, 59727847, 361929877, 3211623147, 2505202138, 3569255213, 1484005843, 1239443753, 2395588676, 1975683434, 4102977912, 2572697195, 666464733, 3202437046, 4035489047, 3374361702, 2110667444, 1675577880, 3843699074, 2538681184, 1649639237, 2976151520, 3144396420, 4269907996, 4178062228, 1883793496, 2403728665, 2497604743, 1383856311, 2876494627, 1917518562, 3810496343, 1716890410, 3001755655, 800440835, 2261089178, 3543599269, 807962610, 599762354, 33778362, 3977675356, 2328828971, 2809771154, 4077384432, 1315562145, 1708848333, 101039829, 3509871135, 3299278474, 875451293, 2733856160, 92987698, 2767645557, 193195065, 1080094634, 1584504582, 3178106961, 1042385657, 2531067453, 3711829422, 1306967366, 2438237621, 1908694277, 67556463, 1615861247, 429456164, 3602770327, 2302690252, 1742315127, 2968011453, 126454664, 3877198648, 2043211483, 2709260871, 2084704233, 4169408201, 0, 159417987, 841739592, 504459436, 1817866830, 4245618683, 260388950, 1034867998, 908933415, 168810852, 1750902305, 2606453969, 607530554, 202008497, 2472011535, 3035535058, 463180190, 2160117071, 1641816226, 1517767529, 470948374, 3801332234, 3231722213, 1008918595, 303765277, 235474187, 4069246893, 766945465, 337553864, 1475418501, 2943682380, 4003061179, 2743034109, 4144047775, 1551037884, 1147550661, 1543208500, 2336434550, 3408119516, 3069049960, 3102011747, 3610369226, 1113818384, 328671808, 2227573024, 2236228733, 3535486456, 2935566865, 3341394285, 496906059, 3702665459, 226906860, 2009195472, 733156972, 2842737049, 294930682, 1206477858, 2835123396, 2700099354, 1451044056, 573804783, 2269728455, 3644379585, 2362090238, 2564033334, 2801107407, 2776292904, 3669462566, 1068351396, 742039012, 1350078989, 1784663195, 1417561698, 4136440770, 2430122216, 775550814, 2193862645, 2673705150, 1775276924, 1876241833, 3475313331, 3366754619, 270040487, 3902563182, 3678124923, 3441850377, 1851332852, 3969562369, 2203032232, 3868552805, 2868897406, 566021896, 4011190502, 3135740889, 1248802510, 3936291284, 699432150, 832877231, 708780849, 3332740144, 899835584, 1951317047, 4236429990, 3767586992, 866637845, 4043610186, 1106041591, 2144161806, 395441711, 1984812685, 1139781709, 3433712980, 3835036895, 2664543715, 1282050075, 3240894392, 1181045119, 2640243204, 25965917, 4203181171, 4211818798, 3009879386, 2463879762, 3910161971, 1842759443, 2597806476, 933301370, 1509430414, 3943906441, 3467192302, 3076639029, 3776767469, 2051518780, 2631065433, 1441952575, 404016761, 1942435775, 1408749034, 1610459739, 3745345300, 2017778566, 3400528769, 3110650942, 941896748, 3265478751, 371049330, 3168937228, 675039627, 4279080257, 967311729, 135050206, 3635733660, 1683407248, 2076935265, 3576870512, 1215061108, 3501741890];
      T6 = [1347548327, 1400783205, 3273267108, 2520393566, 3409685355, 4045380933, 2880240216, 2471224067, 1428173050, 4138563181, 2441661558, 636813900, 4233094615, 3620022987, 2149987652, 2411029155, 1239331162, 1730525723, 2554718734, 3781033664, 46346101, 310463728, 2743944855, 3328955385, 3875770207, 2501218972, 3955191162, 3667219033, 768917123, 3545789473, 692707433, 1150208456, 1786102409, 2029293177, 1805211710, 3710368113, 3065962831, 401639597, 1724457132, 3028143674, 409198410, 2196052529, 1620529459, 1164071807, 3769721975, 2226875310, 486441376, 2499348523, 1483753576, 428819965, 2274680428, 3075636216, 598438867, 3799141122, 1474502543, 711349675, 129166120, 53458370, 2592523643, 2782082824, 4063242375, 2988687269, 3120694122, 1559041666, 730517276, 2460449204, 4042459122, 2706270690, 3446004468, 3573941694, 533804130, 2328143614, 2637442643, 2695033685, 839224033, 1973745387, 957055980, 2856345839, 106852767, 1371368976, 4181598602, 1033297158, 2933734917, 1179510461, 3046200461, 91341917, 1862534868, 4284502037, 605657339, 2547432937, 3431546947, 2003294622, 3182487618, 2282195339, 954669403, 3682191598, 1201765386, 3917234703, 3388507166, 0, 2198438022, 1211247597, 2887651696, 1315723890, 4227665663, 1443857720, 507358933, 657861945, 1678381017, 560487590, 3516619604, 975451694, 2970356327, 261314535, 3535072918, 2652609425, 1333838021, 2724322336, 1767536459, 370938394, 182621114, 3854606378, 1128014560, 487725847, 185469197, 2918353863, 3106780840, 3356761769, 2237133081, 1286567175, 3152976349, 4255350624, 2683765030, 3160175349, 3309594171, 878443390, 1988838185, 3704300486, 1756818940, 1673061617, 3403100636, 272786309, 1075025698, 545572369, 2105887268, 4174560061, 296679730, 1841768865, 1260232239, 4091327024, 3960309330, 3497509347, 1814803222, 2578018489, 4195456072, 575138148, 3299409036, 446754879, 3629546796, 4011996048, 3347532110, 3252238545, 4270639778, 915985419, 3483825537, 681933534, 651868046, 2755636671, 3828103837, 223377554, 2607439820, 1649704518, 3270937875, 3901806776, 1580087799, 4118987695, 3198115200, 2087309459, 2842678573, 3016697106, 1003007129, 2802849917, 1860738147, 2077965243, 164439672, 4100872472, 32283319, 2827177882, 1709610350, 2125135846, 136428751, 3874428392, 3652904859, 3460984630, 3572145929, 3593056380, 2939266226, 824852259, 818324884, 3224740454, 930369212, 2801566410, 2967507152, 355706840, 1257309336, 4148292826, 243256656, 790073846, 2373340630, 1296297904, 1422699085, 3756299780, 3818836405, 457992840, 3099667487, 2135319889, 77422314, 1560382517, 1945798516, 788204353, 1521706781, 1385356242, 870912086, 325965383, 2358957921, 2050466060, 2388260884, 2313884476, 4006521127, 901210569, 3990953189, 1014646705, 1503449823, 1062597235, 2031621326, 3212035895, 3931371469, 1533017514, 350174575, 2256028891, 2177544179, 1052338372, 741876788, 1606591296, 1914052035, 213705253, 2334669897, 1107234197, 1899603969, 3725069491, 2631447780, 2422494913, 1635502980, 1893020342, 1950903388, 1120974935];
      T7 = [2807058932, 1699970625, 2764249623, 1586903591, 1808481195, 1173430173, 1487645946, 59984867, 4199882800, 1844882806, 1989249228, 1277555970, 3623636965, 3419915562, 1149249077, 2744104290, 1514790577, 459744698, 244860394, 3235995134, 1963115311, 4027744588, 2544078150, 4190530515, 1608975247, 2627016082, 2062270317, 1507497298, 2200818878, 567498868, 1764313568, 3359936201, 2305455554, 2037970062, 1047239e3, 1910319033, 1337376481, 2904027272, 2892417312, 984907214, 1243112415, 830661914, 861968209, 2135253587, 2011214180, 2927934315, 2686254721, 731183368, 1750626376, 4246310725, 1820824798, 4172763771, 3542330227, 48394827, 2404901663, 2871682645, 671593195, 3254988725, 2073724613, 145085239, 2280796200, 2779915199, 1790575107, 2187128086, 472615631, 3029510009, 4075877127, 3802222185, 4107101658, 3201631749, 1646252340, 4270507174, 1402811438, 1436590835, 3778151818, 3950355702, 3963161475, 4020912224, 2667994737, 273792366, 2331590177, 104699613, 95345982, 3175501286, 2377486676, 1560637892, 3564045318, 369057872, 4213447064, 3919042237, 1137477952, 2658625497, 1119727848, 2340947849, 1530455833, 4007360968, 172466556, 266959938, 516552836, 0, 2256734592, 3980931627, 1890328081, 1917742170, 4294704398, 945164165, 3575528878, 958871085, 3647212047, 2787207260, 1423022939, 775562294, 1739656202, 3876557655, 2530391278, 2443058075, 3310321856, 547512796, 1265195639, 437656594, 3121275539, 719700128, 3762502690, 387781147, 218828297, 3350065803, 2830708150, 2848461854, 428169201, 122466165, 3720081049, 1627235199, 648017665, 4122762354, 1002783846, 2117360635, 695634755, 3336358691, 4234721005, 4049844452, 3704280881, 2232435299, 574624663, 287343814, 612205898, 1039717051, 840019705, 2708326185, 793451934, 821288114, 1391201670, 3822090177, 376187827, 3113855344, 1224348052, 1679968233, 2361698556, 1058709744, 752375421, 2431590963, 1321699145, 3519142200, 2734591178, 188127444, 2177869557, 3727205754, 2384911031, 3215212461, 2648976442, 2450346104, 3432737375, 1180849278, 331544205, 3102249176, 4150144569, 2952102595, 2159976285, 2474404304, 766078933, 313773861, 2570832044, 2108100632, 1668212892, 3145456443, 2013908262, 418672217, 3070356634, 2594734927, 1852171925, 3867060991, 3473416636, 3907448597, 2614737639, 919489135, 164948639, 2094410160, 2997825956, 590424639, 2486224549, 1723872674, 3157750862, 3399941250, 3501252752, 3625268135, 2555048196, 3673637356, 1343127501, 4130281361, 3599595085, 2957853679, 1297403050, 81781910, 3051593425, 2283490410, 532201772, 1367295589, 3926170974, 895287692, 1953757831, 1093597963, 492483431, 3528626907, 1446242576, 1192455638, 1636604631, 209336225, 344873464, 1015671571, 669961897, 3375740769, 3857572124, 2973530695, 3747192018, 1933530610, 3464042516, 935293895, 3454686199, 2858115069, 1863638845, 3683022916, 4085369519, 3292445032, 875313188, 1080017571, 3279033885, 621591778, 1233856572, 2504130317, 24197544, 3017672716, 3835484340, 3247465558, 2220981195, 3060847922, 1551124588, 1463996600];
      T8 = [4104605777, 1097159550, 396673818, 660510266, 2875968315, 2638606623, 4200115116, 3808662347, 821712160, 1986918061, 3430322568, 38544885, 3856137295, 718002117, 893681702, 1654886325, 2975484382, 3122358053, 3926825029, 4274053469, 796197571, 1290801793, 1184342925, 3556361835, 2405426947, 2459735317, 1836772287, 1381620373, 3196267988, 1948373848, 3764988233, 3385345166, 3263785589, 2390325492, 1480485785, 3111247143, 3780097726, 2293045232, 548169417, 3459953789, 3746175075, 439452389, 1362321559, 1400849762, 1685577905, 1806599355, 2174754046, 137073913, 1214797936, 1174215055, 3731654548, 2079897426, 1943217067, 1258480242, 529487843, 1437280870, 3945269170, 3049390895, 3313212038, 923313619, 679998e3, 3215307299, 57326082, 377642221, 3474729866, 2041877159, 133361907, 1776460110, 3673476453, 96392454, 878845905, 2801699524, 777231668, 4082475170, 2330014213, 4142626212, 2213296395, 1626319424, 1906247262, 1846563261, 562755902, 3708173718, 1040559837, 3871163981, 1418573201, 3294430577, 114585348, 1343618912, 2566595609, 3186202582, 1078185097, 3651041127, 3896688048, 2307622919, 425408743, 3371096953, 2081048481, 1108339068, 2216610296, 0, 2156299017, 736970802, 292596766, 1517440620, 251657213, 2235061775, 2933202493, 758720310, 265905162, 1554391400, 1532285339, 908999204, 174567692, 1474760595, 4002861748, 2610011675, 3234156416, 3693126241, 2001430874, 303699484, 2478443234, 2687165888, 585122620, 454499602, 151849742, 2345119218, 3064510765, 514443284, 4044981591, 1963412655, 2581445614, 2137062819, 19308535, 1928707164, 1715193156, 4219352155, 1126790795, 600235211, 3992742070, 3841024952, 836553431, 1669664834, 2535604243, 3323011204, 1243905413, 3141400786, 4180808110, 698445255, 2653899549, 2989552604, 2253581325, 3252932727, 3004591147, 1891211689, 2487810577, 3915653703, 4237083816, 4030667424, 2100090966, 865136418, 1229899655, 953270745, 3399679628, 3557504664, 4118925222, 2061379749, 3079546586, 2915017791, 983426092, 2022837584, 1607244650, 2118541908, 2366882550, 3635996816, 972512814, 3283088770, 1568718495, 3499326569, 3576539503, 621982671, 2895723464, 410887952, 2623762152, 1002142683, 645401037, 1494807662, 2595684844, 1335535747, 2507040230, 4293295786, 3167684641, 367585007, 3885750714, 1865862730, 2668221674, 2960971305, 2763173681, 1059270954, 2777952454, 2724642869, 1320957812, 2194319100, 2429595872, 2815956275, 77089521, 3973773121, 3444575871, 2448830231, 1305906550, 4021308739, 2857194700, 2516901860, 3518358430, 1787304780, 740276417, 1699839814, 1592394909, 2352307457, 2272556026, 188821243, 1729977011, 3687994002, 274084841, 3594982253, 3613494426, 2701949495, 4162096729, 322734571, 2837966542, 1640576439, 484830689, 1202797690, 3537852828, 4067639125, 349075736, 3342319475, 4157467219, 4255800159, 1030690015, 1155237496, 2951971274, 1757691577, 607398968, 2738905026, 499347990, 3794078908, 1011452712, 227885567, 2818666809, 213114376, 3034881240, 1455525988, 3414450555, 850817237, 1817998408, 3092726480];
      U1 = [0, 235474187, 470948374, 303765277, 941896748, 908933415, 607530554, 708780849, 1883793496, 2118214995, 1817866830, 1649639237, 1215061108, 1181045119, 1417561698, 1517767529, 3767586992, 4003061179, 4236429990, 4069246893, 3635733660, 3602770327, 3299278474, 3400528769, 2430122216, 2664543715, 2362090238, 2193862645, 2835123396, 2801107407, 3035535058, 3135740889, 3678124923, 3576870512, 3341394285, 3374361702, 3810496343, 3977675356, 4279080257, 4043610186, 2876494627, 2776292904, 3076639029, 3110650942, 2472011535, 2640243204, 2403728665, 2169303058, 1001089995, 899835584, 666464733, 699432150, 59727847, 226906860, 530400753, 294930682, 1273168787, 1172967064, 1475418501, 1509430414, 1942435775, 2110667444, 1876241833, 1641816226, 2910219766, 2743034109, 2976151520, 3211623147, 2505202138, 2606453969, 2302690252, 2269728455, 3711829422, 3543599269, 3240894392, 3475313331, 3843699074, 3943906441, 4178062228, 4144047775, 1306967366, 1139781709, 1374988112, 1610459739, 1975683434, 2076935265, 1775276924, 1742315127, 1034867998, 866637845, 566021896, 800440835, 92987698, 193195065, 429456164, 395441711, 1984812685, 2017778566, 1784663195, 1683407248, 1315562145, 1080094634, 1383856311, 1551037884, 101039829, 135050206, 437757123, 337553864, 1042385657, 807962610, 573804783, 742039012, 2531067453, 2564033334, 2328828971, 2227573024, 2935566865, 2700099354, 3001755655, 3168937228, 3868552805, 3902563182, 4203181171, 4102977912, 3736164937, 3501741890, 3265478751, 3433712980, 1106041591, 1340463100, 1576976609, 1408749034, 2043211483, 2009195472, 1708848333, 1809054150, 832877231, 1068351396, 766945465, 599762354, 159417987, 126454664, 361929877, 463180190, 2709260871, 2943682380, 3178106961, 3009879386, 2572697195, 2538681184, 2236228733, 2336434550, 3509871135, 3745345300, 3441850377, 3274667266, 3910161971, 3877198648, 4110568485, 4211818798, 2597806476, 2497604743, 2261089178, 2295101073, 2733856160, 2902087851, 3202437046, 2968011453, 3936291284, 3835036895, 4136440770, 4169408201, 3535486456, 3702665459, 3467192302, 3231722213, 2051518780, 1951317047, 1716890410, 1750902305, 1113818384, 1282050075, 1584504582, 1350078989, 168810852, 67556463, 371049330, 404016761, 841739592, 1008918595, 775550814, 540080725, 3969562369, 3801332234, 4035489047, 4269907996, 3569255213, 3669462566, 3366754619, 3332740144, 2631065433, 2463879762, 2160117071, 2395588676, 2767645557, 2868897406, 3102011747, 3069049960, 202008497, 33778362, 270040487, 504459436, 875451293, 975658646, 675039627, 641025152, 2084704233, 1917518562, 1615861247, 1851332852, 1147550661, 1248802510, 1484005843, 1451044056, 933301370, 967311729, 733156972, 632953703, 260388950, 25965917, 328671808, 496906059, 1206477858, 1239443753, 1543208500, 1441952575, 2144161806, 1908694277, 1675577880, 1842759443, 3610369226, 3644379585, 3408119516, 3307916247, 4011190502, 3776767469, 4077384432, 4245618683, 2809771154, 2842737049, 3144396420, 3043140495, 2673705150, 2438237621, 2203032232, 2370213795];
      U2 = [0, 185469197, 370938394, 487725847, 741876788, 657861945, 975451694, 824852259, 1483753576, 1400783205, 1315723890, 1164071807, 1950903388, 2135319889, 1649704518, 1767536459, 2967507152, 3152976349, 2801566410, 2918353863, 2631447780, 2547432937, 2328143614, 2177544179, 3901806776, 3818836405, 4270639778, 4118987695, 3299409036, 3483825537, 3535072918, 3652904859, 2077965243, 1893020342, 1841768865, 1724457132, 1474502543, 1559041666, 1107234197, 1257309336, 598438867, 681933534, 901210569, 1052338372, 261314535, 77422314, 428819965, 310463728, 3409685355, 3224740454, 3710368113, 3593056380, 3875770207, 3960309330, 4045380933, 4195456072, 2471224067, 2554718734, 2237133081, 2388260884, 3212035895, 3028143674, 2842678573, 2724322336, 4138563181, 4255350624, 3769721975, 3955191162, 3667219033, 3516619604, 3431546947, 3347532110, 2933734917, 2782082824, 3099667487, 3016697106, 2196052529, 2313884476, 2499348523, 2683765030, 1179510461, 1296297904, 1347548327, 1533017514, 1786102409, 1635502980, 2087309459, 2003294622, 507358933, 355706840, 136428751, 53458370, 839224033, 957055980, 605657339, 790073846, 2373340630, 2256028891, 2607439820, 2422494913, 2706270690, 2856345839, 3075636216, 3160175349, 3573941694, 3725069491, 3273267108, 3356761769, 4181598602, 4063242375, 4011996048, 3828103837, 1033297158, 915985419, 730517276, 545572369, 296679730, 446754879, 129166120, 213705253, 1709610350, 1860738147, 1945798516, 2029293177, 1239331162, 1120974935, 1606591296, 1422699085, 4148292826, 4233094615, 3781033664, 3931371469, 3682191598, 3497509347, 3446004468, 3328955385, 2939266226, 2755636671, 3106780840, 2988687269, 2198438022, 2282195339, 2501218972, 2652609425, 1201765386, 1286567175, 1371368976, 1521706781, 1805211710, 1620529459, 2105887268, 1988838185, 533804130, 350174575, 164439672, 46346101, 870912086, 954669403, 636813900, 788204353, 2358957921, 2274680428, 2592523643, 2441661558, 2695033685, 2880240216, 3065962831, 3182487618, 3572145929, 3756299780, 3270937875, 3388507166, 4174560061, 4091327024, 4006521127, 3854606378, 1014646705, 930369212, 711349675, 560487590, 272786309, 457992840, 106852767, 223377554, 1678381017, 1862534868, 1914052035, 2031621326, 1211247597, 1128014560, 1580087799, 1428173050, 32283319, 182621114, 401639597, 486441376, 768917123, 651868046, 1003007129, 818324884, 1503449823, 1385356242, 1333838021, 1150208456, 1973745387, 2125135846, 1673061617, 1756818940, 2970356327, 3120694122, 2802849917, 2887651696, 2637442643, 2520393566, 2334669897, 2149987652, 3917234703, 3799141122, 4284502037, 4100872472, 3309594171, 3460984630, 3545789473, 3629546796, 2050466060, 1899603969, 1814803222, 1730525723, 1443857720, 1560382517, 1075025698, 1260232239, 575138148, 692707433, 878443390, 1062597235, 243256656, 91341917, 409198410, 325965383, 3403100636, 3252238545, 3704300486, 3620022987, 3874428392, 3990953189, 4042459122, 4227665663, 2460449204, 2578018489, 2226875310, 2411029155, 3198115200, 3046200461, 2827177882, 2743944855];
      U3 = [0, 218828297, 437656594, 387781147, 875313188, 958871085, 775562294, 590424639, 1750626376, 1699970625, 1917742170, 2135253587, 1551124588, 1367295589, 1180849278, 1265195639, 3501252752, 3720081049, 3399941250, 3350065803, 3835484340, 3919042237, 4270507174, 4085369519, 3102249176, 3051593425, 2734591178, 2952102595, 2361698556, 2177869557, 2530391278, 2614737639, 3145456443, 3060847922, 2708326185, 2892417312, 2404901663, 2187128086, 2504130317, 2555048196, 3542330227, 3727205754, 3375740769, 3292445032, 3876557655, 3926170974, 4246310725, 4027744588, 1808481195, 1723872674, 1910319033, 2094410160, 1608975247, 1391201670, 1173430173, 1224348052, 59984867, 244860394, 428169201, 344873464, 935293895, 984907214, 766078933, 547512796, 1844882806, 1627235199, 2011214180, 2062270317, 1507497298, 1423022939, 1137477952, 1321699145, 95345982, 145085239, 532201772, 313773861, 830661914, 1015671571, 731183368, 648017665, 3175501286, 2957853679, 2807058932, 2858115069, 2305455554, 2220981195, 2474404304, 2658625497, 3575528878, 3625268135, 3473416636, 3254988725, 3778151818, 3963161475, 4213447064, 4130281361, 3599595085, 3683022916, 3432737375, 3247465558, 3802222185, 4020912224, 4172763771, 4122762354, 3201631749, 3017672716, 2764249623, 2848461854, 2331590177, 2280796200, 2431590963, 2648976442, 104699613, 188127444, 472615631, 287343814, 840019705, 1058709744, 671593195, 621591778, 1852171925, 1668212892, 1953757831, 2037970062, 1514790577, 1463996600, 1080017571, 1297403050, 3673637356, 3623636965, 3235995134, 3454686199, 4007360968, 3822090177, 4107101658, 4190530515, 2997825956, 3215212461, 2830708150, 2779915199, 2256734592, 2340947849, 2627016082, 2443058075, 172466556, 122466165, 273792366, 492483431, 1047239e3, 861968209, 612205898, 695634755, 1646252340, 1863638845, 2013908262, 1963115311, 1446242576, 1530455833, 1277555970, 1093597963, 1636604631, 1820824798, 2073724613, 1989249228, 1436590835, 1487645946, 1337376481, 1119727848, 164948639, 81781910, 331544205, 516552836, 1039717051, 821288114, 669961897, 719700128, 2973530695, 3157750862, 2871682645, 2787207260, 2232435299, 2283490410, 2667994737, 2450346104, 3647212047, 3564045318, 3279033885, 3464042516, 3980931627, 3762502690, 4150144569, 4199882800, 3070356634, 3121275539, 2904027272, 2686254721, 2200818878, 2384911031, 2570832044, 2486224549, 3747192018, 3528626907, 3310321856, 3359936201, 3950355702, 3867060991, 4049844452, 4234721005, 1739656202, 1790575107, 2108100632, 1890328081, 1402811438, 1586903591, 1233856572, 1149249077, 266959938, 48394827, 369057872, 418672217, 1002783846, 919489135, 567498868, 752375421, 209336225, 24197544, 376187827, 459744698, 945164165, 895287692, 574624663, 793451934, 1679968233, 1764313568, 2117360635, 1933530610, 1343127501, 1560637892, 1243112415, 1192455638, 3704280881, 3519142200, 3336358691, 3419915562, 3907448597, 3857572124, 4075877127, 4294704398, 3029510009, 3113855344, 2927934315, 2744104290, 2159976285, 2377486676, 2594734927, 2544078150];
      U4 = [0, 151849742, 303699484, 454499602, 607398968, 758720310, 908999204, 1059270954, 1214797936, 1097159550, 1517440620, 1400849762, 1817998408, 1699839814, 2118541908, 2001430874, 2429595872, 2581445614, 2194319100, 2345119218, 3034881240, 3186202582, 2801699524, 2951971274, 3635996816, 3518358430, 3399679628, 3283088770, 4237083816, 4118925222, 4002861748, 3885750714, 1002142683, 850817237, 698445255, 548169417, 529487843, 377642221, 227885567, 77089521, 1943217067, 2061379749, 1640576439, 1757691577, 1474760595, 1592394909, 1174215055, 1290801793, 2875968315, 2724642869, 3111247143, 2960971305, 2405426947, 2253581325, 2638606623, 2487810577, 3808662347, 3926825029, 4044981591, 4162096729, 3342319475, 3459953789, 3576539503, 3693126241, 1986918061, 2137062819, 1685577905, 1836772287, 1381620373, 1532285339, 1078185097, 1229899655, 1040559837, 923313619, 740276417, 621982671, 439452389, 322734571, 137073913, 19308535, 3871163981, 4021308739, 4104605777, 4255800159, 3263785589, 3414450555, 3499326569, 3651041127, 2933202493, 2815956275, 3167684641, 3049390895, 2330014213, 2213296395, 2566595609, 2448830231, 1305906550, 1155237496, 1607244650, 1455525988, 1776460110, 1626319424, 2079897426, 1928707164, 96392454, 213114376, 396673818, 514443284, 562755902, 679998e3, 865136418, 983426092, 3708173718, 3557504664, 3474729866, 3323011204, 4180808110, 4030667424, 3945269170, 3794078908, 2507040230, 2623762152, 2272556026, 2390325492, 2975484382, 3092726480, 2738905026, 2857194700, 3973773121, 3856137295, 4274053469, 4157467219, 3371096953, 3252932727, 3673476453, 3556361835, 2763173681, 2915017791, 3064510765, 3215307299, 2156299017, 2307622919, 2459735317, 2610011675, 2081048481, 1963412655, 1846563261, 1729977011, 1480485785, 1362321559, 1243905413, 1126790795, 878845905, 1030690015, 645401037, 796197571, 274084841, 425408743, 38544885, 188821243, 3613494426, 3731654548, 3313212038, 3430322568, 4082475170, 4200115116, 3780097726, 3896688048, 2668221674, 2516901860, 2366882550, 2216610296, 3141400786, 2989552604, 2837966542, 2687165888, 1202797690, 1320957812, 1437280870, 1554391400, 1669664834, 1787304780, 1906247262, 2022837584, 265905162, 114585348, 499347990, 349075736, 736970802, 585122620, 972512814, 821712160, 2595684844, 2478443234, 2293045232, 2174754046, 3196267988, 3079546586, 2895723464, 2777952454, 3537852828, 3687994002, 3234156416, 3385345166, 4142626212, 4293295786, 3841024952, 3992742070, 174567692, 57326082, 410887952, 292596766, 777231668, 660510266, 1011452712, 893681702, 1108339068, 1258480242, 1343618912, 1494807662, 1715193156, 1865862730, 1948373848, 2100090966, 2701949495, 2818666809, 3004591147, 3122358053, 2235061775, 2352307457, 2535604243, 2653899549, 3915653703, 3764988233, 4219352155, 4067639125, 3444575871, 3294430577, 3746175075, 3594982253, 836553431, 953270745, 600235211, 718002117, 367585007, 484830689, 133361907, 251657213, 2041877159, 1891211689, 1806599355, 1654886325, 1568718495, 1418573201, 1335535747, 1184342925];
      AES = class _AES {
        get key() {
          return __classPrivateFieldGet(this, _AES_key, "f").slice();
        }
        constructor(key) {
          _AES_key.set(this, void 0);
          _AES_Kd.set(this, void 0);
          _AES_Ke.set(this, void 0);
          if (!(this instanceof _AES)) {
            throw Error("AES must be instanitated with `new`");
          }
          __classPrivateFieldSet(this, _AES_key, new Uint8Array(key), "f");
          const rounds = numberOfRounds[this.key.length];
          if (rounds == null) {
            throw new TypeError("invalid key size (must be 16, 24 or 32 bytes)");
          }
          __classPrivateFieldSet(this, _AES_Ke, [], "f");
          __classPrivateFieldSet(this, _AES_Kd, [], "f");
          for (let i = 0; i <= rounds; i++) {
            __classPrivateFieldGet(this, _AES_Ke, "f").push([0, 0, 0, 0]);
            __classPrivateFieldGet(this, _AES_Kd, "f").push([0, 0, 0, 0]);
          }
          const roundKeyCount = (rounds + 1) * 4;
          const KC = this.key.length / 4;
          const tk = convertToInt32(this.key);
          let index2;
          for (let i = 0; i < KC; i++) {
            index2 = i >> 2;
            __classPrivateFieldGet(this, _AES_Ke, "f")[index2][i % 4] = tk[i];
            __classPrivateFieldGet(this, _AES_Kd, "f")[rounds - index2][i % 4] = tk[i];
          }
          let rconpointer = 0;
          let t = KC, tt;
          while (t < roundKeyCount) {
            tt = tk[KC - 1];
            tk[0] ^= S[tt >> 16 & 255] << 24 ^ S[tt >> 8 & 255] << 16 ^ S[tt & 255] << 8 ^ S[tt >> 24 & 255] ^ rcon[rconpointer] << 24;
            rconpointer += 1;
            if (KC != 8) {
              for (let i2 = 1; i2 < KC; i2++) {
                tk[i2] ^= tk[i2 - 1];
              }
            } else {
              for (let i2 = 1; i2 < KC / 2; i2++) {
                tk[i2] ^= tk[i2 - 1];
              }
              tt = tk[KC / 2 - 1];
              tk[KC / 2] ^= S[tt & 255] ^ S[tt >> 8 & 255] << 8 ^ S[tt >> 16 & 255] << 16 ^ S[tt >> 24 & 255] << 24;
              for (let i2 = KC / 2 + 1; i2 < KC; i2++) {
                tk[i2] ^= tk[i2 - 1];
              }
            }
            let i = 0, r, c;
            while (i < KC && t < roundKeyCount) {
              r = t >> 2;
              c = t % 4;
              __classPrivateFieldGet(this, _AES_Ke, "f")[r][c] = tk[i];
              __classPrivateFieldGet(this, _AES_Kd, "f")[rounds - r][c] = tk[i++];
              t++;
            }
          }
          for (let r = 1; r < rounds; r++) {
            for (let c = 0; c < 4; c++) {
              tt = __classPrivateFieldGet(this, _AES_Kd, "f")[r][c];
              __classPrivateFieldGet(this, _AES_Kd, "f")[r][c] = U1[tt >> 24 & 255] ^ U2[tt >> 16 & 255] ^ U3[tt >> 8 & 255] ^ U4[tt & 255];
            }
          }
        }
        encrypt(plaintext) {
          if (plaintext.length != 16) {
            throw new TypeError("invalid plaintext size (must be 16 bytes)");
          }
          const rounds = __classPrivateFieldGet(this, _AES_Ke, "f").length - 1;
          const a = [0, 0, 0, 0];
          let t = convertToInt32(plaintext);
          for (let i = 0; i < 4; i++) {
            t[i] ^= __classPrivateFieldGet(this, _AES_Ke, "f")[0][i];
          }
          for (let r = 1; r < rounds; r++) {
            for (let i = 0; i < 4; i++) {
              a[i] = T12[t[i] >> 24 & 255] ^ T2[t[(i + 1) % 4] >> 16 & 255] ^ T3[t[(i + 2) % 4] >> 8 & 255] ^ T4[t[(i + 3) % 4] & 255] ^ __classPrivateFieldGet(this, _AES_Ke, "f")[r][i];
            }
            t = a.slice();
          }
          const result = new Uint8Array(16);
          let tt = 0;
          for (let i = 0; i < 4; i++) {
            tt = __classPrivateFieldGet(this, _AES_Ke, "f")[rounds][i];
            result[4 * i] = (S[t[i] >> 24 & 255] ^ tt >> 24) & 255;
            result[4 * i + 1] = (S[t[(i + 1) % 4] >> 16 & 255] ^ tt >> 16) & 255;
            result[4 * i + 2] = (S[t[(i + 2) % 4] >> 8 & 255] ^ tt >> 8) & 255;
            result[4 * i + 3] = (S[t[(i + 3) % 4] & 255] ^ tt) & 255;
          }
          return result;
        }
        decrypt(ciphertext) {
          if (ciphertext.length != 16) {
            throw new TypeError("invalid ciphertext size (must be 16 bytes)");
          }
          const rounds = __classPrivateFieldGet(this, _AES_Kd, "f").length - 1;
          const a = [0, 0, 0, 0];
          let t = convertToInt32(ciphertext);
          for (let i = 0; i < 4; i++) {
            t[i] ^= __classPrivateFieldGet(this, _AES_Kd, "f")[0][i];
          }
          for (let r = 1; r < rounds; r++) {
            for (let i = 0; i < 4; i++) {
              a[i] = T5[t[i] >> 24 & 255] ^ T6[t[(i + 3) % 4] >> 16 & 255] ^ T7[t[(i + 2) % 4] >> 8 & 255] ^ T8[t[(i + 1) % 4] & 255] ^ __classPrivateFieldGet(this, _AES_Kd, "f")[r][i];
            }
            t = a.slice();
          }
          const result = new Uint8Array(16);
          let tt = 0;
          for (let i = 0; i < 4; i++) {
            tt = __classPrivateFieldGet(this, _AES_Kd, "f")[rounds][i];
            result[4 * i] = (Si[t[i] >> 24 & 255] ^ tt >> 24) & 255;
            result[4 * i + 1] = (Si[t[(i + 3) % 4] >> 16 & 255] ^ tt >> 16) & 255;
            result[4 * i + 2] = (Si[t[(i + 2) % 4] >> 8 & 255] ^ tt >> 8) & 255;
            result[4 * i + 3] = (Si[t[(i + 1) % 4] & 255] ^ tt) & 255;
          }
          return result;
        }
      };
      _AES_key = /* @__PURE__ */ new WeakMap(), _AES_Kd = /* @__PURE__ */ new WeakMap(), _AES_Ke = /* @__PURE__ */ new WeakMap();
    }
  });

  // node_modules/aes-js/lib.esm/mode.js
  var ModeOfOperation;
  var init_mode = __esm({
    "node_modules/aes-js/lib.esm/mode.js"() {
      init_aes();
      ModeOfOperation = class {
        constructor(name, key, cls) {
          if (cls && !(this instanceof cls)) {
            throw new Error(`${name} must be instantiated with "new"`);
          }
          Object.defineProperties(this, {
            aes: { enumerable: true, value: new AES(key) },
            name: { enumerable: true, value: name }
          });
        }
      };
    }
  });

  // node_modules/aes-js/lib.esm/mode-cbc.js
  var __classPrivateFieldSet2, __classPrivateFieldGet2, _CBC_iv, _CBC_lastBlock, CBC;
  var init_mode_cbc = __esm({
    "node_modules/aes-js/lib.esm/mode-cbc.js"() {
      init_mode();
      __classPrivateFieldSet2 = function(receiver, state, value, kind, f2) {
        if (kind === "m") throw new TypeError("Private method is not writable");
        if (kind === "a" && !f2) throw new TypeError("Private accessor was defined without a setter");
        if (typeof state === "function" ? receiver !== state || !f2 : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
        return kind === "a" ? f2.call(receiver, value) : f2 ? f2.value = value : state.set(receiver, value), value;
      };
      __classPrivateFieldGet2 = function(receiver, state, kind, f2) {
        if (kind === "a" && !f2) throw new TypeError("Private accessor was defined without a getter");
        if (typeof state === "function" ? receiver !== state || !f2 : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return kind === "m" ? f2 : kind === "a" ? f2.call(receiver) : f2 ? f2.value : state.get(receiver);
      };
      CBC = class _CBC extends ModeOfOperation {
        constructor(key, iv) {
          super("ECC", key, _CBC);
          _CBC_iv.set(this, void 0);
          _CBC_lastBlock.set(this, void 0);
          if (iv) {
            if (iv.length % 16) {
              throw new TypeError("invalid iv size (must be 16 bytes)");
            }
            __classPrivateFieldSet2(this, _CBC_iv, new Uint8Array(iv), "f");
          } else {
            __classPrivateFieldSet2(this, _CBC_iv, new Uint8Array(16), "f");
          }
          __classPrivateFieldSet2(this, _CBC_lastBlock, this.iv, "f");
        }
        get iv() {
          return new Uint8Array(__classPrivateFieldGet2(this, _CBC_iv, "f"));
        }
        encrypt(plaintext) {
          if (plaintext.length % 16) {
            throw new TypeError("invalid plaintext size (must be multiple of 16 bytes)");
          }
          const ciphertext = new Uint8Array(plaintext.length);
          for (let i = 0; i < plaintext.length; i += 16) {
            for (let j = 0; j < 16; j++) {
              __classPrivateFieldGet2(this, _CBC_lastBlock, "f")[j] ^= plaintext[i + j];
            }
            __classPrivateFieldSet2(this, _CBC_lastBlock, this.aes.encrypt(__classPrivateFieldGet2(this, _CBC_lastBlock, "f")), "f");
            ciphertext.set(__classPrivateFieldGet2(this, _CBC_lastBlock, "f"), i);
          }
          return ciphertext;
        }
        decrypt(ciphertext) {
          if (ciphertext.length % 16) {
            throw new TypeError("invalid ciphertext size (must be multiple of 16 bytes)");
          }
          const plaintext = new Uint8Array(ciphertext.length);
          for (let i = 0; i < ciphertext.length; i += 16) {
            const block = this.aes.decrypt(ciphertext.subarray(i, i + 16));
            for (let j = 0; j < 16; j++) {
              plaintext[i + j] = block[j] ^ __classPrivateFieldGet2(this, _CBC_lastBlock, "f")[j];
              __classPrivateFieldGet2(this, _CBC_lastBlock, "f")[j] = ciphertext[i + j];
            }
          }
          return plaintext;
        }
      };
      _CBC_iv = /* @__PURE__ */ new WeakMap(), _CBC_lastBlock = /* @__PURE__ */ new WeakMap();
    }
  });

  // node_modules/aes-js/lib.esm/mode-cfb.js
  var __classPrivateFieldGet3, _CFB_instances, _CFB_iv, _CFB_shiftRegister, _CFB_shift;
  var init_mode_cfb = __esm({
    "node_modules/aes-js/lib.esm/mode-cfb.js"() {
      init_mode();
      __classPrivateFieldGet3 = function(receiver, state, kind, f2) {
        if (kind === "a" && !f2) throw new TypeError("Private accessor was defined without a getter");
        if (typeof state === "function" ? receiver !== state || !f2 : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return kind === "m" ? f2 : kind === "a" ? f2.call(receiver) : f2 ? f2.value : state.get(receiver);
      };
      _CFB_iv = /* @__PURE__ */ new WeakMap(), _CFB_shiftRegister = /* @__PURE__ */ new WeakMap(), _CFB_instances = /* @__PURE__ */ new WeakSet(), _CFB_shift = function _CFB_shift2(data) {
        const segmentSize = this.segmentSize / 8;
        __classPrivateFieldGet3(this, _CFB_shiftRegister, "f").set(__classPrivateFieldGet3(this, _CFB_shiftRegister, "f").subarray(segmentSize));
        __classPrivateFieldGet3(this, _CFB_shiftRegister, "f").set(data.subarray(0, segmentSize), 16 - segmentSize);
      };
    }
  });

  // node_modules/aes-js/lib.esm/mode-ctr.js
  var __classPrivateFieldSet3, __classPrivateFieldGet4, _CTR_remaining, _CTR_remainingIndex, _CTR_counter, CTR;
  var init_mode_ctr = __esm({
    "node_modules/aes-js/lib.esm/mode-ctr.js"() {
      init_mode();
      __classPrivateFieldSet3 = function(receiver, state, value, kind, f2) {
        if (kind === "m") throw new TypeError("Private method is not writable");
        if (kind === "a" && !f2) throw new TypeError("Private accessor was defined without a setter");
        if (typeof state === "function" ? receiver !== state || !f2 : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
        return kind === "a" ? f2.call(receiver, value) : f2 ? f2.value = value : state.set(receiver, value), value;
      };
      __classPrivateFieldGet4 = function(receiver, state, kind, f2) {
        if (kind === "a" && !f2) throw new TypeError("Private accessor was defined without a getter");
        if (typeof state === "function" ? receiver !== state || !f2 : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return kind === "m" ? f2 : kind === "a" ? f2.call(receiver) : f2 ? f2.value : state.get(receiver);
      };
      CTR = class _CTR extends ModeOfOperation {
        constructor(key, initialValue) {
          super("CTR", key, _CTR);
          _CTR_remaining.set(this, void 0);
          _CTR_remainingIndex.set(this, void 0);
          _CTR_counter.set(this, void 0);
          __classPrivateFieldSet3(this, _CTR_counter, new Uint8Array(16), "f");
          __classPrivateFieldGet4(this, _CTR_counter, "f").fill(0);
          __classPrivateFieldSet3(this, _CTR_remaining, __classPrivateFieldGet4(this, _CTR_counter, "f"), "f");
          __classPrivateFieldSet3(this, _CTR_remainingIndex, 16, "f");
          if (initialValue == null) {
            initialValue = 1;
          }
          if (typeof initialValue === "number") {
            this.setCounterValue(initialValue);
          } else {
            this.setCounterBytes(initialValue);
          }
        }
        get counter() {
          return new Uint8Array(__classPrivateFieldGet4(this, _CTR_counter, "f"));
        }
        setCounterValue(value) {
          if (!Number.isInteger(value) || value < 0 || value > Number.MAX_SAFE_INTEGER) {
            throw new TypeError("invalid counter initial integer value");
          }
          for (let index2 = 15; index2 >= 0; --index2) {
            __classPrivateFieldGet4(this, _CTR_counter, "f")[index2] = value % 256;
            value = Math.floor(value / 256);
          }
        }
        setCounterBytes(value) {
          if (value.length !== 16) {
            throw new TypeError("invalid counter initial Uint8Array value length");
          }
          __classPrivateFieldGet4(this, _CTR_counter, "f").set(value);
        }
        increment() {
          for (let i = 15; i >= 0; i--) {
            if (__classPrivateFieldGet4(this, _CTR_counter, "f")[i] === 255) {
              __classPrivateFieldGet4(this, _CTR_counter, "f")[i] = 0;
            } else {
              __classPrivateFieldGet4(this, _CTR_counter, "f")[i]++;
              break;
            }
          }
        }
        encrypt(plaintext) {
          var _a2, _b;
          const crypttext = new Uint8Array(plaintext);
          for (let i = 0; i < crypttext.length; i++) {
            if (__classPrivateFieldGet4(this, _CTR_remainingIndex, "f") === 16) {
              __classPrivateFieldSet3(this, _CTR_remaining, this.aes.encrypt(__classPrivateFieldGet4(this, _CTR_counter, "f")), "f");
              __classPrivateFieldSet3(this, _CTR_remainingIndex, 0, "f");
              this.increment();
            }
            crypttext[i] ^= __classPrivateFieldGet4(this, _CTR_remaining, "f")[__classPrivateFieldSet3(this, _CTR_remainingIndex, (_b = __classPrivateFieldGet4(this, _CTR_remainingIndex, "f"), _a2 = _b++, _b), "f"), _a2];
          }
          return crypttext;
        }
        decrypt(ciphertext) {
          return this.encrypt(ciphertext);
        }
      };
      _CTR_remaining = /* @__PURE__ */ new WeakMap(), _CTR_remainingIndex = /* @__PURE__ */ new WeakMap(), _CTR_counter = /* @__PURE__ */ new WeakMap();
    }
  });

  // node_modules/aes-js/lib.esm/mode-ecb.js
  var init_mode_ecb = __esm({
    "node_modules/aes-js/lib.esm/mode-ecb.js"() {
      init_mode();
    }
  });

  // node_modules/aes-js/lib.esm/mode-ofb.js
  var _OFB_iv, _OFB_lastPrecipher, _OFB_lastPrecipherIndex;
  var init_mode_ofb = __esm({
    "node_modules/aes-js/lib.esm/mode-ofb.js"() {
      init_mode();
      _OFB_iv = /* @__PURE__ */ new WeakMap(), _OFB_lastPrecipher = /* @__PURE__ */ new WeakMap(), _OFB_lastPrecipherIndex = /* @__PURE__ */ new WeakMap();
    }
  });

  // node_modules/aes-js/lib.esm/padding.js
  function pkcs7Strip(data) {
    if (data.length < 16) {
      throw new TypeError("PKCS#7 invalid length");
    }
    const padder = data[data.length - 1];
    if (padder > 16) {
      throw new TypeError("PKCS#7 padding byte out of range");
    }
    const length = data.length - padder;
    for (let i = 0; i < padder; i++) {
      if (data[length + i] !== padder) {
        throw new TypeError("PKCS#7 invalid padding byte");
      }
    }
    return new Uint8Array(data.subarray(0, length));
  }
  var init_padding = __esm({
    "node_modules/aes-js/lib.esm/padding.js"() {
    }
  });

  // node_modules/aes-js/lib.esm/index.js
  var init_lib = __esm({
    "node_modules/aes-js/lib.esm/index.js"() {
      init_aes();
      init_mode();
      init_mode_cbc();
      init_mode_cfb();
      init_mode_ctr();
      init_mode_ecb();
      init_mode_ofb();
      init_padding();
    }
  });

  // node_modules/ethers/lib.esm/wallet/utils.js
  function looseArrayify(hexString) {
    if (typeof hexString === "string" && !hexString.startsWith("0x")) {
      hexString = "0x" + hexString;
    }
    return getBytesCopy(hexString);
  }
  function zpad(value, length) {
    value = String(value);
    while (value.length < length) {
      value = "0" + value;
    }
    return value;
  }
  function getPassword(password) {
    if (typeof password === "string") {
      return toUtf8Bytes(password, "NFKC");
    }
    return getBytesCopy(password);
  }
  function spelunk(object2, _path) {
    const match = _path.match(/^([a-z0-9$_.-]*)(:([a-z]+))?(!)?$/i);
    assertArgument(match != null, "invalid path", "path", _path);
    const path = match[1];
    const type = match[3];
    const reqd = match[4] === "!";
    let cur = object2;
    for (const comp of path.toLowerCase().split(".")) {
      if (Array.isArray(cur)) {
        if (!comp.match(/^[0-9]+$/)) {
          break;
        }
        cur = cur[parseInt(comp)];
      } else if (typeof cur === "object") {
        let found = null;
        for (const key in cur) {
          if (key.toLowerCase() === comp) {
            found = cur[key];
            break;
          }
        }
        cur = found;
      } else {
        cur = null;
      }
      if (cur == null) {
        break;
      }
    }
    assertArgument(!reqd || cur != null, "missing required value", "path", path);
    if (type && cur != null) {
      if (type === "int") {
        if (typeof cur === "string" && cur.match(/^-?[0-9]+$/)) {
          return parseInt(cur);
        } else if (Number.isSafeInteger(cur)) {
          return cur;
        }
      }
      if (type === "number") {
        if (typeof cur === "string" && cur.match(/^-?[0-9.]*$/)) {
          return parseFloat(cur);
        }
      }
      if (type === "data") {
        if (typeof cur === "string") {
          return looseArrayify(cur);
        }
      }
      if (type === "array" && Array.isArray(cur)) {
        return cur;
      }
      if (type === typeof cur) {
        return cur;
      }
      assertArgument(false, `wrong type found for ${type} `, "path", path);
    }
    return cur;
  }
  var init_utils4 = __esm({
    "node_modules/ethers/lib.esm/wallet/utils.js"() {
      init_utils();
    }
  });

  // node_modules/ethers/lib.esm/wallet/json-keystore.js
  function isKeystoreJson(json) {
    try {
      const data = JSON.parse(json);
      const version5 = data.version != null ? parseInt(data.version) : 0;
      if (version5 === 3) {
        return true;
      }
    } catch (error) {
    }
    return false;
  }
  function decrypt(data, key, ciphertext) {
    const cipher = spelunk(data, "crypto.cipher:string");
    if (cipher === "aes-128-ctr") {
      const iv = spelunk(data, "crypto.cipherparams.iv:data!");
      const aesCtr = new CTR(key, iv);
      return hexlify(aesCtr.decrypt(ciphertext));
    }
    assert(false, "unsupported cipher", "UNSUPPORTED_OPERATION", {
      operation: "decrypt"
    });
  }
  function getAccount(data, _key) {
    const key = getBytes(_key);
    const ciphertext = spelunk(data, "crypto.ciphertext:data!");
    const computedMAC = hexlify(keccak256(concat([key.slice(16, 32), ciphertext]))).substring(2);
    assertArgument(computedMAC === spelunk(data, "crypto.mac:string!").toLowerCase(), "incorrect password", "password", "[ REDACTED ]");
    const privateKey = decrypt(data, key.slice(0, 16), ciphertext);
    const address = computeAddress(privateKey);
    if (data.address) {
      let check = data.address.toLowerCase();
      if (!check.startsWith("0x")) {
        check = "0x" + check;
      }
      assertArgument(getAddress(check) === address, "keystore address/privateKey mismatch", "address", data.address);
    }
    const account = { address, privateKey };
    const version5 = spelunk(data, "x-ethers.version:string");
    if (version5 === "0.1") {
      const mnemonicKey = key.slice(32, 64);
      const mnemonicCiphertext = spelunk(data, "x-ethers.mnemonicCiphertext:data!");
      const mnemonicIv = spelunk(data, "x-ethers.mnemonicCounter:data!");
      const mnemonicAesCtr = new CTR(mnemonicKey, mnemonicIv);
      account.mnemonic = {
        path: spelunk(data, "x-ethers.path:string") || defaultPath,
        locale: spelunk(data, "x-ethers.locale:string") || "en",
        entropy: hexlify(getBytes(mnemonicAesCtr.decrypt(mnemonicCiphertext)))
      };
    }
    return account;
  }
  function getDecryptKdfParams(data) {
    const kdf = spelunk(data, "crypto.kdf:string");
    if (kdf && typeof kdf === "string") {
      if (kdf.toLowerCase() === "scrypt") {
        const salt = spelunk(data, "crypto.kdfparams.salt:data!");
        const N3 = spelunk(data, "crypto.kdfparams.n:int!");
        const r = spelunk(data, "crypto.kdfparams.r:int!");
        const p = spelunk(data, "crypto.kdfparams.p:int!");
        assertArgument(N3 > 0 && (N3 & N3 - 1) === 0, "invalid kdf.N", "kdf.N", N3);
        assertArgument(r > 0 && p > 0, "invalid kdf", "kdf", kdf);
        const dkLen = spelunk(data, "crypto.kdfparams.dklen:int!");
        assertArgument(dkLen === 32, "invalid kdf.dklen", "kdf.dflen", dkLen);
        return { name: "scrypt", salt, N: N3, r, p, dkLen: 64 };
      } else if (kdf.toLowerCase() === "pbkdf2") {
        const salt = spelunk(data, "crypto.kdfparams.salt:data!");
        const prf = spelunk(data, "crypto.kdfparams.prf:string!");
        const algorithm = prf.split("-").pop();
        assertArgument(algorithm === "sha256" || algorithm === "sha512", "invalid kdf.pdf", "kdf.pdf", prf);
        const count = spelunk(data, "crypto.kdfparams.c:int!");
        const dkLen = spelunk(data, "crypto.kdfparams.dklen:int!");
        assertArgument(dkLen === 32, "invalid kdf.dklen", "kdf.dklen", dkLen);
        return { name: "pbkdf2", salt, count, dkLen, algorithm };
      }
    }
    assertArgument(false, "unsupported key-derivation function", "kdf", kdf);
  }
  function decryptKeystoreJsonSync(json, _password) {
    const data = JSON.parse(json);
    const password = getPassword(_password);
    const params = getDecryptKdfParams(data);
    if (params.name === "pbkdf2") {
      const { salt: salt2, count, dkLen: dkLen2, algorithm } = params;
      const key2 = pbkdf22(password, salt2, count, dkLen2, algorithm);
      return getAccount(data, key2);
    }
    assert(params.name === "scrypt", "cannot be reached", "UNKNOWN_ERROR", { params });
    const { salt, N: N3, r, p, dkLen } = params;
    const key = scryptSync(password, salt, N3, r, p, dkLen);
    return getAccount(data, key);
  }
  function stall3(duration) {
    return new Promise((resolve) => {
      setTimeout(() => {
        resolve();
      }, duration);
    });
  }
  async function decryptKeystoreJson(json, _password, progress) {
    const data = JSON.parse(json);
    const password = getPassword(_password);
    const params = getDecryptKdfParams(data);
    if (params.name === "pbkdf2") {
      if (progress) {
        progress(0);
        await stall3(0);
      }
      const { salt: salt2, count, dkLen: dkLen2, algorithm } = params;
      const key2 = pbkdf22(password, salt2, count, dkLen2, algorithm);
      if (progress) {
        progress(1);
        await stall3(0);
      }
      return getAccount(data, key2);
    }
    assert(params.name === "scrypt", "cannot be reached", "UNKNOWN_ERROR", { params });
    const { salt, N: N3, r, p, dkLen } = params;
    const key = await scrypt2(password, salt, N3, r, p, dkLen, progress);
    return getAccount(data, key);
  }
  function getEncryptKdfParams(options) {
    const salt = options.salt != null ? getBytes(options.salt, "options.salt") : randomBytes3(32);
    let N3 = 1 << 17, r = 8, p = 1;
    if (options.scrypt) {
      if (options.scrypt.N) {
        N3 = options.scrypt.N;
      }
      if (options.scrypt.r) {
        r = options.scrypt.r;
      }
      if (options.scrypt.p) {
        p = options.scrypt.p;
      }
    }
    assertArgument(typeof N3 === "number" && N3 > 0 && Number.isSafeInteger(N3) && (BigInt(N3) & BigInt(N3 - 1)) === BigInt(0), "invalid scrypt N parameter", "options.N", N3);
    assertArgument(typeof r === "number" && r > 0 && Number.isSafeInteger(r), "invalid scrypt r parameter", "options.r", r);
    assertArgument(typeof p === "number" && p > 0 && Number.isSafeInteger(p), "invalid scrypt p parameter", "options.p", p);
    return { name: "scrypt", dkLen: 32, salt, N: N3, r, p };
  }
  function _encryptKeystore(key, kdf, account, options) {
    const privateKey = getBytes(account.privateKey, "privateKey");
    const iv = options.iv != null ? getBytes(options.iv, "options.iv") : randomBytes3(16);
    assertArgument(iv.length === 16, "invalid options.iv length", "options.iv", options.iv);
    const uuidRandom = options.uuid != null ? getBytes(options.uuid, "options.uuid") : randomBytes3(16);
    assertArgument(uuidRandom.length === 16, "invalid options.uuid length", "options.uuid", options.iv);
    const derivedKey = key.slice(0, 16);
    const macPrefix = key.slice(16, 32);
    const aesCtr = new CTR(derivedKey, iv);
    const ciphertext = getBytes(aesCtr.encrypt(privateKey));
    const mac = keccak256(concat([macPrefix, ciphertext]));
    const data = {
      address: account.address.substring(2).toLowerCase(),
      id: uuidV4(uuidRandom),
      version: 3,
      Crypto: {
        cipher: "aes-128-ctr",
        cipherparams: {
          iv: hexlify(iv).substring(2)
        },
        ciphertext: hexlify(ciphertext).substring(2),
        kdf: "scrypt",
        kdfparams: {
          salt: hexlify(kdf.salt).substring(2),
          n: kdf.N,
          dklen: 32,
          p: kdf.p,
          r: kdf.r
        },
        mac: mac.substring(2)
      }
    };
    if (account.mnemonic) {
      const client = options.client != null ? options.client : `ethers/${version}`;
      const path = account.mnemonic.path || defaultPath;
      const locale = account.mnemonic.locale || "en";
      const mnemonicKey = key.slice(32, 64);
      const entropy = getBytes(account.mnemonic.entropy, "account.mnemonic.entropy");
      const mnemonicIv = randomBytes3(16);
      const mnemonicAesCtr = new CTR(mnemonicKey, mnemonicIv);
      const mnemonicCiphertext = getBytes(mnemonicAesCtr.encrypt(entropy));
      const now = /* @__PURE__ */ new Date();
      const timestamp = now.getUTCFullYear() + "-" + zpad(now.getUTCMonth() + 1, 2) + "-" + zpad(now.getUTCDate(), 2) + "T" + zpad(now.getUTCHours(), 2) + "-" + zpad(now.getUTCMinutes(), 2) + "-" + zpad(now.getUTCSeconds(), 2) + ".0Z";
      const gethFilename = "UTC--" + timestamp + "--" + data.address;
      data["x-ethers"] = {
        client,
        gethFilename,
        path,
        locale,
        mnemonicCounter: hexlify(mnemonicIv).substring(2),
        mnemonicCiphertext: hexlify(mnemonicCiphertext).substring(2),
        version: "0.1"
      };
    }
    return JSON.stringify(data);
  }
  function encryptKeystoreJsonSync(account, password, options) {
    if (options == null) {
      options = {};
    }
    const passwordBytes = getPassword(password);
    const kdf = getEncryptKdfParams(options);
    const key = scryptSync(passwordBytes, kdf.salt, kdf.N, kdf.r, kdf.p, 64);
    return _encryptKeystore(getBytes(key), kdf, account, options);
  }
  async function encryptKeystoreJson(account, password, options) {
    if (options == null) {
      options = {};
    }
    const passwordBytes = getPassword(password);
    const kdf = getEncryptKdfParams(options);
    const key = await scrypt2(passwordBytes, kdf.salt, kdf.N, kdf.r, kdf.p, 64, options.progressCallback);
    return _encryptKeystore(getBytes(key), kdf, account, options);
  }
  var defaultPath;
  var init_json_keystore = __esm({
    "node_modules/ethers/lib.esm/wallet/json-keystore.js"() {
      init_lib();
      init_address2();
      init_crypto2();
      init_transaction2();
      init_utils();
      init_utils4();
      init_version();
      defaultPath = "m/44'/60'/0'/0/0";
    }
  });

  // node_modules/ethers/lib.esm/wallet/hdwallet.js
  function zpad2(value, length) {
    let result = "";
    while (value) {
      result = Nibbles2[value % 16] + result;
      value = Math.trunc(value / 16);
    }
    while (result.length < length * 2) {
      result = "0" + result;
    }
    return "0x" + result;
  }
  function encodeBase58Check(_value2) {
    const value = getBytes(_value2);
    const check = dataSlice(sha2562(sha2562(value)), 0, 4);
    const bytes2 = concat([value, check]);
    return encodeBase58(bytes2);
  }
  function ser_I(index2, chainCode, publicKey, privateKey) {
    const data = new Uint8Array(37);
    if (index2 & HardenedBit) {
      assert(privateKey != null, "cannot derive child of neutered node", "UNSUPPORTED_OPERATION", {
        operation: "deriveChild"
      });
      data.set(getBytes(privateKey), 1);
    } else {
      data.set(getBytes(publicKey));
    }
    for (let i = 24; i >= 0; i -= 8) {
      data[33 + (i >> 3)] = index2 >> 24 - i & 255;
    }
    const I = getBytes(computeHmac("sha512", chainCode, data));
    return { IL: I.slice(0, 32), IR: I.slice(32) };
  }
  function derivePath(node, path) {
    const components = path.split("/");
    assertArgument(components.length > 0, "invalid path", "path", path);
    if (components[0] === "m") {
      assertArgument(node.depth === 0, `cannot derive root path (i.e. path starting with "m/") for a node at non-zero depth ${node.depth}`, "path", path);
      components.shift();
    }
    let result = node;
    for (let i = 0; i < components.length; i++) {
      const component = components[i];
      if (component.match(/^[0-9]+'$/)) {
        const index2 = parseInt(component.substring(0, component.length - 1));
        assertArgument(index2 < HardenedBit, "invalid path index", `path[${i}]`, component);
        result = result.deriveChild(HardenedBit + index2);
      } else if (component.match(/^[0-9]+$/)) {
        const index2 = parseInt(component);
        assertArgument(index2 < HardenedBit, "invalid path index", `path[${i}]`, component);
        result = result.deriveChild(index2);
      } else {
        assertArgument(false, "invalid path component", `path[${i}]`, component);
      }
    }
    return result;
  }
  function getAccountPath(_index) {
    const index2 = getNumber(_index, "index");
    assertArgument(index2 >= 0 && index2 < HardenedBit, "invalid account index", "index", index2);
    return `m/44'/60'/${index2}'/0/0`;
  }
  function getIndexedAccountPath(_index) {
    const index2 = getNumber(_index, "index");
    assertArgument(index2 >= 0 && index2 < HardenedBit, "invalid account index", "index", index2);
    return `m/44'/60'/0'/0/${index2}`;
  }
  var defaultPath2, MasterSecret, HardenedBit, N2, Nibbles2, _guard6, _HDNodeWallet_instances, account_fn, _HDNodeWallet_static, fromSeed_fn, _HDNodeWallet, HDNodeWallet, HDNodeVoidWallet;
  var init_hdwallet = __esm({
    "node_modules/ethers/lib.esm/wallet/hdwallet.js"() {
      init_crypto2();
      init_providers();
      init_transaction2();
      init_utils();
      init_lang_en();
      init_base_wallet();
      init_mnemonic();
      init_json_keystore();
      defaultPath2 = "m/44'/60'/0'/0/0";
      MasterSecret = new Uint8Array([66, 105, 116, 99, 111, 105, 110, 32, 115, 101, 101, 100]);
      HardenedBit = 2147483648;
      N2 = BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141");
      Nibbles2 = "0123456789abcdef";
      _guard6 = {};
      _HDNodeWallet = class _HDNodeWallet extends BaseWallet {
        /**
         *  @private
         */
        constructor(guard, signingKey, parentFingerprint, chainCode, path, index2, depth, mnemonic, provider) {
          super(signingKey, provider);
          __privateAdd(this, _HDNodeWallet_instances);
          /**
           *  The compressed public key.
           */
          __publicField(this, "publicKey");
          /**
           *  The fingerprint.
           *
           *  A fingerprint allows quick qay to detect parent and child nodes,
           *  but developers should be prepared to deal with collisions as it
           *  is only 4 bytes.
           */
          __publicField(this, "fingerprint");
          /**
           *  The parent fingerprint.
           */
          __publicField(this, "parentFingerprint");
          /**
           *  The mnemonic used to create this HD Node, if available.
           *
           *  Sources such as extended keys do not encode the mnemonic, in
           *  which case this will be ``null``.
           */
          __publicField(this, "mnemonic");
          /**
           *  The chaincode, which is effectively a public key used
           *  to derive children.
           */
          __publicField(this, "chainCode");
          /**
           *  The derivation path of this wallet.
           *
           *  Since extended keys do not provide full path details, this
           *  may be ``null``, if instantiated from a source that does not
           *  encode it.
           */
          __publicField(this, "path");
          /**
           *  The child index of this wallet. Values over ``2 *\* 31`` indicate
           *  the node is hardened.
           */
          __publicField(this, "index");
          /**
           *  The depth of this wallet, which is the number of components
           *  in its path.
           */
          __publicField(this, "depth");
          assertPrivate(guard, _guard6, "HDNodeWallet");
          defineProperties(this, { publicKey: signingKey.compressedPublicKey });
          const fingerprint = dataSlice(ripemd1602(sha2562(this.publicKey)), 0, 4);
          defineProperties(this, {
            parentFingerprint,
            fingerprint,
            chainCode,
            path,
            index: index2,
            depth
          });
          defineProperties(this, { mnemonic });
        }
        connect(provider) {
          return new _HDNodeWallet(_guard6, this.signingKey, this.parentFingerprint, this.chainCode, this.path, this.index, this.depth, this.mnemonic, provider);
        }
        /**
         *  Resolves to a [JSON Keystore Wallet](json-wallets) encrypted with
         *  %%password%%.
         *
         *  If %%progressCallback%% is specified, it will receive periodic
         *  updates as the encryption process progreses.
         */
        async encrypt(password, progressCallback) {
          return await encryptKeystoreJson(__privateMethod(this, _HDNodeWallet_instances, account_fn).call(this), password, { progressCallback });
        }
        /**
         *  Returns a [JSON Keystore Wallet](json-wallets) encryped with
         *  %%password%%.
         *
         *  It is preferred to use the [async version](encrypt) instead,
         *  which allows a [[ProgressCallback]] to keep the user informed.
         *
         *  This method will block the event loop (freezing all UI) until
         *  it is complete, which may be a non-trivial duration.
         */
        encryptSync(password) {
          return encryptKeystoreJsonSync(__privateMethod(this, _HDNodeWallet_instances, account_fn).call(this), password);
        }
        /**
         *  The extended key.
         *
         *  This key will begin with the prefix ``xpriv`` and can be used to
         *  reconstruct this HD Node to derive its children.
         */
        get extendedKey() {
          assert(this.depth < 256, "Depth too deep", "UNSUPPORTED_OPERATION", { operation: "extendedKey" });
          return encodeBase58Check(concat([
            "0x0488ADE4",
            zpad2(this.depth, 1),
            this.parentFingerprint,
            zpad2(this.index, 4),
            this.chainCode,
            concat(["0x00", this.privateKey])
          ]));
        }
        /**
         *  Returns true if this wallet has a path, providing a Type Guard
         *  that the path is non-null.
         */
        hasPath() {
          return this.path != null;
        }
        /**
         *  Returns a neutered HD Node, which removes the private details
         *  of an HD Node.
         *
         *  A neutered node has no private key, but can be used to derive
         *  child addresses and other public data about the HD Node.
         */
        neuter() {
          return new HDNodeVoidWallet(_guard6, this.address, this.publicKey, this.parentFingerprint, this.chainCode, this.path, this.index, this.depth, this.provider);
        }
        /**
         *  Return the child for %%index%%.
         */
        deriveChild(_index) {
          const index2 = getNumber(_index, "index");
          assertArgument(index2 <= 4294967295, "invalid index", "index", index2);
          let path = this.path;
          if (path) {
            path += "/" + (index2 & ~HardenedBit);
            if (index2 & HardenedBit) {
              path += "'";
            }
          }
          const { IR, IL } = ser_I(index2, this.chainCode, this.publicKey, this.privateKey);
          const ki = new SigningKey(toBeHex((toBigInt(IL) + BigInt(this.privateKey)) % N2, 32));
          return new _HDNodeWallet(_guard6, ki, this.fingerprint, hexlify(IR), path, index2, this.depth + 1, this.mnemonic, this.provider);
        }
        /**
         *  Return the HDNode for %%path%% from this node.
         */
        derivePath(path) {
          return derivePath(this, path);
        }
        /**
         *  Creates a new HD Node from %%extendedKey%%.
         *
         *  If the %%extendedKey%% will either have a prefix or ``xpub`` or
         *  ``xpriv``, returning a neutered HD Node ([[HDNodeVoidWallet]])
         *  or full HD Node ([[HDNodeWallet) respectively.
         */
        static fromExtendedKey(extendedKey) {
          const bytes2 = toBeArray(decodeBase58(extendedKey));
          assertArgument(bytes2.length === 82 || encodeBase58Check(bytes2.slice(0, 78)) === extendedKey, "invalid extended key", "extendedKey", "[ REDACTED ]");
          const depth = bytes2[4];
          const parentFingerprint = hexlify(bytes2.slice(5, 9));
          const index2 = parseInt(hexlify(bytes2.slice(9, 13)).substring(2), 16);
          const chainCode = hexlify(bytes2.slice(13, 45));
          const key = bytes2.slice(45, 78);
          switch (hexlify(bytes2.slice(0, 4))) {
            // Public Key
            case "0x0488b21e":
            case "0x043587cf": {
              const publicKey = hexlify(key);
              return new HDNodeVoidWallet(_guard6, computeAddress(publicKey), publicKey, parentFingerprint, chainCode, null, index2, depth, null);
            }
            // Private Key
            case "0x0488ade4":
            case "0x04358394 ":
              if (key[0] !== 0) {
                break;
              }
              return new _HDNodeWallet(_guard6, new SigningKey(key.slice(1)), parentFingerprint, chainCode, null, index2, depth, null, null);
          }
          assertArgument(false, "invalid extended key prefix", "extendedKey", "[ REDACTED ]");
        }
        /**
         *  Creates a new random HDNode.
         */
        static createRandom(password, path, wordlist2) {
          var _a2;
          if (password == null) {
            password = "";
          }
          if (path == null) {
            path = defaultPath2;
          }
          if (wordlist2 == null) {
            wordlist2 = LangEn.wordlist();
          }
          const mnemonic = Mnemonic.fromEntropy(randomBytes3(16), password, wordlist2);
          return __privateMethod(_a2 = _HDNodeWallet, _HDNodeWallet_static, fromSeed_fn).call(_a2, mnemonic.computeSeed(), mnemonic).derivePath(path);
        }
        /**
         *  Create an HD Node from %%mnemonic%%.
         */
        static fromMnemonic(mnemonic, path) {
          var _a2;
          if (!path) {
            path = defaultPath2;
          }
          return __privateMethod(_a2 = _HDNodeWallet, _HDNodeWallet_static, fromSeed_fn).call(_a2, mnemonic.computeSeed(), mnemonic).derivePath(path);
        }
        /**
         *  Creates an HD Node from a mnemonic %%phrase%%.
         */
        static fromPhrase(phrase, password, path, wordlist2) {
          var _a2;
          if (password == null) {
            password = "";
          }
          if (path == null) {
            path = defaultPath2;
          }
          if (wordlist2 == null) {
            wordlist2 = LangEn.wordlist();
          }
          const mnemonic = Mnemonic.fromPhrase(phrase, password, wordlist2);
          return __privateMethod(_a2 = _HDNodeWallet, _HDNodeWallet_static, fromSeed_fn).call(_a2, mnemonic.computeSeed(), mnemonic).derivePath(path);
        }
        /**
         *  Creates an HD Node from a %%seed%%.
         */
        static fromSeed(seed) {
          var _a2;
          return __privateMethod(_a2 = _HDNodeWallet, _HDNodeWallet_static, fromSeed_fn).call(_a2, seed, null);
        }
      };
      _HDNodeWallet_instances = new WeakSet();
      account_fn = function() {
        const account = { address: this.address, privateKey: this.privateKey };
        const m = this.mnemonic;
        if (this.path && m && m.wordlist.locale === "en" && m.password === "") {
          account.mnemonic = {
            path: this.path,
            locale: "en",
            entropy: m.entropy
          };
        }
        return account;
      };
      _HDNodeWallet_static = new WeakSet();
      fromSeed_fn = function(_seed, mnemonic) {
        assertArgument(isBytesLike(_seed), "invalid seed", "seed", "[REDACTED]");
        const seed = getBytes(_seed, "seed");
        assertArgument(seed.length >= 16 && seed.length <= 64, "invalid seed", "seed", "[REDACTED]");
        const I = getBytes(computeHmac("sha512", MasterSecret, seed));
        const signingKey = new SigningKey(hexlify(I.slice(0, 32)));
        return new _HDNodeWallet(_guard6, signingKey, "0x00000000", hexlify(I.slice(32)), "m", 0, 0, mnemonic, null);
      };
      __privateAdd(_HDNodeWallet, _HDNodeWallet_static);
      HDNodeWallet = _HDNodeWallet;
      HDNodeVoidWallet = class _HDNodeVoidWallet extends VoidSigner {
        /**
         *  @private
         */
        constructor(guard, address, publicKey, parentFingerprint, chainCode, path, index2, depth, provider) {
          super(address, provider);
          /**
           *  The compressed public key.
           */
          __publicField(this, "publicKey");
          /**
           *  The fingerprint.
           *
           *  A fingerprint allows quick qay to detect parent and child nodes,
           *  but developers should be prepared to deal with collisions as it
           *  is only 4 bytes.
           */
          __publicField(this, "fingerprint");
          /**
           *  The parent node fingerprint.
           */
          __publicField(this, "parentFingerprint");
          /**
           *  The chaincode, which is effectively a public key used
           *  to derive children.
           */
          __publicField(this, "chainCode");
          /**
           *  The derivation path of this wallet.
           *
           *  Since extended keys do not provider full path details, this
           *  may be ``null``, if instantiated from a source that does not
           *  enocde it.
           */
          __publicField(this, "path");
          /**
           *  The child index of this wallet. Values over ``2 *\* 31`` indicate
           *  the node is hardened.
           */
          __publicField(this, "index");
          /**
           *  The depth of this wallet, which is the number of components
           *  in its path.
           */
          __publicField(this, "depth");
          assertPrivate(guard, _guard6, "HDNodeVoidWallet");
          defineProperties(this, { publicKey });
          const fingerprint = dataSlice(ripemd1602(sha2562(publicKey)), 0, 4);
          defineProperties(this, {
            publicKey,
            fingerprint,
            parentFingerprint,
            chainCode,
            path,
            index: index2,
            depth
          });
        }
        connect(provider) {
          return new _HDNodeVoidWallet(_guard6, this.address, this.publicKey, this.parentFingerprint, this.chainCode, this.path, this.index, this.depth, provider);
        }
        /**
         *  The extended key.
         *
         *  This key will begin with the prefix ``xpub`` and can be used to
         *  reconstruct this neutered key to derive its children addresses.
         */
        get extendedKey() {
          assert(this.depth < 256, "Depth too deep", "UNSUPPORTED_OPERATION", { operation: "extendedKey" });
          return encodeBase58Check(concat([
            "0x0488B21E",
            zpad2(this.depth, 1),
            this.parentFingerprint,
            zpad2(this.index, 4),
            this.chainCode,
            this.publicKey
          ]));
        }
        /**
         *  Returns true if this wallet has a path, providing a Type Guard
         *  that the path is non-null.
         */
        hasPath() {
          return this.path != null;
        }
        /**
         *  Return the child for %%index%%.
         */
        deriveChild(_index) {
          const index2 = getNumber(_index, "index");
          assertArgument(index2 <= 4294967295, "invalid index", "index", index2);
          let path = this.path;
          if (path) {
            path += "/" + (index2 & ~HardenedBit);
            if (index2 & HardenedBit) {
              path += "'";
            }
          }
          const { IR, IL } = ser_I(index2, this.chainCode, this.publicKey, null);
          const Ki = SigningKey.addPoints(IL, this.publicKey, true);
          const address = computeAddress(Ki);
          return new _HDNodeVoidWallet(_guard6, address, Ki, this.fingerprint, hexlify(IR), path, index2, this.depth + 1, this.provider);
        }
        /**
         *  Return the signer for %%path%% from this node.
         */
        derivePath(path) {
          return derivePath(this, path);
        }
      };
    }
  });

  // node_modules/ethers/lib.esm/wallet/json-crowdsale.js
  function isCrowdsaleJson(json) {
    try {
      const data = JSON.parse(json);
      if (data.encseed) {
        return true;
      }
    } catch (error) {
    }
    return false;
  }
  function decryptCrowdsaleJson(json, _password) {
    const data = JSON.parse(json);
    const password = getPassword(_password);
    const address = getAddress(spelunk(data, "ethaddr:string!"));
    const encseed = looseArrayify(spelunk(data, "encseed:string!"));
    assertArgument(encseed && encseed.length % 16 === 0, "invalid encseed", "json", json);
    const key = getBytes(pbkdf22(password, password, 2e3, 32, "sha256")).slice(0, 16);
    const iv = encseed.slice(0, 16);
    const encryptedSeed = encseed.slice(16);
    const aesCbc = new CBC(key, iv);
    const seed = pkcs7Strip(getBytes(aesCbc.decrypt(encryptedSeed)));
    let seedHex = "";
    for (let i = 0; i < seed.length; i++) {
      seedHex += String.fromCharCode(seed[i]);
    }
    return { address, privateKey: id(seedHex) };
  }
  var init_json_crowdsale = __esm({
    "node_modules/ethers/lib.esm/wallet/json-crowdsale.js"() {
      init_lib();
      init_address2();
      init_crypto2();
      init_hash();
      init_utils();
      init_utils4();
    }
  });

  // node_modules/ethers/lib.esm/wallet/wallet.js
  function stall4(duration) {
    return new Promise((resolve) => {
      setTimeout(() => {
        resolve();
      }, duration);
    });
  }
  var _Wallet_static, fromAccount_fn, _Wallet, Wallet;
  var init_wallet = __esm({
    "node_modules/ethers/lib.esm/wallet/wallet.js"() {
      init_crypto2();
      init_utils();
      init_base_wallet();
      init_hdwallet();
      init_json_crowdsale();
      init_json_keystore();
      init_mnemonic();
      _Wallet = class _Wallet extends BaseWallet {
        /**
         *  Create a new wallet for the private %%key%%, optionally connected
         *  to %%provider%%.
         */
        constructor(key, provider) {
          if (typeof key === "string" && !key.startsWith("0x")) {
            key = "0x" + key;
          }
          let signingKey = typeof key === "string" ? new SigningKey(key) : key;
          super(signingKey, provider);
        }
        connect(provider) {
          return new _Wallet(this.signingKey, provider);
        }
        /**
         *  Resolves to a [JSON Keystore Wallet](json-wallets) encrypted with
         *  %%password%%.
         *
         *  If %%progressCallback%% is specified, it will receive periodic
         *  updates as the encryption process progreses.
         */
        async encrypt(password, progressCallback) {
          const account = { address: this.address, privateKey: this.privateKey };
          return await encryptKeystoreJson(account, password, { progressCallback });
        }
        /**
         *  Returns a [JSON Keystore Wallet](json-wallets) encryped with
         *  %%password%%.
         *
         *  It is preferred to use the [async version](encrypt) instead,
         *  which allows a [[ProgressCallback]] to keep the user informed.
         *
         *  This method will block the event loop (freezing all UI) until
         *  it is complete, which may be a non-trivial duration.
         */
        encryptSync(password) {
          const account = { address: this.address, privateKey: this.privateKey };
          return encryptKeystoreJsonSync(account, password);
        }
        /**
         *  Creates (asynchronously) a **Wallet** by decrypting the %%json%%
         *  with %%password%%.
         *
         *  If %%progress%% is provided, it is called periodically during
         *  decryption so that any UI can be updated.
         */
        static async fromEncryptedJson(json, password, progress) {
          var _a2;
          let account = null;
          if (isKeystoreJson(json)) {
            account = await decryptKeystoreJson(json, password, progress);
          } else if (isCrowdsaleJson(json)) {
            if (progress) {
              progress(0);
              await stall4(0);
            }
            account = decryptCrowdsaleJson(json, password);
            if (progress) {
              progress(1);
              await stall4(0);
            }
          }
          return __privateMethod(_a2 = _Wallet, _Wallet_static, fromAccount_fn).call(_a2, account);
        }
        /**
         *  Creates a **Wallet** by decrypting the %%json%% with %%password%%.
         *
         *  The [[fromEncryptedJson]] method is preferred, as this method
         *  will lock up and freeze the UI during decryption, which may take
         *  some time.
         */
        static fromEncryptedJsonSync(json, password) {
          var _a2;
          let account = null;
          if (isKeystoreJson(json)) {
            account = decryptKeystoreJsonSync(json, password);
          } else if (isCrowdsaleJson(json)) {
            account = decryptCrowdsaleJson(json, password);
          } else {
            assertArgument(false, "invalid JSON wallet", "json", "[ REDACTED ]");
          }
          return __privateMethod(_a2 = _Wallet, _Wallet_static, fromAccount_fn).call(_a2, account);
        }
        /**
         *  Creates a new random [[HDNodeWallet]] using the available
         *  [cryptographic random source](randomBytes).
         *
         *  If there is no crytographic random source, this will throw.
         */
        static createRandom(provider) {
          const wallet = HDNodeWallet.createRandom();
          if (provider) {
            return wallet.connect(provider);
          }
          return wallet;
        }
        /**
         *  Creates a [[HDNodeWallet]] for %%phrase%%.
         */
        static fromPhrase(phrase, provider) {
          const wallet = HDNodeWallet.fromPhrase(phrase);
          if (provider) {
            return wallet.connect(provider);
          }
          return wallet;
        }
      };
      _Wallet_static = new WeakSet();
      fromAccount_fn = function(account) {
        assertArgument(account, "invalid JSON wallet", "json", "[ REDACTED ]");
        if ("mnemonic" in account && account.mnemonic && account.mnemonic.locale === "en") {
          const mnemonic = Mnemonic.fromEntropy(account.mnemonic.entropy);
          const wallet2 = HDNodeWallet.fromMnemonic(mnemonic, account.mnemonic.path);
          if (wallet2.address === account.address && wallet2.privateKey === account.privateKey) {
            return wallet2;
          }
          console.log("WARNING: JSON mismatch address/privateKey != mnemonic; fallback onto private key");
        }
        const wallet = new _Wallet(account.privateKey);
        assertArgument(wallet.address === account.address, "address/privateKey mismatch", "json", "[ REDACTED ]");
        return wallet;
      };
      __privateAdd(_Wallet, _Wallet_static);
      Wallet = _Wallet;
    }
  });

  // node_modules/ethers/lib.esm/wallet/index.js
  var init_wallet2 = __esm({
    "node_modules/ethers/lib.esm/wallet/index.js"() {
      init_base_wallet();
      init_hdwallet();
      init_json_crowdsale();
      init_json_keystore();
      init_mnemonic();
      init_wallet();
    }
  });

  // node_modules/ethers/lib.esm/wordlists/bit-reader.js
  function decodeBits(width, data) {
    const maxValue2 = (1 << width) - 1;
    const result = [];
    let accum = 0, bits = 0, flood = 0;
    for (let i = 0; i < data.length; i++) {
      accum = accum << 6 | Base64.indexOf(data[i]);
      bits += 6;
      while (bits >= width) {
        const value = accum >> bits - width;
        accum &= (1 << bits - width) - 1;
        bits -= width;
        if (value === 0) {
          flood += maxValue2;
        } else {
          result.push(value + flood);
          flood = 0;
        }
      }
    }
    return result;
  }
  var Base64;
  var init_bit_reader = __esm({
    "node_modules/ethers/lib.esm/wordlists/bit-reader.js"() {
      Base64 = ")!@#$%^&*(ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_";
    }
  });

  // node_modules/ethers/lib.esm/wordlists/decode-owla.js
  function decodeOwlA(data, accents) {
    let words2 = decodeOwl(data).join(",");
    accents.split(/,/g).forEach((accent) => {
      const match = accent.match(/^([a-z]*)([0-9]+)([0-9])(.*)$/);
      assertArgument(match !== null, "internal error parsing accents", "accents", accents);
      let posOffset = 0;
      const positions = decodeBits(parseInt(match[3]), match[4]);
      const charCode = parseInt(match[2]);
      const regex = new RegExp(`([${match[1]}])`, "g");
      words2 = words2.replace(regex, (all, letter) => {
        const rem = --positions[posOffset];
        if (rem === 0) {
          letter = String.fromCharCode(letter.charCodeAt(0), charCode);
          posOffset++;
        }
        return letter;
      });
    });
    return words2.split(",");
  }
  var init_decode_owla = __esm({
    "node_modules/ethers/lib.esm/wordlists/decode-owla.js"() {
      init_utils();
      init_bit_reader();
      init_decode_owl();
    }
  });

  // node_modules/ethers/lib.esm/wordlists/wordlist-owla.js
  var _accent, WordlistOwlA;
  var init_wordlist_owla = __esm({
    "node_modules/ethers/lib.esm/wordlists/wordlist-owla.js"() {
      init_wordlist_owl();
      init_decode_owla();
      WordlistOwlA = class extends WordlistOwl {
        /**
         *  Creates a new Wordlist for %%locale%% using the OWLA %%data%%
         *  and %%accent%% data and validated against the %%checksum%%.
         */
        constructor(locale, data, accent, checksum4) {
          super(locale, data, checksum4);
          __privateAdd(this, _accent);
          __privateSet(this, _accent, accent);
        }
        /**
         *  The OWLA-encoded accent data.
         */
        get _accent() {
          return __privateGet(this, _accent);
        }
        /**
         *  Decode all the words for the wordlist.
         */
        _decodeWords() {
          return decodeOwlA(this._data, this._accent);
        }
      };
      _accent = new WeakMap();
    }
  });

  // node_modules/ethers/lib.esm/wordlists/wordlists-browser.js
  var wordlists;
  var init_wordlists_browser = __esm({
    "node_modules/ethers/lib.esm/wordlists/wordlists-browser.js"() {
      init_lang_en();
      wordlists = {
        en: LangEn.wordlist()
      };
    }
  });

  // node_modules/ethers/lib.esm/wordlists/index.js
  var init_wordlists = __esm({
    "node_modules/ethers/lib.esm/wordlists/index.js"() {
      init_wordlist();
      init_lang_en();
      init_wordlist_owl();
      init_wordlist_owla();
      init_wordlists_browser();
    }
  });

  // node_modules/ethers/lib.esm/ethers.js
  var ethers_exports = {};
  __export(ethers_exports, {
    AbiCoder: () => AbiCoder,
    AbstractProvider: () => AbstractProvider,
    AbstractSigner: () => AbstractSigner,
    AlchemyProvider: () => AlchemyProvider,
    AnkrProvider: () => AnkrProvider,
    BaseContract: () => BaseContract,
    BaseWallet: () => BaseWallet,
    Block: () => Block,
    BlockscoutProvider: () => BlockscoutProvider,
    BrowserProvider: () => BrowserProvider,
    ChainstackProvider: () => ChainstackProvider,
    CloudflareProvider: () => CloudflareProvider,
    ConstructorFragment: () => ConstructorFragment,
    Contract: () => Contract,
    ContractEventPayload: () => ContractEventPayload,
    ContractFactory: () => ContractFactory,
    ContractTransactionReceipt: () => ContractTransactionReceipt,
    ContractTransactionResponse: () => ContractTransactionResponse,
    ContractUnknownEventPayload: () => ContractUnknownEventPayload,
    EnsPlugin: () => EnsPlugin,
    EnsResolver: () => EnsResolver,
    ErrorDescription: () => ErrorDescription,
    ErrorFragment: () => ErrorFragment,
    EtherSymbol: () => EtherSymbol,
    EtherscanPlugin: () => EtherscanPlugin,
    EtherscanProvider: () => EtherscanProvider,
    EventFragment: () => EventFragment,
    EventLog: () => EventLog,
    EventPayload: () => EventPayload,
    FallbackFragment: () => FallbackFragment,
    FallbackProvider: () => FallbackProvider,
    FeeData: () => FeeData,
    FeeDataNetworkPlugin: () => FeeDataNetworkPlugin,
    FetchCancelSignal: () => FetchCancelSignal,
    FetchRequest: () => FetchRequest,
    FetchResponse: () => FetchResponse,
    FetchUrlFeeDataNetworkPlugin: () => FetchUrlFeeDataNetworkPlugin,
    FixedNumber: () => FixedNumber,
    Fragment: () => Fragment,
    FunctionFragment: () => FunctionFragment,
    GasCostPlugin: () => GasCostPlugin,
    HDNodeVoidWallet: () => HDNodeVoidWallet,
    HDNodeWallet: () => HDNodeWallet,
    Indexed: () => Indexed,
    InfuraProvider: () => InfuraProvider,
    InfuraWebSocketProvider: () => InfuraWebSocketProvider,
    Interface: () => Interface,
    IpcSocketProvider: () => IpcSocketProvider,
    JsonRpcApiProvider: () => JsonRpcApiProvider,
    JsonRpcProvider: () => JsonRpcProvider,
    JsonRpcSigner: () => JsonRpcSigner,
    LangEn: () => LangEn,
    Log: () => Log,
    LogDescription: () => LogDescription,
    MaxInt256: () => MaxInt256,
    MaxUint256: () => MaxUint256,
    MessagePrefix: () => MessagePrefix,
    MinInt256: () => MinInt256,
    Mnemonic: () => Mnemonic,
    MulticoinProviderPlugin: () => MulticoinProviderPlugin,
    N: () => N,
    NamedFragment: () => NamedFragment,
    Network: () => Network,
    NetworkPlugin: () => NetworkPlugin,
    NonceManager: () => NonceManager,
    ParamType: () => ParamType,
    PocketProvider: () => PocketProvider,
    QuickNodeProvider: () => QuickNodeProvider,
    Result: () => Result,
    Signature: () => Signature,
    SigningKey: () => SigningKey,
    SocketBlockSubscriber: () => SocketBlockSubscriber,
    SocketEventSubscriber: () => SocketEventSubscriber,
    SocketPendingSubscriber: () => SocketPendingSubscriber,
    SocketProvider: () => SocketProvider,
    SocketSubscriber: () => SocketSubscriber,
    StructFragment: () => StructFragment,
    Transaction: () => Transaction,
    TransactionDescription: () => TransactionDescription,
    TransactionReceipt: () => TransactionReceipt,
    TransactionResponse: () => TransactionResponse,
    Typed: () => Typed,
    TypedDataEncoder: () => TypedDataEncoder,
    UndecodedEventLog: () => UndecodedEventLog,
    UnmanagedSubscriber: () => UnmanagedSubscriber,
    Utf8ErrorFuncs: () => Utf8ErrorFuncs,
    VoidSigner: () => VoidSigner,
    Wallet: () => Wallet,
    WebSocketProvider: () => WebSocketProvider,
    WeiPerEther: () => WeiPerEther,
    Wordlist: () => Wordlist,
    WordlistOwl: () => WordlistOwl,
    WordlistOwlA: () => WordlistOwlA,
    ZeroAddress: () => ZeroAddress,
    ZeroHash: () => ZeroHash,
    accessListify: () => accessListify,
    assert: () => assert,
    assertArgument: () => assertArgument,
    assertArgumentCount: () => assertArgumentCount,
    assertNormalize: () => assertNormalize,
    assertPrivate: () => assertPrivate,
    authorizationify: () => authorizationify,
    checkResultErrors: () => checkResultErrors,
    computeAddress: () => computeAddress,
    computeHmac: () => computeHmac,
    concat: () => concat,
    copyRequest: () => copyRequest,
    dataLength: () => dataLength,
    dataSlice: () => dataSlice,
    decodeBase58: () => decodeBase58,
    decodeBase64: () => decodeBase64,
    decodeBytes32String: () => decodeBytes32String,
    decodeRlp: () => decodeRlp,
    decryptCrowdsaleJson: () => decryptCrowdsaleJson,
    decryptKeystoreJson: () => decryptKeystoreJson,
    decryptKeystoreJsonSync: () => decryptKeystoreJsonSync,
    defaultPath: () => defaultPath2,
    defineProperties: () => defineProperties,
    dnsEncode: () => dnsEncode,
    encodeBase58: () => encodeBase58,
    encodeBase64: () => encodeBase64,
    encodeBytes32String: () => encodeBytes32String,
    encodeRlp: () => encodeRlp,
    encryptKeystoreJson: () => encryptKeystoreJson,
    encryptKeystoreJsonSync: () => encryptKeystoreJsonSync,
    ensNormalize: () => ensNormalize,
    formatEther: () => formatEther,
    formatUnits: () => formatUnits,
    fromTwos: () => fromTwos,
    getAccountPath: () => getAccountPath,
    getAddress: () => getAddress,
    getBigInt: () => getBigInt,
    getBytes: () => getBytes,
    getBytesCopy: () => getBytesCopy,
    getCreate2Address: () => getCreate2Address,
    getCreateAddress: () => getCreateAddress,
    getDefaultProvider: () => getDefaultProvider,
    getIcapAddress: () => getIcapAddress,
    getIndexedAccountPath: () => getIndexedAccountPath,
    getNumber: () => getNumber,
    getUint: () => getUint,
    hashAuthorization: () => hashAuthorization,
    hashMessage: () => hashMessage,
    hexlify: () => hexlify,
    id: () => id,
    isAddress: () => isAddress,
    isAddressable: () => isAddressable,
    isBytesLike: () => isBytesLike,
    isCallException: () => isCallException,
    isCrowdsaleJson: () => isCrowdsaleJson,
    isError: () => isError,
    isHexString: () => isHexString,
    isKeystoreJson: () => isKeystoreJson,
    isValidName: () => isValidName,
    keccak256: () => keccak256,
    lock: () => lock,
    makeError: () => makeError,
    mask: () => mask,
    namehash: () => namehash,
    parseEther: () => parseEther,
    parseUnits: () => parseUnits,
    pbkdf2: () => pbkdf22,
    randomBytes: () => randomBytes3,
    recoverAddress: () => recoverAddress,
    resolveAddress: () => resolveAddress,
    resolveProperties: () => resolveProperties,
    ripemd160: () => ripemd1602,
    scrypt: () => scrypt2,
    scryptSync: () => scryptSync,
    sha256: () => sha2562,
    sha512: () => sha5122,
    showThrottleMessage: () => showThrottleMessage,
    solidityPacked: () => solidityPacked,
    solidityPackedKeccak256: () => solidityPackedKeccak256,
    solidityPackedSha256: () => solidityPackedSha256,
    stripZerosLeft: () => stripZerosLeft,
    toBeArray: () => toBeArray,
    toBeHex: () => toBeHex,
    toBigInt: () => toBigInt,
    toNumber: () => toNumber,
    toQuantity: () => toQuantity,
    toTwos: () => toTwos,
    toUtf8Bytes: () => toUtf8Bytes,
    toUtf8CodePoints: () => toUtf8CodePoints,
    toUtf8String: () => toUtf8String,
    uuidV4: () => uuidV4,
    verifyAuthorization: () => verifyAuthorization,
    verifyMessage: () => verifyMessage,
    verifyTypedData: () => verifyTypedData,
    version: () => version,
    wordlists: () => wordlists,
    zeroPadBytes: () => zeroPadBytes,
    zeroPadValue: () => zeroPadValue
  });
  var init_ethers = __esm({
    "node_modules/ethers/lib.esm/ethers.js"() {
      init_version();
      init_abi();
      init_address2();
      init_constants();
      init_contract2();
      init_crypto2();
      init_hash();
      init_providers();
      init_transaction2();
      init_utils();
      init_wallet2();
      init_wordlists();
    }
  });

  // node_modules/ethers/lib.esm/index.js
  var init_lib2 = __esm({
    "node_modules/ethers/lib.esm/index.js"() {
      init_ethers();
      init_ethers();
    }
  });

  // node_modules/abitype/dist/esm/version.js
  var version2;
  var init_version2 = __esm({
    "node_modules/abitype/dist/esm/version.js"() {
      version2 = "1.0.8";
    }
  });

  // node_modules/abitype/dist/esm/errors.js
  var BaseError;
  var init_errors2 = __esm({
    "node_modules/abitype/dist/esm/errors.js"() {
      init_version2();
      BaseError = class _BaseError extends Error {
        constructor(shortMessage, args = {}) {
          const details = args.cause instanceof _BaseError ? args.cause.details : args.cause?.message ? args.cause.message : args.details;
          const docsPath8 = args.cause instanceof _BaseError ? args.cause.docsPath || args.docsPath : args.docsPath;
          const message = [
            shortMessage || "An error occurred.",
            "",
            ...args.metaMessages ? [...args.metaMessages, ""] : [],
            ...docsPath8 ? [`Docs: https://abitype.dev${docsPath8}`] : [],
            ...details ? [`Details: ${details}`] : [],
            `Version: abitype@${version2}`
          ].join("\n");
          super(message);
          Object.defineProperty(this, "details", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
          });
          Object.defineProperty(this, "docsPath", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
          });
          Object.defineProperty(this, "metaMessages", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
          });
          Object.defineProperty(this, "shortMessage", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
          });
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "AbiTypeError"
          });
          if (args.cause)
            this.cause = args.cause;
          this.details = details;
          this.docsPath = docsPath8;
          this.metaMessages = args.metaMessages;
          this.shortMessage = shortMessage;
        }
      };
    }
  });

  // node_modules/abitype/dist/esm/regex.js
  function execTyped(regex, string) {
    const match = regex.exec(string);
    return match?.groups;
  }
  var bytesRegex, integerRegex, isTupleRegex;
  var init_regex = __esm({
    "node_modules/abitype/dist/esm/regex.js"() {
      bytesRegex = /^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/;
      integerRegex = /^u?int(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/;
      isTupleRegex = /^\(.+?\).*?$/;
    }
  });

  // node_modules/abitype/dist/esm/human-readable/formatAbiParameter.js
  function formatAbiParameter(abiParameter) {
    let type = abiParameter.type;
    if (tupleRegex.test(abiParameter.type) && "components" in abiParameter) {
      type = "(";
      const length = abiParameter.components.length;
      for (let i = 0; i < length; i++) {
        const component = abiParameter.components[i];
        type += formatAbiParameter(component);
        if (i < length - 1)
          type += ", ";
      }
      const result = execTyped(tupleRegex, abiParameter.type);
      type += `)${result?.array ?? ""}`;
      return formatAbiParameter({
        ...abiParameter,
        type
      });
    }
    if ("indexed" in abiParameter && abiParameter.indexed)
      type = `${type} indexed`;
    if (abiParameter.name)
      return `${type} ${abiParameter.name}`;
    return type;
  }
  var tupleRegex;
  var init_formatAbiParameter = __esm({
    "node_modules/abitype/dist/esm/human-readable/formatAbiParameter.js"() {
      init_regex();
      tupleRegex = /^tuple(?<array>(\[(\d*)\])*)$/;
    }
  });

  // node_modules/abitype/dist/esm/human-readable/formatAbiParameters.js
  function formatAbiParameters(abiParameters) {
    let params = "";
    const length = abiParameters.length;
    for (let i = 0; i < length; i++) {
      const abiParameter = abiParameters[i];
      params += formatAbiParameter(abiParameter);
      if (i !== length - 1)
        params += ", ";
    }
    return params;
  }
  var init_formatAbiParameters = __esm({
    "node_modules/abitype/dist/esm/human-readable/formatAbiParameters.js"() {
      init_formatAbiParameter();
    }
  });

  // node_modules/abitype/dist/esm/human-readable/formatAbiItem.js
  function formatAbiItem(abiItem) {
    if (abiItem.type === "function")
      return `function ${abiItem.name}(${formatAbiParameters(abiItem.inputs)})${abiItem.stateMutability && abiItem.stateMutability !== "nonpayable" ? ` ${abiItem.stateMutability}` : ""}${abiItem.outputs?.length ? ` returns (${formatAbiParameters(abiItem.outputs)})` : ""}`;
    if (abiItem.type === "event")
      return `event ${abiItem.name}(${formatAbiParameters(abiItem.inputs)})`;
    if (abiItem.type === "error")
      return `error ${abiItem.name}(${formatAbiParameters(abiItem.inputs)})`;
    if (abiItem.type === "constructor")
      return `constructor(${formatAbiParameters(abiItem.inputs)})${abiItem.stateMutability === "payable" ? " payable" : ""}`;
    if (abiItem.type === "fallback")
      return `fallback() external${abiItem.stateMutability === "payable" ? " payable" : ""}`;
    return "receive() external payable";
  }
  var init_formatAbiItem = __esm({
    "node_modules/abitype/dist/esm/human-readable/formatAbiItem.js"() {
      init_formatAbiParameters();
    }
  });

  // node_modules/abitype/dist/esm/human-readable/runtime/signatures.js
  function isErrorSignature(signature) {
    return errorSignatureRegex.test(signature);
  }
  function execErrorSignature(signature) {
    return execTyped(errorSignatureRegex, signature);
  }
  function isEventSignature(signature) {
    return eventSignatureRegex.test(signature);
  }
  function execEventSignature(signature) {
    return execTyped(eventSignatureRegex, signature);
  }
  function isFunctionSignature(signature) {
    return functionSignatureRegex.test(signature);
  }
  function execFunctionSignature(signature) {
    return execTyped(functionSignatureRegex, signature);
  }
  function isStructSignature(signature) {
    return structSignatureRegex.test(signature);
  }
  function execStructSignature(signature) {
    return execTyped(structSignatureRegex, signature);
  }
  function isConstructorSignature(signature) {
    return constructorSignatureRegex.test(signature);
  }
  function execConstructorSignature(signature) {
    return execTyped(constructorSignatureRegex, signature);
  }
  function isFallbackSignature(signature) {
    return fallbackSignatureRegex.test(signature);
  }
  function execFallbackSignature(signature) {
    return execTyped(fallbackSignatureRegex, signature);
  }
  function isReceiveSignature(signature) {
    return receiveSignatureRegex.test(signature);
  }
  var errorSignatureRegex, eventSignatureRegex, functionSignatureRegex, structSignatureRegex, constructorSignatureRegex, fallbackSignatureRegex, receiveSignatureRegex, eventModifiers, functionModifiers;
  var init_signatures = __esm({
    "node_modules/abitype/dist/esm/human-readable/runtime/signatures.js"() {
      init_regex();
      errorSignatureRegex = /^error (?<name>[a-zA-Z$_][a-zA-Z0-9$_]*)\((?<parameters>.*?)\)$/;
      eventSignatureRegex = /^event (?<name>[a-zA-Z$_][a-zA-Z0-9$_]*)\((?<parameters>.*?)\)$/;
      functionSignatureRegex = /^function (?<name>[a-zA-Z$_][a-zA-Z0-9$_]*)\((?<parameters>.*?)\)(?: (?<scope>external|public{1}))?(?: (?<stateMutability>pure|view|nonpayable|payable{1}))?(?: returns\s?\((?<returns>.*?)\))?$/;
      structSignatureRegex = /^struct (?<name>[a-zA-Z$_][a-zA-Z0-9$_]*) \{(?<properties>.*?)\}$/;
      constructorSignatureRegex = /^constructor\((?<parameters>.*?)\)(?:\s(?<stateMutability>payable{1}))?$/;
      fallbackSignatureRegex = /^fallback\(\) external(?:\s(?<stateMutability>payable{1}))?$/;
      receiveSignatureRegex = /^receive\(\) external payable$/;
      eventModifiers = /* @__PURE__ */ new Set(["indexed"]);
      functionModifiers = /* @__PURE__ */ new Set([
        "calldata",
        "memory",
        "storage"
      ]);
    }
  });

  // node_modules/abitype/dist/esm/human-readable/errors/abiItem.js
  var InvalidAbiItemError, UnknownTypeError, UnknownSolidityTypeError;
  var init_abiItem = __esm({
    "node_modules/abitype/dist/esm/human-readable/errors/abiItem.js"() {
      init_errors2();
      InvalidAbiItemError = class extends BaseError {
        constructor({ signature }) {
          super("Failed to parse ABI item.", {
            details: `parseAbiItem(${JSON.stringify(signature, null, 2)})`,
            docsPath: "/api/human#parseabiitem-1"
          });
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "InvalidAbiItemError"
          });
        }
      };
      UnknownTypeError = class extends BaseError {
        constructor({ type }) {
          super("Unknown type.", {
            metaMessages: [
              `Type "${type}" is not a valid ABI type. Perhaps you forgot to include a struct signature?`
            ]
          });
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "UnknownTypeError"
          });
        }
      };
      UnknownSolidityTypeError = class extends BaseError {
        constructor({ type }) {
          super("Unknown type.", {
            metaMessages: [`Type "${type}" is not a valid ABI type.`]
          });
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "UnknownSolidityTypeError"
          });
        }
      };
    }
  });

  // node_modules/abitype/dist/esm/human-readable/errors/abiParameter.js
  var InvalidParameterError, SolidityProtectedKeywordError, InvalidModifierError, InvalidFunctionModifierError, InvalidAbiTypeParameterError;
  var init_abiParameter = __esm({
    "node_modules/abitype/dist/esm/human-readable/errors/abiParameter.js"() {
      init_errors2();
      InvalidParameterError = class extends BaseError {
        constructor({ param }) {
          super("Invalid ABI parameter.", {
            details: param
          });
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "InvalidParameterError"
          });
        }
      };
      SolidityProtectedKeywordError = class extends BaseError {
        constructor({ param, name }) {
          super("Invalid ABI parameter.", {
            details: param,
            metaMessages: [
              `"${name}" is a protected Solidity keyword. More info: https://docs.soliditylang.org/en/latest/cheatsheet.html`
            ]
          });
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "SolidityProtectedKeywordError"
          });
        }
      };
      InvalidModifierError = class extends BaseError {
        constructor({ param, type, modifier }) {
          super("Invalid ABI parameter.", {
            details: param,
            metaMessages: [
              `Modifier "${modifier}" not allowed${type ? ` in "${type}" type` : ""}.`
            ]
          });
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "InvalidModifierError"
          });
        }
      };
      InvalidFunctionModifierError = class extends BaseError {
        constructor({ param, type, modifier }) {
          super("Invalid ABI parameter.", {
            details: param,
            metaMessages: [
              `Modifier "${modifier}" not allowed${type ? ` in "${type}" type` : ""}.`,
              `Data location can only be specified for array, struct, or mapping types, but "${modifier}" was given.`
            ]
          });
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "InvalidFunctionModifierError"
          });
        }
      };
      InvalidAbiTypeParameterError = class extends BaseError {
        constructor({ abiParameter }) {
          super("Invalid ABI parameter.", {
            details: JSON.stringify(abiParameter, null, 2),
            metaMessages: ["ABI parameter type is invalid."]
          });
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "InvalidAbiTypeParameterError"
          });
        }
      };
    }
  });

  // node_modules/abitype/dist/esm/human-readable/errors/signature.js
  var InvalidSignatureError, UnknownSignatureError, InvalidStructSignatureError;
  var init_signature2 = __esm({
    "node_modules/abitype/dist/esm/human-readable/errors/signature.js"() {
      init_errors2();
      InvalidSignatureError = class extends BaseError {
        constructor({ signature, type }) {
          super(`Invalid ${type} signature.`, {
            details: signature
          });
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "InvalidSignatureError"
          });
        }
      };
      UnknownSignatureError = class extends BaseError {
        constructor({ signature }) {
          super("Unknown signature.", {
            details: signature
          });
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "UnknownSignatureError"
          });
        }
      };
      InvalidStructSignatureError = class extends BaseError {
        constructor({ signature }) {
          super("Invalid struct signature.", {
            details: signature,
            metaMessages: ["No properties exist."]
          });
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "InvalidStructSignatureError"
          });
        }
      };
    }
  });

  // node_modules/abitype/dist/esm/human-readable/errors/struct.js
  var CircularReferenceError;
  var init_struct = __esm({
    "node_modules/abitype/dist/esm/human-readable/errors/struct.js"() {
      init_errors2();
      CircularReferenceError = class extends BaseError {
        constructor({ type }) {
          super("Circular reference detected.", {
            metaMessages: [`Struct "${type}" is a circular reference.`]
          });
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "CircularReferenceError"
          });
        }
      };
    }
  });

  // node_modules/abitype/dist/esm/human-readable/errors/splitParameters.js
  var InvalidParenthesisError;
  var init_splitParameters = __esm({
    "node_modules/abitype/dist/esm/human-readable/errors/splitParameters.js"() {
      init_errors2();
      InvalidParenthesisError = class extends BaseError {
        constructor({ current, depth }) {
          super("Unbalanced parentheses.", {
            metaMessages: [
              `"${current.trim()}" has too many ${depth > 0 ? "opening" : "closing"} parentheses.`
            ],
            details: `Depth "${depth}"`
          });
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "InvalidParenthesisError"
          });
        }
      };
    }
  });

  // node_modules/abitype/dist/esm/human-readable/runtime/cache.js
  function getParameterCacheKey(param, type, structs) {
    let structKey = "";
    if (structs)
      for (const struct of Object.entries(structs)) {
        if (!struct)
          continue;
        let propertyKey = "";
        for (const property of struct[1]) {
          propertyKey += `[${property.type}${property.name ? `:${property.name}` : ""}]`;
        }
        structKey += `(${struct[0]}{${propertyKey}})`;
      }
    if (type)
      return `${type}:${param}${structKey}`;
    return param;
  }
  var parameterCache;
  var init_cache = __esm({
    "node_modules/abitype/dist/esm/human-readable/runtime/cache.js"() {
      parameterCache = /* @__PURE__ */ new Map([
        // Unnamed
        ["address", { type: "address" }],
        ["bool", { type: "bool" }],
        ["bytes", { type: "bytes" }],
        ["bytes32", { type: "bytes32" }],
        ["int", { type: "int256" }],
        ["int256", { type: "int256" }],
        ["string", { type: "string" }],
        ["uint", { type: "uint256" }],
        ["uint8", { type: "uint8" }],
        ["uint16", { type: "uint16" }],
        ["uint24", { type: "uint24" }],
        ["uint32", { type: "uint32" }],
        ["uint64", { type: "uint64" }],
        ["uint96", { type: "uint96" }],
        ["uint112", { type: "uint112" }],
        ["uint160", { type: "uint160" }],
        ["uint192", { type: "uint192" }],
        ["uint256", { type: "uint256" }],
        // Named
        ["address owner", { type: "address", name: "owner" }],
        ["address to", { type: "address", name: "to" }],
        ["bool approved", { type: "bool", name: "approved" }],
        ["bytes _data", { type: "bytes", name: "_data" }],
        ["bytes data", { type: "bytes", name: "data" }],
        ["bytes signature", { type: "bytes", name: "signature" }],
        ["bytes32 hash", { type: "bytes32", name: "hash" }],
        ["bytes32 r", { type: "bytes32", name: "r" }],
        ["bytes32 root", { type: "bytes32", name: "root" }],
        ["bytes32 s", { type: "bytes32", name: "s" }],
        ["string name", { type: "string", name: "name" }],
        ["string symbol", { type: "string", name: "symbol" }],
        ["string tokenURI", { type: "string", name: "tokenURI" }],
        ["uint tokenId", { type: "uint256", name: "tokenId" }],
        ["uint8 v", { type: "uint8", name: "v" }],
        ["uint256 balance", { type: "uint256", name: "balance" }],
        ["uint256 tokenId", { type: "uint256", name: "tokenId" }],
        ["uint256 value", { type: "uint256", name: "value" }],
        // Indexed
        [
          "event:address indexed from",
          { type: "address", name: "from", indexed: true }
        ],
        ["event:address indexed to", { type: "address", name: "to", indexed: true }],
        [
          "event:uint indexed tokenId",
          { type: "uint256", name: "tokenId", indexed: true }
        ],
        [
          "event:uint256 indexed tokenId",
          { type: "uint256", name: "tokenId", indexed: true }
        ]
      ]);
    }
  });

  // node_modules/abitype/dist/esm/human-readable/runtime/utils.js
  function parseSignature(signature, structs = {}) {
    if (isFunctionSignature(signature))
      return parseFunctionSignature(signature, structs);
    if (isEventSignature(signature))
      return parseEventSignature(signature, structs);
    if (isErrorSignature(signature))
      return parseErrorSignature(signature, structs);
    if (isConstructorSignature(signature))
      return parseConstructorSignature(signature, structs);
    if (isFallbackSignature(signature))
      return parseFallbackSignature(signature);
    if (isReceiveSignature(signature))
      return {
        type: "receive",
        stateMutability: "payable"
      };
    throw new UnknownSignatureError({ signature });
  }
  function parseFunctionSignature(signature, structs = {}) {
    const match = execFunctionSignature(signature);
    if (!match)
      throw new InvalidSignatureError({ signature, type: "function" });
    const inputParams = splitParameters(match.parameters);
    const inputs = [];
    const inputLength = inputParams.length;
    for (let i = 0; i < inputLength; i++) {
      inputs.push(parseAbiParameter(inputParams[i], {
        modifiers: functionModifiers,
        structs,
        type: "function"
      }));
    }
    const outputs = [];
    if (match.returns) {
      const outputParams = splitParameters(match.returns);
      const outputLength = outputParams.length;
      for (let i = 0; i < outputLength; i++) {
        outputs.push(parseAbiParameter(outputParams[i], {
          modifiers: functionModifiers,
          structs,
          type: "function"
        }));
      }
    }
    return {
      name: match.name,
      type: "function",
      stateMutability: match.stateMutability ?? "nonpayable",
      inputs,
      outputs
    };
  }
  function parseEventSignature(signature, structs = {}) {
    const match = execEventSignature(signature);
    if (!match)
      throw new InvalidSignatureError({ signature, type: "event" });
    const params = splitParameters(match.parameters);
    const abiParameters = [];
    const length = params.length;
    for (let i = 0; i < length; i++)
      abiParameters.push(parseAbiParameter(params[i], {
        modifiers: eventModifiers,
        structs,
        type: "event"
      }));
    return { name: match.name, type: "event", inputs: abiParameters };
  }
  function parseErrorSignature(signature, structs = {}) {
    const match = execErrorSignature(signature);
    if (!match)
      throw new InvalidSignatureError({ signature, type: "error" });
    const params = splitParameters(match.parameters);
    const abiParameters = [];
    const length = params.length;
    for (let i = 0; i < length; i++)
      abiParameters.push(parseAbiParameter(params[i], { structs, type: "error" }));
    return { name: match.name, type: "error", inputs: abiParameters };
  }
  function parseConstructorSignature(signature, structs = {}) {
    const match = execConstructorSignature(signature);
    if (!match)
      throw new InvalidSignatureError({ signature, type: "constructor" });
    const params = splitParameters(match.parameters);
    const abiParameters = [];
    const length = params.length;
    for (let i = 0; i < length; i++)
      abiParameters.push(parseAbiParameter(params[i], { structs, type: "constructor" }));
    return {
      type: "constructor",
      stateMutability: match.stateMutability ?? "nonpayable",
      inputs: abiParameters
    };
  }
  function parseFallbackSignature(signature) {
    const match = execFallbackSignature(signature);
    if (!match)
      throw new InvalidSignatureError({ signature, type: "fallback" });
    return {
      type: "fallback",
      stateMutability: match.stateMutability ?? "nonpayable"
    };
  }
  function parseAbiParameter(param, options) {
    const parameterCacheKey = getParameterCacheKey(param, options?.type, options?.structs);
    if (parameterCache.has(parameterCacheKey))
      return parameterCache.get(parameterCacheKey);
    const isTuple = isTupleRegex.test(param);
    const match = execTyped(isTuple ? abiParameterWithTupleRegex : abiParameterWithoutTupleRegex, param);
    if (!match)
      throw new InvalidParameterError({ param });
    if (match.name && isSolidityKeyword(match.name))
      throw new SolidityProtectedKeywordError({ param, name: match.name });
    const name = match.name ? { name: match.name } : {};
    const indexed = match.modifier === "indexed" ? { indexed: true } : {};
    const structs = options?.structs ?? {};
    let type;
    let components = {};
    if (isTuple) {
      type = "tuple";
      const params = splitParameters(match.type);
      const components_ = [];
      const length = params.length;
      for (let i = 0; i < length; i++) {
        components_.push(parseAbiParameter(params[i], { structs }));
      }
      components = { components: components_ };
    } else if (match.type in structs) {
      type = "tuple";
      components = { components: structs[match.type] };
    } else if (dynamicIntegerRegex.test(match.type)) {
      type = `${match.type}256`;
    } else {
      type = match.type;
      if (!(options?.type === "struct") && !isSolidityType(type))
        throw new UnknownSolidityTypeError({ type });
    }
    if (match.modifier) {
      if (!options?.modifiers?.has?.(match.modifier))
        throw new InvalidModifierError({
          param,
          type: options?.type,
          modifier: match.modifier
        });
      if (functionModifiers.has(match.modifier) && !isValidDataLocation(type, !!match.array))
        throw new InvalidFunctionModifierError({
          param,
          type: options?.type,
          modifier: match.modifier
        });
    }
    const abiParameter = {
      type: `${type}${match.array ?? ""}`,
      ...name,
      ...indexed,
      ...components
    };
    parameterCache.set(parameterCacheKey, abiParameter);
    return abiParameter;
  }
  function splitParameters(params, result = [], current = "", depth = 0) {
    const length = params.trim().length;
    for (let i = 0; i < length; i++) {
      const char = params[i];
      const tail = params.slice(i + 1);
      switch (char) {
        case ",":
          return depth === 0 ? splitParameters(tail, [...result, current.trim()]) : splitParameters(tail, result, `${current}${char}`, depth);
        case "(":
          return splitParameters(tail, result, `${current}${char}`, depth + 1);
        case ")":
          return splitParameters(tail, result, `${current}${char}`, depth - 1);
        default:
          return splitParameters(tail, result, `${current}${char}`, depth);
      }
    }
    if (current === "")
      return result;
    if (depth !== 0)
      throw new InvalidParenthesisError({ current, depth });
    result.push(current.trim());
    return result;
  }
  function isSolidityType(type) {
    return type === "address" || type === "bool" || type === "function" || type === "string" || bytesRegex.test(type) || integerRegex.test(type);
  }
  function isSolidityKeyword(name) {
    return name === "address" || name === "bool" || name === "function" || name === "string" || name === "tuple" || bytesRegex.test(name) || integerRegex.test(name) || protectedKeywordsRegex.test(name);
  }
  function isValidDataLocation(type, isArray) {
    return isArray || type === "bytes" || type === "string" || type === "tuple";
  }
  var abiParameterWithoutTupleRegex, abiParameterWithTupleRegex, dynamicIntegerRegex, protectedKeywordsRegex;
  var init_utils5 = __esm({
    "node_modules/abitype/dist/esm/human-readable/runtime/utils.js"() {
      init_regex();
      init_abiItem();
      init_abiParameter();
      init_signature2();
      init_splitParameters();
      init_cache();
      init_signatures();
      abiParameterWithoutTupleRegex = /^(?<type>[a-zA-Z$_][a-zA-Z0-9$_]*)(?<array>(?:\[\d*?\])+?)?(?:\s(?<modifier>calldata|indexed|memory|storage{1}))?(?:\s(?<name>[a-zA-Z$_][a-zA-Z0-9$_]*))?$/;
      abiParameterWithTupleRegex = /^\((?<type>.+?)\)(?<array>(?:\[\d*?\])+?)?(?:\s(?<modifier>calldata|indexed|memory|storage{1}))?(?:\s(?<name>[a-zA-Z$_][a-zA-Z0-9$_]*))?$/;
      dynamicIntegerRegex = /^u?int$/;
      protectedKeywordsRegex = /^(?:after|alias|anonymous|apply|auto|byte|calldata|case|catch|constant|copyof|default|defined|error|event|external|false|final|function|immutable|implements|in|indexed|inline|internal|let|mapping|match|memory|mutable|null|of|override|partial|private|promise|public|pure|reference|relocatable|return|returns|sizeof|static|storage|struct|super|supports|switch|this|true|try|typedef|typeof|var|view|virtual)$/;
    }
  });

  // node_modules/abitype/dist/esm/human-readable/runtime/structs.js
  function parseStructs(signatures) {
    const shallowStructs = {};
    const signaturesLength = signatures.length;
    for (let i = 0; i < signaturesLength; i++) {
      const signature = signatures[i];
      if (!isStructSignature(signature))
        continue;
      const match = execStructSignature(signature);
      if (!match)
        throw new InvalidSignatureError({ signature, type: "struct" });
      const properties = match.properties.split(";");
      const components = [];
      const propertiesLength = properties.length;
      for (let k = 0; k < propertiesLength; k++) {
        const property = properties[k];
        const trimmed = property.trim();
        if (!trimmed)
          continue;
        const abiParameter = parseAbiParameter(trimmed, {
          type: "struct"
        });
        components.push(abiParameter);
      }
      if (!components.length)
        throw new InvalidStructSignatureError({ signature });
      shallowStructs[match.name] = components;
    }
    const resolvedStructs = {};
    const entries = Object.entries(shallowStructs);
    const entriesLength = entries.length;
    for (let i = 0; i < entriesLength; i++) {
      const [name, parameters] = entries[i];
      resolvedStructs[name] = resolveStructs(parameters, shallowStructs);
    }
    return resolvedStructs;
  }
  function resolveStructs(abiParameters, structs, ancestors = /* @__PURE__ */ new Set()) {
    const components = [];
    const length = abiParameters.length;
    for (let i = 0; i < length; i++) {
      const abiParameter = abiParameters[i];
      const isTuple = isTupleRegex.test(abiParameter.type);
      if (isTuple)
        components.push(abiParameter);
      else {
        const match = execTyped(typeWithoutTupleRegex, abiParameter.type);
        if (!match?.type)
          throw new InvalidAbiTypeParameterError({ abiParameter });
        const { array, type } = match;
        if (type in structs) {
          if (ancestors.has(type))
            throw new CircularReferenceError({ type });
          components.push({
            ...abiParameter,
            type: `tuple${array ?? ""}`,
            components: resolveStructs(structs[type] ?? [], structs, /* @__PURE__ */ new Set([...ancestors, type]))
          });
        } else {
          if (isSolidityType(type))
            components.push(abiParameter);
          else
            throw new UnknownTypeError({ type });
        }
      }
    }
    return components;
  }
  var typeWithoutTupleRegex;
  var init_structs = __esm({
    "node_modules/abitype/dist/esm/human-readable/runtime/structs.js"() {
      init_regex();
      init_abiItem();
      init_abiParameter();
      init_signature2();
      init_struct();
      init_signatures();
      init_utils5();
      typeWithoutTupleRegex = /^(?<type>[a-zA-Z$_][a-zA-Z0-9$_]*)(?<array>(?:\[\d*?\])+?)?$/;
    }
  });

  // node_modules/abitype/dist/esm/human-readable/parseAbi.js
  function parseAbi(signatures) {
    const structs = parseStructs(signatures);
    const abi2 = [];
    const length = signatures.length;
    for (let i = 0; i < length; i++) {
      const signature = signatures[i];
      if (isStructSignature(signature))
        continue;
      abi2.push(parseSignature(signature, structs));
    }
    return abi2;
  }
  var init_parseAbi = __esm({
    "node_modules/abitype/dist/esm/human-readable/parseAbi.js"() {
      init_signatures();
      init_structs();
      init_utils5();
    }
  });

  // node_modules/abitype/dist/esm/human-readable/parseAbiItem.js
  function parseAbiItem(signature) {
    let abiItem;
    if (typeof signature === "string")
      abiItem = parseSignature(signature);
    else {
      const structs = parseStructs(signature);
      const length = signature.length;
      for (let i = 0; i < length; i++) {
        const signature_ = signature[i];
        if (isStructSignature(signature_))
          continue;
        abiItem = parseSignature(signature_, structs);
        break;
      }
    }
    if (!abiItem)
      throw new InvalidAbiItemError({ signature });
    return abiItem;
  }
  var init_parseAbiItem = __esm({
    "node_modules/abitype/dist/esm/human-readable/parseAbiItem.js"() {
      init_abiItem();
      init_signatures();
      init_structs();
      init_utils5();
    }
  });

  // node_modules/abitype/dist/esm/exports/index.js
  var init_exports = __esm({
    "node_modules/abitype/dist/esm/exports/index.js"() {
      init_formatAbiItem();
      init_parseAbi();
      init_parseAbiItem();
    }
  });

  // node_modules/viem/_esm/utils/getAction.js
  function getAction(client, actionFn, name) {
    const action_implicit = client[actionFn.name];
    if (typeof action_implicit === "function")
      return action_implicit;
    const action_explicit = client[name];
    if (typeof action_explicit === "function")
      return action_explicit;
    return (params) => actionFn(client, params);
  }
  var init_getAction = __esm({
    "node_modules/viem/_esm/utils/getAction.js"() {
    }
  });

  // node_modules/viem/_esm/utils/abi/formatAbiItem.js
  function formatAbiItem2(abiItem, { includeName = false } = {}) {
    if (abiItem.type !== "function" && abiItem.type !== "event" && abiItem.type !== "error")
      throw new InvalidDefinitionTypeError(abiItem.type);
    return `${abiItem.name}(${formatAbiParams(abiItem.inputs, { includeName })})`;
  }
  function formatAbiParams(params, { includeName = false } = {}) {
    if (!params)
      return "";
    return params.map((param) => formatAbiParam(param, { includeName })).join(includeName ? ", " : ",");
  }
  function formatAbiParam(param, { includeName }) {
    if (param.type.startsWith("tuple")) {
      return `(${formatAbiParams(param.components, { includeName })})${param.type.slice("tuple".length)}`;
    }
    return param.type + (includeName && param.name ? ` ${param.name}` : "");
  }
  var init_formatAbiItem2 = __esm({
    "node_modules/viem/_esm/utils/abi/formatAbiItem.js"() {
      init_abi2();
    }
  });

  // node_modules/viem/_esm/utils/data/isHex.js
  function isHex(value, { strict = true } = {}) {
    if (!value)
      return false;
    if (typeof value !== "string")
      return false;
    return strict ? /^0x[0-9a-fA-F]*$/.test(value) : value.startsWith("0x");
  }
  var init_isHex = __esm({
    "node_modules/viem/_esm/utils/data/isHex.js"() {
    }
  });

  // node_modules/viem/_esm/utils/data/size.js
  function size(value) {
    if (isHex(value, { strict: false }))
      return Math.ceil((value.length - 2) / 2);
    return value.length;
  }
  var init_size = __esm({
    "node_modules/viem/_esm/utils/data/size.js"() {
      init_isHex();
    }
  });

  // node_modules/viem/_esm/errors/version.js
  var version3;
  var init_version3 = __esm({
    "node_modules/viem/_esm/errors/version.js"() {
      version3 = "2.31.7";
    }
  });

  // node_modules/viem/_esm/errors/base.js
  function walk(err, fn) {
    if (fn?.(err))
      return err;
    if (err && typeof err === "object" && "cause" in err && err.cause !== void 0)
      return walk(err.cause, fn);
    return fn ? null : err;
  }
  var errorConfig, BaseError2;
  var init_base = __esm({
    "node_modules/viem/_esm/errors/base.js"() {
      init_version3();
      errorConfig = {
        getDocsUrl: ({ docsBaseUrl, docsPath: docsPath8 = "", docsSlug }) => docsPath8 ? `${docsBaseUrl ?? "https://viem.sh"}${docsPath8}${docsSlug ? `#${docsSlug}` : ""}` : void 0,
        version: `viem@${version3}`
      };
      BaseError2 = class _BaseError extends Error {
        constructor(shortMessage, args = {}) {
          const details = (() => {
            if (args.cause instanceof _BaseError)
              return args.cause.details;
            if (args.cause?.message)
              return args.cause.message;
            return args.details;
          })();
          const docsPath8 = (() => {
            if (args.cause instanceof _BaseError)
              return args.cause.docsPath || args.docsPath;
            return args.docsPath;
          })();
          const docsUrl = errorConfig.getDocsUrl?.({ ...args, docsPath: docsPath8 });
          const message = [
            shortMessage || "An error occurred.",
            "",
            ...args.metaMessages ? [...args.metaMessages, ""] : [],
            ...docsUrl ? [`Docs: ${docsUrl}`] : [],
            ...details ? [`Details: ${details}`] : [],
            ...errorConfig.version ? [`Version: ${errorConfig.version}`] : []
          ].join("\n");
          super(message, args.cause ? { cause: args.cause } : void 0);
          Object.defineProperty(this, "details", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
          });
          Object.defineProperty(this, "docsPath", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
          });
          Object.defineProperty(this, "metaMessages", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
          });
          Object.defineProperty(this, "shortMessage", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
          });
          Object.defineProperty(this, "version", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
          });
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "BaseError"
          });
          this.details = details;
          this.docsPath = docsPath8;
          this.metaMessages = args.metaMessages;
          this.name = args.name ?? this.name;
          this.shortMessage = shortMessage;
          this.version = version3;
        }
        walk(fn) {
          return walk(this, fn);
        }
      };
    }
  });

  // node_modules/viem/_esm/errors/abi.js
  var AbiConstructorNotFoundError, AbiConstructorParamsNotFoundError, AbiDecodingDataSizeTooSmallError, AbiDecodingZeroDataError, AbiEncodingArrayLengthMismatchError, AbiEncodingBytesSizeMismatchError, AbiEncodingLengthMismatchError, AbiErrorInputsNotFoundError, AbiErrorNotFoundError, AbiErrorSignatureNotFoundError, AbiEventSignatureEmptyTopicsError, AbiEventSignatureNotFoundError, AbiEventNotFoundError, AbiFunctionNotFoundError, AbiFunctionOutputsNotFoundError, AbiFunctionSignatureNotFoundError, AbiItemAmbiguityError, BytesSizeMismatchError, DecodeLogDataMismatch, DecodeLogTopicsMismatch, InvalidAbiEncodingTypeError, InvalidAbiDecodingTypeError, InvalidArrayError, InvalidDefinitionTypeError;
  var init_abi2 = __esm({
    "node_modules/viem/_esm/errors/abi.js"() {
      init_formatAbiItem2();
      init_size();
      init_base();
      AbiConstructorNotFoundError = class extends BaseError2 {
        constructor({ docsPath: docsPath8 }) {
          super([
            "A constructor was not found on the ABI.",
            "Make sure you are using the correct ABI and that the constructor exists on it."
          ].join("\n"), {
            docsPath: docsPath8,
            name: "AbiConstructorNotFoundError"
          });
        }
      };
      AbiConstructorParamsNotFoundError = class extends BaseError2 {
        constructor({ docsPath: docsPath8 }) {
          super([
            "Constructor arguments were provided (`args`), but a constructor parameters (`inputs`) were not found on the ABI.",
            "Make sure you are using the correct ABI, and that the `inputs` attribute on the constructor exists."
          ].join("\n"), {
            docsPath: docsPath8,
            name: "AbiConstructorParamsNotFoundError"
          });
        }
      };
      AbiDecodingDataSizeTooSmallError = class extends BaseError2 {
        constructor({ data, params, size: size5 }) {
          super([`Data size of ${size5} bytes is too small for given parameters.`].join("\n"), {
            metaMessages: [
              `Params: (${formatAbiParams(params, { includeName: true })})`,
              `Data:   ${data} (${size5} bytes)`
            ],
            name: "AbiDecodingDataSizeTooSmallError"
          });
          Object.defineProperty(this, "data", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
          });
          Object.defineProperty(this, "params", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
          });
          Object.defineProperty(this, "size", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
          });
          this.data = data;
          this.params = params;
          this.size = size5;
        }
      };
      AbiDecodingZeroDataError = class extends BaseError2 {
        constructor() {
          super('Cannot decode zero data ("0x") with ABI parameters.', {
            name: "AbiDecodingZeroDataError"
          });
        }
      };
      AbiEncodingArrayLengthMismatchError = class extends BaseError2 {
        constructor({ expectedLength, givenLength, type }) {
          super([
            `ABI encoding array length mismatch for type ${type}.`,
            `Expected length: ${expectedLength}`,
            `Given length: ${givenLength}`
          ].join("\n"), { name: "AbiEncodingArrayLengthMismatchError" });
        }
      };
      AbiEncodingBytesSizeMismatchError = class extends BaseError2 {
        constructor({ expectedSize, value }) {
          super(`Size of bytes "${value}" (bytes${size(value)}) does not match expected size (bytes${expectedSize}).`, { name: "AbiEncodingBytesSizeMismatchError" });
        }
      };
      AbiEncodingLengthMismatchError = class extends BaseError2 {
        constructor({ expectedLength, givenLength }) {
          super([
            "ABI encoding params/values length mismatch.",
            `Expected length (params): ${expectedLength}`,
            `Given length (values): ${givenLength}`
          ].join("\n"), { name: "AbiEncodingLengthMismatchError" });
        }
      };
      AbiErrorInputsNotFoundError = class extends BaseError2 {
        constructor(errorName, { docsPath: docsPath8 }) {
          super([
            `Arguments (\`args\`) were provided to "${errorName}", but "${errorName}" on the ABI does not contain any parameters (\`inputs\`).`,
            "Cannot encode error result without knowing what the parameter types are.",
            "Make sure you are using the correct ABI and that the inputs exist on it."
          ].join("\n"), {
            docsPath: docsPath8,
            name: "AbiErrorInputsNotFoundError"
          });
        }
      };
      AbiErrorNotFoundError = class extends BaseError2 {
        constructor(errorName, { docsPath: docsPath8 } = {}) {
          super([
            `Error ${errorName ? `"${errorName}" ` : ""}not found on ABI.`,
            "Make sure you are using the correct ABI and that the error exists on it."
          ].join("\n"), {
            docsPath: docsPath8,
            name: "AbiErrorNotFoundError"
          });
        }
      };
      AbiErrorSignatureNotFoundError = class extends BaseError2 {
        constructor(signature, { docsPath: docsPath8 }) {
          super([
            `Encoded error signature "${signature}" not found on ABI.`,
            "Make sure you are using the correct ABI and that the error exists on it.",
            `You can look up the decoded signature here: https://openchain.xyz/signatures?query=${signature}.`
          ].join("\n"), {
            docsPath: docsPath8,
            name: "AbiErrorSignatureNotFoundError"
          });
          Object.defineProperty(this, "signature", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
          });
          this.signature = signature;
        }
      };
      AbiEventSignatureEmptyTopicsError = class extends BaseError2 {
        constructor({ docsPath: docsPath8 }) {
          super("Cannot extract event signature from empty topics.", {
            docsPath: docsPath8,
            name: "AbiEventSignatureEmptyTopicsError"
          });
        }
      };
      AbiEventSignatureNotFoundError = class extends BaseError2 {
        constructor(signature, { docsPath: docsPath8 }) {
          super([
            `Encoded event signature "${signature}" not found on ABI.`,
            "Make sure you are using the correct ABI and that the event exists on it.",
            `You can look up the signature here: https://openchain.xyz/signatures?query=${signature}.`
          ].join("\n"), {
            docsPath: docsPath8,
            name: "AbiEventSignatureNotFoundError"
          });
        }
      };
      AbiEventNotFoundError = class extends BaseError2 {
        constructor(eventName, { docsPath: docsPath8 } = {}) {
          super([
            `Event ${eventName ? `"${eventName}" ` : ""}not found on ABI.`,
            "Make sure you are using the correct ABI and that the event exists on it."
          ].join("\n"), {
            docsPath: docsPath8,
            name: "AbiEventNotFoundError"
          });
        }
      };
      AbiFunctionNotFoundError = class extends BaseError2 {
        constructor(functionName, { docsPath: docsPath8 } = {}) {
          super([
            `Function ${functionName ? `"${functionName}" ` : ""}not found on ABI.`,
            "Make sure you are using the correct ABI and that the function exists on it."
          ].join("\n"), {
            docsPath: docsPath8,
            name: "AbiFunctionNotFoundError"
          });
        }
      };
      AbiFunctionOutputsNotFoundError = class extends BaseError2 {
        constructor(functionName, { docsPath: docsPath8 }) {
          super([
            `Function "${functionName}" does not contain any \`outputs\` on ABI.`,
            "Cannot decode function result without knowing what the parameter types are.",
            "Make sure you are using the correct ABI and that the function exists on it."
          ].join("\n"), {
            docsPath: docsPath8,
            name: "AbiFunctionOutputsNotFoundError"
          });
        }
      };
      AbiFunctionSignatureNotFoundError = class extends BaseError2 {
        constructor(signature, { docsPath: docsPath8 }) {
          super([
            `Encoded function signature "${signature}" not found on ABI.`,
            "Make sure you are using the correct ABI and that the function exists on it.",
            `You can look up the signature here: https://openchain.xyz/signatures?query=${signature}.`
          ].join("\n"), {
            docsPath: docsPath8,
            name: "AbiFunctionSignatureNotFoundError"
          });
        }
      };
      AbiItemAmbiguityError = class extends BaseError2 {
        constructor(x, y) {
          super("Found ambiguous types in overloaded ABI items.", {
            metaMessages: [
              `\`${x.type}\` in \`${formatAbiItem2(x.abiItem)}\`, and`,
              `\`${y.type}\` in \`${formatAbiItem2(y.abiItem)}\``,
              "",
              "These types encode differently and cannot be distinguished at runtime.",
              "Remove one of the ambiguous items in the ABI."
            ],
            name: "AbiItemAmbiguityError"
          });
        }
      };
      BytesSizeMismatchError = class extends BaseError2 {
        constructor({ expectedSize, givenSize }) {
          super(`Expected bytes${expectedSize}, got bytes${givenSize}.`, {
            name: "BytesSizeMismatchError"
          });
        }
      };
      DecodeLogDataMismatch = class extends BaseError2 {
        constructor({ abiItem, data, params, size: size5 }) {
          super([
            `Data size of ${size5} bytes is too small for non-indexed event parameters.`
          ].join("\n"), {
            metaMessages: [
              `Params: (${formatAbiParams(params, { includeName: true })})`,
              `Data:   ${data} (${size5} bytes)`
            ],
            name: "DecodeLogDataMismatch"
          });
          Object.defineProperty(this, "abiItem", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
          });
          Object.defineProperty(this, "data", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
          });
          Object.defineProperty(this, "params", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
          });
          Object.defineProperty(this, "size", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
          });
          this.abiItem = abiItem;
          this.data = data;
          this.params = params;
          this.size = size5;
        }
      };
      DecodeLogTopicsMismatch = class extends BaseError2 {
        constructor({ abiItem, param }) {
          super([
            `Expected a topic for indexed event parameter${param.name ? ` "${param.name}"` : ""} on event "${formatAbiItem2(abiItem, { includeName: true })}".`
          ].join("\n"), { name: "DecodeLogTopicsMismatch" });
          Object.defineProperty(this, "abiItem", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
          });
          this.abiItem = abiItem;
        }
      };
      InvalidAbiEncodingTypeError = class extends BaseError2 {
        constructor(type, { docsPath: docsPath8 }) {
          super([
            `Type "${type}" is not a valid encoding type.`,
            "Please provide a valid ABI type."
          ].join("\n"), { docsPath: docsPath8, name: "InvalidAbiEncodingType" });
        }
      };
      InvalidAbiDecodingTypeError = class extends BaseError2 {
        constructor(type, { docsPath: docsPath8 }) {
          super([
            `Type "${type}" is not a valid decoding type.`,
            "Please provide a valid ABI type."
          ].join("\n"), { docsPath: docsPath8, name: "InvalidAbiDecodingType" });
        }
      };
      InvalidArrayError = class extends BaseError2 {
        constructor(value) {
          super([`Value "${value}" is not a valid array.`].join("\n"), {
            name: "InvalidArrayError"
          });
        }
      };
      InvalidDefinitionTypeError = class extends BaseError2 {
        constructor(type) {
          super([
            `"${type}" is not a valid definition type.`,
            'Valid types: "function", "event", "error"'
          ].join("\n"), { name: "InvalidDefinitionTypeError" });
        }
      };
    }
  });

  // node_modules/viem/_esm/errors/log.js
  var FilterTypeNotSupportedError;
  var init_log = __esm({
    "node_modules/viem/_esm/errors/log.js"() {
      init_base();
      FilterTypeNotSupportedError = class extends BaseError2 {
        constructor(type) {
          super(`Filter type "${type}" is not supported.`, {
            name: "FilterTypeNotSupportedError"
          });
        }
      };
    }
  });

  // node_modules/viem/_esm/errors/data.js
  var SliceOffsetOutOfBoundsError, SizeExceedsPaddingSizeError, InvalidBytesLengthError;
  var init_data2 = __esm({
    "node_modules/viem/_esm/errors/data.js"() {
      init_base();
      SliceOffsetOutOfBoundsError = class extends BaseError2 {
        constructor({ offset, position, size: size5 }) {
          super(`Slice ${position === "start" ? "starting" : "ending"} at offset "${offset}" is out-of-bounds (size: ${size5}).`, { name: "SliceOffsetOutOfBoundsError" });
        }
      };
      SizeExceedsPaddingSizeError = class extends BaseError2 {
        constructor({ size: size5, targetSize, type }) {
          super(`${type.charAt(0).toUpperCase()}${type.slice(1).toLowerCase()} size (${size5}) exceeds padding size (${targetSize}).`, { name: "SizeExceedsPaddingSizeError" });
        }
      };
      InvalidBytesLengthError = class extends BaseError2 {
        constructor({ size: size5, targetSize, type }) {
          super(`${type.charAt(0).toUpperCase()}${type.slice(1).toLowerCase()} is expected to be ${targetSize} ${type} long, but is ${size5} ${type} long.`, { name: "InvalidBytesLengthError" });
        }
      };
    }
  });

  // node_modules/viem/_esm/utils/data/pad.js
  function pad(hexOrBytes, { dir, size: size5 = 32 } = {}) {
    if (typeof hexOrBytes === "string")
      return padHex(hexOrBytes, { dir, size: size5 });
    return padBytes(hexOrBytes, { dir, size: size5 });
  }
  function padHex(hex_, { dir, size: size5 = 32 } = {}) {
    if (size5 === null)
      return hex_;
    const hex = hex_.replace("0x", "");
    if (hex.length > size5 * 2)
      throw new SizeExceedsPaddingSizeError({
        size: Math.ceil(hex.length / 2),
        targetSize: size5,
        type: "hex"
      });
    return `0x${hex[dir === "right" ? "padEnd" : "padStart"](size5 * 2, "0")}`;
  }
  function padBytes(bytes2, { dir, size: size5 = 32 } = {}) {
    if (size5 === null)
      return bytes2;
    if (bytes2.length > size5)
      throw new SizeExceedsPaddingSizeError({
        size: bytes2.length,
        targetSize: size5,
        type: "bytes"
      });
    const paddedBytes = new Uint8Array(size5);
    for (let i = 0; i < size5; i++) {
      const padEnd = dir === "right";
      paddedBytes[padEnd ? i : size5 - i - 1] = bytes2[padEnd ? i : bytes2.length - i - 1];
    }
    return paddedBytes;
  }
  var init_pad = __esm({
    "node_modules/viem/_esm/utils/data/pad.js"() {
      init_data2();
    }
  });

  // node_modules/viem/_esm/errors/encoding.js
  var IntegerOutOfRangeError, InvalidBytesBooleanError, InvalidHexBooleanError, SizeOverflowError;
  var init_encoding = __esm({
    "node_modules/viem/_esm/errors/encoding.js"() {
      init_base();
      IntegerOutOfRangeError = class extends BaseError2 {
        constructor({ max, min, signed: signed2, size: size5, value }) {
          super(`Number "${value}" is not in safe ${size5 ? `${size5 * 8}-bit ${signed2 ? "signed" : "unsigned"} ` : ""}integer range ${max ? `(${min} to ${max})` : `(above ${min})`}`, { name: "IntegerOutOfRangeError" });
        }
      };
      InvalidBytesBooleanError = class extends BaseError2 {
        constructor(bytes2) {
          super(`Bytes value "${bytes2}" is not a valid boolean. The bytes array must contain a single byte of either a 0 or 1 value.`, {
            name: "InvalidBytesBooleanError"
          });
        }
      };
      InvalidHexBooleanError = class extends BaseError2 {
        constructor(hex) {
          super(`Hex value "${hex}" is not a valid boolean. The hex value must be "0x0" (false) or "0x1" (true).`, { name: "InvalidHexBooleanError" });
        }
      };
      SizeOverflowError = class extends BaseError2 {
        constructor({ givenSize, maxSize }) {
          super(`Size cannot exceed ${maxSize} bytes. Given size: ${givenSize} bytes.`, { name: "SizeOverflowError" });
        }
      };
    }
  });

  // node_modules/viem/_esm/utils/data/trim.js
  function trim(hexOrBytes, { dir = "left" } = {}) {
    let data = typeof hexOrBytes === "string" ? hexOrBytes.replace("0x", "") : hexOrBytes;
    let sliceLength = 0;
    for (let i = 0; i < data.length - 1; i++) {
      if (data[dir === "left" ? i : data.length - i - 1].toString() === "0")
        sliceLength++;
      else
        break;
    }
    data = dir === "left" ? data.slice(sliceLength) : data.slice(0, data.length - sliceLength);
    if (typeof hexOrBytes === "string") {
      if (data.length === 1 && dir === "right")
        data = `${data}0`;
      return `0x${data.length % 2 === 1 ? `0${data}` : data}`;
    }
    return data;
  }
  var init_trim = __esm({
    "node_modules/viem/_esm/utils/data/trim.js"() {
    }
  });

  // node_modules/viem/_esm/utils/encoding/fromHex.js
  function assertSize(hexOrBytes, { size: size5 }) {
    if (size(hexOrBytes) > size5)
      throw new SizeOverflowError({
        givenSize: size(hexOrBytes),
        maxSize: size5
      });
  }
  function hexToBigInt(hex, opts = {}) {
    const { signed: signed2 } = opts;
    if (opts.size)
      assertSize(hex, { size: opts.size });
    const value = BigInt(hex);
    if (!signed2)
      return value;
    const size5 = (hex.length - 2) / 2;
    const max = (1n << BigInt(size5) * 8n - 1n) - 1n;
    if (value <= max)
      return value;
    return value - BigInt(`0x${"f".padStart(size5 * 2, "f")}`) - 1n;
  }
  function hexToBool(hex_, opts = {}) {
    let hex = hex_;
    if (opts.size) {
      assertSize(hex, { size: opts.size });
      hex = trim(hex);
    }
    if (trim(hex) === "0x00")
      return false;
    if (trim(hex) === "0x01")
      return true;
    throw new InvalidHexBooleanError(hex);
  }
  function hexToNumber2(hex, opts = {}) {
    return Number(hexToBigInt(hex, opts));
  }
  var init_fromHex = __esm({
    "node_modules/viem/_esm/utils/encoding/fromHex.js"() {
      init_encoding();
      init_size();
      init_trim();
    }
  });

  // node_modules/viem/_esm/utils/encoding/toHex.js
  function toHex(value, opts = {}) {
    if (typeof value === "number" || typeof value === "bigint")
      return numberToHex(value, opts);
    if (typeof value === "string") {
      return stringToHex(value, opts);
    }
    if (typeof value === "boolean")
      return boolToHex(value, opts);
    return bytesToHex2(value, opts);
  }
  function boolToHex(value, opts = {}) {
    const hex = `0x${Number(value)}`;
    if (typeof opts.size === "number") {
      assertSize(hex, { size: opts.size });
      return pad(hex, { size: opts.size });
    }
    return hex;
  }
  function bytesToHex2(value, opts = {}) {
    let string = "";
    for (let i = 0; i < value.length; i++) {
      string += hexes2[value[i]];
    }
    const hex = `0x${string}`;
    if (typeof opts.size === "number") {
      assertSize(hex, { size: opts.size });
      return pad(hex, { dir: "right", size: opts.size });
    }
    return hex;
  }
  function numberToHex(value_, opts = {}) {
    const { signed: signed2, size: size5 } = opts;
    const value = BigInt(value_);
    let maxValue2;
    if (size5) {
      if (signed2)
        maxValue2 = (1n << BigInt(size5) * 8n - 1n) - 1n;
      else
        maxValue2 = 2n ** (BigInt(size5) * 8n) - 1n;
    } else if (typeof value_ === "number") {
      maxValue2 = BigInt(Number.MAX_SAFE_INTEGER);
    }
    const minValue = typeof maxValue2 === "bigint" && signed2 ? -maxValue2 - 1n : 0;
    if (maxValue2 && value > maxValue2 || value < minValue) {
      const suffix = typeof value_ === "bigint" ? "n" : "";
      throw new IntegerOutOfRangeError({
        max: maxValue2 ? `${maxValue2}${suffix}` : void 0,
        min: `${minValue}${suffix}`,
        signed: signed2,
        size: size5,
        value: `${value_}${suffix}`
      });
    }
    const hex = `0x${(signed2 && value < 0 ? (1n << BigInt(size5 * 8)) + BigInt(value) : value).toString(16)}`;
    if (size5)
      return pad(hex, { size: size5 });
    return hex;
  }
  function stringToHex(value_, opts = {}) {
    const value = encoder.encode(value_);
    return bytesToHex2(value, opts);
  }
  var hexes2, encoder;
  var init_toHex = __esm({
    "node_modules/viem/_esm/utils/encoding/toHex.js"() {
      init_encoding();
      init_pad();
      init_fromHex();
      hexes2 = /* @__PURE__ */ Array.from({ length: 256 }, (_v2, i) => i.toString(16).padStart(2, "0"));
      encoder = /* @__PURE__ */ new TextEncoder();
    }
  });

  // node_modules/viem/_esm/utils/encoding/toBytes.js
  function toBytes2(value, opts = {}) {
    if (typeof value === "number" || typeof value === "bigint")
      return numberToBytes(value, opts);
    if (typeof value === "boolean")
      return boolToBytes(value, opts);
    if (isHex(value))
      return hexToBytes2(value, opts);
    return stringToBytes(value, opts);
  }
  function boolToBytes(value, opts = {}) {
    const bytes2 = new Uint8Array(1);
    bytes2[0] = Number(value);
    if (typeof opts.size === "number") {
      assertSize(bytes2, { size: opts.size });
      return pad(bytes2, { size: opts.size });
    }
    return bytes2;
  }
  function charCodeToBase16(char) {
    if (char >= charCodeMap.zero && char <= charCodeMap.nine)
      return char - charCodeMap.zero;
    if (char >= charCodeMap.A && char <= charCodeMap.F)
      return char - (charCodeMap.A - 10);
    if (char >= charCodeMap.a && char <= charCodeMap.f)
      return char - (charCodeMap.a - 10);
    return void 0;
  }
  function hexToBytes2(hex_, opts = {}) {
    let hex = hex_;
    if (opts.size) {
      assertSize(hex, { size: opts.size });
      hex = pad(hex, { dir: "right", size: opts.size });
    }
    let hexString = hex.slice(2);
    if (hexString.length % 2)
      hexString = `0${hexString}`;
    const length = hexString.length / 2;
    const bytes2 = new Uint8Array(length);
    for (let index2 = 0, j = 0; index2 < length; index2++) {
      const nibbleLeft = charCodeToBase16(hexString.charCodeAt(j++));
      const nibbleRight = charCodeToBase16(hexString.charCodeAt(j++));
      if (nibbleLeft === void 0 || nibbleRight === void 0) {
        throw new BaseError2(`Invalid byte sequence ("${hexString[j - 2]}${hexString[j - 1]}" in "${hexString}").`);
      }
      bytes2[index2] = nibbleLeft * 16 + nibbleRight;
    }
    return bytes2;
  }
  function numberToBytes(value, opts) {
    const hex = numberToHex(value, opts);
    return hexToBytes2(hex);
  }
  function stringToBytes(value, opts = {}) {
    const bytes2 = encoder2.encode(value);
    if (typeof opts.size === "number") {
      assertSize(bytes2, { size: opts.size });
      return pad(bytes2, { dir: "right", size: opts.size });
    }
    return bytes2;
  }
  var encoder2, charCodeMap;
  var init_toBytes = __esm({
    "node_modules/viem/_esm/utils/encoding/toBytes.js"() {
      init_base();
      init_isHex();
      init_pad();
      init_fromHex();
      init_toHex();
      encoder2 = /* @__PURE__ */ new TextEncoder();
      charCodeMap = {
        zero: 48,
        nine: 57,
        A: 65,
        F: 70,
        a: 97,
        f: 102
      };
    }
  });

  // node_modules/viem/node_modules/@noble/hashes/esm/_u64.js
  function fromBig2(n2, le = false) {
    if (le)
      return { h: Number(n2 & U32_MASK642), l: Number(n2 >> _32n2 & U32_MASK642) };
    return { h: Number(n2 >> _32n2 & U32_MASK642) | 0, l: Number(n2 & U32_MASK642) | 0 };
  }
  function split3(lst, le = false) {
    const len = lst.length;
    let Ah = new Uint32Array(len);
    let Al = new Uint32Array(len);
    for (let i = 0; i < len; i++) {
      const { h, l } = fromBig2(lst[i], le);
      [Ah[i], Al[i]] = [h, l];
    }
    return [Ah, Al];
  }
  var U32_MASK642, _32n2, rotlSH2, rotlSL2, rotlBH2, rotlBL2;
  var init_u642 = __esm({
    "node_modules/viem/node_modules/@noble/hashes/esm/_u64.js"() {
      U32_MASK642 = /* @__PURE__ */ BigInt(2 ** 32 - 1);
      _32n2 = /* @__PURE__ */ BigInt(32);
      rotlSH2 = (h, l, s) => h << s | l >>> 32 - s;
      rotlSL2 = (h, l, s) => l << s | h >>> 32 - s;
      rotlBH2 = (h, l, s) => l << s - 32 | h >>> 64 - s;
      rotlBL2 = (h, l, s) => h << s - 32 | l >>> 64 - s;
    }
  });

  // node_modules/viem/node_modules/@noble/hashes/esm/crypto.js
  var crypto4;
  var init_crypto3 = __esm({
    "node_modules/viem/node_modules/@noble/hashes/esm/crypto.js"() {
      crypto4 = typeof globalThis === "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
    }
  });

  // node_modules/viem/node_modules/@noble/hashes/esm/utils.js
  function isBytes(a) {
    return a instanceof Uint8Array || ArrayBuffer.isView(a) && a.constructor.name === "Uint8Array";
  }
  function anumber(n2) {
    if (!Number.isSafeInteger(n2) || n2 < 0)
      throw new Error("positive integer expected, got " + n2);
  }
  function abytes(b2, ...lengths) {
    if (!isBytes(b2))
      throw new Error("Uint8Array expected");
    if (lengths.length > 0 && !lengths.includes(b2.length))
      throw new Error("Uint8Array expected of length " + lengths + ", got length=" + b2.length);
  }
  function ahash(h) {
    if (typeof h !== "function" || typeof h.create !== "function")
      throw new Error("Hash should be wrapped by utils.createHasher");
    anumber(h.outputLen);
    anumber(h.blockLen);
  }
  function aexists(instance, checkFinished = true) {
    if (instance.destroyed)
      throw new Error("Hash instance has been destroyed");
    if (checkFinished && instance.finished)
      throw new Error("Hash#digest() has already been called");
  }
  function aoutput(out, instance) {
    abytes(out);
    const min = instance.outputLen;
    if (out.length < min) {
      throw new Error("digestInto() expects output buffer of length at least " + min);
    }
  }
  function u322(arr) {
    return new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
  }
  function clean(...arrays) {
    for (let i = 0; i < arrays.length; i++) {
      arrays[i].fill(0);
    }
  }
  function createView2(arr) {
    return new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
  }
  function rotr2(word, shift) {
    return word << 32 - shift | word >>> shift;
  }
  function byteSwap(word) {
    return word << 24 & 4278190080 | word << 8 & 16711680 | word >>> 8 & 65280 | word >>> 24 & 255;
  }
  function byteSwap32(arr) {
    for (let i = 0; i < arr.length; i++) {
      arr[i] = byteSwap(arr[i]);
    }
    return arr;
  }
  function bytesToHex3(bytes2) {
    abytes(bytes2);
    if (hasHexBuiltin)
      return bytes2.toHex();
    let hex = "";
    for (let i = 0; i < bytes2.length; i++) {
      hex += hexes3[bytes2[i]];
    }
    return hex;
  }
  function asciiToBase16(ch) {
    if (ch >= asciis._0 && ch <= asciis._9)
      return ch - asciis._0;
    if (ch >= asciis.A && ch <= asciis.F)
      return ch - (asciis.A - 10);
    if (ch >= asciis.a && ch <= asciis.f)
      return ch - (asciis.a - 10);
    return;
  }
  function hexToBytes3(hex) {
    if (typeof hex !== "string")
      throw new Error("hex string expected, got " + typeof hex);
    if (hasHexBuiltin)
      return Uint8Array.fromHex(hex);
    const hl = hex.length;
    const al = hl / 2;
    if (hl % 2)
      throw new Error("hex string expected, got unpadded hex of length " + hl);
    const array = new Uint8Array(al);
    for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {
      const n1 = asciiToBase16(hex.charCodeAt(hi));
      const n2 = asciiToBase16(hex.charCodeAt(hi + 1));
      if (n1 === void 0 || n2 === void 0) {
        const char = hex[hi] + hex[hi + 1];
        throw new Error('hex string expected, got non-hex character "' + char + '" at index ' + hi);
      }
      array[ai] = n1 * 16 + n2;
    }
    return array;
  }
  function utf8ToBytes3(str) {
    if (typeof str !== "string")
      throw new Error("string expected");
    return new Uint8Array(new TextEncoder().encode(str));
  }
  function toBytes3(data) {
    if (typeof data === "string")
      data = utf8ToBytes3(data);
    abytes(data);
    return data;
  }
  function concatBytes3(...arrays) {
    let sum = 0;
    for (let i = 0; i < arrays.length; i++) {
      const a = arrays[i];
      abytes(a);
      sum += a.length;
    }
    const res = new Uint8Array(sum);
    for (let i = 0, pad4 = 0; i < arrays.length; i++) {
      const a = arrays[i];
      res.set(a, pad4);
      pad4 += a.length;
    }
    return res;
  }
  function createHasher(hashCons) {
    const hashC = (msg) => hashCons().update(toBytes3(msg)).digest();
    const tmp = hashCons();
    hashC.outputLen = tmp.outputLen;
    hashC.blockLen = tmp.blockLen;
    hashC.create = () => hashCons();
    return hashC;
  }
  function randomBytes4(bytesLength = 32) {
    if (crypto4 && typeof crypto4.getRandomValues === "function") {
      return crypto4.getRandomValues(new Uint8Array(bytesLength));
    }
    if (crypto4 && typeof crypto4.randomBytes === "function") {
      return Uint8Array.from(crypto4.randomBytes(bytesLength));
    }
    throw new Error("crypto.getRandomValues must be defined");
  }
  var isLE2, swap32IfBE, hasHexBuiltin, hexes3, asciis, Hash2;
  var init_utils6 = __esm({
    "node_modules/viem/node_modules/@noble/hashes/esm/utils.js"() {
      init_crypto3();
      isLE2 = /* @__PURE__ */ (() => new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68)();
      swap32IfBE = isLE2 ? (u) => u : byteSwap32;
      hasHexBuiltin = /* @__PURE__ */ (() => (
        // @ts-ignore
        typeof Uint8Array.from([]).toHex === "function" && typeof Uint8Array.fromHex === "function"
      ))();
      hexes3 = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, "0"));
      asciis = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };
      Hash2 = class {
      };
    }
  });

  // node_modules/viem/node_modules/@noble/hashes/esm/sha3.js
  function keccakP2(s, rounds = 24) {
    const B = new Uint32Array(5 * 2);
    for (let round = 24 - rounds; round < 24; round++) {
      for (let x = 0; x < 10; x++)
        B[x] = s[x] ^ s[x + 10] ^ s[x + 20] ^ s[x + 30] ^ s[x + 40];
      for (let x = 0; x < 10; x += 2) {
        const idx1 = (x + 8) % 10;
        const idx0 = (x + 2) % 10;
        const B0 = B[idx0];
        const B1 = B[idx0 + 1];
        const Th = rotlH2(B0, B1, 1) ^ B[idx1];
        const Tl = rotlL2(B0, B1, 1) ^ B[idx1 + 1];
        for (let y = 0; y < 50; y += 10) {
          s[x + y] ^= Th;
          s[x + y + 1] ^= Tl;
        }
      }
      let curH = s[2];
      let curL = s[3];
      for (let t = 0; t < 24; t++) {
        const shift = SHA3_ROTL2[t];
        const Th = rotlH2(curH, curL, shift);
        const Tl = rotlL2(curH, curL, shift);
        const PI = SHA3_PI2[t];
        curH = s[PI];
        curL = s[PI + 1];
        s[PI] = Th;
        s[PI + 1] = Tl;
      }
      for (let y = 0; y < 50; y += 10) {
        for (let x = 0; x < 10; x++)
          B[x] = s[y + x];
        for (let x = 0; x < 10; x++)
          s[y + x] ^= ~B[(x + 2) % 10] & B[(x + 4) % 10];
      }
      s[0] ^= SHA3_IOTA_H2[round];
      s[1] ^= SHA3_IOTA_L2[round];
    }
    clean(B);
  }
  var _0n7, _1n7, _2n6, _7n2, _256n2, _0x71n2, SHA3_PI2, SHA3_ROTL2, _SHA3_IOTA2, IOTAS, SHA3_IOTA_H2, SHA3_IOTA_L2, rotlH2, rotlL2, Keccak2, gen2, keccak_2562;
  var init_sha32 = __esm({
    "node_modules/viem/node_modules/@noble/hashes/esm/sha3.js"() {
      init_u642();
      init_utils6();
      _0n7 = BigInt(0);
      _1n7 = BigInt(1);
      _2n6 = BigInt(2);
      _7n2 = BigInt(7);
      _256n2 = BigInt(256);
      _0x71n2 = BigInt(113);
      SHA3_PI2 = [];
      SHA3_ROTL2 = [];
      _SHA3_IOTA2 = [];
      for (let round = 0, R = _1n7, x = 1, y = 0; round < 24; round++) {
        [x, y] = [y, (2 * x + 3 * y) % 5];
        SHA3_PI2.push(2 * (5 * y + x));
        SHA3_ROTL2.push((round + 1) * (round + 2) / 2 % 64);
        let t = _0n7;
        for (let j = 0; j < 7; j++) {
          R = (R << _1n7 ^ (R >> _7n2) * _0x71n2) % _256n2;
          if (R & _2n6)
            t ^= _1n7 << (_1n7 << /* @__PURE__ */ BigInt(j)) - _1n7;
        }
        _SHA3_IOTA2.push(t);
      }
      IOTAS = split3(_SHA3_IOTA2, true);
      SHA3_IOTA_H2 = IOTAS[0];
      SHA3_IOTA_L2 = IOTAS[1];
      rotlH2 = (h, l, s) => s > 32 ? rotlBH2(h, l, s) : rotlSH2(h, l, s);
      rotlL2 = (h, l, s) => s > 32 ? rotlBL2(h, l, s) : rotlSL2(h, l, s);
      Keccak2 = class _Keccak extends Hash2 {
        // NOTE: we accept arguments in bytes instead of bits here.
        constructor(blockLen, suffix, outputLen, enableXOF = false, rounds = 24) {
          super();
          this.pos = 0;
          this.posOut = 0;
          this.finished = false;
          this.destroyed = false;
          this.enableXOF = false;
          this.blockLen = blockLen;
          this.suffix = suffix;
          this.outputLen = outputLen;
          this.enableXOF = enableXOF;
          this.rounds = rounds;
          anumber(outputLen);
          if (!(0 < blockLen && blockLen < 200))
            throw new Error("only keccak-f1600 function is supported");
          this.state = new Uint8Array(200);
          this.state32 = u322(this.state);
        }
        clone() {
          return this._cloneInto();
        }
        keccak() {
          swap32IfBE(this.state32);
          keccakP2(this.state32, this.rounds);
          swap32IfBE(this.state32);
          this.posOut = 0;
          this.pos = 0;
        }
        update(data) {
          aexists(this);
          data = toBytes3(data);
          abytes(data);
          const { blockLen, state } = this;
          const len = data.length;
          for (let pos = 0; pos < len; ) {
            const take = Math.min(blockLen - this.pos, len - pos);
            for (let i = 0; i < take; i++)
              state[this.pos++] ^= data[pos++];
            if (this.pos === blockLen)
              this.keccak();
          }
          return this;
        }
        finish() {
          if (this.finished)
            return;
          this.finished = true;
          const { state, suffix, pos, blockLen } = this;
          state[pos] ^= suffix;
          if ((suffix & 128) !== 0 && pos === blockLen - 1)
            this.keccak();
          state[blockLen - 1] ^= 128;
          this.keccak();
        }
        writeInto(out) {
          aexists(this, false);
          abytes(out);
          this.finish();
          const bufferOut = this.state;
          const { blockLen } = this;
          for (let pos = 0, len = out.length; pos < len; ) {
            if (this.posOut >= blockLen)
              this.keccak();
            const take = Math.min(blockLen - this.posOut, len - pos);
            out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);
            this.posOut += take;
            pos += take;
          }
          return out;
        }
        xofInto(out) {
          if (!this.enableXOF)
            throw new Error("XOF is not possible for this instance");
          return this.writeInto(out);
        }
        xof(bytes2) {
          anumber(bytes2);
          return this.xofInto(new Uint8Array(bytes2));
        }
        digestInto(out) {
          aoutput(out, this);
          if (this.finished)
            throw new Error("digest() was already called");
          this.writeInto(out);
          this.destroy();
          return out;
        }
        digest() {
          return this.digestInto(new Uint8Array(this.outputLen));
        }
        destroy() {
          this.destroyed = true;
          clean(this.state);
        }
        _cloneInto(to) {
          const { blockLen, suffix, outputLen, rounds, enableXOF } = this;
          to || (to = new _Keccak(blockLen, suffix, outputLen, enableXOF, rounds));
          to.state32.set(this.state32);
          to.pos = this.pos;
          to.posOut = this.posOut;
          to.finished = this.finished;
          to.rounds = rounds;
          to.suffix = suffix;
          to.outputLen = outputLen;
          to.enableXOF = enableXOF;
          to.destroyed = this.destroyed;
          return to;
        }
      };
      gen2 = (suffix, blockLen, outputLen) => createHasher(() => new Keccak2(blockLen, suffix, outputLen));
      keccak_2562 = /* @__PURE__ */ (() => gen2(1, 136, 256 / 8))();
    }
  });

  // node_modules/viem/_esm/utils/hash/keccak256.js
  function keccak2562(value, to_) {
    const to = to_ || "hex";
    const bytes2 = keccak_2562(isHex(value, { strict: false }) ? toBytes2(value) : value);
    if (to === "bytes")
      return bytes2;
    return toHex(bytes2);
  }
  var init_keccak256 = __esm({
    "node_modules/viem/_esm/utils/hash/keccak256.js"() {
      init_sha32();
      init_isHex();
      init_toBytes();
      init_toHex();
    }
  });

  // node_modules/viem/_esm/utils/hash/hashSignature.js
  function hashSignature(sig) {
    return hash2(sig);
  }
  var hash2;
  var init_hashSignature = __esm({
    "node_modules/viem/_esm/utils/hash/hashSignature.js"() {
      init_toBytes();
      init_keccak256();
      hash2 = (value) => keccak2562(toBytes2(value));
    }
  });

  // node_modules/viem/_esm/utils/hash/normalizeSignature.js
  function normalizeSignature(signature) {
    let active = true;
    let current = "";
    let level = 0;
    let result = "";
    let valid = false;
    for (let i = 0; i < signature.length; i++) {
      const char = signature[i];
      if (["(", ")", ","].includes(char))
        active = true;
      if (char === "(")
        level++;
      if (char === ")")
        level--;
      if (!active)
        continue;
      if (level === 0) {
        if (char === " " && ["event", "function", ""].includes(result))
          result = "";
        else {
          result += char;
          if (char === ")") {
            valid = true;
            break;
          }
        }
        continue;
      }
      if (char === " ") {
        if (signature[i - 1] !== "," && current !== "," && current !== ",(") {
          current = "";
          active = false;
        }
        continue;
      }
      result += char;
      current += char;
    }
    if (!valid)
      throw new BaseError2("Unable to normalize signature.");
    return result;
  }
  var init_normalizeSignature = __esm({
    "node_modules/viem/_esm/utils/hash/normalizeSignature.js"() {
      init_base();
    }
  });

  // node_modules/viem/_esm/utils/hash/toSignature.js
  var toSignature;
  var init_toSignature = __esm({
    "node_modules/viem/_esm/utils/hash/toSignature.js"() {
      init_exports();
      init_normalizeSignature();
      toSignature = (def) => {
        const def_ = (() => {
          if (typeof def === "string")
            return def;
          return formatAbiItem(def);
        })();
        return normalizeSignature(def_);
      };
    }
  });

  // node_modules/viem/_esm/utils/hash/toSignatureHash.js
  function toSignatureHash(fn) {
    return hashSignature(toSignature(fn));
  }
  var init_toSignatureHash = __esm({
    "node_modules/viem/_esm/utils/hash/toSignatureHash.js"() {
      init_hashSignature();
      init_toSignature();
    }
  });

  // node_modules/viem/_esm/utils/hash/toEventSelector.js
  var toEventSelector;
  var init_toEventSelector = __esm({
    "node_modules/viem/_esm/utils/hash/toEventSelector.js"() {
      init_toSignatureHash();
      toEventSelector = toSignatureHash;
    }
  });

  // node_modules/viem/_esm/errors/address.js
  var InvalidAddressError;
  var init_address5 = __esm({
    "node_modules/viem/_esm/errors/address.js"() {
      init_base();
      InvalidAddressError = class extends BaseError2 {
        constructor({ address }) {
          super(`Address "${address}" is invalid.`, {
            metaMessages: [
              "- Address must be a hex value of 20 bytes (40 hex characters).",
              "- Address must match its checksum counterpart."
            ],
            name: "InvalidAddressError"
          });
        }
      };
    }
  });

  // node_modules/viem/_esm/utils/lru.js
  var LruMap;
  var init_lru = __esm({
    "node_modules/viem/_esm/utils/lru.js"() {
      LruMap = class extends Map {
        constructor(size5) {
          super();
          Object.defineProperty(this, "maxSize", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
          });
          this.maxSize = size5;
        }
        get(key) {
          const value = super.get(key);
          if (super.has(key) && value !== void 0) {
            this.delete(key);
            super.set(key, value);
          }
          return value;
        }
        set(key, value) {
          super.set(key, value);
          if (this.maxSize && this.size > this.maxSize) {
            const firstKey = this.keys().next().value;
            if (firstKey)
              this.delete(firstKey);
          }
          return this;
        }
      };
    }
  });

  // node_modules/viem/_esm/utils/address/getAddress.js
  function checksumAddress(address_, chainId) {
    if (checksumAddressCache.has(`${address_}.${chainId}`))
      return checksumAddressCache.get(`${address_}.${chainId}`);
    const hexAddress = chainId ? `${chainId}${address_.toLowerCase()}` : address_.substring(2).toLowerCase();
    const hash3 = keccak2562(stringToBytes(hexAddress), "bytes");
    const address = (chainId ? hexAddress.substring(`${chainId}0x`.length) : hexAddress).split("");
    for (let i = 0; i < 40; i += 2) {
      if (hash3[i >> 1] >> 4 >= 8 && address[i]) {
        address[i] = address[i].toUpperCase();
      }
      if ((hash3[i >> 1] & 15) >= 8 && address[i + 1]) {
        address[i + 1] = address[i + 1].toUpperCase();
      }
    }
    const result = `0x${address.join("")}`;
    checksumAddressCache.set(`${address_}.${chainId}`, result);
    return result;
  }
  function getAddress2(address, chainId) {
    if (!isAddress2(address, { strict: false }))
      throw new InvalidAddressError({ address });
    return checksumAddress(address, chainId);
  }
  var checksumAddressCache;
  var init_getAddress = __esm({
    "node_modules/viem/_esm/utils/address/getAddress.js"() {
      init_address5();
      init_toBytes();
      init_keccak256();
      init_lru();
      init_isAddress();
      checksumAddressCache = /* @__PURE__ */ new LruMap(8192);
    }
  });

  // node_modules/viem/_esm/utils/address/isAddress.js
  function isAddress2(address, options) {
    const { strict = true } = options ?? {};
    const cacheKey2 = `${address}.${strict}`;
    if (isAddressCache.has(cacheKey2))
      return isAddressCache.get(cacheKey2);
    const result = (() => {
      if (!addressRegex.test(address))
        return false;
      if (address.toLowerCase() === address)
        return true;
      if (strict)
        return checksumAddress(address) === address;
      return true;
    })();
    isAddressCache.set(cacheKey2, result);
    return result;
  }
  var addressRegex, isAddressCache;
  var init_isAddress = __esm({
    "node_modules/viem/_esm/utils/address/isAddress.js"() {
      init_lru();
      init_getAddress();
      addressRegex = /^0x[a-fA-F0-9]{40}$/;
      isAddressCache = /* @__PURE__ */ new LruMap(8192);
    }
  });

  // node_modules/viem/_esm/utils/data/concat.js
  function concat2(values) {
    if (typeof values[0] === "string")
      return concatHex(values);
    return concatBytes4(values);
  }
  function concatBytes4(values) {
    let length = 0;
    for (const arr of values) {
      length += arr.length;
    }
    const result = new Uint8Array(length);
    let offset = 0;
    for (const arr of values) {
      result.set(arr, offset);
      offset += arr.length;
    }
    return result;
  }
  function concatHex(values) {
    return `0x${values.reduce((acc, x) => acc + x.replace("0x", ""), "")}`;
  }
  var init_concat = __esm({
    "node_modules/viem/_esm/utils/data/concat.js"() {
    }
  });

  // node_modules/viem/_esm/utils/data/slice.js
  function slice(value, start, end, { strict } = {}) {
    if (isHex(value, { strict: false }))
      return sliceHex(value, start, end, {
        strict
      });
    return sliceBytes(value, start, end, {
      strict
    });
  }
  function assertStartOffset(value, start) {
    if (typeof start === "number" && start > 0 && start > size(value) - 1)
      throw new SliceOffsetOutOfBoundsError({
        offset: start,
        position: "start",
        size: size(value)
      });
  }
  function assertEndOffset(value, start, end) {
    if (typeof start === "number" && typeof end === "number" && size(value) !== end - start) {
      throw new SliceOffsetOutOfBoundsError({
        offset: end,
        position: "end",
        size: size(value)
      });
    }
  }
  function sliceBytes(value_, start, end, { strict } = {}) {
    assertStartOffset(value_, start);
    const value = value_.slice(start, end);
    if (strict)
      assertEndOffset(value, start, end);
    return value;
  }
  function sliceHex(value_, start, end, { strict } = {}) {
    assertStartOffset(value_, start);
    const value = `0x${value_.replace("0x", "").slice((start ?? 0) * 2, (end ?? value_.length) * 2)}`;
    if (strict)
      assertEndOffset(value, start, end);
    return value;
  }
  var init_slice = __esm({
    "node_modules/viem/_esm/utils/data/slice.js"() {
      init_data2();
      init_isHex();
      init_size();
    }
  });

  // node_modules/viem/_esm/utils/regex.js
  var bytesRegex2, integerRegex2;
  var init_regex2 = __esm({
    "node_modules/viem/_esm/utils/regex.js"() {
      bytesRegex2 = /^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/;
      integerRegex2 = /^(u?int)(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/;
    }
  });

  // node_modules/viem/_esm/utils/abi/encodeAbiParameters.js
  function encodeAbiParameters(params, values) {
    if (params.length !== values.length)
      throw new AbiEncodingLengthMismatchError({
        expectedLength: params.length,
        givenLength: values.length
      });
    const preparedParams = prepareParams({
      params,
      values
    });
    const data = encodeParams(preparedParams);
    if (data.length === 0)
      return "0x";
    return data;
  }
  function prepareParams({ params, values }) {
    const preparedParams = [];
    for (let i = 0; i < params.length; i++) {
      preparedParams.push(prepareParam({ param: params[i], value: values[i] }));
    }
    return preparedParams;
  }
  function prepareParam({ param, value }) {
    const arrayComponents = getArrayComponents(param.type);
    if (arrayComponents) {
      const [length, type] = arrayComponents;
      return encodeArray(value, { length, param: { ...param, type } });
    }
    if (param.type === "tuple") {
      return encodeTuple(value, {
        param
      });
    }
    if (param.type === "address") {
      return encodeAddress(value);
    }
    if (param.type === "bool") {
      return encodeBool(value);
    }
    if (param.type.startsWith("uint") || param.type.startsWith("int")) {
      const signed2 = param.type.startsWith("int");
      const [, , size5 = "256"] = integerRegex2.exec(param.type) ?? [];
      return encodeNumber(value, {
        signed: signed2,
        size: Number(size5)
      });
    }
    if (param.type.startsWith("bytes")) {
      return encodeBytes2(value, { param });
    }
    if (param.type === "string") {
      return encodeString(value);
    }
    throw new InvalidAbiEncodingTypeError(param.type, {
      docsPath: "/docs/contract/encodeAbiParameters"
    });
  }
  function encodeParams(preparedParams) {
    let staticSize = 0;
    for (let i = 0; i < preparedParams.length; i++) {
      const { dynamic, encoded } = preparedParams[i];
      if (dynamic)
        staticSize += 32;
      else
        staticSize += size(encoded);
    }
    const staticParams = [];
    const dynamicParams = [];
    let dynamicSize = 0;
    for (let i = 0; i < preparedParams.length; i++) {
      const { dynamic, encoded } = preparedParams[i];
      if (dynamic) {
        staticParams.push(numberToHex(staticSize + dynamicSize, { size: 32 }));
        dynamicParams.push(encoded);
        dynamicSize += size(encoded);
      } else {
        staticParams.push(encoded);
      }
    }
    return concat2([...staticParams, ...dynamicParams]);
  }
  function encodeAddress(value) {
    if (!isAddress2(value))
      throw new InvalidAddressError({ address: value });
    return { dynamic: false, encoded: padHex(value.toLowerCase()) };
  }
  function encodeArray(value, { length, param }) {
    const dynamic = length === null;
    if (!Array.isArray(value))
      throw new InvalidArrayError(value);
    if (!dynamic && value.length !== length)
      throw new AbiEncodingArrayLengthMismatchError({
        expectedLength: length,
        givenLength: value.length,
        type: `${param.type}[${length}]`
      });
    let dynamicChild = false;
    const preparedParams = [];
    for (let i = 0; i < value.length; i++) {
      const preparedParam = prepareParam({ param, value: value[i] });
      if (preparedParam.dynamic)
        dynamicChild = true;
      preparedParams.push(preparedParam);
    }
    if (dynamic || dynamicChild) {
      const data = encodeParams(preparedParams);
      if (dynamic) {
        const length2 = numberToHex(preparedParams.length, { size: 32 });
        return {
          dynamic: true,
          encoded: preparedParams.length > 0 ? concat2([length2, data]) : length2
        };
      }
      if (dynamicChild)
        return { dynamic: true, encoded: data };
    }
    return {
      dynamic: false,
      encoded: concat2(preparedParams.map(({ encoded }) => encoded))
    };
  }
  function encodeBytes2(value, { param }) {
    const [, paramSize] = param.type.split("bytes");
    const bytesSize = size(value);
    if (!paramSize) {
      let value_ = value;
      if (bytesSize % 32 !== 0)
        value_ = padHex(value_, {
          dir: "right",
          size: Math.ceil((value.length - 2) / 2 / 32) * 32
        });
      return {
        dynamic: true,
        encoded: concat2([padHex(numberToHex(bytesSize, { size: 32 })), value_])
      };
    }
    if (bytesSize !== Number.parseInt(paramSize))
      throw new AbiEncodingBytesSizeMismatchError({
        expectedSize: Number.parseInt(paramSize),
        value
      });
    return { dynamic: false, encoded: padHex(value, { dir: "right" }) };
  }
  function encodeBool(value) {
    if (typeof value !== "boolean")
      throw new BaseError2(`Invalid boolean value: "${value}" (type: ${typeof value}). Expected: \`true\` or \`false\`.`);
    return { dynamic: false, encoded: padHex(boolToHex(value)) };
  }
  function encodeNumber(value, { signed: signed2, size: size5 = 256 }) {
    if (typeof size5 === "number") {
      const max = 2n ** (BigInt(size5) - (signed2 ? 1n : 0n)) - 1n;
      const min = signed2 ? -max - 1n : 0n;
      if (value > max || value < min)
        throw new IntegerOutOfRangeError({
          max: max.toString(),
          min: min.toString(),
          signed: signed2,
          size: size5 / 8,
          value: value.toString()
        });
    }
    return {
      dynamic: false,
      encoded: numberToHex(value, {
        size: 32,
        signed: signed2
      })
    };
  }
  function encodeString(value) {
    const hexValue = stringToHex(value);
    const partsLength = Math.ceil(size(hexValue) / 32);
    const parts = [];
    for (let i = 0; i < partsLength; i++) {
      parts.push(padHex(slice(hexValue, i * 32, (i + 1) * 32), {
        dir: "right"
      }));
    }
    return {
      dynamic: true,
      encoded: concat2([
        padHex(numberToHex(size(hexValue), { size: 32 })),
        ...parts
      ])
    };
  }
  function encodeTuple(value, { param }) {
    let dynamic = false;
    const preparedParams = [];
    for (let i = 0; i < param.components.length; i++) {
      const param_ = param.components[i];
      const index2 = Array.isArray(value) ? i : param_.name;
      const preparedParam = prepareParam({
        param: param_,
        value: value[index2]
      });
      preparedParams.push(preparedParam);
      if (preparedParam.dynamic)
        dynamic = true;
    }
    return {
      dynamic,
      encoded: dynamic ? encodeParams(preparedParams) : concat2(preparedParams.map(({ encoded }) => encoded))
    };
  }
  function getArrayComponents(type) {
    const matches = type.match(/^(.*)\[(\d+)?\]$/);
    return matches ? (
      // Return `null` if the array is dynamic.
      [matches[2] ? Number(matches[2]) : null, matches[1]]
    ) : void 0;
  }
  var init_encodeAbiParameters = __esm({
    "node_modules/viem/_esm/utils/abi/encodeAbiParameters.js"() {
      init_abi2();
      init_address5();
      init_base();
      init_encoding();
      init_isAddress();
      init_concat();
      init_pad();
      init_size();
      init_slice();
      init_toHex();
      init_regex2();
    }
  });

  // node_modules/viem/_esm/utils/hash/toFunctionSelector.js
  var toFunctionSelector;
  var init_toFunctionSelector = __esm({
    "node_modules/viem/_esm/utils/hash/toFunctionSelector.js"() {
      init_slice();
      init_toSignatureHash();
      toFunctionSelector = (fn) => slice(toSignatureHash(fn), 0, 4);
    }
  });

  // node_modules/viem/_esm/utils/abi/getAbiItem.js
  function getAbiItem(parameters) {
    const { abi: abi2, args = [], name } = parameters;
    const isSelector = isHex(name, { strict: false });
    const abiItems = abi2.filter((abiItem) => {
      if (isSelector) {
        if (abiItem.type === "function")
          return toFunctionSelector(abiItem) === name;
        if (abiItem.type === "event")
          return toEventSelector(abiItem) === name;
        return false;
      }
      return "name" in abiItem && abiItem.name === name;
    });
    if (abiItems.length === 0)
      return void 0;
    if (abiItems.length === 1)
      return abiItems[0];
    let matchedAbiItem = void 0;
    for (const abiItem of abiItems) {
      if (!("inputs" in abiItem))
        continue;
      if (!args || args.length === 0) {
        if (!abiItem.inputs || abiItem.inputs.length === 0)
          return abiItem;
        continue;
      }
      if (!abiItem.inputs)
        continue;
      if (abiItem.inputs.length === 0)
        continue;
      if (abiItem.inputs.length !== args.length)
        continue;
      const matched = args.every((arg, index2) => {
        const abiParameter = "inputs" in abiItem && abiItem.inputs[index2];
        if (!abiParameter)
          return false;
        return isArgOfType(arg, abiParameter);
      });
      if (matched) {
        if (matchedAbiItem && "inputs" in matchedAbiItem && matchedAbiItem.inputs) {
          const ambiguousTypes = getAmbiguousTypes(abiItem.inputs, matchedAbiItem.inputs, args);
          if (ambiguousTypes)
            throw new AbiItemAmbiguityError({
              abiItem,
              type: ambiguousTypes[0]
            }, {
              abiItem: matchedAbiItem,
              type: ambiguousTypes[1]
            });
        }
        matchedAbiItem = abiItem;
      }
    }
    if (matchedAbiItem)
      return matchedAbiItem;
    return abiItems[0];
  }
  function isArgOfType(arg, abiParameter) {
    const argType = typeof arg;
    const abiParameterType = abiParameter.type;
    switch (abiParameterType) {
      case "address":
        return isAddress2(arg, { strict: false });
      case "bool":
        return argType === "boolean";
      case "function":
        return argType === "string";
      case "string":
        return argType === "string";
      default: {
        if (abiParameterType === "tuple" && "components" in abiParameter)
          return Object.values(abiParameter.components).every((component, index2) => {
            return isArgOfType(Object.values(arg)[index2], component);
          });
        if (/^u?int(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/.test(abiParameterType))
          return argType === "number" || argType === "bigint";
        if (/^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/.test(abiParameterType))
          return argType === "string" || arg instanceof Uint8Array;
        if (/[a-z]+[1-9]{0,3}(\[[0-9]{0,}\])+$/.test(abiParameterType)) {
          return Array.isArray(arg) && arg.every((x) => isArgOfType(x, {
            ...abiParameter,
            // Pop off `[]` or `[M]` from end of type
            type: abiParameterType.replace(/(\[[0-9]{0,}\])$/, "")
          }));
        }
        return false;
      }
    }
  }
  function getAmbiguousTypes(sourceParameters, targetParameters, args) {
    for (const parameterIndex in sourceParameters) {
      const sourceParameter = sourceParameters[parameterIndex];
      const targetParameter = targetParameters[parameterIndex];
      if (sourceParameter.type === "tuple" && targetParameter.type === "tuple" && "components" in sourceParameter && "components" in targetParameter)
        return getAmbiguousTypes(sourceParameter.components, targetParameter.components, args[parameterIndex]);
      const types = [sourceParameter.type, targetParameter.type];
      const ambiguous = (() => {
        if (types.includes("address") && types.includes("bytes20"))
          return true;
        if (types.includes("address") && types.includes("string"))
          return isAddress2(args[parameterIndex], { strict: false });
        if (types.includes("address") && types.includes("bytes"))
          return isAddress2(args[parameterIndex], { strict: false });
        return false;
      })();
      if (ambiguous)
        return types;
    }
    return;
  }
  var init_getAbiItem = __esm({
    "node_modules/viem/_esm/utils/abi/getAbiItem.js"() {
      init_abi2();
      init_isHex();
      init_isAddress();
      init_toEventSelector();
      init_toFunctionSelector();
    }
  });

  // node_modules/viem/_esm/utils/abi/encodeEventTopics.js
  function encodeEventTopics(parameters) {
    const { abi: abi2, eventName, args } = parameters;
    let abiItem = abi2[0];
    if (eventName) {
      const item = getAbiItem({ abi: abi2, name: eventName });
      if (!item)
        throw new AbiEventNotFoundError(eventName, { docsPath });
      abiItem = item;
    }
    if (abiItem.type !== "event")
      throw new AbiEventNotFoundError(void 0, { docsPath });
    const definition = formatAbiItem2(abiItem);
    const signature = toEventSelector(definition);
    let topics = [];
    if (args && "inputs" in abiItem) {
      const indexedInputs = abiItem.inputs?.filter((param) => "indexed" in param && param.indexed);
      const args_ = Array.isArray(args) ? args : Object.values(args).length > 0 ? indexedInputs?.map((x) => args[x.name]) ?? [] : [];
      if (args_.length > 0) {
        topics = indexedInputs?.map((param, i) => {
          if (Array.isArray(args_[i]))
            return args_[i].map((_, j) => encodeArg({ param, value: args_[i][j] }));
          return typeof args_[i] !== "undefined" && args_[i] !== null ? encodeArg({ param, value: args_[i] }) : null;
        }) ?? [];
      }
    }
    return [signature, ...topics];
  }
  function encodeArg({ param, value }) {
    if (param.type === "string" || param.type === "bytes")
      return keccak2562(toBytes2(value));
    if (param.type === "tuple" || param.type.match(/^(.*)\[(\d+)?\]$/))
      throw new FilterTypeNotSupportedError(param.type);
    return encodeAbiParameters([param], [value]);
  }
  var docsPath;
  var init_encodeEventTopics = __esm({
    "node_modules/viem/_esm/utils/abi/encodeEventTopics.js"() {
      init_abi2();
      init_log();
      init_toBytes();
      init_keccak256();
      init_toEventSelector();
      init_encodeAbiParameters();
      init_formatAbiItem2();
      init_getAbiItem();
      docsPath = "/docs/contract/encodeEventTopics";
    }
  });

  // node_modules/viem/_esm/utils/filters/createFilterRequestScope.js
  function createFilterRequestScope(client, { method }) {
    const requestMap = {};
    if (client.transport.type === "fallback")
      client.transport.onResponse?.(({ method: method_, response: id2, status, transport }) => {
        if (status === "success" && method === method_)
          requestMap[id2] = transport.request;
      });
    return (id2) => requestMap[id2] || client.request;
  }
  var init_createFilterRequestScope = __esm({
    "node_modules/viem/_esm/utils/filters/createFilterRequestScope.js"() {
    }
  });

  // node_modules/viem/_esm/actions/public/createContractEventFilter.js
  async function createContractEventFilter(client, parameters) {
    const { address, abi: abi2, args, eventName, fromBlock, strict, toBlock } = parameters;
    const getRequest = createFilterRequestScope(client, {
      method: "eth_newFilter"
    });
    const topics = eventName ? encodeEventTopics({
      abi: abi2,
      args,
      eventName
    }) : void 0;
    const id2 = await client.request({
      method: "eth_newFilter",
      params: [
        {
          address,
          fromBlock: typeof fromBlock === "bigint" ? numberToHex(fromBlock) : fromBlock,
          toBlock: typeof toBlock === "bigint" ? numberToHex(toBlock) : toBlock,
          topics
        }
      ]
    });
    return {
      abi: abi2,
      args,
      eventName,
      id: id2,
      request: getRequest(id2),
      strict: Boolean(strict),
      type: "event"
    };
  }
  var init_createContractEventFilter = __esm({
    "node_modules/viem/_esm/actions/public/createContractEventFilter.js"() {
      init_encodeEventTopics();
      init_toHex();
      init_createFilterRequestScope();
    }
  });

  // node_modules/viem/_esm/accounts/utils/parseAccount.js
  function parseAccount(account) {
    if (typeof account === "string")
      return { address: account, type: "json-rpc" };
    return account;
  }
  var init_parseAccount = __esm({
    "node_modules/viem/_esm/accounts/utils/parseAccount.js"() {
    }
  });

  // node_modules/viem/_esm/utils/abi/prepareEncodeFunctionData.js
  function prepareEncodeFunctionData(parameters) {
    const { abi: abi2, args, functionName } = parameters;
    let abiItem = abi2[0];
    if (functionName) {
      const item = getAbiItem({
        abi: abi2,
        args,
        name: functionName
      });
      if (!item)
        throw new AbiFunctionNotFoundError(functionName, { docsPath: docsPath2 });
      abiItem = item;
    }
    if (abiItem.type !== "function")
      throw new AbiFunctionNotFoundError(void 0, { docsPath: docsPath2 });
    return {
      abi: [abiItem],
      functionName: toFunctionSelector(formatAbiItem2(abiItem))
    };
  }
  var docsPath2;
  var init_prepareEncodeFunctionData = __esm({
    "node_modules/viem/_esm/utils/abi/prepareEncodeFunctionData.js"() {
      init_abi2();
      init_toFunctionSelector();
      init_formatAbiItem2();
      init_getAbiItem();
      docsPath2 = "/docs/contract/encodeFunctionData";
    }
  });

  // node_modules/viem/_esm/utils/abi/encodeFunctionData.js
  function encodeFunctionData(parameters) {
    const { args } = parameters;
    const { abi: abi2, functionName } = (() => {
      if (parameters.abi.length === 1 && parameters.functionName?.startsWith("0x"))
        return parameters;
      return prepareEncodeFunctionData(parameters);
    })();
    const abiItem = abi2[0];
    const signature = functionName;
    const data = "inputs" in abiItem && abiItem.inputs ? encodeAbiParameters(abiItem.inputs, args ?? []) : void 0;
    return concatHex([signature, data ?? "0x"]);
  }
  var init_encodeFunctionData = __esm({
    "node_modules/viem/_esm/utils/abi/encodeFunctionData.js"() {
      init_concat();
      init_encodeAbiParameters();
      init_prepareEncodeFunctionData();
    }
  });

  // node_modules/viem/_esm/constants/solidity.js
  var panicReasons, solidityError, solidityPanic;
  var init_solidity2 = __esm({
    "node_modules/viem/_esm/constants/solidity.js"() {
      panicReasons = {
        1: "An `assert` condition failed.",
        17: "Arithmetic operation resulted in underflow or overflow.",
        18: "Division or modulo by zero (e.g. `5 / 0` or `23 % 0`).",
        33: "Attempted to convert to an invalid type.",
        34: "Attempted to access a storage byte array that is incorrectly encoded.",
        49: "Performed `.pop()` on an empty array",
        50: "Array index is out of bounds.",
        65: "Allocated too much memory or created an array which is too large.",
        81: "Attempted to call a zero-initialized variable of internal function type."
      };
      solidityError = {
        inputs: [
          {
            name: "message",
            type: "string"
          }
        ],
        name: "Error",
        type: "error"
      };
      solidityPanic = {
        inputs: [
          {
            name: "reason",
            type: "uint256"
          }
        ],
        name: "Panic",
        type: "error"
      };
    }
  });

  // node_modules/viem/_esm/errors/cursor.js
  var NegativeOffsetError, PositionOutOfBoundsError, RecursiveReadLimitExceededError;
  var init_cursor = __esm({
    "node_modules/viem/_esm/errors/cursor.js"() {
      init_base();
      NegativeOffsetError = class extends BaseError2 {
        constructor({ offset }) {
          super(`Offset \`${offset}\` cannot be negative.`, {
            name: "NegativeOffsetError"
          });
        }
      };
      PositionOutOfBoundsError = class extends BaseError2 {
        constructor({ length, position }) {
          super(`Position \`${position}\` is out of bounds (\`0 < position < ${length}\`).`, { name: "PositionOutOfBoundsError" });
        }
      };
      RecursiveReadLimitExceededError = class extends BaseError2 {
        constructor({ count, limit }) {
          super(`Recursive read limit of \`${limit}\` exceeded (recursive read count: \`${count}\`).`, { name: "RecursiveReadLimitExceededError" });
        }
      };
    }
  });

  // node_modules/viem/_esm/utils/cursor.js
  function createCursor(bytes2, { recursiveReadLimit = 8192 } = {}) {
    const cursor = Object.create(staticCursor);
    cursor.bytes = bytes2;
    cursor.dataView = new DataView(bytes2.buffer, bytes2.byteOffset, bytes2.byteLength);
    cursor.positionReadCount = /* @__PURE__ */ new Map();
    cursor.recursiveReadLimit = recursiveReadLimit;
    return cursor;
  }
  var staticCursor;
  var init_cursor2 = __esm({
    "node_modules/viem/_esm/utils/cursor.js"() {
      init_cursor();
      staticCursor = {
        bytes: new Uint8Array(),
        dataView: new DataView(new ArrayBuffer(0)),
        position: 0,
        positionReadCount: /* @__PURE__ */ new Map(),
        recursiveReadCount: 0,
        recursiveReadLimit: Number.POSITIVE_INFINITY,
        assertReadLimit() {
          if (this.recursiveReadCount >= this.recursiveReadLimit)
            throw new RecursiveReadLimitExceededError({
              count: this.recursiveReadCount + 1,
              limit: this.recursiveReadLimit
            });
        },
        assertPosition(position) {
          if (position < 0 || position > this.bytes.length - 1)
            throw new PositionOutOfBoundsError({
              length: this.bytes.length,
              position
            });
        },
        decrementPosition(offset) {
          if (offset < 0)
            throw new NegativeOffsetError({ offset });
          const position = this.position - offset;
          this.assertPosition(position);
          this.position = position;
        },
        getReadCount(position) {
          return this.positionReadCount.get(position || this.position) || 0;
        },
        incrementPosition(offset) {
          if (offset < 0)
            throw new NegativeOffsetError({ offset });
          const position = this.position + offset;
          this.assertPosition(position);
          this.position = position;
        },
        inspectByte(position_) {
          const position = position_ ?? this.position;
          this.assertPosition(position);
          return this.bytes[position];
        },
        inspectBytes(length, position_) {
          const position = position_ ?? this.position;
          this.assertPosition(position + length - 1);
          return this.bytes.subarray(position, position + length);
        },
        inspectUint8(position_) {
          const position = position_ ?? this.position;
          this.assertPosition(position);
          return this.bytes[position];
        },
        inspectUint16(position_) {
          const position = position_ ?? this.position;
          this.assertPosition(position + 1);
          return this.dataView.getUint16(position);
        },
        inspectUint24(position_) {
          const position = position_ ?? this.position;
          this.assertPosition(position + 2);
          return (this.dataView.getUint16(position) << 8) + this.dataView.getUint8(position + 2);
        },
        inspectUint32(position_) {
          const position = position_ ?? this.position;
          this.assertPosition(position + 3);
          return this.dataView.getUint32(position);
        },
        pushByte(byte) {
          this.assertPosition(this.position);
          this.bytes[this.position] = byte;
          this.position++;
        },
        pushBytes(bytes2) {
          this.assertPosition(this.position + bytes2.length - 1);
          this.bytes.set(bytes2, this.position);
          this.position += bytes2.length;
        },
        pushUint8(value) {
          this.assertPosition(this.position);
          this.bytes[this.position] = value;
          this.position++;
        },
        pushUint16(value) {
          this.assertPosition(this.position + 1);
          this.dataView.setUint16(this.position, value);
          this.position += 2;
        },
        pushUint24(value) {
          this.assertPosition(this.position + 2);
          this.dataView.setUint16(this.position, value >> 8);
          this.dataView.setUint8(this.position + 2, value & ~4294967040);
          this.position += 3;
        },
        pushUint32(value) {
          this.assertPosition(this.position + 3);
          this.dataView.setUint32(this.position, value);
          this.position += 4;
        },
        readByte() {
          this.assertReadLimit();
          this._touch();
          const value = this.inspectByte();
          this.position++;
          return value;
        },
        readBytes(length, size5) {
          this.assertReadLimit();
          this._touch();
          const value = this.inspectBytes(length);
          this.position += size5 ?? length;
          return value;
        },
        readUint8() {
          this.assertReadLimit();
          this._touch();
          const value = this.inspectUint8();
          this.position += 1;
          return value;
        },
        readUint16() {
          this.assertReadLimit();
          this._touch();
          const value = this.inspectUint16();
          this.position += 2;
          return value;
        },
        readUint24() {
          this.assertReadLimit();
          this._touch();
          const value = this.inspectUint24();
          this.position += 3;
          return value;
        },
        readUint32() {
          this.assertReadLimit();
          this._touch();
          const value = this.inspectUint32();
          this.position += 4;
          return value;
        },
        get remaining() {
          return this.bytes.length - this.position;
        },
        setPosition(position) {
          const oldPosition = this.position;
          this.assertPosition(position);
          this.position = position;
          return () => this.position = oldPosition;
        },
        _touch() {
          if (this.recursiveReadLimit === Number.POSITIVE_INFINITY)
            return;
          const count = this.getReadCount();
          this.positionReadCount.set(this.position, count + 1);
          if (count > 0)
            this.recursiveReadCount++;
        }
      };
    }
  });

  // node_modules/viem/_esm/utils/encoding/fromBytes.js
  function bytesToBigInt(bytes2, opts = {}) {
    if (typeof opts.size !== "undefined")
      assertSize(bytes2, { size: opts.size });
    const hex = bytesToHex2(bytes2, opts);
    return hexToBigInt(hex, opts);
  }
  function bytesToBool(bytes_, opts = {}) {
    let bytes2 = bytes_;
    if (typeof opts.size !== "undefined") {
      assertSize(bytes2, { size: opts.size });
      bytes2 = trim(bytes2);
    }
    if (bytes2.length > 1 || bytes2[0] > 1)
      throw new InvalidBytesBooleanError(bytes2);
    return Boolean(bytes2[0]);
  }
  function bytesToNumber(bytes2, opts = {}) {
    if (typeof opts.size !== "undefined")
      assertSize(bytes2, { size: opts.size });
    const hex = bytesToHex2(bytes2, opts);
    return hexToNumber2(hex, opts);
  }
  function bytesToString(bytes_, opts = {}) {
    let bytes2 = bytes_;
    if (typeof opts.size !== "undefined") {
      assertSize(bytes2, { size: opts.size });
      bytes2 = trim(bytes2, { dir: "right" });
    }
    return new TextDecoder().decode(bytes2);
  }
  var init_fromBytes = __esm({
    "node_modules/viem/_esm/utils/encoding/fromBytes.js"() {
      init_encoding();
      init_trim();
      init_fromHex();
      init_toHex();
    }
  });

  // node_modules/viem/_esm/utils/abi/decodeAbiParameters.js
  function decodeAbiParameters(params, data) {
    const bytes2 = typeof data === "string" ? hexToBytes2(data) : data;
    const cursor = createCursor(bytes2);
    if (size(bytes2) === 0 && params.length > 0)
      throw new AbiDecodingZeroDataError();
    if (size(data) && size(data) < 32)
      throw new AbiDecodingDataSizeTooSmallError({
        data: typeof data === "string" ? data : bytesToHex2(data),
        params,
        size: size(data)
      });
    let consumed = 0;
    const values = [];
    for (let i = 0; i < params.length; ++i) {
      const param = params[i];
      cursor.setPosition(consumed);
      const [data2, consumed_] = decodeParameter(cursor, param, {
        staticPosition: 0
      });
      consumed += consumed_;
      values.push(data2);
    }
    return values;
  }
  function decodeParameter(cursor, param, { staticPosition }) {
    const arrayComponents = getArrayComponents(param.type);
    if (arrayComponents) {
      const [length, type] = arrayComponents;
      return decodeArray(cursor, { ...param, type }, { length, staticPosition });
    }
    if (param.type === "tuple")
      return decodeTuple(cursor, param, { staticPosition });
    if (param.type === "address")
      return decodeAddress(cursor);
    if (param.type === "bool")
      return decodeBool(cursor);
    if (param.type.startsWith("bytes"))
      return decodeBytes(cursor, param, { staticPosition });
    if (param.type.startsWith("uint") || param.type.startsWith("int"))
      return decodeNumber(cursor, param);
    if (param.type === "string")
      return decodeString(cursor, { staticPosition });
    throw new InvalidAbiDecodingTypeError(param.type, {
      docsPath: "/docs/contract/decodeAbiParameters"
    });
  }
  function decodeAddress(cursor) {
    const value = cursor.readBytes(32);
    return [checksumAddress(bytesToHex2(sliceBytes(value, -20))), 32];
  }
  function decodeArray(cursor, param, { length, staticPosition }) {
    if (!length) {
      const offset = bytesToNumber(cursor.readBytes(sizeOfOffset));
      const start = staticPosition + offset;
      const startOfData = start + sizeOfLength;
      cursor.setPosition(start);
      const length2 = bytesToNumber(cursor.readBytes(sizeOfLength));
      const dynamicChild = hasDynamicChild(param);
      let consumed2 = 0;
      const value2 = [];
      for (let i = 0; i < length2; ++i) {
        cursor.setPosition(startOfData + (dynamicChild ? i * 32 : consumed2));
        const [data, consumed_] = decodeParameter(cursor, param, {
          staticPosition: startOfData
        });
        consumed2 += consumed_;
        value2.push(data);
      }
      cursor.setPosition(staticPosition + 32);
      return [value2, 32];
    }
    if (hasDynamicChild(param)) {
      const offset = bytesToNumber(cursor.readBytes(sizeOfOffset));
      const start = staticPosition + offset;
      const value2 = [];
      for (let i = 0; i < length; ++i) {
        cursor.setPosition(start + i * 32);
        const [data] = decodeParameter(cursor, param, {
          staticPosition: start
        });
        value2.push(data);
      }
      cursor.setPosition(staticPosition + 32);
      return [value2, 32];
    }
    let consumed = 0;
    const value = [];
    for (let i = 0; i < length; ++i) {
      const [data, consumed_] = decodeParameter(cursor, param, {
        staticPosition: staticPosition + consumed
      });
      consumed += consumed_;
      value.push(data);
    }
    return [value, consumed];
  }
  function decodeBool(cursor) {
    return [bytesToBool(cursor.readBytes(32), { size: 32 }), 32];
  }
  function decodeBytes(cursor, param, { staticPosition }) {
    const [_, size5] = param.type.split("bytes");
    if (!size5) {
      const offset = bytesToNumber(cursor.readBytes(32));
      cursor.setPosition(staticPosition + offset);
      const length = bytesToNumber(cursor.readBytes(32));
      if (length === 0) {
        cursor.setPosition(staticPosition + 32);
        return ["0x", 32];
      }
      const data = cursor.readBytes(length);
      cursor.setPosition(staticPosition + 32);
      return [bytesToHex2(data), 32];
    }
    const value = bytesToHex2(cursor.readBytes(Number.parseInt(size5), 32));
    return [value, 32];
  }
  function decodeNumber(cursor, param) {
    const signed2 = param.type.startsWith("int");
    const size5 = Number.parseInt(param.type.split("int")[1] || "256");
    const value = cursor.readBytes(32);
    return [
      size5 > 48 ? bytesToBigInt(value, { signed: signed2 }) : bytesToNumber(value, { signed: signed2 }),
      32
    ];
  }
  function decodeTuple(cursor, param, { staticPosition }) {
    const hasUnnamedChild = param.components.length === 0 || param.components.some(({ name }) => !name);
    const value = hasUnnamedChild ? [] : {};
    let consumed = 0;
    if (hasDynamicChild(param)) {
      const offset = bytesToNumber(cursor.readBytes(sizeOfOffset));
      const start = staticPosition + offset;
      for (let i = 0; i < param.components.length; ++i) {
        const component = param.components[i];
        cursor.setPosition(start + consumed);
        const [data, consumed_] = decodeParameter(cursor, component, {
          staticPosition: start
        });
        consumed += consumed_;
        value[hasUnnamedChild ? i : component?.name] = data;
      }
      cursor.setPosition(staticPosition + 32);
      return [value, 32];
    }
    for (let i = 0; i < param.components.length; ++i) {
      const component = param.components[i];
      const [data, consumed_] = decodeParameter(cursor, component, {
        staticPosition
      });
      value[hasUnnamedChild ? i : component?.name] = data;
      consumed += consumed_;
    }
    return [value, consumed];
  }
  function decodeString(cursor, { staticPosition }) {
    const offset = bytesToNumber(cursor.readBytes(32));
    const start = staticPosition + offset;
    cursor.setPosition(start);
    const length = bytesToNumber(cursor.readBytes(32));
    if (length === 0) {
      cursor.setPosition(staticPosition + 32);
      return ["", 32];
    }
    const data = cursor.readBytes(length, 32);
    const value = bytesToString(trim(data));
    cursor.setPosition(staticPosition + 32);
    return [value, 32];
  }
  function hasDynamicChild(param) {
    const { type } = param;
    if (type === "string")
      return true;
    if (type === "bytes")
      return true;
    if (type.endsWith("[]"))
      return true;
    if (type === "tuple")
      return param.components?.some(hasDynamicChild);
    const arrayComponents = getArrayComponents(param.type);
    if (arrayComponents && hasDynamicChild({ ...param, type: arrayComponents[1] }))
      return true;
    return false;
  }
  var sizeOfLength, sizeOfOffset;
  var init_decodeAbiParameters = __esm({
    "node_modules/viem/_esm/utils/abi/decodeAbiParameters.js"() {
      init_abi2();
      init_getAddress();
      init_cursor2();
      init_size();
      init_slice();
      init_trim();
      init_fromBytes();
      init_toBytes();
      init_toHex();
      init_encodeAbiParameters();
      sizeOfLength = 32;
      sizeOfOffset = 32;
    }
  });

  // node_modules/viem/_esm/utils/abi/decodeErrorResult.js
  function decodeErrorResult(parameters) {
    const { abi: abi2, data } = parameters;
    const signature = slice(data, 0, 4);
    if (signature === "0x")
      throw new AbiDecodingZeroDataError();
    const abi_ = [...abi2 || [], solidityError, solidityPanic];
    const abiItem = abi_.find((x) => x.type === "error" && signature === toFunctionSelector(formatAbiItem2(x)));
    if (!abiItem)
      throw new AbiErrorSignatureNotFoundError(signature, {
        docsPath: "/docs/contract/decodeErrorResult"
      });
    return {
      abiItem,
      args: "inputs" in abiItem && abiItem.inputs && abiItem.inputs.length > 0 ? decodeAbiParameters(abiItem.inputs, slice(data, 4)) : void 0,
      errorName: abiItem.name
    };
  }
  var init_decodeErrorResult = __esm({
    "node_modules/viem/_esm/utils/abi/decodeErrorResult.js"() {
      init_solidity2();
      init_abi2();
      init_slice();
      init_toFunctionSelector();
      init_decodeAbiParameters();
      init_formatAbiItem2();
    }
  });

  // node_modules/viem/_esm/utils/stringify.js
  var stringify3;
  var init_stringify = __esm({
    "node_modules/viem/_esm/utils/stringify.js"() {
      stringify3 = (value, replacer, space) => JSON.stringify(value, (key, value_) => {
        const value2 = typeof value_ === "bigint" ? value_.toString() : value_;
        return typeof replacer === "function" ? replacer(key, value2) : value2;
      }, space);
    }
  });

  // node_modules/viem/_esm/utils/abi/formatAbiItemWithArgs.js
  function formatAbiItemWithArgs({ abiItem, args, includeFunctionName = true, includeName = false }) {
    if (!("name" in abiItem))
      return;
    if (!("inputs" in abiItem))
      return;
    if (!abiItem.inputs)
      return;
    return `${includeFunctionName ? abiItem.name : ""}(${abiItem.inputs.map((input, i) => `${includeName && input.name ? `${input.name}: ` : ""}${typeof args[i] === "object" ? stringify3(args[i]) : args[i]}`).join(", ")})`;
  }
  var init_formatAbiItemWithArgs = __esm({
    "node_modules/viem/_esm/utils/abi/formatAbiItemWithArgs.js"() {
      init_stringify();
    }
  });

  // node_modules/viem/_esm/constants/unit.js
  var etherUnits, gweiUnits;
  var init_unit = __esm({
    "node_modules/viem/_esm/constants/unit.js"() {
      etherUnits = {
        gwei: 9,
        wei: 18
      };
      gweiUnits = {
        ether: -9,
        wei: 9
      };
    }
  });

  // node_modules/viem/_esm/utils/unit/formatUnits.js
  function formatUnits2(value, decimals) {
    let display = value.toString();
    const negative = display.startsWith("-");
    if (negative)
      display = display.slice(1);
    display = display.padStart(decimals, "0");
    let [integer, fraction] = [
      display.slice(0, display.length - decimals),
      display.slice(display.length - decimals)
    ];
    fraction = fraction.replace(/(0+)$/, "");
    return `${negative ? "-" : ""}${integer || "0"}${fraction ? `.${fraction}` : ""}`;
  }
  var init_formatUnits = __esm({
    "node_modules/viem/_esm/utils/unit/formatUnits.js"() {
    }
  });

  // node_modules/viem/_esm/utils/unit/formatEther.js
  function formatEther2(wei, unit = "wei") {
    return formatUnits2(wei, etherUnits[unit]);
  }
  var init_formatEther = __esm({
    "node_modules/viem/_esm/utils/unit/formatEther.js"() {
      init_unit();
      init_formatUnits();
    }
  });

  // node_modules/viem/_esm/utils/unit/formatGwei.js
  function formatGwei(wei, unit = "wei") {
    return formatUnits2(wei, gweiUnits[unit]);
  }
  var init_formatGwei = __esm({
    "node_modules/viem/_esm/utils/unit/formatGwei.js"() {
      init_unit();
      init_formatUnits();
    }
  });

  // node_modules/viem/_esm/errors/stateOverride.js
  function prettyStateMapping(stateMapping) {
    return stateMapping.reduce((pretty, { slot, value }) => {
      return `${pretty}        ${slot}: ${value}
`;
    }, "");
  }
  function prettyStateOverride(stateOverride) {
    return stateOverride.reduce((pretty, { address, ...state }) => {
      let val = `${pretty}    ${address}:
`;
      if (state.nonce)
        val += `      nonce: ${state.nonce}
`;
      if (state.balance)
        val += `      balance: ${state.balance}
`;
      if (state.code)
        val += `      code: ${state.code}
`;
      if (state.state) {
        val += "      state:\n";
        val += prettyStateMapping(state.state);
      }
      if (state.stateDiff) {
        val += "      stateDiff:\n";
        val += prettyStateMapping(state.stateDiff);
      }
      return val;
    }, "  State Override:\n").slice(0, -1);
  }
  var AccountStateConflictError, StateAssignmentConflictError;
  var init_stateOverride = __esm({
    "node_modules/viem/_esm/errors/stateOverride.js"() {
      init_base();
      AccountStateConflictError = class extends BaseError2 {
        constructor({ address }) {
          super(`State for account "${address}" is set multiple times.`, {
            name: "AccountStateConflictError"
          });
        }
      };
      StateAssignmentConflictError = class extends BaseError2 {
        constructor() {
          super("state and stateDiff are set on the same account.", {
            name: "StateAssignmentConflictError"
          });
        }
      };
    }
  });

  // node_modules/viem/_esm/errors/transaction.js
  function prettyPrint(args) {
    const entries = Object.entries(args).map(([key, value]) => {
      if (value === void 0 || value === false)
        return null;
      return [key, value];
    }).filter(Boolean);
    const maxLength = entries.reduce((acc, [key]) => Math.max(acc, key.length), 0);
    return entries.map(([key, value]) => `  ${`${key}:`.padEnd(maxLength + 1)}  ${value}`).join("\n");
  }
  var FeeConflictError, InvalidLegacyVError, InvalidSerializableTransactionError, InvalidStorageKeySizeError, TransactionExecutionError, TransactionNotFoundError, TransactionReceiptNotFoundError, WaitForTransactionReceiptTimeoutError;
  var init_transaction3 = __esm({
    "node_modules/viem/_esm/errors/transaction.js"() {
      init_formatEther();
      init_formatGwei();
      init_base();
      FeeConflictError = class extends BaseError2 {
        constructor() {
          super([
            "Cannot specify both a `gasPrice` and a `maxFeePerGas`/`maxPriorityFeePerGas`.",
            "Use `maxFeePerGas`/`maxPriorityFeePerGas` for EIP-1559 compatible networks, and `gasPrice` for others."
          ].join("\n"), { name: "FeeConflictError" });
        }
      };
      InvalidLegacyVError = class extends BaseError2 {
        constructor({ v }) {
          super(`Invalid \`v\` value "${v}". Expected 27 or 28.`, {
            name: "InvalidLegacyVError"
          });
        }
      };
      InvalidSerializableTransactionError = class extends BaseError2 {
        constructor({ transaction }) {
          super("Cannot infer a transaction type from provided transaction.", {
            metaMessages: [
              "Provided Transaction:",
              "{",
              prettyPrint(transaction),
              "}",
              "",
              "To infer the type, either provide:",
              "- a `type` to the Transaction, or",
              "- an EIP-1559 Transaction with `maxFeePerGas`, or",
              "- an EIP-2930 Transaction with `gasPrice` & `accessList`, or",
              "- an EIP-4844 Transaction with `blobs`, `blobVersionedHashes`, `sidecars`, or",
              "- an EIP-7702 Transaction with `authorizationList`, or",
              "- a Legacy Transaction with `gasPrice`"
            ],
            name: "InvalidSerializableTransactionError"
          });
        }
      };
      InvalidStorageKeySizeError = class extends BaseError2 {
        constructor({ storageKey }) {
          super(`Size for storage key "${storageKey}" is invalid. Expected 32 bytes. Got ${Math.floor((storageKey.length - 2) / 2)} bytes.`, { name: "InvalidStorageKeySizeError" });
        }
      };
      TransactionExecutionError = class extends BaseError2 {
        constructor(cause, { account, docsPath: docsPath8, chain, data, gas, gasPrice, maxFeePerGas, maxPriorityFeePerGas, nonce, to, value }) {
          const prettyArgs = prettyPrint({
            chain: chain && `${chain?.name} (id: ${chain?.id})`,
            from: account?.address,
            to,
            value: typeof value !== "undefined" && `${formatEther2(value)} ${chain?.nativeCurrency?.symbol || "ETH"}`,
            data,
            gas,
            gasPrice: typeof gasPrice !== "undefined" && `${formatGwei(gasPrice)} gwei`,
            maxFeePerGas: typeof maxFeePerGas !== "undefined" && `${formatGwei(maxFeePerGas)} gwei`,
            maxPriorityFeePerGas: typeof maxPriorityFeePerGas !== "undefined" && `${formatGwei(maxPriorityFeePerGas)} gwei`,
            nonce
          });
          super(cause.shortMessage, {
            cause,
            docsPath: docsPath8,
            metaMessages: [
              ...cause.metaMessages ? [...cause.metaMessages, " "] : [],
              "Request Arguments:",
              prettyArgs
            ].filter(Boolean),
            name: "TransactionExecutionError"
          });
          Object.defineProperty(this, "cause", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
          });
          this.cause = cause;
        }
      };
      TransactionNotFoundError = class extends BaseError2 {
        constructor({ blockHash, blockNumber, blockTag, hash: hash3, index: index2 }) {
          let identifier = "Transaction";
          if (blockTag && index2 !== void 0)
            identifier = `Transaction at block time "${blockTag}" at index "${index2}"`;
          if (blockHash && index2 !== void 0)
            identifier = `Transaction at block hash "${blockHash}" at index "${index2}"`;
          if (blockNumber && index2 !== void 0)
            identifier = `Transaction at block number "${blockNumber}" at index "${index2}"`;
          if (hash3)
            identifier = `Transaction with hash "${hash3}"`;
          super(`${identifier} could not be found.`, {
            name: "TransactionNotFoundError"
          });
        }
      };
      TransactionReceiptNotFoundError = class extends BaseError2 {
        constructor({ hash: hash3 }) {
          super(`Transaction receipt with hash "${hash3}" could not be found. The Transaction may not be processed on a block yet.`, {
            name: "TransactionReceiptNotFoundError"
          });
        }
      };
      WaitForTransactionReceiptTimeoutError = class extends BaseError2 {
        constructor({ hash: hash3 }) {
          super(`Timed out while waiting for transaction with hash "${hash3}" to be confirmed.`, { name: "WaitForTransactionReceiptTimeoutError" });
        }
      };
    }
  });

  // node_modules/viem/_esm/errors/utils.js
  var getContractAddress, getUrl2;
  var init_utils7 = __esm({
    "node_modules/viem/_esm/errors/utils.js"() {
      getContractAddress = (address) => address;
      getUrl2 = (url) => url;
    }
  });

  // node_modules/viem/_esm/errors/contract.js
  var CallExecutionError, ContractFunctionExecutionError, ContractFunctionRevertedError, ContractFunctionZeroDataError, CounterfactualDeploymentFailedError, RawContractError;
  var init_contract3 = __esm({
    "node_modules/viem/_esm/errors/contract.js"() {
      init_parseAccount();
      init_solidity2();
      init_decodeErrorResult();
      init_formatAbiItem2();
      init_formatAbiItemWithArgs();
      init_getAbiItem();
      init_formatEther();
      init_formatGwei();
      init_abi2();
      init_base();
      init_stateOverride();
      init_transaction3();
      init_utils7();
      CallExecutionError = class extends BaseError2 {
        constructor(cause, { account: account_, docsPath: docsPath8, chain, data, gas, gasPrice, maxFeePerGas, maxPriorityFeePerGas, nonce, to, value, stateOverride }) {
          const account = account_ ? parseAccount(account_) : void 0;
          let prettyArgs = prettyPrint({
            from: account?.address,
            to,
            value: typeof value !== "undefined" && `${formatEther2(value)} ${chain?.nativeCurrency?.symbol || "ETH"}`,
            data,
            gas,
            gasPrice: typeof gasPrice !== "undefined" && `${formatGwei(gasPrice)} gwei`,
            maxFeePerGas: typeof maxFeePerGas !== "undefined" && `${formatGwei(maxFeePerGas)} gwei`,
            maxPriorityFeePerGas: typeof maxPriorityFeePerGas !== "undefined" && `${formatGwei(maxPriorityFeePerGas)} gwei`,
            nonce
          });
          if (stateOverride) {
            prettyArgs += `
${prettyStateOverride(stateOverride)}`;
          }
          super(cause.shortMessage, {
            cause,
            docsPath: docsPath8,
            metaMessages: [
              ...cause.metaMessages ? [...cause.metaMessages, " "] : [],
              "Raw Call Arguments:",
              prettyArgs
            ].filter(Boolean),
            name: "CallExecutionError"
          });
          Object.defineProperty(this, "cause", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
          });
          this.cause = cause;
        }
      };
      ContractFunctionExecutionError = class extends BaseError2 {
        constructor(cause, { abi: abi2, args, contractAddress, docsPath: docsPath8, functionName, sender }) {
          const abiItem = getAbiItem({ abi: abi2, args, name: functionName });
          const formattedArgs = abiItem ? formatAbiItemWithArgs({
            abiItem,
            args,
            includeFunctionName: false,
            includeName: false
          }) : void 0;
          const functionWithParams = abiItem ? formatAbiItem2(abiItem, { includeName: true }) : void 0;
          const prettyArgs = prettyPrint({
            address: contractAddress && getContractAddress(contractAddress),
            function: functionWithParams,
            args: formattedArgs && formattedArgs !== "()" && `${[...Array(functionName?.length ?? 0).keys()].map(() => " ").join("")}${formattedArgs}`,
            sender
          });
          super(cause.shortMessage || `An unknown error occurred while executing the contract function "${functionName}".`, {
            cause,
            docsPath: docsPath8,
            metaMessages: [
              ...cause.metaMessages ? [...cause.metaMessages, " "] : [],
              prettyArgs && "Contract Call:",
              prettyArgs
            ].filter(Boolean),
            name: "ContractFunctionExecutionError"
          });
          Object.defineProperty(this, "abi", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
          });
          Object.defineProperty(this, "args", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
          });
          Object.defineProperty(this, "cause", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
          });
          Object.defineProperty(this, "contractAddress", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
          });
          Object.defineProperty(this, "formattedArgs", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
          });
          Object.defineProperty(this, "functionName", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
          });
          Object.defineProperty(this, "sender", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
          });
          this.abi = abi2;
          this.args = args;
          this.cause = cause;
          this.contractAddress = contractAddress;
          this.functionName = functionName;
          this.sender = sender;
        }
      };
      ContractFunctionRevertedError = class extends BaseError2 {
        constructor({ abi: abi2, data, functionName, message }) {
          let cause;
          let decodedData = void 0;
          let metaMessages;
          let reason;
          if (data && data !== "0x") {
            try {
              decodedData = decodeErrorResult({ abi: abi2, data });
              const { abiItem, errorName, args: errorArgs } = decodedData;
              if (errorName === "Error") {
                reason = errorArgs[0];
              } else if (errorName === "Panic") {
                const [firstArg] = errorArgs;
                reason = panicReasons[firstArg];
              } else {
                const errorWithParams = abiItem ? formatAbiItem2(abiItem, { includeName: true }) : void 0;
                const formattedArgs = abiItem && errorArgs ? formatAbiItemWithArgs({
                  abiItem,
                  args: errorArgs,
                  includeFunctionName: false,
                  includeName: false
                }) : void 0;
                metaMessages = [
                  errorWithParams ? `Error: ${errorWithParams}` : "",
                  formattedArgs && formattedArgs !== "()" ? `       ${[...Array(errorName?.length ?? 0).keys()].map(() => " ").join("")}${formattedArgs}` : ""
                ];
              }
            } catch (err) {
              cause = err;
            }
          } else if (message)
            reason = message;
          let signature;
          if (cause instanceof AbiErrorSignatureNotFoundError) {
            signature = cause.signature;
            metaMessages = [
              `Unable to decode signature "${signature}" as it was not found on the provided ABI.`,
              "Make sure you are using the correct ABI and that the error exists on it.",
              `You can look up the decoded signature here: https://openchain.xyz/signatures?query=${signature}.`
            ];
          }
          super(reason && reason !== "execution reverted" || signature ? [
            `The contract function "${functionName}" reverted with the following ${signature ? "signature" : "reason"}:`,
            reason || signature
          ].join("\n") : `The contract function "${functionName}" reverted.`, {
            cause,
            metaMessages,
            name: "ContractFunctionRevertedError"
          });
          Object.defineProperty(this, "data", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
          });
          Object.defineProperty(this, "raw", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
          });
          Object.defineProperty(this, "reason", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
          });
          Object.defineProperty(this, "signature", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
          });
          this.data = decodedData;
          this.raw = data;
          this.reason = reason;
          this.signature = signature;
        }
      };
      ContractFunctionZeroDataError = class extends BaseError2 {
        constructor({ functionName }) {
          super(`The contract function "${functionName}" returned no data ("0x").`, {
            metaMessages: [
              "This could be due to any of the following:",
              `  - The contract does not have the function "${functionName}",`,
              "  - The parameters passed to the contract function may be invalid, or",
              "  - The address is not a contract."
            ],
            name: "ContractFunctionZeroDataError"
          });
        }
      };
      CounterfactualDeploymentFailedError = class extends BaseError2 {
        constructor({ factory }) {
          super(`Deployment for counterfactual contract call failed${factory ? ` for factory "${factory}".` : ""}`, {
            metaMessages: [
              "Please ensure:",
              "- The `factory` is a valid contract deployment factory (ie. Create2 Factory, ERC-4337 Factory, etc).",
              "- The `factoryData` is a valid encoded function call for contract deployment function on the factory."
            ],
            name: "CounterfactualDeploymentFailedError"
          });
        }
      };
      RawContractError = class extends BaseError2 {
        constructor({ data, message }) {
          super(message || "", { name: "RawContractError" });
          Object.defineProperty(this, "code", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 3
          });
          Object.defineProperty(this, "data", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
          });
          this.data = data;
        }
      };
    }
  });

  // node_modules/viem/_esm/errors/request.js
  var HttpRequestError, RpcRequestError, TimeoutError;
  var init_request = __esm({
    "node_modules/viem/_esm/errors/request.js"() {
      init_stringify();
      init_base();
      init_utils7();
      HttpRequestError = class extends BaseError2 {
        constructor({ body, cause, details, headers, status, url }) {
          super("HTTP request failed.", {
            cause,
            details,
            metaMessages: [
              status && `Status: ${status}`,
              `URL: ${getUrl2(url)}`,
              body && `Request body: ${stringify3(body)}`
            ].filter(Boolean),
            name: "HttpRequestError"
          });
          Object.defineProperty(this, "body", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
          });
          Object.defineProperty(this, "headers", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
          });
          Object.defineProperty(this, "status", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
          });
          Object.defineProperty(this, "url", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
          });
          this.body = body;
          this.headers = headers;
          this.status = status;
          this.url = url;
        }
      };
      RpcRequestError = class extends BaseError2 {
        constructor({ body, error, url }) {
          super("RPC Request failed.", {
            cause: error,
            details: error.message,
            metaMessages: [`URL: ${getUrl2(url)}`, `Request body: ${stringify3(body)}`],
            name: "RpcRequestError"
          });
          Object.defineProperty(this, "code", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
          });
          Object.defineProperty(this, "data", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
          });
          this.code = error.code;
          this.data = error.data;
        }
      };
      TimeoutError = class extends BaseError2 {
        constructor({ body, url }) {
          super("The request took too long to respond.", {
            details: "The request timed out.",
            metaMessages: [`URL: ${getUrl2(url)}`, `Request body: ${stringify3(body)}`],
            name: "TimeoutError"
          });
        }
      };
    }
  });

  // node_modules/viem/_esm/errors/rpc.js
  var unknownErrorCode, RpcError, ProviderRpcError, ParseRpcError, InvalidRequestRpcError, MethodNotFoundRpcError, InvalidParamsRpcError, InternalRpcError, InvalidInputRpcError, ResourceNotFoundRpcError, ResourceUnavailableRpcError, TransactionRejectedRpcError, MethodNotSupportedRpcError, LimitExceededRpcError, JsonRpcVersionUnsupportedError, UserRejectedRequestError, UnauthorizedProviderError, UnsupportedProviderMethodError, ProviderDisconnectedError, ChainDisconnectedError, SwitchChainError, UnsupportedNonOptionalCapabilityError, UnsupportedChainIdError, DuplicateIdError, UnknownBundleIdError, BundleTooLargeError, AtomicReadyWalletRejectedUpgradeError, AtomicityNotSupportedError, UnknownRpcError;
  var init_rpc = __esm({
    "node_modules/viem/_esm/errors/rpc.js"() {
      init_base();
      init_request();
      unknownErrorCode = -1;
      RpcError = class extends BaseError2 {
        constructor(cause, { code, docsPath: docsPath8, metaMessages, name, shortMessage }) {
          super(shortMessage, {
            cause,
            docsPath: docsPath8,
            metaMessages: metaMessages || cause?.metaMessages,
            name: name || "RpcError"
          });
          Object.defineProperty(this, "code", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
          });
          this.name = name || cause.name;
          this.code = cause instanceof RpcRequestError ? cause.code : code ?? unknownErrorCode;
        }
      };
      ProviderRpcError = class extends RpcError {
        constructor(cause, options) {
          super(cause, options);
          Object.defineProperty(this, "data", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
          });
          this.data = options.data;
        }
      };
      ParseRpcError = class _ParseRpcError extends RpcError {
        constructor(cause) {
          super(cause, {
            code: _ParseRpcError.code,
            name: "ParseRpcError",
            shortMessage: "Invalid JSON was received by the server. An error occurred on the server while parsing the JSON text."
          });
        }
      };
      Object.defineProperty(ParseRpcError, "code", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: -32700
      });
      InvalidRequestRpcError = class _InvalidRequestRpcError extends RpcError {
        constructor(cause) {
          super(cause, {
            code: _InvalidRequestRpcError.code,
            name: "InvalidRequestRpcError",
            shortMessage: "JSON is not a valid request object."
          });
        }
      };
      Object.defineProperty(InvalidRequestRpcError, "code", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: -32600
      });
      MethodNotFoundRpcError = class _MethodNotFoundRpcError extends RpcError {
        constructor(cause, { method } = {}) {
          super(cause, {
            code: _MethodNotFoundRpcError.code,
            name: "MethodNotFoundRpcError",
            shortMessage: `The method${method ? ` "${method}"` : ""} does not exist / is not available.`
          });
        }
      };
      Object.defineProperty(MethodNotFoundRpcError, "code", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: -32601
      });
      InvalidParamsRpcError = class _InvalidParamsRpcError extends RpcError {
        constructor(cause) {
          super(cause, {
            code: _InvalidParamsRpcError.code,
            name: "InvalidParamsRpcError",
            shortMessage: [
              "Invalid parameters were provided to the RPC method.",
              "Double check you have provided the correct parameters."
            ].join("\n")
          });
        }
      };
      Object.defineProperty(InvalidParamsRpcError, "code", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: -32602
      });
      InternalRpcError = class _InternalRpcError extends RpcError {
        constructor(cause) {
          super(cause, {
            code: _InternalRpcError.code,
            name: "InternalRpcError",
            shortMessage: "An internal error was received."
          });
        }
      };
      Object.defineProperty(InternalRpcError, "code", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: -32603
      });
      InvalidInputRpcError = class _InvalidInputRpcError extends RpcError {
        constructor(cause) {
          super(cause, {
            code: _InvalidInputRpcError.code,
            name: "InvalidInputRpcError",
            shortMessage: [
              "Missing or invalid parameters.",
              "Double check you have provided the correct parameters."
            ].join("\n")
          });
        }
      };
      Object.defineProperty(InvalidInputRpcError, "code", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: -32e3
      });
      ResourceNotFoundRpcError = class _ResourceNotFoundRpcError extends RpcError {
        constructor(cause) {
          super(cause, {
            code: _ResourceNotFoundRpcError.code,
            name: "ResourceNotFoundRpcError",
            shortMessage: "Requested resource not found."
          });
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "ResourceNotFoundRpcError"
          });
        }
      };
      Object.defineProperty(ResourceNotFoundRpcError, "code", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: -32001
      });
      ResourceUnavailableRpcError = class _ResourceUnavailableRpcError extends RpcError {
        constructor(cause) {
          super(cause, {
            code: _ResourceUnavailableRpcError.code,
            name: "ResourceUnavailableRpcError",
            shortMessage: "Requested resource not available."
          });
        }
      };
      Object.defineProperty(ResourceUnavailableRpcError, "code", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: -32002
      });
      TransactionRejectedRpcError = class _TransactionRejectedRpcError extends RpcError {
        constructor(cause) {
          super(cause, {
            code: _TransactionRejectedRpcError.code,
            name: "TransactionRejectedRpcError",
            shortMessage: "Transaction creation failed."
          });
        }
      };
      Object.defineProperty(TransactionRejectedRpcError, "code", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: -32003
      });
      MethodNotSupportedRpcError = class _MethodNotSupportedRpcError extends RpcError {
        constructor(cause, { method } = {}) {
          super(cause, {
            code: _MethodNotSupportedRpcError.code,
            name: "MethodNotSupportedRpcError",
            shortMessage: `Method${method ? ` "${method}"` : ""} is not supported.`
          });
        }
      };
      Object.defineProperty(MethodNotSupportedRpcError, "code", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: -32004
      });
      LimitExceededRpcError = class _LimitExceededRpcError extends RpcError {
        constructor(cause) {
          super(cause, {
            code: _LimitExceededRpcError.code,
            name: "LimitExceededRpcError",
            shortMessage: "Request exceeds defined limit."
          });
        }
      };
      Object.defineProperty(LimitExceededRpcError, "code", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: -32005
      });
      JsonRpcVersionUnsupportedError = class _JsonRpcVersionUnsupportedError extends RpcError {
        constructor(cause) {
          super(cause, {
            code: _JsonRpcVersionUnsupportedError.code,
            name: "JsonRpcVersionUnsupportedError",
            shortMessage: "Version of JSON-RPC protocol is not supported."
          });
        }
      };
      Object.defineProperty(JsonRpcVersionUnsupportedError, "code", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: -32006
      });
      UserRejectedRequestError = class _UserRejectedRequestError extends ProviderRpcError {
        constructor(cause) {
          super(cause, {
            code: _UserRejectedRequestError.code,
            name: "UserRejectedRequestError",
            shortMessage: "User rejected the request."
          });
        }
      };
      Object.defineProperty(UserRejectedRequestError, "code", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: 4001
      });
      UnauthorizedProviderError = class _UnauthorizedProviderError extends ProviderRpcError {
        constructor(cause) {
          super(cause, {
            code: _UnauthorizedProviderError.code,
            name: "UnauthorizedProviderError",
            shortMessage: "The requested method and/or account has not been authorized by the user."
          });
        }
      };
      Object.defineProperty(UnauthorizedProviderError, "code", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: 4100
      });
      UnsupportedProviderMethodError = class _UnsupportedProviderMethodError extends ProviderRpcError {
        constructor(cause, { method } = {}) {
          super(cause, {
            code: _UnsupportedProviderMethodError.code,
            name: "UnsupportedProviderMethodError",
            shortMessage: `The Provider does not support the requested method${method ? ` " ${method}"` : ""}.`
          });
        }
      };
      Object.defineProperty(UnsupportedProviderMethodError, "code", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: 4200
      });
      ProviderDisconnectedError = class _ProviderDisconnectedError extends ProviderRpcError {
        constructor(cause) {
          super(cause, {
            code: _ProviderDisconnectedError.code,
            name: "ProviderDisconnectedError",
            shortMessage: "The Provider is disconnected from all chains."
          });
        }
      };
      Object.defineProperty(ProviderDisconnectedError, "code", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: 4900
      });
      ChainDisconnectedError = class _ChainDisconnectedError extends ProviderRpcError {
        constructor(cause) {
          super(cause, {
            code: _ChainDisconnectedError.code,
            name: "ChainDisconnectedError",
            shortMessage: "The Provider is not connected to the requested chain."
          });
        }
      };
      Object.defineProperty(ChainDisconnectedError, "code", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: 4901
      });
      SwitchChainError = class _SwitchChainError extends ProviderRpcError {
        constructor(cause) {
          super(cause, {
            code: _SwitchChainError.code,
            name: "SwitchChainError",
            shortMessage: "An error occurred when attempting to switch chain."
          });
        }
      };
      Object.defineProperty(SwitchChainError, "code", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: 4902
      });
      UnsupportedNonOptionalCapabilityError = class _UnsupportedNonOptionalCapabilityError extends ProviderRpcError {
        constructor(cause) {
          super(cause, {
            code: _UnsupportedNonOptionalCapabilityError.code,
            name: "UnsupportedNonOptionalCapabilityError",
            shortMessage: "This Wallet does not support a capability that was not marked as optional."
          });
        }
      };
      Object.defineProperty(UnsupportedNonOptionalCapabilityError, "code", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: 5700
      });
      UnsupportedChainIdError = class _UnsupportedChainIdError extends ProviderRpcError {
        constructor(cause) {
          super(cause, {
            code: _UnsupportedChainIdError.code,
            name: "UnsupportedChainIdError",
            shortMessage: "This Wallet does not support the requested chain ID."
          });
        }
      };
      Object.defineProperty(UnsupportedChainIdError, "code", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: 5710
      });
      DuplicateIdError = class _DuplicateIdError extends ProviderRpcError {
        constructor(cause) {
          super(cause, {
            code: _DuplicateIdError.code,
            name: "DuplicateIdError",
            shortMessage: "There is already a bundle submitted with this ID."
          });
        }
      };
      Object.defineProperty(DuplicateIdError, "code", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: 5720
      });
      UnknownBundleIdError = class _UnknownBundleIdError extends ProviderRpcError {
        constructor(cause) {
          super(cause, {
            code: _UnknownBundleIdError.code,
            name: "UnknownBundleIdError",
            shortMessage: "This bundle id is unknown / has not been submitted"
          });
        }
      };
      Object.defineProperty(UnknownBundleIdError, "code", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: 5730
      });
      BundleTooLargeError = class _BundleTooLargeError extends ProviderRpcError {
        constructor(cause) {
          super(cause, {
            code: _BundleTooLargeError.code,
            name: "BundleTooLargeError",
            shortMessage: "The call bundle is too large for the Wallet to process."
          });
        }
      };
      Object.defineProperty(BundleTooLargeError, "code", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: 5740
      });
      AtomicReadyWalletRejectedUpgradeError = class _AtomicReadyWalletRejectedUpgradeError extends ProviderRpcError {
        constructor(cause) {
          super(cause, {
            code: _AtomicReadyWalletRejectedUpgradeError.code,
            name: "AtomicReadyWalletRejectedUpgradeError",
            shortMessage: "The Wallet can support atomicity after an upgrade, but the user rejected the upgrade."
          });
        }
      };
      Object.defineProperty(AtomicReadyWalletRejectedUpgradeError, "code", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: 5750
      });
      AtomicityNotSupportedError = class _AtomicityNotSupportedError extends ProviderRpcError {
        constructor(cause) {
          super(cause, {
            code: _AtomicityNotSupportedError.code,
            name: "AtomicityNotSupportedError",
            shortMessage: "The wallet does not support atomic execution but the request requires it."
          });
        }
      };
      Object.defineProperty(AtomicityNotSupportedError, "code", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: 5760
      });
      UnknownRpcError = class extends RpcError {
        constructor(cause) {
          super(cause, {
            name: "UnknownRpcError",
            shortMessage: "An unknown RPC error occurred."
          });
        }
      };
    }
  });

  // node_modules/viem/_esm/utils/errors/getContractError.js
  function getContractError(err, { abi: abi2, address, args, docsPath: docsPath8, functionName, sender }) {
    const error = err instanceof RawContractError ? err : err instanceof BaseError2 ? err.walk((err2) => "data" in err2) || err.walk() : {};
    const { code, data, details, message, shortMessage } = error;
    const cause = (() => {
      if (err instanceof AbiDecodingZeroDataError)
        return new ContractFunctionZeroDataError({ functionName });
      if ([EXECUTION_REVERTED_ERROR_CODE, InternalRpcError.code].includes(code) && (data || details || message || shortMessage)) {
        return new ContractFunctionRevertedError({
          abi: abi2,
          data: typeof data === "object" ? data.data : data,
          functionName,
          message: error instanceof RpcRequestError ? details : shortMessage ?? message
        });
      }
      return err;
    })();
    return new ContractFunctionExecutionError(cause, {
      abi: abi2,
      args,
      contractAddress: address,
      docsPath: docsPath8,
      functionName,
      sender
    });
  }
  var EXECUTION_REVERTED_ERROR_CODE;
  var init_getContractError = __esm({
    "node_modules/viem/_esm/utils/errors/getContractError.js"() {
      init_abi2();
      init_base();
      init_contract3();
      init_request();
      init_rpc();
      EXECUTION_REVERTED_ERROR_CODE = 3;
    }
  });

  // node_modules/viem/_esm/accounts/utils/publicKeyToAddress.js
  function publicKeyToAddress(publicKey) {
    const address = keccak2562(`0x${publicKey.substring(4)}`).substring(26);
    return checksumAddress(`0x${address}`);
  }
  var init_publicKeyToAddress = __esm({
    "node_modules/viem/_esm/accounts/utils/publicKeyToAddress.js"() {
      init_getAddress();
      init_keccak256();
    }
  });

  // node_modules/viem/node_modules/@noble/hashes/esm/_md.js
  function setBigUint642(view, byteOffset, value, isLE4) {
    if (typeof view.setBigUint64 === "function")
      return view.setBigUint64(byteOffset, value, isLE4);
    const _32n4 = BigInt(32);
    const _u32_max = BigInt(4294967295);
    const wh = Number(value >> _32n4 & _u32_max);
    const wl = Number(value & _u32_max);
    const h = isLE4 ? 4 : 0;
    const l = isLE4 ? 0 : 4;
    view.setUint32(byteOffset + h, wh, isLE4);
    view.setUint32(byteOffset + l, wl, isLE4);
  }
  function Chi2(a, b2, c) {
    return a & b2 ^ ~a & c;
  }
  function Maj2(a, b2, c) {
    return a & b2 ^ a & c ^ b2 & c;
  }
  var HashMD, SHA256_IV;
  var init_md = __esm({
    "node_modules/viem/node_modules/@noble/hashes/esm/_md.js"() {
      init_utils6();
      HashMD = class extends Hash2 {
        constructor(blockLen, outputLen, padOffset, isLE4) {
          super();
          this.finished = false;
          this.length = 0;
          this.pos = 0;
          this.destroyed = false;
          this.blockLen = blockLen;
          this.outputLen = outputLen;
          this.padOffset = padOffset;
          this.isLE = isLE4;
          this.buffer = new Uint8Array(blockLen);
          this.view = createView2(this.buffer);
        }
        update(data) {
          aexists(this);
          data = toBytes3(data);
          abytes(data);
          const { view, buffer: buffer2, blockLen } = this;
          const len = data.length;
          for (let pos = 0; pos < len; ) {
            const take = Math.min(blockLen - this.pos, len - pos);
            if (take === blockLen) {
              const dataView = createView2(data);
              for (; blockLen <= len - pos; pos += blockLen)
                this.process(dataView, pos);
              continue;
            }
            buffer2.set(data.subarray(pos, pos + take), this.pos);
            this.pos += take;
            pos += take;
            if (this.pos === blockLen) {
              this.process(view, 0);
              this.pos = 0;
            }
          }
          this.length += data.length;
          this.roundClean();
          return this;
        }
        digestInto(out) {
          aexists(this);
          aoutput(out, this);
          this.finished = true;
          const { buffer: buffer2, view, blockLen, isLE: isLE4 } = this;
          let { pos } = this;
          buffer2[pos++] = 128;
          clean(this.buffer.subarray(pos));
          if (this.padOffset > blockLen - pos) {
            this.process(view, 0);
            pos = 0;
          }
          for (let i = pos; i < blockLen; i++)
            buffer2[i] = 0;
          setBigUint642(view, blockLen - 8, BigInt(this.length * 8), isLE4);
          this.process(view, 0);
          const oview = createView2(out);
          const len = this.outputLen;
          if (len % 4)
            throw new Error("_sha2: outputLen should be aligned to 32bit");
          const outLen = len / 4;
          const state = this.get();
          if (outLen > state.length)
            throw new Error("_sha2: outputLen bigger than state");
          for (let i = 0; i < outLen; i++)
            oview.setUint32(4 * i, state[i], isLE4);
        }
        digest() {
          const { buffer: buffer2, outputLen } = this;
          this.digestInto(buffer2);
          const res = buffer2.slice(0, outputLen);
          this.destroy();
          return res;
        }
        _cloneInto(to) {
          to || (to = new this.constructor());
          to.set(...this.get());
          const { blockLen, buffer: buffer2, length, finished, destroyed, pos } = this;
          to.destroyed = destroyed;
          to.finished = finished;
          to.length = length;
          to.pos = pos;
          if (length % blockLen)
            to.buffer.set(buffer2);
          return to;
        }
        clone() {
          return this._cloneInto();
        }
      };
      SHA256_IV = /* @__PURE__ */ Uint32Array.from([
        1779033703,
        3144134277,
        1013904242,
        2773480762,
        1359893119,
        2600822924,
        528734635,
        1541459225
      ]);
    }
  });

  // node_modules/viem/node_modules/@noble/hashes/esm/sha2.js
  var SHA256_K2, SHA256_W2, SHA2562, sha2563;
  var init_sha23 = __esm({
    "node_modules/viem/node_modules/@noble/hashes/esm/sha2.js"() {
      init_md();
      init_utils6();
      SHA256_K2 = /* @__PURE__ */ Uint32Array.from([
        1116352408,
        1899447441,
        3049323471,
        3921009573,
        961987163,
        1508970993,
        2453635748,
        2870763221,
        3624381080,
        310598401,
        607225278,
        1426881987,
        1925078388,
        2162078206,
        2614888103,
        3248222580,
        3835390401,
        4022224774,
        264347078,
        604807628,
        770255983,
        1249150122,
        1555081692,
        1996064986,
        2554220882,
        2821834349,
        2952996808,
        3210313671,
        3336571891,
        3584528711,
        113926993,
        338241895,
        666307205,
        773529912,
        1294757372,
        1396182291,
        1695183700,
        1986661051,
        2177026350,
        2456956037,
        2730485921,
        2820302411,
        3259730800,
        3345764771,
        3516065817,
        3600352804,
        4094571909,
        275423344,
        430227734,
        506948616,
        659060556,
        883997877,
        958139571,
        1322822218,
        1537002063,
        1747873779,
        1955562222,
        2024104815,
        2227730452,
        2361852424,
        2428436474,
        2756734187,
        3204031479,
        3329325298
      ]);
      SHA256_W2 = /* @__PURE__ */ new Uint32Array(64);
      SHA2562 = class extends HashMD {
        constructor(outputLen = 32) {
          super(64, outputLen, 8, false);
          this.A = SHA256_IV[0] | 0;
          this.B = SHA256_IV[1] | 0;
          this.C = SHA256_IV[2] | 0;
          this.D = SHA256_IV[3] | 0;
          this.E = SHA256_IV[4] | 0;
          this.F = SHA256_IV[5] | 0;
          this.G = SHA256_IV[6] | 0;
          this.H = SHA256_IV[7] | 0;
        }
        get() {
          const { A, B, C, D, E, F, G, H } = this;
          return [A, B, C, D, E, F, G, H];
        }
        // prettier-ignore
        set(A, B, C, D, E, F, G, H) {
          this.A = A | 0;
          this.B = B | 0;
          this.C = C | 0;
          this.D = D | 0;
          this.E = E | 0;
          this.F = F | 0;
          this.G = G | 0;
          this.H = H | 0;
        }
        process(view, offset) {
          for (let i = 0; i < 16; i++, offset += 4)
            SHA256_W2[i] = view.getUint32(offset, false);
          for (let i = 16; i < 64; i++) {
            const W15 = SHA256_W2[i - 15];
            const W2 = SHA256_W2[i - 2];
            const s0 = rotr2(W15, 7) ^ rotr2(W15, 18) ^ W15 >>> 3;
            const s1 = rotr2(W2, 17) ^ rotr2(W2, 19) ^ W2 >>> 10;
            SHA256_W2[i] = s1 + SHA256_W2[i - 7] + s0 + SHA256_W2[i - 16] | 0;
          }
          let { A, B, C, D, E, F, G, H } = this;
          for (let i = 0; i < 64; i++) {
            const sigma1 = rotr2(E, 6) ^ rotr2(E, 11) ^ rotr2(E, 25);
            const T13 = H + sigma1 + Chi2(E, F, G) + SHA256_K2[i] + SHA256_W2[i] | 0;
            const sigma0 = rotr2(A, 2) ^ rotr2(A, 13) ^ rotr2(A, 22);
            const T22 = sigma0 + Maj2(A, B, C) | 0;
            H = G;
            G = F;
            F = E;
            E = D + T13 | 0;
            D = C;
            C = B;
            B = A;
            A = T13 + T22 | 0;
          }
          A = A + this.A | 0;
          B = B + this.B | 0;
          C = C + this.C | 0;
          D = D + this.D | 0;
          E = E + this.E | 0;
          F = F + this.F | 0;
          G = G + this.G | 0;
          H = H + this.H | 0;
          this.set(A, B, C, D, E, F, G, H);
        }
        roundClean() {
          clean(SHA256_W2);
        }
        destroy() {
          this.set(0, 0, 0, 0, 0, 0, 0, 0);
          clean(this.buffer);
        }
      };
      sha2563 = /* @__PURE__ */ createHasher(() => new SHA2562());
    }
  });

  // node_modules/viem/node_modules/@noble/hashes/esm/hmac.js
  var HMAC2, hmac2;
  var init_hmac3 = __esm({
    "node_modules/viem/node_modules/@noble/hashes/esm/hmac.js"() {
      init_utils6();
      HMAC2 = class extends Hash2 {
        constructor(hash3, _key) {
          super();
          this.finished = false;
          this.destroyed = false;
          ahash(hash3);
          const key = toBytes3(_key);
          this.iHash = hash3.create();
          if (typeof this.iHash.update !== "function")
            throw new Error("Expected instance of class which extends utils.Hash");
          this.blockLen = this.iHash.blockLen;
          this.outputLen = this.iHash.outputLen;
          const blockLen = this.blockLen;
          const pad4 = new Uint8Array(blockLen);
          pad4.set(key.length > blockLen ? hash3.create().update(key).digest() : key);
          for (let i = 0; i < pad4.length; i++)
            pad4[i] ^= 54;
          this.iHash.update(pad4);
          this.oHash = hash3.create();
          for (let i = 0; i < pad4.length; i++)
            pad4[i] ^= 54 ^ 92;
          this.oHash.update(pad4);
          clean(pad4);
        }
        update(buf) {
          aexists(this);
          this.iHash.update(buf);
          return this;
        }
        digestInto(out) {
          aexists(this);
          abytes(out, this.outputLen);
          this.finished = true;
          this.iHash.digestInto(out);
          this.oHash.update(out);
          this.oHash.digestInto(out);
          this.destroy();
        }
        digest() {
          const out = new Uint8Array(this.oHash.outputLen);
          this.digestInto(out);
          return out;
        }
        _cloneInto(to) {
          to || (to = Object.create(Object.getPrototypeOf(this), {}));
          const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;
          to = to;
          to.finished = finished;
          to.destroyed = destroyed;
          to.blockLen = blockLen;
          to.outputLen = outputLen;
          to.oHash = oHash._cloneInto(to.oHash);
          to.iHash = iHash._cloneInto(to.iHash);
          return to;
        }
        clone() {
          return this._cloneInto();
        }
        destroy() {
          this.destroyed = true;
          this.oHash.destroy();
          this.iHash.destroy();
        }
      };
      hmac2 = (hash3, key, message) => new HMAC2(hash3, key).update(message).digest();
      hmac2.create = (hash3, key) => new HMAC2(hash3, key);
    }
  });

  // node_modules/viem/node_modules/@noble/curves/esm/utils.js
  function abool(title, value) {
    if (typeof value !== "boolean")
      throw new Error(title + " boolean expected, got " + value);
  }
  function numberToHexUnpadded2(num2) {
    const hex = num2.toString(16);
    return hex.length & 1 ? "0" + hex : hex;
  }
  function hexToNumber3(hex) {
    if (typeof hex !== "string")
      throw new Error("hex string expected, got " + typeof hex);
    return hex === "" ? _0n8 : BigInt("0x" + hex);
  }
  function bytesToNumberBE2(bytes2) {
    return hexToNumber3(bytesToHex3(bytes2));
  }
  function bytesToNumberLE2(bytes2) {
    abytes(bytes2);
    return hexToNumber3(bytesToHex3(Uint8Array.from(bytes2).reverse()));
  }
  function numberToBytesBE2(n2, len) {
    return hexToBytes3(n2.toString(16).padStart(len * 2, "0"));
  }
  function numberToBytesLE2(n2, len) {
    return numberToBytesBE2(n2, len).reverse();
  }
  function ensureBytes2(title, hex, expectedLength) {
    let res;
    if (typeof hex === "string") {
      try {
        res = hexToBytes3(hex);
      } catch (e) {
        throw new Error(title + " must be hex string or Uint8Array, cause: " + e);
      }
    } else if (isBytes(hex)) {
      res = Uint8Array.from(hex);
    } else {
      throw new Error(title + " must be hex string or Uint8Array");
    }
    const len = res.length;
    if (typeof expectedLength === "number" && len !== expectedLength)
      throw new Error(title + " of length " + expectedLength + " expected, got " + len);
    return res;
  }
  function inRange(n2, min, max) {
    return isPosBig(n2) && isPosBig(min) && isPosBig(max) && min <= n2 && n2 < max;
  }
  function aInRange(title, n2, min, max) {
    if (!inRange(n2, min, max))
      throw new Error("expected valid " + title + ": " + min + " <= n < " + max + ", got " + n2);
  }
  function bitLen2(n2) {
    let len;
    for (len = 0; n2 > _0n8; n2 >>= _1n8, len += 1)
      ;
    return len;
  }
  function createHmacDrbg2(hashLen, qByteLen, hmacFn) {
    if (typeof hashLen !== "number" || hashLen < 2)
      throw new Error("hashLen must be a number");
    if (typeof qByteLen !== "number" || qByteLen < 2)
      throw new Error("qByteLen must be a number");
    if (typeof hmacFn !== "function")
      throw new Error("hmacFn must be a function");
    const u8n2 = (len) => new Uint8Array(len);
    const u8of = (byte) => Uint8Array.of(byte);
    let v = u8n2(hashLen);
    let k = u8n2(hashLen);
    let i = 0;
    const reset = () => {
      v.fill(1);
      k.fill(0);
      i = 0;
    };
    const h = (...b2) => hmacFn(k, v, ...b2);
    const reseed = (seed = u8n2(0)) => {
      k = h(u8of(0), seed);
      v = h();
      if (seed.length === 0)
        return;
      k = h(u8of(1), seed);
      v = h();
    };
    const gen4 = () => {
      if (i++ >= 1e3)
        throw new Error("drbg: tried 1000 values");
      let len = 0;
      const out = [];
      while (len < qByteLen) {
        v = h();
        const sl = v.slice();
        out.push(sl);
        len += v.length;
      }
      return concatBytes3(...out);
    };
    const genUntil = (seed, pred) => {
      reset();
      reseed(seed);
      let res = void 0;
      while (!(res = pred(gen4())))
        reseed();
      reset();
      return res;
    };
    return genUntil;
  }
  function isHash(val) {
    return typeof val === "function" && Number.isSafeInteger(val.outputLen);
  }
  function _validateObject(object2, fields, optFields = {}) {
    if (!object2 || typeof object2 !== "object")
      throw new Error("expected valid options object");
    function checkField(fieldName, expectedType, isOpt) {
      const val = object2[fieldName];
      if (isOpt && val === void 0)
        return;
      const current = typeof val;
      if (current !== expectedType || val === null)
        throw new Error(`param "${fieldName}" is invalid: expected ${expectedType}, got ${current}`);
    }
    Object.entries(fields).forEach(([k, v]) => checkField(k, v, false));
    Object.entries(optFields).forEach(([k, v]) => checkField(k, v, true));
  }
  function memoized(fn) {
    const map = /* @__PURE__ */ new WeakMap();
    return (arg, ...args) => {
      const val = map.get(arg);
      if (val !== void 0)
        return val;
      const computed = fn(arg, ...args);
      map.set(arg, computed);
      return computed;
    };
  }
  var _0n8, _1n8, isPosBig, bitMask2;
  var init_utils8 = __esm({
    "node_modules/viem/node_modules/@noble/curves/esm/utils.js"() {
      init_utils6();
      init_utils6();
      _0n8 = /* @__PURE__ */ BigInt(0);
      _1n8 = /* @__PURE__ */ BigInt(1);
      isPosBig = (n2) => typeof n2 === "bigint" && _0n8 <= n2;
      bitMask2 = (n2) => (_1n8 << BigInt(n2)) - _1n8;
    }
  });

  // node_modules/viem/node_modules/@noble/curves/esm/abstract/modular.js
  function mod2(a, b2) {
    const result = a % b2;
    return result >= _0n9 ? result : b2 + result;
  }
  function pow22(x, power, modulo) {
    let res = x;
    while (power-- > _0n9) {
      res *= res;
      res %= modulo;
    }
    return res;
  }
  function invert2(number2, modulo) {
    if (number2 === _0n9)
      throw new Error("invert: expected non-zero number");
    if (modulo <= _0n9)
      throw new Error("invert: expected positive modulus, got " + modulo);
    let a = mod2(number2, modulo);
    let b2 = modulo;
    let x = _0n9, y = _1n9, u = _1n9, v = _0n9;
    while (a !== _0n9) {
      const q = b2 / a;
      const r = b2 % a;
      const m = x - u * q;
      const n2 = y - v * q;
      b2 = a, a = r, x = u, y = v, u = m, v = n2;
    }
    const gcd = b2;
    if (gcd !== _1n9)
      throw new Error("invert: does not exist");
    return mod2(x, modulo);
  }
  function sqrt3mod4(Fp2, n2) {
    const p1div4 = (Fp2.ORDER + _1n9) / _4n3;
    const root = Fp2.pow(n2, p1div4);
    if (!Fp2.eql(Fp2.sqr(root), n2))
      throw new Error("Cannot find square root");
    return root;
  }
  function sqrt5mod8(Fp2, n2) {
    const p5div8 = (Fp2.ORDER - _5n2) / _8n2;
    const n22 = Fp2.mul(n2, _2n7);
    const v = Fp2.pow(n22, p5div8);
    const nv = Fp2.mul(n2, v);
    const i = Fp2.mul(Fp2.mul(nv, _2n7), v);
    const root = Fp2.mul(nv, Fp2.sub(i, Fp2.ONE));
    if (!Fp2.eql(Fp2.sqr(root), n2))
      throw new Error("Cannot find square root");
    return root;
  }
  function tonelliShanks2(P) {
    if (P < BigInt(3))
      throw new Error("sqrt is not defined for small field");
    let Q = P - _1n9;
    let S2 = 0;
    while (Q % _2n7 === _0n9) {
      Q /= _2n7;
      S2++;
    }
    let Z = _2n7;
    const _Fp = Field2(P);
    while (FpLegendre(_Fp, Z) === 1) {
      if (Z++ > 1e3)
        throw new Error("Cannot find square root: probably non-prime P");
    }
    if (S2 === 1)
      return sqrt3mod4;
    let cc = _Fp.pow(Z, Q);
    const Q1div2 = (Q + _1n9) / _2n7;
    return function tonelliSlow(Fp2, n2) {
      if (Fp2.is0(n2))
        return n2;
      if (FpLegendre(Fp2, n2) !== 1)
        throw new Error("Cannot find square root");
      let M = S2;
      let c = Fp2.mul(Fp2.ONE, cc);
      let t = Fp2.pow(n2, Q);
      let R = Fp2.pow(n2, Q1div2);
      while (!Fp2.eql(t, Fp2.ONE)) {
        if (Fp2.is0(t))
          return Fp2.ZERO;
        let i = 1;
        let t_tmp = Fp2.sqr(t);
        while (!Fp2.eql(t_tmp, Fp2.ONE)) {
          i++;
          t_tmp = Fp2.sqr(t_tmp);
          if (i === M)
            throw new Error("Cannot find square root");
        }
        const exponent = _1n9 << BigInt(M - i - 1);
        const b2 = Fp2.pow(c, exponent);
        M = i;
        c = Fp2.sqr(b2);
        t = Fp2.mul(t, c);
        R = Fp2.mul(R, b2);
      }
      return R;
    };
  }
  function FpSqrt2(P) {
    if (P % _4n3 === _3n3)
      return sqrt3mod4;
    if (P % _8n2 === _5n2)
      return sqrt5mod8;
    return tonelliShanks2(P);
  }
  function validateField2(field) {
    const initial = {
      ORDER: "bigint",
      MASK: "bigint",
      BYTES: "number",
      BITS: "number"
    };
    const opts = FIELD_FIELDS2.reduce((map, val) => {
      map[val] = "function";
      return map;
    }, initial);
    _validateObject(field, opts);
    return field;
  }
  function FpPow2(Fp2, num2, power) {
    if (power < _0n9)
      throw new Error("invalid exponent, negatives unsupported");
    if (power === _0n9)
      return Fp2.ONE;
    if (power === _1n9)
      return num2;
    let p = Fp2.ONE;
    let d = num2;
    while (power > _0n9) {
      if (power & _1n9)
        p = Fp2.mul(p, d);
      d = Fp2.sqr(d);
      power >>= _1n9;
    }
    return p;
  }
  function FpInvertBatch2(Fp2, nums, passZero = false) {
    const inverted = new Array(nums.length).fill(passZero ? Fp2.ZERO : void 0);
    const multipliedAcc = nums.reduce((acc, num2, i) => {
      if (Fp2.is0(num2))
        return acc;
      inverted[i] = acc;
      return Fp2.mul(acc, num2);
    }, Fp2.ONE);
    const invertedAcc = Fp2.inv(multipliedAcc);
    nums.reduceRight((acc, num2, i) => {
      if (Fp2.is0(num2))
        return acc;
      inverted[i] = Fp2.mul(acc, inverted[i]);
      return Fp2.mul(acc, num2);
    }, invertedAcc);
    return inverted;
  }
  function FpLegendre(Fp2, n2) {
    const p1mod2 = (Fp2.ORDER - _1n9) / _2n7;
    const powered = Fp2.pow(n2, p1mod2);
    const yes = Fp2.eql(powered, Fp2.ONE);
    const zero = Fp2.eql(powered, Fp2.ZERO);
    const no = Fp2.eql(powered, Fp2.neg(Fp2.ONE));
    if (!yes && !zero && !no)
      throw new Error("invalid Legendre symbol result");
    return yes ? 1 : zero ? 0 : -1;
  }
  function nLength2(n2, nBitLength) {
    if (nBitLength !== void 0)
      anumber(nBitLength);
    const _nBitLength = nBitLength !== void 0 ? nBitLength : n2.toString(2).length;
    const nByteLength = Math.ceil(_nBitLength / 8);
    return { nBitLength: _nBitLength, nByteLength };
  }
  function Field2(ORDER, bitLenOrOpts, isLE4 = false, opts = {}) {
    if (ORDER <= _0n9)
      throw new Error("invalid field: expected ORDER > 0, got " + ORDER);
    let _nbitLength = void 0;
    let _sqrt = void 0;
    if (typeof bitLenOrOpts === "object" && bitLenOrOpts != null) {
      if (opts.sqrt || isLE4)
        throw new Error("cannot specify opts in two arguments");
      const _opts = bitLenOrOpts;
      if (_opts.BITS)
        _nbitLength = _opts.BITS;
      if (_opts.sqrt)
        _sqrt = _opts.sqrt;
      if (typeof _opts.isLE === "boolean")
        isLE4 = _opts.isLE;
    } else {
      if (typeof bitLenOrOpts === "number")
        _nbitLength = bitLenOrOpts;
      if (opts.sqrt)
        _sqrt = opts.sqrt;
    }
    const { nBitLength: BITS, nByteLength: BYTES } = nLength2(ORDER, _nbitLength);
    if (BYTES > 2048)
      throw new Error("invalid field: expected ORDER of <= 2048 bytes");
    let sqrtP;
    const f2 = Object.freeze({
      ORDER,
      isLE: isLE4,
      BITS,
      BYTES,
      MASK: bitMask2(BITS),
      ZERO: _0n9,
      ONE: _1n9,
      create: (num2) => mod2(num2, ORDER),
      isValid: (num2) => {
        if (typeof num2 !== "bigint")
          throw new Error("invalid field element: expected bigint, got " + typeof num2);
        return _0n9 <= num2 && num2 < ORDER;
      },
      is0: (num2) => num2 === _0n9,
      // is valid and invertible
      isValidNot0: (num2) => !f2.is0(num2) && f2.isValid(num2),
      isOdd: (num2) => (num2 & _1n9) === _1n9,
      neg: (num2) => mod2(-num2, ORDER),
      eql: (lhs, rhs) => lhs === rhs,
      sqr: (num2) => mod2(num2 * num2, ORDER),
      add: (lhs, rhs) => mod2(lhs + rhs, ORDER),
      sub: (lhs, rhs) => mod2(lhs - rhs, ORDER),
      mul: (lhs, rhs) => mod2(lhs * rhs, ORDER),
      pow: (num2, power) => FpPow2(f2, num2, power),
      div: (lhs, rhs) => mod2(lhs * invert2(rhs, ORDER), ORDER),
      // Same as above, but doesn't normalize
      sqrN: (num2) => num2 * num2,
      addN: (lhs, rhs) => lhs + rhs,
      subN: (lhs, rhs) => lhs - rhs,
      mulN: (lhs, rhs) => lhs * rhs,
      inv: (num2) => invert2(num2, ORDER),
      sqrt: _sqrt || ((n2) => {
        if (!sqrtP)
          sqrtP = FpSqrt2(ORDER);
        return sqrtP(f2, n2);
      }),
      toBytes: (num2) => isLE4 ? numberToBytesLE2(num2, BYTES) : numberToBytesBE2(num2, BYTES),
      fromBytes: (bytes2) => {
        if (bytes2.length !== BYTES)
          throw new Error("Field.fromBytes: expected " + BYTES + " bytes, got " + bytes2.length);
        return isLE4 ? bytesToNumberLE2(bytes2) : bytesToNumberBE2(bytes2);
      },
      // TODO: we don't need it here, move out to separate fn
      invertBatch: (lst) => FpInvertBatch2(f2, lst),
      // We can't move this out because Fp6, Fp12 implement it
      // and it's unclear what to return in there.
      cmov: (a, b2, c) => c ? b2 : a
    });
    return Object.freeze(f2);
  }
  function getFieldBytesLength2(fieldOrder) {
    if (typeof fieldOrder !== "bigint")
      throw new Error("field order must be bigint");
    const bitLength = fieldOrder.toString(2).length;
    return Math.ceil(bitLength / 8);
  }
  function getMinHashLength2(fieldOrder) {
    const length = getFieldBytesLength2(fieldOrder);
    return length + Math.ceil(length / 2);
  }
  function mapHashToField2(key, fieldOrder, isLE4 = false) {
    const len = key.length;
    const fieldLen = getFieldBytesLength2(fieldOrder);
    const minLen = getMinHashLength2(fieldOrder);
    if (len < 16 || len < minLen || len > 1024)
      throw new Error("expected " + minLen + "-1024 bytes of input, got " + len);
    const num2 = isLE4 ? bytesToNumberLE2(key) : bytesToNumberBE2(key);
    const reduced = mod2(num2, fieldOrder - _1n9) + _1n9;
    return isLE4 ? numberToBytesLE2(reduced, fieldLen) : numberToBytesBE2(reduced, fieldLen);
  }
  var _0n9, _1n9, _2n7, _3n3, _4n3, _5n2, _8n2, FIELD_FIELDS2;
  var init_modular2 = __esm({
    "node_modules/viem/node_modules/@noble/curves/esm/abstract/modular.js"() {
      init_utils8();
      _0n9 = BigInt(0);
      _1n9 = BigInt(1);
      _2n7 = /* @__PURE__ */ BigInt(2);
      _3n3 = /* @__PURE__ */ BigInt(3);
      _4n3 = /* @__PURE__ */ BigInt(4);
      _5n2 = /* @__PURE__ */ BigInt(5);
      _8n2 = /* @__PURE__ */ BigInt(8);
      FIELD_FIELDS2 = [
        "create",
        "isValid",
        "is0",
        "neg",
        "inv",
        "sqrt",
        "sqr",
        "eql",
        "add",
        "sub",
        "mul",
        "pow",
        "div",
        "addN",
        "subN",
        "mulN",
        "sqrN"
      ];
    }
  });

  // node_modules/viem/node_modules/@noble/curves/esm/abstract/curve.js
  function negateCt(condition, item) {
    const neg = item.negate();
    return condition ? neg : item;
  }
  function normalizeZ(c, property, points) {
    const getz = property === "pz" ? (p) => p.pz : (p) => p.ez;
    const toInv = FpInvertBatch2(c.Fp, points.map(getz));
    const affined = points.map((p, i) => p.toAffine(toInv[i]));
    return affined.map(c.fromAffine);
  }
  function validateW(W, bits) {
    if (!Number.isSafeInteger(W) || W <= 0 || W > bits)
      throw new Error("invalid window size, expected [1.." + bits + "], got W=" + W);
  }
  function calcWOpts(W, scalarBits) {
    validateW(W, scalarBits);
    const windows = Math.ceil(scalarBits / W) + 1;
    const windowSize = 2 ** (W - 1);
    const maxNumber = 2 ** W;
    const mask2 = bitMask2(W);
    const shiftBy = BigInt(W);
    return { windows, windowSize, mask: mask2, maxNumber, shiftBy };
  }
  function calcOffsets(n2, window2, wOpts) {
    const { windowSize, mask: mask2, maxNumber, shiftBy } = wOpts;
    let wbits = Number(n2 & mask2);
    let nextN = n2 >> shiftBy;
    if (wbits > windowSize) {
      wbits -= maxNumber;
      nextN += _1n10;
    }
    const offsetStart = window2 * windowSize;
    const offset = offsetStart + Math.abs(wbits) - 1;
    const isZero = wbits === 0;
    const isNeg = wbits < 0;
    const isNegF = window2 % 2 !== 0;
    const offsetF = offsetStart;
    return { nextN, offset, isZero, isNeg, isNegF, offsetF };
  }
  function validateMSMPoints(points, c) {
    if (!Array.isArray(points))
      throw new Error("array expected");
    points.forEach((p, i) => {
      if (!(p instanceof c))
        throw new Error("invalid point at index " + i);
    });
  }
  function validateMSMScalars(scalars, field) {
    if (!Array.isArray(scalars))
      throw new Error("array of scalars expected");
    scalars.forEach((s, i) => {
      if (!field.isValid(s))
        throw new Error("invalid scalar at index " + i);
    });
  }
  function getW(P) {
    return pointWindowSizes.get(P) || 1;
  }
  function assert0(n2) {
    if (n2 !== _0n10)
      throw new Error("invalid wNAF");
  }
  function wNAF2(c, bits) {
    return {
      constTimeNegate: negateCt,
      hasPrecomputes(elm) {
        return getW(elm) !== 1;
      },
      // non-const time multiplication ladder
      unsafeLadder(elm, n2, p = c.ZERO) {
        let d = elm;
        while (n2 > _0n10) {
          if (n2 & _1n10)
            p = p.add(d);
          d = d.double();
          n2 >>= _1n10;
        }
        return p;
      },
      /**
       * Creates a wNAF precomputation window. Used for caching.
       * Default window size is set by `utils.precompute()` and is equal to 8.
       * Number of precomputed points depends on the curve size:
       * 2^(1) * (Math.ceil( / ) + 1), where:
       * -  is the window size
       * -  is the bitlength of the curve order.
       * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.
       * @param elm Point instance
       * @param W window size
       * @returns precomputed point tables flattened to a single array
       */
      precomputeWindow(elm, W) {
        const { windows, windowSize } = calcWOpts(W, bits);
        const points = [];
        let p = elm;
        let base = p;
        for (let window2 = 0; window2 < windows; window2++) {
          base = p;
          points.push(base);
          for (let i = 1; i < windowSize; i++) {
            base = base.add(p);
            points.push(base);
          }
          p = base.double();
        }
        return points;
      },
      /**
       * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.
       * @param W window size
       * @param precomputes precomputed tables
       * @param n scalar (we don't check here, but should be less than curve order)
       * @returns real and fake (for const-time) points
       */
      wNAF(W, precomputes, n2) {
        let p = c.ZERO;
        let f2 = c.BASE;
        const wo = calcWOpts(W, bits);
        for (let window2 = 0; window2 < wo.windows; window2++) {
          const { nextN, offset, isZero, isNeg, isNegF, offsetF } = calcOffsets(n2, window2, wo);
          n2 = nextN;
          if (isZero) {
            f2 = f2.add(negateCt(isNegF, precomputes[offsetF]));
          } else {
            p = p.add(negateCt(isNeg, precomputes[offset]));
          }
        }
        assert0(n2);
        return { p, f: f2 };
      },
      /**
       * Implements ec unsafe (non const-time) multiplication using precomputed tables and w-ary non-adjacent form.
       * @param W window size
       * @param precomputes precomputed tables
       * @param n scalar (we don't check here, but should be less than curve order)
       * @param acc accumulator point to add result of multiplication
       * @returns point
       */
      wNAFUnsafe(W, precomputes, n2, acc = c.ZERO) {
        const wo = calcWOpts(W, bits);
        for (let window2 = 0; window2 < wo.windows; window2++) {
          if (n2 === _0n10)
            break;
          const { nextN, offset, isZero, isNeg } = calcOffsets(n2, window2, wo);
          n2 = nextN;
          if (isZero) {
            continue;
          } else {
            const item = precomputes[offset];
            acc = acc.add(isNeg ? item.negate() : item);
          }
        }
        assert0(n2);
        return acc;
      },
      getPrecomputes(W, P, transform) {
        let comp = pointPrecomputes.get(P);
        if (!comp) {
          comp = this.precomputeWindow(P, W);
          if (W !== 1) {
            if (typeof transform === "function")
              comp = transform(comp);
            pointPrecomputes.set(P, comp);
          }
        }
        return comp;
      },
      wNAFCached(P, n2, transform) {
        const W = getW(P);
        return this.wNAF(W, this.getPrecomputes(W, P, transform), n2);
      },
      wNAFCachedUnsafe(P, n2, transform, prev) {
        const W = getW(P);
        if (W === 1)
          return this.unsafeLadder(P, n2, prev);
        return this.wNAFUnsafe(W, this.getPrecomputes(W, P, transform), n2, prev);
      },
      // We calculate precomputes for elliptic curve point multiplication
      // using windowed method. This specifies window size and
      // stores precomputed values. Usually only base point would be precomputed.
      setWindowSize(P, W) {
        validateW(W, bits);
        pointWindowSizes.set(P, W);
        pointPrecomputes.delete(P);
      }
    };
  }
  function mulEndoUnsafe(c, point, k1, k2) {
    let acc = point;
    let p1 = c.ZERO;
    let p2 = c.ZERO;
    while (k1 > _0n10 || k2 > _0n10) {
      if (k1 & _1n10)
        p1 = p1.add(acc);
      if (k2 & _1n10)
        p2 = p2.add(acc);
      acc = acc.double();
      k1 >>= _1n10;
      k2 >>= _1n10;
    }
    return { p1, p2 };
  }
  function pippenger(c, fieldN, points, scalars) {
    validateMSMPoints(points, c);
    validateMSMScalars(scalars, fieldN);
    const plength = points.length;
    const slength = scalars.length;
    if (plength !== slength)
      throw new Error("arrays of points and scalars must have equal length");
    const zero = c.ZERO;
    const wbits = bitLen2(BigInt(plength));
    let windowSize = 1;
    if (wbits > 12)
      windowSize = wbits - 3;
    else if (wbits > 4)
      windowSize = wbits - 2;
    else if (wbits > 0)
      windowSize = 2;
    const MASK = bitMask2(windowSize);
    const buckets = new Array(Number(MASK) + 1).fill(zero);
    const lastBits = Math.floor((fieldN.BITS - 1) / windowSize) * windowSize;
    let sum = zero;
    for (let i = lastBits; i >= 0; i -= windowSize) {
      buckets.fill(zero);
      for (let j = 0; j < slength; j++) {
        const scalar = scalars[j];
        const wbits2 = Number(scalar >> BigInt(i) & MASK);
        buckets[wbits2] = buckets[wbits2].add(points[j]);
      }
      let resI = zero;
      for (let j = buckets.length - 1, sumI = zero; j > 0; j--) {
        sumI = sumI.add(buckets[j]);
        resI = resI.add(sumI);
      }
      sum = sum.add(resI);
      if (i !== 0)
        for (let j = 0; j < windowSize; j++)
          sum = sum.double();
    }
    return sum;
  }
  function createField(order, field) {
    if (field) {
      if (field.ORDER !== order)
        throw new Error("Field.ORDER must match order: Fp == p, Fn == n");
      validateField2(field);
      return field;
    } else {
      return Field2(order);
    }
  }
  function _createCurveFields(type, CURVE, curveOpts = {}) {
    if (!CURVE || typeof CURVE !== "object")
      throw new Error(`expected valid ${type} CURVE object`);
    for (const p of ["p", "n", "h"]) {
      const val = CURVE[p];
      if (!(typeof val === "bigint" && val > _0n10))
        throw new Error(`CURVE.${p} must be positive bigint`);
    }
    const Fp2 = createField(CURVE.p, curveOpts.Fp);
    const Fn = createField(CURVE.n, curveOpts.Fn);
    const _b = type === "weierstrass" ? "b" : "d";
    const params = ["Gx", "Gy", "a", _b];
    for (const p of params) {
      if (!Fp2.isValid(CURVE[p]))
        throw new Error(`CURVE.${p} must be valid field element of CURVE.Fp`);
    }
    return { Fp: Fp2, Fn };
  }
  var _0n10, _1n10, pointPrecomputes, pointWindowSizes;
  var init_curve2 = __esm({
    "node_modules/viem/node_modules/@noble/curves/esm/abstract/curve.js"() {
      init_utils8();
      init_modular2();
      _0n10 = BigInt(0);
      _1n10 = BigInt(1);
      pointPrecomputes = /* @__PURE__ */ new WeakMap();
      pointWindowSizes = /* @__PURE__ */ new WeakMap();
    }
  });

  // node_modules/viem/node_modules/@noble/curves/esm/abstract/weierstrass.js
  function validateSigVerOpts(opts) {
    if (opts.lowS !== void 0)
      abool("lowS", opts.lowS);
    if (opts.prehash !== void 0)
      abool("prehash", opts.prehash);
  }
  function _legacyHelperEquat(Fp2, a, b2) {
    function weierstrassEquation(x) {
      const x2 = Fp2.sqr(x);
      const x3 = Fp2.mul(x2, x);
      return Fp2.add(Fp2.add(x3, Fp2.mul(x, a)), b2);
    }
    return weierstrassEquation;
  }
  function _legacyHelperNormPriv(Fn, allowedPrivateKeyLengths, wrapPrivateKey) {
    const { BYTES: expected } = Fn;
    function normPrivateKeyToScalar(key) {
      let num2;
      if (typeof key === "bigint") {
        num2 = key;
      } else {
        let bytes2 = ensureBytes2("private key", key);
        if (allowedPrivateKeyLengths) {
          if (!allowedPrivateKeyLengths.includes(bytes2.length * 2))
            throw new Error("invalid private key");
          const padded = new Uint8Array(expected);
          padded.set(bytes2, padded.length - bytes2.length);
          bytes2 = padded;
        }
        try {
          num2 = Fn.fromBytes(bytes2);
        } catch (error) {
          throw new Error(`invalid private key: expected ui8a of size ${expected}, got ${typeof key}`);
        }
      }
      if (wrapPrivateKey)
        num2 = Fn.create(num2);
      if (!Fn.isValidNot0(num2))
        throw new Error("invalid private key: out of range [1..N-1]");
      return num2;
    }
    return normPrivateKeyToScalar;
  }
  function weierstrassN(CURVE, curveOpts = {}) {
    const { Fp: Fp2, Fn } = _createCurveFields("weierstrass", CURVE, curveOpts);
    const { h: cofactor, n: CURVE_ORDER } = CURVE;
    _validateObject(curveOpts, {}, {
      allowInfinityPoint: "boolean",
      clearCofactor: "function",
      isTorsionFree: "function",
      fromBytes: "function",
      toBytes: "function",
      endo: "object",
      wrapPrivateKey: "boolean"
    });
    const { endo } = curveOpts;
    if (endo) {
      if (!Fp2.is0(CURVE.a) || typeof endo.beta !== "bigint" || typeof endo.splitScalar !== "function") {
        throw new Error('invalid endo: expected "beta": bigint and "splitScalar": function');
      }
    }
    function assertCompressionIsSupported() {
      if (!Fp2.isOdd)
        throw new Error("compression is not supported: Field does not have .isOdd()");
    }
    function pointToBytes2(_c, point, isCompressed) {
      const { x, y } = point.toAffine();
      const bx = Fp2.toBytes(x);
      abool("isCompressed", isCompressed);
      if (isCompressed) {
        assertCompressionIsSupported();
        const hasEvenY = !Fp2.isOdd(y);
        return concatBytes3(pprefix(hasEvenY), bx);
      } else {
        return concatBytes3(Uint8Array.of(4), bx, Fp2.toBytes(y));
      }
    }
    function pointFromBytes(bytes2) {
      abytes(bytes2);
      const L = Fp2.BYTES;
      const LC = L + 1;
      const LU = 2 * L + 1;
      const length = bytes2.length;
      const head = bytes2[0];
      const tail = bytes2.subarray(1);
      if (length === LC && (head === 2 || head === 3)) {
        const x = Fp2.fromBytes(tail);
        if (!Fp2.isValid(x))
          throw new Error("bad point: is not on curve, wrong x");
        const y2 = weierstrassEquation(x);
        let y;
        try {
          y = Fp2.sqrt(y2);
        } catch (sqrtError) {
          const err = sqrtError instanceof Error ? ": " + sqrtError.message : "";
          throw new Error("bad point: is not on curve, sqrt error" + err);
        }
        assertCompressionIsSupported();
        const isYOdd = Fp2.isOdd(y);
        const isHeadOdd = (head & 1) === 1;
        if (isHeadOdd !== isYOdd)
          y = Fp2.neg(y);
        return { x, y };
      } else if (length === LU && head === 4) {
        const x = Fp2.fromBytes(tail.subarray(L * 0, L * 1));
        const y = Fp2.fromBytes(tail.subarray(L * 1, L * 2));
        if (!isValidXY(x, y))
          throw new Error("bad point: is not on curve");
        return { x, y };
      } else {
        throw new Error(`bad point: got length ${length}, expected compressed=${LC} or uncompressed=${LU}`);
      }
    }
    const toBytes5 = curveOpts.toBytes || pointToBytes2;
    const fromBytes2 = curveOpts.fromBytes || pointFromBytes;
    const weierstrassEquation = _legacyHelperEquat(Fp2, CURVE.a, CURVE.b);
    function isValidXY(x, y) {
      const left = Fp2.sqr(y);
      const right = weierstrassEquation(x);
      return Fp2.eql(left, right);
    }
    if (!isValidXY(CURVE.Gx, CURVE.Gy))
      throw new Error("bad curve params: generator point");
    const _4a3 = Fp2.mul(Fp2.pow(CURVE.a, _3n4), _4n4);
    const _27b2 = Fp2.mul(Fp2.sqr(CURVE.b), BigInt(27));
    if (Fp2.is0(Fp2.add(_4a3, _27b2)))
      throw new Error("bad curve params: a or b");
    function acoord(title, n2, banZero = false) {
      if (!Fp2.isValid(n2) || banZero && Fp2.is0(n2))
        throw new Error(`bad point coordinate ${title}`);
      return n2;
    }
    function aprjpoint(other) {
      if (!(other instanceof Point3))
        throw new Error("ProjectivePoint expected");
    }
    const toAffineMemo = memoized((p, iz) => {
      const { px: x, py: y, pz: z } = p;
      if (Fp2.eql(z, Fp2.ONE))
        return { x, y };
      const is0 = p.is0();
      if (iz == null)
        iz = is0 ? Fp2.ONE : Fp2.inv(z);
      const ax = Fp2.mul(x, iz);
      const ay = Fp2.mul(y, iz);
      const zz = Fp2.mul(z, iz);
      if (is0)
        return { x: Fp2.ZERO, y: Fp2.ZERO };
      if (!Fp2.eql(zz, Fp2.ONE))
        throw new Error("invZ was invalid");
      return { x: ax, y: ay };
    });
    const assertValidMemo = memoized((p) => {
      if (p.is0()) {
        if (curveOpts.allowInfinityPoint && !Fp2.is0(p.py))
          return;
        throw new Error("bad point: ZERO");
      }
      const { x, y } = p.toAffine();
      if (!Fp2.isValid(x) || !Fp2.isValid(y))
        throw new Error("bad point: x or y not field elements");
      if (!isValidXY(x, y))
        throw new Error("bad point: equation left != right");
      if (!p.isTorsionFree())
        throw new Error("bad point: not in prime-order subgroup");
      return true;
    });
    function finishEndo(endoBeta, k1p, k2p, k1neg, k2neg) {
      k2p = new Point3(Fp2.mul(k2p.px, endoBeta), k2p.py, k2p.pz);
      k1p = negateCt(k1neg, k1p);
      k2p = negateCt(k2neg, k2p);
      return k1p.add(k2p);
    }
    class Point3 {
      /** Does NOT validate if the point is valid. Use `.assertValidity()`. */
      constructor(px, py, pz) {
        this.px = acoord("x", px);
        this.py = acoord("y", py, true);
        this.pz = acoord("z", pz);
        Object.freeze(this);
      }
      /** Does NOT validate if the point is valid. Use `.assertValidity()`. */
      static fromAffine(p) {
        const { x, y } = p || {};
        if (!p || !Fp2.isValid(x) || !Fp2.isValid(y))
          throw new Error("invalid affine point");
        if (p instanceof Point3)
          throw new Error("projective point not allowed");
        if (Fp2.is0(x) && Fp2.is0(y))
          return Point3.ZERO;
        return new Point3(x, y, Fp2.ONE);
      }
      get x() {
        return this.toAffine().x;
      }
      get y() {
        return this.toAffine().y;
      }
      static normalizeZ(points) {
        return normalizeZ(Point3, "pz", points);
      }
      static fromBytes(bytes2) {
        abytes(bytes2);
        return Point3.fromHex(bytes2);
      }
      /** Converts hash string or Uint8Array to Point. */
      static fromHex(hex) {
        const P = Point3.fromAffine(fromBytes2(ensureBytes2("pointHex", hex)));
        P.assertValidity();
        return P;
      }
      /** Multiplies generator point by privateKey. */
      static fromPrivateKey(privateKey) {
        const normPrivateKeyToScalar = _legacyHelperNormPriv(Fn, curveOpts.allowedPrivateKeyLengths, curveOpts.wrapPrivateKey);
        return Point3.BASE.multiply(normPrivateKeyToScalar(privateKey));
      }
      /** Multiscalar Multiplication */
      static msm(points, scalars) {
        return pippenger(Point3, Fn, points, scalars);
      }
      /**
       *
       * @param windowSize
       * @param isLazy true will defer table computation until the first multiplication
       * @returns
       */
      precompute(windowSize = 8, isLazy = true) {
        wnaf.setWindowSize(this, windowSize);
        if (!isLazy)
          this.multiply(_3n4);
        return this;
      }
      /** "Private method", don't use it directly */
      _setWindowSize(windowSize) {
        this.precompute(windowSize);
      }
      // TODO: return `this`
      /** A point on curve is valid if it conforms to equation. */
      assertValidity() {
        assertValidMemo(this);
      }
      hasEvenY() {
        const { y } = this.toAffine();
        if (!Fp2.isOdd)
          throw new Error("Field doesn't support isOdd");
        return !Fp2.isOdd(y);
      }
      /** Compare one point to another. */
      equals(other) {
        aprjpoint(other);
        const { px: X1, py: Y1, pz: Z1 } = this;
        const { px: X2, py: Y2, pz: Z2 } = other;
        const U12 = Fp2.eql(Fp2.mul(X1, Z2), Fp2.mul(X2, Z1));
        const U22 = Fp2.eql(Fp2.mul(Y1, Z2), Fp2.mul(Y2, Z1));
        return U12 && U22;
      }
      /** Flips point to one corresponding to (x, -y) in Affine coordinates. */
      negate() {
        return new Point3(this.px, Fp2.neg(this.py), this.pz);
      }
      // Renes-Costello-Batina exception-free doubling formula.
      // There is 30% faster Jacobian formula, but it is not complete.
      // https://eprint.iacr.org/2015/1060, algorithm 3
      // Cost: 8M + 3S + 3*a + 2*b3 + 15add.
      double() {
        const { a, b: b2 } = CURVE;
        const b3 = Fp2.mul(b2, _3n4);
        const { px: X1, py: Y1, pz: Z1 } = this;
        let X3 = Fp2.ZERO, Y3 = Fp2.ZERO, Z3 = Fp2.ZERO;
        let t0 = Fp2.mul(X1, X1);
        let t1 = Fp2.mul(Y1, Y1);
        let t2 = Fp2.mul(Z1, Z1);
        let t3 = Fp2.mul(X1, Y1);
        t3 = Fp2.add(t3, t3);
        Z3 = Fp2.mul(X1, Z1);
        Z3 = Fp2.add(Z3, Z3);
        X3 = Fp2.mul(a, Z3);
        Y3 = Fp2.mul(b3, t2);
        Y3 = Fp2.add(X3, Y3);
        X3 = Fp2.sub(t1, Y3);
        Y3 = Fp2.add(t1, Y3);
        Y3 = Fp2.mul(X3, Y3);
        X3 = Fp2.mul(t3, X3);
        Z3 = Fp2.mul(b3, Z3);
        t2 = Fp2.mul(a, t2);
        t3 = Fp2.sub(t0, t2);
        t3 = Fp2.mul(a, t3);
        t3 = Fp2.add(t3, Z3);
        Z3 = Fp2.add(t0, t0);
        t0 = Fp2.add(Z3, t0);
        t0 = Fp2.add(t0, t2);
        t0 = Fp2.mul(t0, t3);
        Y3 = Fp2.add(Y3, t0);
        t2 = Fp2.mul(Y1, Z1);
        t2 = Fp2.add(t2, t2);
        t0 = Fp2.mul(t2, t3);
        X3 = Fp2.sub(X3, t0);
        Z3 = Fp2.mul(t2, t1);
        Z3 = Fp2.add(Z3, Z3);
        Z3 = Fp2.add(Z3, Z3);
        return new Point3(X3, Y3, Z3);
      }
      // Renes-Costello-Batina exception-free addition formula.
      // There is 30% faster Jacobian formula, but it is not complete.
      // https://eprint.iacr.org/2015/1060, algorithm 1
      // Cost: 12M + 0S + 3*a + 3*b3 + 23add.
      add(other) {
        aprjpoint(other);
        const { px: X1, py: Y1, pz: Z1 } = this;
        const { px: X2, py: Y2, pz: Z2 } = other;
        let X3 = Fp2.ZERO, Y3 = Fp2.ZERO, Z3 = Fp2.ZERO;
        const a = CURVE.a;
        const b3 = Fp2.mul(CURVE.b, _3n4);
        let t0 = Fp2.mul(X1, X2);
        let t1 = Fp2.mul(Y1, Y2);
        let t2 = Fp2.mul(Z1, Z2);
        let t3 = Fp2.add(X1, Y1);
        let t4 = Fp2.add(X2, Y2);
        t3 = Fp2.mul(t3, t4);
        t4 = Fp2.add(t0, t1);
        t3 = Fp2.sub(t3, t4);
        t4 = Fp2.add(X1, Z1);
        let t5 = Fp2.add(X2, Z2);
        t4 = Fp2.mul(t4, t5);
        t5 = Fp2.add(t0, t2);
        t4 = Fp2.sub(t4, t5);
        t5 = Fp2.add(Y1, Z1);
        X3 = Fp2.add(Y2, Z2);
        t5 = Fp2.mul(t5, X3);
        X3 = Fp2.add(t1, t2);
        t5 = Fp2.sub(t5, X3);
        Z3 = Fp2.mul(a, t4);
        X3 = Fp2.mul(b3, t2);
        Z3 = Fp2.add(X3, Z3);
        X3 = Fp2.sub(t1, Z3);
        Z3 = Fp2.add(t1, Z3);
        Y3 = Fp2.mul(X3, Z3);
        t1 = Fp2.add(t0, t0);
        t1 = Fp2.add(t1, t0);
        t2 = Fp2.mul(a, t2);
        t4 = Fp2.mul(b3, t4);
        t1 = Fp2.add(t1, t2);
        t2 = Fp2.sub(t0, t2);
        t2 = Fp2.mul(a, t2);
        t4 = Fp2.add(t4, t2);
        t0 = Fp2.mul(t1, t4);
        Y3 = Fp2.add(Y3, t0);
        t0 = Fp2.mul(t5, t4);
        X3 = Fp2.mul(t3, X3);
        X3 = Fp2.sub(X3, t0);
        t0 = Fp2.mul(t3, t1);
        Z3 = Fp2.mul(t5, Z3);
        Z3 = Fp2.add(Z3, t0);
        return new Point3(X3, Y3, Z3);
      }
      subtract(other) {
        return this.add(other.negate());
      }
      is0() {
        return this.equals(Point3.ZERO);
      }
      /**
       * Constant time multiplication.
       * Uses wNAF method. Windowed method may be 10% faster,
       * but takes 2x longer to generate and consumes 2x memory.
       * Uses precomputes when available.
       * Uses endomorphism for Koblitz curves.
       * @param scalar by which the point would be multiplied
       * @returns New point
       */
      multiply(scalar) {
        const { endo: endo2 } = curveOpts;
        if (!Fn.isValidNot0(scalar))
          throw new Error("invalid scalar: out of range");
        let point, fake;
        const mul = (n2) => wnaf.wNAFCached(this, n2, Point3.normalizeZ);
        if (endo2) {
          const { k1neg, k1, k2neg, k2 } = endo2.splitScalar(scalar);
          const { p: k1p, f: k1f } = mul(k1);
          const { p: k2p, f: k2f } = mul(k2);
          fake = k1f.add(k2f);
          point = finishEndo(endo2.beta, k1p, k2p, k1neg, k2neg);
        } else {
          const { p, f: f2 } = mul(scalar);
          point = p;
          fake = f2;
        }
        return Point3.normalizeZ([point, fake])[0];
      }
      /**
       * Non-constant-time multiplication. Uses double-and-add algorithm.
       * It's faster, but should only be used when you don't care about
       * an exposed private key e.g. sig verification, which works over *public* keys.
       */
      multiplyUnsafe(sc) {
        const { endo: endo2 } = curveOpts;
        const p = this;
        if (!Fn.isValid(sc))
          throw new Error("invalid scalar: out of range");
        if (sc === _0n11 || p.is0())
          return Point3.ZERO;
        if (sc === _1n11)
          return p;
        if (wnaf.hasPrecomputes(this))
          return this.multiply(sc);
        if (endo2) {
          const { k1neg, k1, k2neg, k2 } = endo2.splitScalar(sc);
          const { p1, p2 } = mulEndoUnsafe(Point3, p, k1, k2);
          return finishEndo(endo2.beta, p1, p2, k1neg, k2neg);
        } else {
          return wnaf.wNAFCachedUnsafe(p, sc);
        }
      }
      multiplyAndAddUnsafe(Q, a, b2) {
        const sum = this.multiplyUnsafe(a).add(Q.multiplyUnsafe(b2));
        return sum.is0() ? void 0 : sum;
      }
      /**
       * Converts Projective point to affine (x, y) coordinates.
       * @param invertedZ Z^-1 (inverted zero) - optional, precomputation is useful for invertBatch
       */
      toAffine(invertedZ) {
        return toAffineMemo(this, invertedZ);
      }
      /**
       * Checks whether Point is free of torsion elements (is in prime subgroup).
       * Always torsion-free for cofactor=1 curves.
       */
      isTorsionFree() {
        const { isTorsionFree } = curveOpts;
        if (cofactor === _1n11)
          return true;
        if (isTorsionFree)
          return isTorsionFree(Point3, this);
        return wnaf.wNAFCachedUnsafe(this, CURVE_ORDER).is0();
      }
      clearCofactor() {
        const { clearCofactor } = curveOpts;
        if (cofactor === _1n11)
          return this;
        if (clearCofactor)
          return clearCofactor(Point3, this);
        return this.multiplyUnsafe(cofactor);
      }
      toBytes(isCompressed = true) {
        abool("isCompressed", isCompressed);
        this.assertValidity();
        return toBytes5(Point3, this, isCompressed);
      }
      /** @deprecated use `toBytes` */
      toRawBytes(isCompressed = true) {
        return this.toBytes(isCompressed);
      }
      toHex(isCompressed = true) {
        return bytesToHex3(this.toBytes(isCompressed));
      }
      toString() {
        return `<Point ${this.is0() ? "ZERO" : this.toHex()}>`;
      }
    }
    Point3.BASE = new Point3(CURVE.Gx, CURVE.Gy, Fp2.ONE);
    Point3.ZERO = new Point3(Fp2.ZERO, Fp2.ONE, Fp2.ZERO);
    Point3.Fp = Fp2;
    Point3.Fn = Fn;
    const bits = Fn.BITS;
    const wnaf = wNAF2(Point3, curveOpts.endo ? Math.ceil(bits / 2) : bits);
    return Point3;
  }
  function pprefix(hasEvenY) {
    return Uint8Array.of(hasEvenY ? 2 : 3);
  }
  function ecdsa(Point3, ecdsaOpts, curveOpts = {}) {
    _validateObject(ecdsaOpts, { hash: "function" }, {
      hmac: "function",
      lowS: "boolean",
      randomBytes: "function",
      bits2int: "function",
      bits2int_modN: "function"
    });
    const randomBytes_ = ecdsaOpts.randomBytes || randomBytes4;
    const hmac_ = ecdsaOpts.hmac || ((key, ...msgs) => hmac2(ecdsaOpts.hash, key, concatBytes3(...msgs)));
    const { Fp: Fp2, Fn } = Point3;
    const { ORDER: CURVE_ORDER, BITS: fnBits } = Fn;
    function isBiggerThanHalfOrder(number2) {
      const HALF = CURVE_ORDER >> _1n11;
      return number2 > HALF;
    }
    function normalizeS(s) {
      return isBiggerThanHalfOrder(s) ? Fn.neg(s) : s;
    }
    function aValidRS(title, num2) {
      if (!Fn.isValidNot0(num2))
        throw new Error(`invalid signature ${title}: out of range 1..CURVE.n`);
    }
    class Signature2 {
      constructor(r, s, recovery) {
        aValidRS("r", r);
        aValidRS("s", s);
        this.r = r;
        this.s = s;
        if (recovery != null)
          this.recovery = recovery;
        Object.freeze(this);
      }
      // pair (bytes of r, bytes of s)
      static fromCompact(hex) {
        const L = Fn.BYTES;
        const b2 = ensureBytes2("compactSignature", hex, L * 2);
        return new Signature2(Fn.fromBytes(b2.subarray(0, L)), Fn.fromBytes(b2.subarray(L, L * 2)));
      }
      // DER encoded ECDSA signature
      // https://bitcoin.stackexchange.com/questions/57644/what-are-the-parts-of-a-bitcoin-transaction-input-script
      static fromDER(hex) {
        const { r, s } = DER2.toSig(ensureBytes2("DER", hex));
        return new Signature2(r, s);
      }
      /**
       * @todo remove
       * @deprecated
       */
      assertValidity() {
      }
      addRecoveryBit(recovery) {
        return new Signature2(this.r, this.s, recovery);
      }
      // ProjPointType<bigint>
      recoverPublicKey(msgHash) {
        const FIELD_ORDER = Fp2.ORDER;
        const { r, s, recovery: rec } = this;
        if (rec == null || ![0, 1, 2, 3].includes(rec))
          throw new Error("recovery id invalid");
        const hasCofactor = CURVE_ORDER * _2n8 < FIELD_ORDER;
        if (hasCofactor && rec > 1)
          throw new Error("recovery id is ambiguous for h>1 curve");
        const radj = rec === 2 || rec === 3 ? r + CURVE_ORDER : r;
        if (!Fp2.isValid(radj))
          throw new Error("recovery id 2 or 3 invalid");
        const x = Fp2.toBytes(radj);
        const R = Point3.fromHex(concatBytes3(pprefix((rec & 1) === 0), x));
        const ir = Fn.inv(radj);
        const h = bits2int_modN(ensureBytes2("msgHash", msgHash));
        const u1 = Fn.create(-h * ir);
        const u2 = Fn.create(s * ir);
        const Q = Point3.BASE.multiplyUnsafe(u1).add(R.multiplyUnsafe(u2));
        if (Q.is0())
          throw new Error("point at infinify");
        Q.assertValidity();
        return Q;
      }
      // Signatures should be low-s, to prevent malleability.
      hasHighS() {
        return isBiggerThanHalfOrder(this.s);
      }
      normalizeS() {
        return this.hasHighS() ? new Signature2(this.r, Fn.neg(this.s), this.recovery) : this;
      }
      toBytes(format) {
        if (format === "compact")
          return concatBytes3(Fn.toBytes(this.r), Fn.toBytes(this.s));
        if (format === "der")
          return hexToBytes3(DER2.hexFromSig(this));
        throw new Error("invalid format");
      }
      // DER-encoded
      toDERRawBytes() {
        return this.toBytes("der");
      }
      toDERHex() {
        return bytesToHex3(this.toBytes("der"));
      }
      // padded bytes of r, then padded bytes of s
      toCompactRawBytes() {
        return this.toBytes("compact");
      }
      toCompactHex() {
        return bytesToHex3(this.toBytes("compact"));
      }
    }
    const normPrivateKeyToScalar = _legacyHelperNormPriv(Fn, curveOpts.allowedPrivateKeyLengths, curveOpts.wrapPrivateKey);
    const utils = {
      isValidPrivateKey(privateKey) {
        try {
          normPrivateKeyToScalar(privateKey);
          return true;
        } catch (error) {
          return false;
        }
      },
      normPrivateKeyToScalar,
      /**
       * Produces cryptographically secure private key from random of size
       * (groupLen + ceil(groupLen / 2)) with modulo bias being negligible.
       */
      randomPrivateKey: () => {
        const n2 = CURVE_ORDER;
        return mapHashToField2(randomBytes_(getMinHashLength2(n2)), n2);
      },
      precompute(windowSize = 8, point = Point3.BASE) {
        return point.precompute(windowSize, false);
      }
    };
    function getPublicKey(privateKey, isCompressed = true) {
      return Point3.fromPrivateKey(privateKey).toBytes(isCompressed);
    }
    function isProbPub(item) {
      if (typeof item === "bigint")
        return false;
      if (item instanceof Point3)
        return true;
      const arr = ensureBytes2("key", item);
      const length = arr.length;
      const L = Fp2.BYTES;
      const LC = L + 1;
      const LU = 2 * L + 1;
      if (curveOpts.allowedPrivateKeyLengths || Fn.BYTES === LC) {
        return void 0;
      } else {
        return length === LC || length === LU;
      }
    }
    function getSharedSecret(privateA, publicB, isCompressed = true) {
      if (isProbPub(privateA) === true)
        throw new Error("first arg must be private key");
      if (isProbPub(publicB) === false)
        throw new Error("second arg must be public key");
      const b2 = Point3.fromHex(publicB);
      return b2.multiply(normPrivateKeyToScalar(privateA)).toBytes(isCompressed);
    }
    const bits2int = ecdsaOpts.bits2int || function(bytes2) {
      if (bytes2.length > 8192)
        throw new Error("input is too large");
      const num2 = bytesToNumberBE2(bytes2);
      const delta = bytes2.length * 8 - fnBits;
      return delta > 0 ? num2 >> BigInt(delta) : num2;
    };
    const bits2int_modN = ecdsaOpts.bits2int_modN || function(bytes2) {
      return Fn.create(bits2int(bytes2));
    };
    const ORDER_MASK = bitMask2(fnBits);
    function int2octets(num2) {
      aInRange("num < 2^" + fnBits, num2, _0n11, ORDER_MASK);
      return Fn.toBytes(num2);
    }
    function prepSig(msgHash, privateKey, opts = defaultSigOpts) {
      if (["recovered", "canonical"].some((k) => k in opts))
        throw new Error("sign() legacy options not supported");
      const { hash: hash3 } = ecdsaOpts;
      let { lowS, prehash, extraEntropy: ent } = opts;
      if (lowS == null)
        lowS = true;
      msgHash = ensureBytes2("msgHash", msgHash);
      validateSigVerOpts(opts);
      if (prehash)
        msgHash = ensureBytes2("prehashed msgHash", hash3(msgHash));
      const h1int = bits2int_modN(msgHash);
      const d = normPrivateKeyToScalar(privateKey);
      const seedArgs = [int2octets(d), int2octets(h1int)];
      if (ent != null && ent !== false) {
        const e = ent === true ? randomBytes_(Fp2.BYTES) : ent;
        seedArgs.push(ensureBytes2("extraEntropy", e));
      }
      const seed = concatBytes3(...seedArgs);
      const m = h1int;
      function k2sig(kBytes) {
        const k = bits2int(kBytes);
        if (!Fn.isValidNot0(k))
          return;
        const ik = Fn.inv(k);
        const q = Point3.BASE.multiply(k).toAffine();
        const r = Fn.create(q.x);
        if (r === _0n11)
          return;
        const s = Fn.create(ik * Fn.create(m + r * d));
        if (s === _0n11)
          return;
        let recovery = (q.x === r ? 0 : 2) | Number(q.y & _1n11);
        let normS = s;
        if (lowS && isBiggerThanHalfOrder(s)) {
          normS = normalizeS(s);
          recovery ^= 1;
        }
        return new Signature2(r, normS, recovery);
      }
      return { seed, k2sig };
    }
    const defaultSigOpts = { lowS: ecdsaOpts.lowS, prehash: false };
    const defaultVerOpts = { lowS: ecdsaOpts.lowS, prehash: false };
    function sign2(msgHash, privKey, opts = defaultSigOpts) {
      const { seed, k2sig } = prepSig(msgHash, privKey, opts);
      const drbg = createHmacDrbg2(ecdsaOpts.hash.outputLen, Fn.BYTES, hmac_);
      return drbg(seed, k2sig);
    }
    Point3.BASE.precompute(8);
    function verify(signature, msgHash, publicKey, opts = defaultVerOpts) {
      const sg = signature;
      msgHash = ensureBytes2("msgHash", msgHash);
      publicKey = ensureBytes2("publicKey", publicKey);
      validateSigVerOpts(opts);
      const { lowS, prehash, format } = opts;
      if ("strict" in opts)
        throw new Error("options.strict was renamed to lowS");
      if (format !== void 0 && !["compact", "der", "js"].includes(format))
        throw new Error('format must be "compact", "der" or "js"');
      const isHex2 = typeof sg === "string" || isBytes(sg);
      const isObj = !isHex2 && !format && typeof sg === "object" && sg !== null && typeof sg.r === "bigint" && typeof sg.s === "bigint";
      if (!isHex2 && !isObj)
        throw new Error("invalid signature, expected Uint8Array, hex string or Signature instance");
      let _sig2 = void 0;
      let P;
      try {
        if (isObj) {
          if (format === void 0 || format === "js") {
            _sig2 = new Signature2(sg.r, sg.s);
          } else {
            throw new Error("invalid format");
          }
        }
        if (isHex2) {
          try {
            if (format !== "compact")
              _sig2 = Signature2.fromDER(sg);
          } catch (derError) {
            if (!(derError instanceof DER2.Err))
              throw derError;
          }
          if (!_sig2 && format !== "der")
            _sig2 = Signature2.fromCompact(sg);
        }
        P = Point3.fromHex(publicKey);
      } catch (error) {
        return false;
      }
      if (!_sig2)
        return false;
      if (lowS && _sig2.hasHighS())
        return false;
      if (prehash)
        msgHash = ecdsaOpts.hash(msgHash);
      const { r, s } = _sig2;
      const h = bits2int_modN(msgHash);
      const is = Fn.inv(s);
      const u1 = Fn.create(h * is);
      const u2 = Fn.create(r * is);
      const R = Point3.BASE.multiplyUnsafe(u1).add(P.multiplyUnsafe(u2));
      if (R.is0())
        return false;
      const v = Fn.create(R.x);
      return v === r;
    }
    return Object.freeze({
      getPublicKey,
      getSharedSecret,
      sign: sign2,
      verify,
      utils,
      Point: Point3,
      Signature: Signature2
    });
  }
  function _weierstrass_legacy_opts_to_new(c) {
    const CURVE = {
      a: c.a,
      b: c.b,
      p: c.Fp.ORDER,
      n: c.n,
      h: c.h,
      Gx: c.Gx,
      Gy: c.Gy
    };
    const Fp2 = c.Fp;
    const Fn = Field2(CURVE.n, c.nBitLength);
    const curveOpts = {
      Fp: Fp2,
      Fn,
      allowedPrivateKeyLengths: c.allowedPrivateKeyLengths,
      allowInfinityPoint: c.allowInfinityPoint,
      endo: c.endo,
      wrapPrivateKey: c.wrapPrivateKey,
      isTorsionFree: c.isTorsionFree,
      clearCofactor: c.clearCofactor,
      fromBytes: c.fromBytes,
      toBytes: c.toBytes
    };
    return { CURVE, curveOpts };
  }
  function _ecdsa_legacy_opts_to_new(c) {
    const { CURVE, curveOpts } = _weierstrass_legacy_opts_to_new(c);
    const ecdsaOpts = {
      hash: c.hash,
      hmac: c.hmac,
      randomBytes: c.randomBytes,
      lowS: c.lowS,
      bits2int: c.bits2int,
      bits2int_modN: c.bits2int_modN
    };
    return { CURVE, curveOpts, ecdsaOpts };
  }
  function _ecdsa_new_output_to_legacy(c, ecdsa2) {
    return Object.assign({}, ecdsa2, {
      ProjectivePoint: ecdsa2.Point,
      CURVE: c
    });
  }
  function weierstrass2(c) {
    const { CURVE, curveOpts, ecdsaOpts } = _ecdsa_legacy_opts_to_new(c);
    const Point3 = weierstrassN(CURVE, curveOpts);
    const signs = ecdsa(Point3, ecdsaOpts, curveOpts);
    return _ecdsa_new_output_to_legacy(c, signs);
  }
  function SWUFpSqrtRatio(Fp2, Z) {
    const q = Fp2.ORDER;
    let l = _0n11;
    for (let o = q - _1n11; o % _2n8 === _0n11; o /= _2n8)
      l += _1n11;
    const c1 = l;
    const _2n_pow_c1_1 = _2n8 << c1 - _1n11 - _1n11;
    const _2n_pow_c1 = _2n_pow_c1_1 * _2n8;
    const c2 = (q - _1n11) / _2n_pow_c1;
    const c3 = (c2 - _1n11) / _2n8;
    const c4 = _2n_pow_c1 - _1n11;
    const c5 = _2n_pow_c1_1;
    const c6 = Fp2.pow(Z, c2);
    const c7 = Fp2.pow(Z, (c2 + _1n11) / _2n8);
    let sqrtRatio = (u, v) => {
      let tv1 = c6;
      let tv2 = Fp2.pow(v, c4);
      let tv3 = Fp2.sqr(tv2);
      tv3 = Fp2.mul(tv3, v);
      let tv5 = Fp2.mul(u, tv3);
      tv5 = Fp2.pow(tv5, c3);
      tv5 = Fp2.mul(tv5, tv2);
      tv2 = Fp2.mul(tv5, v);
      tv3 = Fp2.mul(tv5, u);
      let tv4 = Fp2.mul(tv3, tv2);
      tv5 = Fp2.pow(tv4, c5);
      let isQR = Fp2.eql(tv5, Fp2.ONE);
      tv2 = Fp2.mul(tv3, c7);
      tv5 = Fp2.mul(tv4, tv1);
      tv3 = Fp2.cmov(tv2, tv3, isQR);
      tv4 = Fp2.cmov(tv5, tv4, isQR);
      for (let i = c1; i > _1n11; i--) {
        let tv52 = i - _2n8;
        tv52 = _2n8 << tv52 - _1n11;
        let tvv5 = Fp2.pow(tv4, tv52);
        const e1 = Fp2.eql(tvv5, Fp2.ONE);
        tv2 = Fp2.mul(tv3, tv1);
        tv1 = Fp2.mul(tv1, tv1);
        tvv5 = Fp2.mul(tv4, tv1);
        tv3 = Fp2.cmov(tv2, tv3, e1);
        tv4 = Fp2.cmov(tvv5, tv4, e1);
      }
      return { isValid: isQR, value: tv3 };
    };
    if (Fp2.ORDER % _4n4 === _3n4) {
      const c12 = (Fp2.ORDER - _3n4) / _4n4;
      const c22 = Fp2.sqrt(Fp2.neg(Z));
      sqrtRatio = (u, v) => {
        let tv1 = Fp2.sqr(v);
        const tv2 = Fp2.mul(u, v);
        tv1 = Fp2.mul(tv1, tv2);
        let y1 = Fp2.pow(tv1, c12);
        y1 = Fp2.mul(y1, tv2);
        const y2 = Fp2.mul(y1, c22);
        const tv3 = Fp2.mul(Fp2.sqr(y1), v);
        const isQR = Fp2.eql(tv3, u);
        let y = Fp2.cmov(y2, y1, isQR);
        return { isValid: isQR, value: y };
      };
    }
    return sqrtRatio;
  }
  function mapToCurveSimpleSWU(Fp2, opts) {
    validateField2(Fp2);
    const { A, B, Z } = opts;
    if (!Fp2.isValid(A) || !Fp2.isValid(B) || !Fp2.isValid(Z))
      throw new Error("mapToCurveSimpleSWU: invalid opts");
    const sqrtRatio = SWUFpSqrtRatio(Fp2, Z);
    if (!Fp2.isOdd)
      throw new Error("Field does not have .isOdd()");
    return (u) => {
      let tv1, tv2, tv3, tv4, tv5, tv6, x, y;
      tv1 = Fp2.sqr(u);
      tv1 = Fp2.mul(tv1, Z);
      tv2 = Fp2.sqr(tv1);
      tv2 = Fp2.add(tv2, tv1);
      tv3 = Fp2.add(tv2, Fp2.ONE);
      tv3 = Fp2.mul(tv3, B);
      tv4 = Fp2.cmov(Z, Fp2.neg(tv2), !Fp2.eql(tv2, Fp2.ZERO));
      tv4 = Fp2.mul(tv4, A);
      tv2 = Fp2.sqr(tv3);
      tv6 = Fp2.sqr(tv4);
      tv5 = Fp2.mul(tv6, A);
      tv2 = Fp2.add(tv2, tv5);
      tv2 = Fp2.mul(tv2, tv3);
      tv6 = Fp2.mul(tv6, tv4);
      tv5 = Fp2.mul(tv6, B);
      tv2 = Fp2.add(tv2, tv5);
      x = Fp2.mul(tv1, tv3);
      const { isValid, value } = sqrtRatio(tv2, tv6);
      y = Fp2.mul(tv1, u);
      y = Fp2.mul(y, value);
      x = Fp2.cmov(x, tv3, isValid);
      y = Fp2.cmov(y, value, isValid);
      const e1 = Fp2.isOdd(u) === Fp2.isOdd(y);
      y = Fp2.cmov(Fp2.neg(y), y, e1);
      const tv4_inv = FpInvertBatch2(Fp2, [tv4], true)[0];
      x = Fp2.mul(x, tv4_inv);
      return { x, y };
    };
  }
  var DERErr2, DER2, _0n11, _1n11, _2n8, _3n4, _4n4;
  var init_weierstrass2 = __esm({
    "node_modules/viem/node_modules/@noble/curves/esm/abstract/weierstrass.js"() {
      init_hmac3();
      init_utils8();
      init_curve2();
      init_modular2();
      DERErr2 = class extends Error {
        constructor(m = "") {
          super(m);
        }
      };
      DER2 = {
        // asn.1 DER encoding utils
        Err: DERErr2,
        // Basic building block is TLV (Tag-Length-Value)
        _tlv: {
          encode: (tag, data) => {
            const { Err: E } = DER2;
            if (tag < 0 || tag > 256)
              throw new E("tlv.encode: wrong tag");
            if (data.length & 1)
              throw new E("tlv.encode: unpadded data");
            const dataLen = data.length / 2;
            const len = numberToHexUnpadded2(dataLen);
            if (len.length / 2 & 128)
              throw new E("tlv.encode: long form length too big");
            const lenLen = dataLen > 127 ? numberToHexUnpadded2(len.length / 2 | 128) : "";
            const t = numberToHexUnpadded2(tag);
            return t + lenLen + len + data;
          },
          // v - value, l - left bytes (unparsed)
          decode(tag, data) {
            const { Err: E } = DER2;
            let pos = 0;
            if (tag < 0 || tag > 256)
              throw new E("tlv.encode: wrong tag");
            if (data.length < 2 || data[pos++] !== tag)
              throw new E("tlv.decode: wrong tlv");
            const first = data[pos++];
            const isLong = !!(first & 128);
            let length = 0;
            if (!isLong)
              length = first;
            else {
              const lenLen = first & 127;
              if (!lenLen)
                throw new E("tlv.decode(long): indefinite length not supported");
              if (lenLen > 4)
                throw new E("tlv.decode(long): byte length is too big");
              const lengthBytes = data.subarray(pos, pos + lenLen);
              if (lengthBytes.length !== lenLen)
                throw new E("tlv.decode: length bytes not complete");
              if (lengthBytes[0] === 0)
                throw new E("tlv.decode(long): zero leftmost byte");
              for (const b2 of lengthBytes)
                length = length << 8 | b2;
              pos += lenLen;
              if (length < 128)
                throw new E("tlv.decode(long): not minimal encoding");
            }
            const v = data.subarray(pos, pos + length);
            if (v.length !== length)
              throw new E("tlv.decode: wrong value length");
            return { v, l: data.subarray(pos + length) };
          }
        },
        // https://crypto.stackexchange.com/a/57734 Leftmost bit of first byte is 'negative' flag,
        // since we always use positive integers here. It must always be empty:
        // - add zero byte if exists
        // - if next byte doesn't have a flag, leading zero is not allowed (minimal encoding)
        _int: {
          encode(num2) {
            const { Err: E } = DER2;
            if (num2 < _0n11)
              throw new E("integer: negative integers are not allowed");
            let hex = numberToHexUnpadded2(num2);
            if (Number.parseInt(hex[0], 16) & 8)
              hex = "00" + hex;
            if (hex.length & 1)
              throw new E("unexpected DER parsing assertion: unpadded hex");
            return hex;
          },
          decode(data) {
            const { Err: E } = DER2;
            if (data[0] & 128)
              throw new E("invalid signature integer: negative");
            if (data[0] === 0 && !(data[1] & 128))
              throw new E("invalid signature integer: unnecessary leading zero");
            return bytesToNumberBE2(data);
          }
        },
        toSig(hex) {
          const { Err: E, _int: int, _tlv: tlv } = DER2;
          const data = ensureBytes2("signature", hex);
          const { v: seqBytes, l: seqLeftBytes } = tlv.decode(48, data);
          if (seqLeftBytes.length)
            throw new E("invalid signature: left bytes after parsing");
          const { v: rBytes, l: rLeftBytes } = tlv.decode(2, seqBytes);
          const { v: sBytes, l: sLeftBytes } = tlv.decode(2, rLeftBytes);
          if (sLeftBytes.length)
            throw new E("invalid signature: left bytes after parsing");
          return { r: int.decode(rBytes), s: int.decode(sBytes) };
        },
        hexFromSig(sig) {
          const { _tlv: tlv, _int: int } = DER2;
          const rs = tlv.encode(2, int.encode(sig.r));
          const ss = tlv.encode(2, int.encode(sig.s));
          const seq = rs + ss;
          return tlv.encode(48, seq);
        }
      };
      _0n11 = BigInt(0);
      _1n11 = BigInt(1);
      _2n8 = BigInt(2);
      _3n4 = BigInt(3);
      _4n4 = BigInt(4);
    }
  });

  // node_modules/viem/node_modules/@noble/curves/esm/_shortw_utils.js
  function createCurve2(curveDef, defHash) {
    const create = (hash3) => weierstrass2({ ...curveDef, hash: hash3 });
    return { ...create(defHash), create };
  }
  var init_shortw_utils2 = __esm({
    "node_modules/viem/node_modules/@noble/curves/esm/_shortw_utils.js"() {
      init_weierstrass2();
    }
  });

  // node_modules/viem/node_modules/@noble/curves/esm/abstract/hash-to-curve.js
  function i2osp(value, length) {
    anum(value);
    anum(length);
    if (value < 0 || value >= 1 << 8 * length)
      throw new Error("invalid I2OSP input: " + value);
    const res = Array.from({ length }).fill(0);
    for (let i = length - 1; i >= 0; i--) {
      res[i] = value & 255;
      value >>>= 8;
    }
    return new Uint8Array(res);
  }
  function strxor(a, b2) {
    const arr = new Uint8Array(a.length);
    for (let i = 0; i < a.length; i++) {
      arr[i] = a[i] ^ b2[i];
    }
    return arr;
  }
  function anum(item) {
    if (!Number.isSafeInteger(item))
      throw new Error("number expected");
  }
  function expand_message_xmd(msg, DST, lenInBytes, H) {
    abytes(msg);
    abytes(DST);
    anum(lenInBytes);
    if (DST.length > 255)
      DST = H(concatBytes3(utf8ToBytes3("H2C-OVERSIZE-DST-"), DST));
    const { outputLen: b_in_bytes, blockLen: r_in_bytes } = H;
    const ell = Math.ceil(lenInBytes / b_in_bytes);
    if (lenInBytes > 65535 || ell > 255)
      throw new Error("expand_message_xmd: invalid lenInBytes");
    const DST_prime = concatBytes3(DST, i2osp(DST.length, 1));
    const Z_pad = i2osp(0, r_in_bytes);
    const l_i_b_str = i2osp(lenInBytes, 2);
    const b2 = new Array(ell);
    const b_0 = H(concatBytes3(Z_pad, msg, l_i_b_str, i2osp(0, 1), DST_prime));
    b2[0] = H(concatBytes3(b_0, i2osp(1, 1), DST_prime));
    for (let i = 1; i <= ell; i++) {
      const args = [strxor(b_0, b2[i - 1]), i2osp(i + 1, 1), DST_prime];
      b2[i] = H(concatBytes3(...args));
    }
    const pseudo_random_bytes = concatBytes3(...b2);
    return pseudo_random_bytes.slice(0, lenInBytes);
  }
  function expand_message_xof(msg, DST, lenInBytes, k, H) {
    abytes(msg);
    abytes(DST);
    anum(lenInBytes);
    if (DST.length > 255) {
      const dkLen = Math.ceil(2 * k / 8);
      DST = H.create({ dkLen }).update(utf8ToBytes3("H2C-OVERSIZE-DST-")).update(DST).digest();
    }
    if (lenInBytes > 65535 || DST.length > 255)
      throw new Error("expand_message_xof: invalid lenInBytes");
    return H.create({ dkLen: lenInBytes }).update(msg).update(i2osp(lenInBytes, 2)).update(DST).update(i2osp(DST.length, 1)).digest();
  }
  function hash_to_field(msg, count, options) {
    _validateObject(options, {
      p: "bigint",
      m: "number",
      k: "number",
      hash: "function"
    });
    const { p, k, m, hash: hash3, expand, DST: _DST } = options;
    if (!isBytes(_DST) && typeof _DST !== "string")
      throw new Error("DST must be string or uint8array");
    if (!isHash(options.hash))
      throw new Error("expected valid hash");
    abytes(msg);
    anum(count);
    const DST = typeof _DST === "string" ? utf8ToBytes3(_DST) : _DST;
    const log2p = p.toString(2).length;
    const L = Math.ceil((log2p + k) / 8);
    const len_in_bytes = count * m * L;
    let prb;
    if (expand === "xmd") {
      prb = expand_message_xmd(msg, DST, len_in_bytes, hash3);
    } else if (expand === "xof") {
      prb = expand_message_xof(msg, DST, len_in_bytes, k, hash3);
    } else if (expand === "_internal_pass") {
      prb = msg;
    } else {
      throw new Error('expand must be "xmd" or "xof"');
    }
    const u = new Array(count);
    for (let i = 0; i < count; i++) {
      const e = new Array(m);
      for (let j = 0; j < m; j++) {
        const elm_offset = L * (j + i * m);
        const tv = prb.subarray(elm_offset, elm_offset + L);
        e[j] = mod2(os2ip(tv), p);
      }
      u[i] = e;
    }
    return u;
  }
  function isogenyMap(field, map) {
    const coeff = map.map((i) => Array.from(i).reverse());
    return (x, y) => {
      const [xn, xd, yn, yd] = coeff.map((val) => val.reduce((acc, i) => field.add(field.mul(acc, x), i)));
      const [xd_inv, yd_inv] = FpInvertBatch2(field, [xd, yd], true);
      x = field.mul(xn, xd_inv);
      y = field.mul(y, field.mul(yn, yd_inv));
      return { x, y };
    };
  }
  function createHasher2(Point3, mapToCurve, defaults) {
    if (typeof mapToCurve !== "function")
      throw new Error("mapToCurve() must be defined");
    function map(num2) {
      return Point3.fromAffine(mapToCurve(num2));
    }
    function clear(initial) {
      const P = initial.clearCofactor();
      if (P.equals(Point3.ZERO))
        return Point3.ZERO;
      P.assertValidity();
      return P;
    }
    return {
      defaults,
      hashToCurve(msg, options) {
        const dst = defaults.DST ? defaults.DST : {};
        const opts = Object.assign({}, defaults, dst, options);
        const u = hash_to_field(msg, 2, opts);
        const u0 = map(u[0]);
        const u1 = map(u[1]);
        return clear(u0.add(u1));
      },
      encodeToCurve(msg, options) {
        const dst = defaults.encodeDST ? defaults.encodeDST : {};
        const opts = Object.assign({}, defaults, dst, options);
        const u = hash_to_field(msg, 1, opts);
        return clear(map(u[0]));
      },
      /** See {@link H2CHasher} */
      mapToCurve(scalars) {
        if (!Array.isArray(scalars))
          throw new Error("expected array of bigints");
        for (const i of scalars)
          if (typeof i !== "bigint")
            throw new Error("expected array of bigints");
        return clear(map(scalars));
      }
    };
  }
  var os2ip;
  var init_hash_to_curve = __esm({
    "node_modules/viem/node_modules/@noble/curves/esm/abstract/hash-to-curve.js"() {
      init_utils8();
      init_modular2();
      os2ip = bytesToNumberBE2;
    }
  });

  // node_modules/viem/node_modules/@noble/curves/esm/secp256k1.js
  var secp256k1_exports = {};
  __export(secp256k1_exports, {
    encodeToCurve: () => encodeToCurve,
    hashToCurve: () => hashToCurve,
    schnorr: () => schnorr,
    secp256k1: () => secp256k12,
    secp256k1_hasher: () => secp256k1_hasher
  });
  function sqrtMod2(y) {
    const P = secp256k1_CURVE.p;
    const _3n5 = BigInt(3), _6n = BigInt(6), _11n = BigInt(11), _22n = BigInt(22);
    const _23n = BigInt(23), _44n = BigInt(44), _88n = BigInt(88);
    const b2 = y * y * y % P;
    const b3 = b2 * b2 * y % P;
    const b6 = pow22(b3, _3n5, P) * b3 % P;
    const b9 = pow22(b6, _3n5, P) * b3 % P;
    const b11 = pow22(b9, _2n9, P) * b2 % P;
    const b22 = pow22(b11, _11n, P) * b11 % P;
    const b44 = pow22(b22, _22n, P) * b22 % P;
    const b88 = pow22(b44, _44n, P) * b44 % P;
    const b176 = pow22(b88, _88n, P) * b88 % P;
    const b220 = pow22(b176, _44n, P) * b44 % P;
    const b223 = pow22(b220, _3n5, P) * b3 % P;
    const t1 = pow22(b223, _23n, P) * b22 % P;
    const t2 = pow22(t1, _6n, P) * b2 % P;
    const root = pow22(t2, _2n9, P);
    if (!Fpk1.eql(Fpk1.sqr(root), y))
      throw new Error("Cannot find square root");
    return root;
  }
  function taggedHash(tag, ...messages) {
    let tagP = TAGGED_HASH_PREFIXES[tag];
    if (tagP === void 0) {
      const tagH = sha2563(Uint8Array.from(tag, (c) => c.charCodeAt(0)));
      tagP = concatBytes3(tagH, tagH);
      TAGGED_HASH_PREFIXES[tag] = tagP;
    }
    return sha2563(concatBytes3(tagP, ...messages));
  }
  function schnorrGetExtPubKey(priv) {
    let d_ = secp256k12.utils.normPrivateKeyToScalar(priv);
    let p = Point2.fromPrivateKey(d_);
    const scalar = hasEven(p.y) ? d_ : modN(-d_);
    return { scalar, bytes: pointToBytes(p) };
  }
  function lift_x(x) {
    aInRange("x", x, _1n12, secp256k1_CURVE.p);
    const xx = modP(x * x);
    const c = modP(xx * x + BigInt(7));
    let y = sqrtMod2(c);
    if (!hasEven(y))
      y = modP(-y);
    const p = Point2.fromAffine({ x, y });
    p.assertValidity();
    return p;
  }
  function challenge(...args) {
    return modN(num(taggedHash("BIP0340/challenge", ...args)));
  }
  function schnorrGetPublicKey(privateKey) {
    return schnorrGetExtPubKey(privateKey).bytes;
  }
  function schnorrSign(message, privateKey, auxRand = randomBytes4(32)) {
    const m = ensureBytes2("message", message);
    const { bytes: px, scalar: d } = schnorrGetExtPubKey(privateKey);
    const a = ensureBytes2("auxRand", auxRand, 32);
    const t = numTo32b(d ^ num(taggedHash("BIP0340/aux", a)));
    const rand = taggedHash("BIP0340/nonce", t, px, m);
    const k_ = modN(num(rand));
    if (k_ === _0n12)
      throw new Error("sign failed: k is zero");
    const { bytes: rx, scalar: k } = schnorrGetExtPubKey(k_);
    const e = challenge(rx, px, m);
    const sig = new Uint8Array(64);
    sig.set(rx, 0);
    sig.set(numTo32b(modN(k + e * d)), 32);
    if (!schnorrVerify(sig, m, px))
      throw new Error("sign: Invalid signature produced");
    return sig;
  }
  function schnorrVerify(signature, message, publicKey) {
    const sig = ensureBytes2("signature", signature, 64);
    const m = ensureBytes2("message", message);
    const pub = ensureBytes2("publicKey", publicKey, 32);
    try {
      const P = lift_x(num(pub));
      const r = num(sig.subarray(0, 32));
      if (!inRange(r, _1n12, secp256k1_CURVE.p))
        return false;
      const s = num(sig.subarray(32, 64));
      if (!inRange(s, _1n12, secp256k1_CURVE.n))
        return false;
      const e = challenge(numTo32b(r), pointToBytes(P), m);
      const R = Point2.BASE.multiplyUnsafe(s).add(P.multiplyUnsafe(modN(-e)));
      const { x, y } = R.toAffine();
      if (R.is0() || !hasEven(y) || x !== r)
        return false;
      return true;
    } catch (error) {
      return false;
    }
  }
  var secp256k1_CURVE, _0n12, _1n12, _2n9, divNearest2, Fpk1, secp256k12, TAGGED_HASH_PREFIXES, pointToBytes, numTo32b, modP, modN, Point2, hasEven, num, schnorr, isoMap, mapSWU, secp256k1_hasher, hashToCurve, encodeToCurve;
  var init_secp256k12 = __esm({
    "node_modules/viem/node_modules/@noble/curves/esm/secp256k1.js"() {
      init_sha23();
      init_utils6();
      init_shortw_utils2();
      init_hash_to_curve();
      init_modular2();
      init_weierstrass2();
      init_utils8();
      secp256k1_CURVE = {
        p: BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),
        n: BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),
        h: BigInt(1),
        a: BigInt(0),
        b: BigInt(7),
        Gx: BigInt("0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"),
        Gy: BigInt("0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8")
      };
      _0n12 = BigInt(0);
      _1n12 = BigInt(1);
      _2n9 = BigInt(2);
      divNearest2 = (a, b2) => (a + b2 / _2n9) / b2;
      Fpk1 = Field2(secp256k1_CURVE.p, void 0, void 0, { sqrt: sqrtMod2 });
      secp256k12 = createCurve2({
        ...secp256k1_CURVE,
        Fp: Fpk1,
        lowS: true,
        // Allow only low-S signatures by default in sign() and verify()
        endo: {
          // Endomorphism, see above
          beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
          splitScalar: (k) => {
            const n2 = secp256k1_CURVE.n;
            const a1 = BigInt("0x3086d221a7d46bcde86c90e49284eb15");
            const b1 = -_1n12 * BigInt("0xe4437ed6010e88286f547fa90abfe4c3");
            const a2 = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8");
            const b2 = a1;
            const POW_2_128 = BigInt("0x100000000000000000000000000000000");
            const c1 = divNearest2(b2 * k, n2);
            const c2 = divNearest2(-b1 * k, n2);
            let k1 = mod2(k - c1 * a1 - c2 * a2, n2);
            let k2 = mod2(-c1 * b1 - c2 * b2, n2);
            const k1neg = k1 > POW_2_128;
            const k2neg = k2 > POW_2_128;
            if (k1neg)
              k1 = n2 - k1;
            if (k2neg)
              k2 = n2 - k2;
            if (k1 > POW_2_128 || k2 > POW_2_128) {
              throw new Error("splitScalar: Endomorphism failed, k=" + k);
            }
            return { k1neg, k1, k2neg, k2 };
          }
        }
      }, sha2563);
      TAGGED_HASH_PREFIXES = {};
      pointToBytes = (point) => point.toBytes(true).slice(1);
      numTo32b = (n2) => numberToBytesBE2(n2, 32);
      modP = (x) => mod2(x, secp256k1_CURVE.p);
      modN = (x) => mod2(x, secp256k1_CURVE.n);
      Point2 = /* @__PURE__ */ (() => secp256k12.Point)();
      hasEven = (y) => y % _2n9 === _0n12;
      num = bytesToNumberBE2;
      schnorr = /* @__PURE__ */ (() => ({
        getPublicKey: schnorrGetPublicKey,
        sign: schnorrSign,
        verify: schnorrVerify,
        utils: {
          randomPrivateKey: secp256k12.utils.randomPrivateKey,
          lift_x,
          pointToBytes,
          numberToBytesBE: numberToBytesBE2,
          bytesToNumberBE: bytesToNumberBE2,
          taggedHash,
          mod: mod2
        }
      }))();
      isoMap = /* @__PURE__ */ (() => isogenyMap(Fpk1, [
        // xNum
        [
          "0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7",
          "0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581",
          "0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262",
          "0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c"
        ],
        // xDen
        [
          "0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b",
          "0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14",
          "0x0000000000000000000000000000000000000000000000000000000000000001"
          // LAST 1
        ],
        // yNum
        [
          "0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c",
          "0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3",
          "0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931",
          "0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84"
        ],
        // yDen
        [
          "0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b",
          "0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573",
          "0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f",
          "0x0000000000000000000000000000000000000000000000000000000000000001"
          // LAST 1
        ]
      ].map((i) => i.map((j) => BigInt(j)))))();
      mapSWU = /* @__PURE__ */ (() => mapToCurveSimpleSWU(Fpk1, {
        A: BigInt("0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533"),
        B: BigInt("1771"),
        Z: Fpk1.create(BigInt("-11"))
      }))();
      secp256k1_hasher = /* @__PURE__ */ (() => createHasher2(secp256k12.Point, (scalars) => {
        const { x, y } = mapSWU(Fpk1.create(scalars[0]));
        return isoMap(x, y);
      }, {
        DST: "secp256k1_XMD:SHA-256_SSWU_RO_",
        encodeDST: "secp256k1_XMD:SHA-256_SSWU_NU_",
        p: Fpk1.ORDER,
        m: 1,
        k: 128,
        expand: "xmd",
        hash: sha2563
      }))();
      hashToCurve = /* @__PURE__ */ (() => secp256k1_hasher.hashToCurve)();
      encodeToCurve = /* @__PURE__ */ (() => secp256k1_hasher.encodeToCurve)();
    }
  });

  // node_modules/viem/_esm/utils/signature/recoverPublicKey.js
  async function recoverPublicKey({ hash: hash3, signature }) {
    const hashHex = isHex(hash3) ? hash3 : toHex(hash3);
    const { secp256k1: secp256k13 } = await Promise.resolve().then(() => (init_secp256k12(), secp256k1_exports));
    const signature_ = (() => {
      if (typeof signature === "object" && "r" in signature && "s" in signature) {
        const { r, s, v, yParity } = signature;
        const yParityOrV2 = Number(yParity ?? v);
        const recoveryBit2 = toRecoveryBit(yParityOrV2);
        return new secp256k13.Signature(hexToBigInt(r), hexToBigInt(s)).addRecoveryBit(recoveryBit2);
      }
      const signatureHex = isHex(signature) ? signature : toHex(signature);
      if (size(signatureHex) !== 65)
        throw new Error("invalid signature length");
      const yParityOrV = hexToNumber2(`0x${signatureHex.slice(130)}`);
      const recoveryBit = toRecoveryBit(yParityOrV);
      return secp256k13.Signature.fromCompact(signatureHex.substring(2, 130)).addRecoveryBit(recoveryBit);
    })();
    const publicKey = signature_.recoverPublicKey(hashHex.substring(2)).toHex(false);
    return `0x${publicKey}`;
  }
  function toRecoveryBit(yParityOrV) {
    if (yParityOrV === 0 || yParityOrV === 1)
      return yParityOrV;
    if (yParityOrV === 27)
      return 0;
    if (yParityOrV === 28)
      return 1;
    throw new Error("Invalid yParityOrV value");
  }
  var init_recoverPublicKey = __esm({
    "node_modules/viem/_esm/utils/signature/recoverPublicKey.js"() {
      init_isHex();
      init_size();
      init_fromHex();
      init_toHex();
    }
  });

  // node_modules/viem/_esm/utils/signature/recoverAddress.js
  async function recoverAddress2({ hash: hash3, signature }) {
    return publicKeyToAddress(await recoverPublicKey({ hash: hash3, signature }));
  }
  var init_recoverAddress = __esm({
    "node_modules/viem/_esm/utils/signature/recoverAddress.js"() {
      init_publicKeyToAddress();
      init_recoverPublicKey();
    }
  });

  // node_modules/viem/_esm/utils/encoding/toRlp.js
  function toRlp(bytes2, to = "hex") {
    const encodable = getEncodable(bytes2);
    const cursor = createCursor(new Uint8Array(encodable.length));
    encodable.encode(cursor);
    if (to === "hex")
      return bytesToHex2(cursor.bytes);
    return cursor.bytes;
  }
  function getEncodable(bytes2) {
    if (Array.isArray(bytes2))
      return getEncodableList(bytes2.map((x) => getEncodable(x)));
    return getEncodableBytes(bytes2);
  }
  function getEncodableList(list) {
    const bodyLength = list.reduce((acc, x) => acc + x.length, 0);
    const sizeOfBodyLength = getSizeOfLength(bodyLength);
    const length = (() => {
      if (bodyLength <= 55)
        return 1 + bodyLength;
      return 1 + sizeOfBodyLength + bodyLength;
    })();
    return {
      length,
      encode(cursor) {
        if (bodyLength <= 55) {
          cursor.pushByte(192 + bodyLength);
        } else {
          cursor.pushByte(192 + 55 + sizeOfBodyLength);
          if (sizeOfBodyLength === 1)
            cursor.pushUint8(bodyLength);
          else if (sizeOfBodyLength === 2)
            cursor.pushUint16(bodyLength);
          else if (sizeOfBodyLength === 3)
            cursor.pushUint24(bodyLength);
          else
            cursor.pushUint32(bodyLength);
        }
        for (const { encode: encode4 } of list) {
          encode4(cursor);
        }
      }
    };
  }
  function getEncodableBytes(bytesOrHex) {
    const bytes2 = typeof bytesOrHex === "string" ? hexToBytes2(bytesOrHex) : bytesOrHex;
    const sizeOfBytesLength = getSizeOfLength(bytes2.length);
    const length = (() => {
      if (bytes2.length === 1 && bytes2[0] < 128)
        return 1;
      if (bytes2.length <= 55)
        return 1 + bytes2.length;
      return 1 + sizeOfBytesLength + bytes2.length;
    })();
    return {
      length,
      encode(cursor) {
        if (bytes2.length === 1 && bytes2[0] < 128) {
          cursor.pushBytes(bytes2);
        } else if (bytes2.length <= 55) {
          cursor.pushByte(128 + bytes2.length);
          cursor.pushBytes(bytes2);
        } else {
          cursor.pushByte(128 + 55 + sizeOfBytesLength);
          if (sizeOfBytesLength === 1)
            cursor.pushUint8(bytes2.length);
          else if (sizeOfBytesLength === 2)
            cursor.pushUint16(bytes2.length);
          else if (sizeOfBytesLength === 3)
            cursor.pushUint24(bytes2.length);
          else
            cursor.pushUint32(bytes2.length);
          cursor.pushBytes(bytes2);
        }
      }
    };
  }
  function getSizeOfLength(length) {
    if (length < 2 ** 8)
      return 1;
    if (length < 2 ** 16)
      return 2;
    if (length < 2 ** 24)
      return 3;
    if (length < 2 ** 32)
      return 4;
    throw new BaseError2("Length is too large.");
  }
  var init_toRlp = __esm({
    "node_modules/viem/_esm/utils/encoding/toRlp.js"() {
      init_base();
      init_cursor2();
      init_toBytes();
      init_toHex();
    }
  });

  // node_modules/viem/_esm/utils/authorization/hashAuthorization.js
  function hashAuthorization2(parameters) {
    const { chainId, nonce, to } = parameters;
    const address = parameters.contractAddress ?? parameters.address;
    const hash3 = keccak2562(concatHex([
      "0x05",
      toRlp([
        chainId ? numberToHex(chainId) : "0x",
        address,
        nonce ? numberToHex(nonce) : "0x"
      ])
    ]));
    if (to === "bytes")
      return hexToBytes2(hash3);
    return hash3;
  }
  var init_hashAuthorization = __esm({
    "node_modules/viem/_esm/utils/authorization/hashAuthorization.js"() {
      init_concat();
      init_toBytes();
      init_toHex();
      init_toRlp();
      init_keccak256();
    }
  });

  // node_modules/viem/_esm/utils/authorization/recoverAuthorizationAddress.js
  async function recoverAuthorizationAddress(parameters) {
    const { authorization, signature } = parameters;
    return recoverAddress2({
      hash: hashAuthorization2(authorization),
      signature: signature ?? authorization
    });
  }
  var init_recoverAuthorizationAddress = __esm({
    "node_modules/viem/_esm/utils/authorization/recoverAuthorizationAddress.js"() {
      init_recoverAddress();
      init_hashAuthorization();
    }
  });

  // node_modules/viem/_esm/errors/estimateGas.js
  var EstimateGasExecutionError;
  var init_estimateGas = __esm({
    "node_modules/viem/_esm/errors/estimateGas.js"() {
      init_formatEther();
      init_formatGwei();
      init_base();
      init_transaction3();
      EstimateGasExecutionError = class extends BaseError2 {
        constructor(cause, { account, docsPath: docsPath8, chain, data, gas, gasPrice, maxFeePerGas, maxPriorityFeePerGas, nonce, to, value }) {
          const prettyArgs = prettyPrint({
            from: account?.address,
            to,
            value: typeof value !== "undefined" && `${formatEther2(value)} ${chain?.nativeCurrency?.symbol || "ETH"}`,
            data,
            gas,
            gasPrice: typeof gasPrice !== "undefined" && `${formatGwei(gasPrice)} gwei`,
            maxFeePerGas: typeof maxFeePerGas !== "undefined" && `${formatGwei(maxFeePerGas)} gwei`,
            maxPriorityFeePerGas: typeof maxPriorityFeePerGas !== "undefined" && `${formatGwei(maxPriorityFeePerGas)} gwei`,
            nonce
          });
          super(cause.shortMessage, {
            cause,
            docsPath: docsPath8,
            metaMessages: [
              ...cause.metaMessages ? [...cause.metaMessages, " "] : [],
              "Estimate Gas Arguments:",
              prettyArgs
            ].filter(Boolean),
            name: "EstimateGasExecutionError"
          });
          Object.defineProperty(this, "cause", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
          });
          this.cause = cause;
        }
      };
    }
  });

  // node_modules/viem/_esm/errors/node.js
  var ExecutionRevertedError, FeeCapTooHighError, FeeCapTooLowError, NonceTooHighError, NonceTooLowError, NonceMaxValueError, InsufficientFundsError, IntrinsicGasTooHighError, IntrinsicGasTooLowError, TransactionTypeNotSupportedError, TipAboveFeeCapError, UnknownNodeError;
  var init_node = __esm({
    "node_modules/viem/_esm/errors/node.js"() {
      init_formatGwei();
      init_base();
      ExecutionRevertedError = class extends BaseError2 {
        constructor({ cause, message } = {}) {
          const reason = message?.replace("execution reverted: ", "")?.replace("execution reverted", "");
          super(`Execution reverted ${reason ? `with reason: ${reason}` : "for an unknown reason"}.`, {
            cause,
            name: "ExecutionRevertedError"
          });
        }
      };
      Object.defineProperty(ExecutionRevertedError, "code", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: 3
      });
      Object.defineProperty(ExecutionRevertedError, "nodeMessage", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: /execution reverted/
      });
      FeeCapTooHighError = class extends BaseError2 {
        constructor({ cause, maxFeePerGas } = {}) {
          super(`The fee cap (\`maxFeePerGas\`${maxFeePerGas ? ` = ${formatGwei(maxFeePerGas)} gwei` : ""}) cannot be higher than the maximum allowed value (2^256-1).`, {
            cause,
            name: "FeeCapTooHighError"
          });
        }
      };
      Object.defineProperty(FeeCapTooHighError, "nodeMessage", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: /max fee per gas higher than 2\^256-1|fee cap higher than 2\^256-1/
      });
      FeeCapTooLowError = class extends BaseError2 {
        constructor({ cause, maxFeePerGas } = {}) {
          super(`The fee cap (\`maxFeePerGas\`${maxFeePerGas ? ` = ${formatGwei(maxFeePerGas)}` : ""} gwei) cannot be lower than the block base fee.`, {
            cause,
            name: "FeeCapTooLowError"
          });
        }
      };
      Object.defineProperty(FeeCapTooLowError, "nodeMessage", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: /max fee per gas less than block base fee|fee cap less than block base fee|transaction is outdated/
      });
      NonceTooHighError = class extends BaseError2 {
        constructor({ cause, nonce } = {}) {
          super(`Nonce provided for the transaction ${nonce ? `(${nonce}) ` : ""}is higher than the next one expected.`, { cause, name: "NonceTooHighError" });
        }
      };
      Object.defineProperty(NonceTooHighError, "nodeMessage", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: /nonce too high/
      });
      NonceTooLowError = class extends BaseError2 {
        constructor({ cause, nonce } = {}) {
          super([
            `Nonce provided for the transaction ${nonce ? `(${nonce}) ` : ""}is lower than the current nonce of the account.`,
            "Try increasing the nonce or find the latest nonce with `getTransactionCount`."
          ].join("\n"), { cause, name: "NonceTooLowError" });
        }
      };
      Object.defineProperty(NonceTooLowError, "nodeMessage", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: /nonce too low|transaction already imported|already known/
      });
      NonceMaxValueError = class extends BaseError2 {
        constructor({ cause, nonce } = {}) {
          super(`Nonce provided for the transaction ${nonce ? `(${nonce}) ` : ""}exceeds the maximum allowed nonce.`, { cause, name: "NonceMaxValueError" });
        }
      };
      Object.defineProperty(NonceMaxValueError, "nodeMessage", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: /nonce has max value/
      });
      InsufficientFundsError = class extends BaseError2 {
        constructor({ cause } = {}) {
          super([
            "The total cost (gas * gas fee + value) of executing this transaction exceeds the balance of the account."
          ].join("\n"), {
            cause,
            metaMessages: [
              "This error could arise when the account does not have enough funds to:",
              " - pay for the total gas fee,",
              " - pay for the value to send.",
              " ",
              "The cost of the transaction is calculated as `gas * gas fee + value`, where:",
              " - `gas` is the amount of gas needed for transaction to execute,",
              " - `gas fee` is the gas fee,",
              " - `value` is the amount of ether to send to the recipient."
            ],
            name: "InsufficientFundsError"
          });
        }
      };
      Object.defineProperty(InsufficientFundsError, "nodeMessage", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: /insufficient funds|exceeds transaction sender account balance/
      });
      IntrinsicGasTooHighError = class extends BaseError2 {
        constructor({ cause, gas } = {}) {
          super(`The amount of gas ${gas ? `(${gas}) ` : ""}provided for the transaction exceeds the limit allowed for the block.`, {
            cause,
            name: "IntrinsicGasTooHighError"
          });
        }
      };
      Object.defineProperty(IntrinsicGasTooHighError, "nodeMessage", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: /intrinsic gas too high|gas limit reached/
      });
      IntrinsicGasTooLowError = class extends BaseError2 {
        constructor({ cause, gas } = {}) {
          super(`The amount of gas ${gas ? `(${gas}) ` : ""}provided for the transaction is too low.`, {
            cause,
            name: "IntrinsicGasTooLowError"
          });
        }
      };
      Object.defineProperty(IntrinsicGasTooLowError, "nodeMessage", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: /intrinsic gas too low/
      });
      TransactionTypeNotSupportedError = class extends BaseError2 {
        constructor({ cause }) {
          super("The transaction type is not supported for this chain.", {
            cause,
            name: "TransactionTypeNotSupportedError"
          });
        }
      };
      Object.defineProperty(TransactionTypeNotSupportedError, "nodeMessage", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: /transaction type not valid/
      });
      TipAboveFeeCapError = class extends BaseError2 {
        constructor({ cause, maxPriorityFeePerGas, maxFeePerGas } = {}) {
          super([
            `The provided tip (\`maxPriorityFeePerGas\`${maxPriorityFeePerGas ? ` = ${formatGwei(maxPriorityFeePerGas)} gwei` : ""}) cannot be higher than the fee cap (\`maxFeePerGas\`${maxFeePerGas ? ` = ${formatGwei(maxFeePerGas)} gwei` : ""}).`
          ].join("\n"), {
            cause,
            name: "TipAboveFeeCapError"
          });
        }
      };
      Object.defineProperty(TipAboveFeeCapError, "nodeMessage", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: /max priority fee per gas higher than max fee per gas|tip higher than fee cap/
      });
      UnknownNodeError = class extends BaseError2 {
        constructor({ cause }) {
          super(`An error occurred while executing: ${cause?.shortMessage}`, {
            cause,
            name: "UnknownNodeError"
          });
        }
      };
    }
  });

  // node_modules/viem/_esm/utils/errors/getNodeError.js
  function getNodeError(err, args) {
    const message = (err.details || "").toLowerCase();
    const executionRevertedError = err instanceof BaseError2 ? err.walk((e) => e?.code === ExecutionRevertedError.code) : err;
    if (executionRevertedError instanceof BaseError2)
      return new ExecutionRevertedError({
        cause: err,
        message: executionRevertedError.details
      });
    if (ExecutionRevertedError.nodeMessage.test(message))
      return new ExecutionRevertedError({
        cause: err,
        message: err.details
      });
    if (FeeCapTooHighError.nodeMessage.test(message))
      return new FeeCapTooHighError({
        cause: err,
        maxFeePerGas: args?.maxFeePerGas
      });
    if (FeeCapTooLowError.nodeMessage.test(message))
      return new FeeCapTooLowError({
        cause: err,
        maxFeePerGas: args?.maxFeePerGas
      });
    if (NonceTooHighError.nodeMessage.test(message))
      return new NonceTooHighError({ cause: err, nonce: args?.nonce });
    if (NonceTooLowError.nodeMessage.test(message))
      return new NonceTooLowError({ cause: err, nonce: args?.nonce });
    if (NonceMaxValueError.nodeMessage.test(message))
      return new NonceMaxValueError({ cause: err, nonce: args?.nonce });
    if (InsufficientFundsError.nodeMessage.test(message))
      return new InsufficientFundsError({ cause: err });
    if (IntrinsicGasTooHighError.nodeMessage.test(message))
      return new IntrinsicGasTooHighError({ cause: err, gas: args?.gas });
    if (IntrinsicGasTooLowError.nodeMessage.test(message))
      return new IntrinsicGasTooLowError({ cause: err, gas: args?.gas });
    if (TransactionTypeNotSupportedError.nodeMessage.test(message))
      return new TransactionTypeNotSupportedError({ cause: err });
    if (TipAboveFeeCapError.nodeMessage.test(message))
      return new TipAboveFeeCapError({
        cause: err,
        maxFeePerGas: args?.maxFeePerGas,
        maxPriorityFeePerGas: args?.maxPriorityFeePerGas
      });
    return new UnknownNodeError({
      cause: err
    });
  }
  var init_getNodeError = __esm({
    "node_modules/viem/_esm/utils/errors/getNodeError.js"() {
      init_base();
      init_node();
    }
  });

  // node_modules/viem/_esm/utils/errors/getEstimateGasError.js
  function getEstimateGasError(err, { docsPath: docsPath8, ...args }) {
    const cause = (() => {
      const cause2 = getNodeError(err, args);
      if (cause2 instanceof UnknownNodeError)
        return err;
      return cause2;
    })();
    return new EstimateGasExecutionError(cause, {
      docsPath: docsPath8,
      ...args
    });
  }
  var init_getEstimateGasError = __esm({
    "node_modules/viem/_esm/utils/errors/getEstimateGasError.js"() {
      init_estimateGas();
      init_node();
      init_getNodeError();
    }
  });

  // node_modules/viem/_esm/utils/formatters/extract.js
  function extract(value_, { format }) {
    if (!format)
      return {};
    const value = {};
    function extract_(formatted2) {
      const keys = Object.keys(formatted2);
      for (const key of keys) {
        if (key in value_)
          value[key] = value_[key];
        if (formatted2[key] && typeof formatted2[key] === "object" && !Array.isArray(formatted2[key]))
          extract_(formatted2[key]);
      }
    }
    const formatted = format(value_ || {});
    extract_(formatted);
    return value;
  }
  var init_extract = __esm({
    "node_modules/viem/_esm/utils/formatters/extract.js"() {
    }
  });

  // node_modules/viem/_esm/utils/formatters/formatter.js
  function defineFormatter(type, format) {
    return ({ exclude, format: overrides }) => {
      return {
        exclude,
        format: (args) => {
          const formatted = format(args);
          if (exclude) {
            for (const key of exclude) {
              delete formatted[key];
            }
          }
          return {
            ...formatted,
            ...overrides(args)
          };
        },
        type
      };
    };
  }
  var init_formatter = __esm({
    "node_modules/viem/_esm/utils/formatters/formatter.js"() {
    }
  });

  // node_modules/viem/_esm/utils/formatters/transactionRequest.js
  function formatTransactionRequest(request) {
    const rpcRequest = {};
    if (typeof request.authorizationList !== "undefined")
      rpcRequest.authorizationList = formatAuthorizationList2(request.authorizationList);
    if (typeof request.accessList !== "undefined")
      rpcRequest.accessList = request.accessList;
    if (typeof request.blobVersionedHashes !== "undefined")
      rpcRequest.blobVersionedHashes = request.blobVersionedHashes;
    if (typeof request.blobs !== "undefined") {
      if (typeof request.blobs[0] !== "string")
        rpcRequest.blobs = request.blobs.map((x) => bytesToHex2(x));
      else
        rpcRequest.blobs = request.blobs;
    }
    if (typeof request.data !== "undefined")
      rpcRequest.data = request.data;
    if (typeof request.from !== "undefined")
      rpcRequest.from = request.from;
    if (typeof request.gas !== "undefined")
      rpcRequest.gas = numberToHex(request.gas);
    if (typeof request.gasPrice !== "undefined")
      rpcRequest.gasPrice = numberToHex(request.gasPrice);
    if (typeof request.maxFeePerBlobGas !== "undefined")
      rpcRequest.maxFeePerBlobGas = numberToHex(request.maxFeePerBlobGas);
    if (typeof request.maxFeePerGas !== "undefined")
      rpcRequest.maxFeePerGas = numberToHex(request.maxFeePerGas);
    if (typeof request.maxPriorityFeePerGas !== "undefined")
      rpcRequest.maxPriorityFeePerGas = numberToHex(request.maxPriorityFeePerGas);
    if (typeof request.nonce !== "undefined")
      rpcRequest.nonce = numberToHex(request.nonce);
    if (typeof request.to !== "undefined")
      rpcRequest.to = request.to;
    if (typeof request.type !== "undefined")
      rpcRequest.type = rpcTransactionType[request.type];
    if (typeof request.value !== "undefined")
      rpcRequest.value = numberToHex(request.value);
    return rpcRequest;
  }
  function formatAuthorizationList2(authorizationList) {
    return authorizationList.map((authorization) => ({
      address: authorization.address,
      r: authorization.r ? numberToHex(BigInt(authorization.r)) : authorization.r,
      s: authorization.s ? numberToHex(BigInt(authorization.s)) : authorization.s,
      chainId: numberToHex(authorization.chainId),
      nonce: numberToHex(authorization.nonce),
      ...typeof authorization.yParity !== "undefined" ? { yParity: numberToHex(authorization.yParity) } : {},
      ...typeof authorization.v !== "undefined" && typeof authorization.yParity === "undefined" ? { v: numberToHex(authorization.v) } : {}
    }));
  }
  var rpcTransactionType;
  var init_transactionRequest = __esm({
    "node_modules/viem/_esm/utils/formatters/transactionRequest.js"() {
      init_toHex();
      rpcTransactionType = {
        legacy: "0x0",
        eip2930: "0x1",
        eip1559: "0x2",
        eip4844: "0x3",
        eip7702: "0x4"
      };
    }
  });

  // node_modules/viem/_esm/utils/stateOverride.js
  function serializeStateMapping(stateMapping) {
    if (!stateMapping || stateMapping.length === 0)
      return void 0;
    return stateMapping.reduce((acc, { slot, value }) => {
      if (slot.length !== 66)
        throw new InvalidBytesLengthError({
          size: slot.length,
          targetSize: 66,
          type: "hex"
        });
      if (value.length !== 66)
        throw new InvalidBytesLengthError({
          size: value.length,
          targetSize: 66,
          type: "hex"
        });
      acc[slot] = value;
      return acc;
    }, {});
  }
  function serializeAccountStateOverride(parameters) {
    const { balance, nonce, state, stateDiff, code } = parameters;
    const rpcAccountStateOverride = {};
    if (code !== void 0)
      rpcAccountStateOverride.code = code;
    if (balance !== void 0)
      rpcAccountStateOverride.balance = numberToHex(balance);
    if (nonce !== void 0)
      rpcAccountStateOverride.nonce = numberToHex(nonce);
    if (state !== void 0)
      rpcAccountStateOverride.state = serializeStateMapping(state);
    if (stateDiff !== void 0) {
      if (rpcAccountStateOverride.state)
        throw new StateAssignmentConflictError();
      rpcAccountStateOverride.stateDiff = serializeStateMapping(stateDiff);
    }
    return rpcAccountStateOverride;
  }
  function serializeStateOverride(parameters) {
    if (!parameters)
      return void 0;
    const rpcStateOverride = {};
    for (const { address, ...accountState } of parameters) {
      if (!isAddress2(address, { strict: false }))
        throw new InvalidAddressError({ address });
      if (rpcStateOverride[address])
        throw new AccountStateConflictError({ address });
      rpcStateOverride[address] = serializeAccountStateOverride(accountState);
    }
    return rpcStateOverride;
  }
  var init_stateOverride2 = __esm({
    "node_modules/viem/_esm/utils/stateOverride.js"() {
      init_address5();
      init_data2();
      init_stateOverride();
      init_isAddress();
      init_toHex();
    }
  });

  // node_modules/viem/_esm/constants/number.js
  var maxInt8, maxInt16, maxInt24, maxInt32, maxInt40, maxInt48, maxInt56, maxInt64, maxInt72, maxInt80, maxInt88, maxInt96, maxInt104, maxInt112, maxInt120, maxInt128, maxInt136, maxInt144, maxInt152, maxInt160, maxInt168, maxInt176, maxInt184, maxInt192, maxInt200, maxInt208, maxInt216, maxInt224, maxInt232, maxInt240, maxInt248, maxInt256, minInt8, minInt16, minInt24, minInt32, minInt40, minInt48, minInt56, minInt64, minInt72, minInt80, minInt88, minInt96, minInt104, minInt112, minInt120, minInt128, minInt136, minInt144, minInt152, minInt160, minInt168, minInt176, minInt184, minInt192, minInt200, minInt208, minInt216, minInt224, minInt232, minInt240, minInt248, minInt256, maxUint8, maxUint16, maxUint24, maxUint32, maxUint40, maxUint48, maxUint56, maxUint64, maxUint72, maxUint80, maxUint88, maxUint96, maxUint104, maxUint112, maxUint120, maxUint128, maxUint136, maxUint144, maxUint152, maxUint160, maxUint168, maxUint176, maxUint184, maxUint192, maxUint200, maxUint208, maxUint216, maxUint224, maxUint232, maxUint240, maxUint248, maxUint256;
  var init_number2 = __esm({
    "node_modules/viem/_esm/constants/number.js"() {
      maxInt8 = 2n ** (8n - 1n) - 1n;
      maxInt16 = 2n ** (16n - 1n) - 1n;
      maxInt24 = 2n ** (24n - 1n) - 1n;
      maxInt32 = 2n ** (32n - 1n) - 1n;
      maxInt40 = 2n ** (40n - 1n) - 1n;
      maxInt48 = 2n ** (48n - 1n) - 1n;
      maxInt56 = 2n ** (56n - 1n) - 1n;
      maxInt64 = 2n ** (64n - 1n) - 1n;
      maxInt72 = 2n ** (72n - 1n) - 1n;
      maxInt80 = 2n ** (80n - 1n) - 1n;
      maxInt88 = 2n ** (88n - 1n) - 1n;
      maxInt96 = 2n ** (96n - 1n) - 1n;
      maxInt104 = 2n ** (104n - 1n) - 1n;
      maxInt112 = 2n ** (112n - 1n) - 1n;
      maxInt120 = 2n ** (120n - 1n) - 1n;
      maxInt128 = 2n ** (128n - 1n) - 1n;
      maxInt136 = 2n ** (136n - 1n) - 1n;
      maxInt144 = 2n ** (144n - 1n) - 1n;
      maxInt152 = 2n ** (152n - 1n) - 1n;
      maxInt160 = 2n ** (160n - 1n) - 1n;
      maxInt168 = 2n ** (168n - 1n) - 1n;
      maxInt176 = 2n ** (176n - 1n) - 1n;
      maxInt184 = 2n ** (184n - 1n) - 1n;
      maxInt192 = 2n ** (192n - 1n) - 1n;
      maxInt200 = 2n ** (200n - 1n) - 1n;
      maxInt208 = 2n ** (208n - 1n) - 1n;
      maxInt216 = 2n ** (216n - 1n) - 1n;
      maxInt224 = 2n ** (224n - 1n) - 1n;
      maxInt232 = 2n ** (232n - 1n) - 1n;
      maxInt240 = 2n ** (240n - 1n) - 1n;
      maxInt248 = 2n ** (248n - 1n) - 1n;
      maxInt256 = 2n ** (256n - 1n) - 1n;
      minInt8 = -(2n ** (8n - 1n));
      minInt16 = -(2n ** (16n - 1n));
      minInt24 = -(2n ** (24n - 1n));
      minInt32 = -(2n ** (32n - 1n));
      minInt40 = -(2n ** (40n - 1n));
      minInt48 = -(2n ** (48n - 1n));
      minInt56 = -(2n ** (56n - 1n));
      minInt64 = -(2n ** (64n - 1n));
      minInt72 = -(2n ** (72n - 1n));
      minInt80 = -(2n ** (80n - 1n));
      minInt88 = -(2n ** (88n - 1n));
      minInt96 = -(2n ** (96n - 1n));
      minInt104 = -(2n ** (104n - 1n));
      minInt112 = -(2n ** (112n - 1n));
      minInt120 = -(2n ** (120n - 1n));
      minInt128 = -(2n ** (128n - 1n));
      minInt136 = -(2n ** (136n - 1n));
      minInt144 = -(2n ** (144n - 1n));
      minInt152 = -(2n ** (152n - 1n));
      minInt160 = -(2n ** (160n - 1n));
      minInt168 = -(2n ** (168n - 1n));
      minInt176 = -(2n ** (176n - 1n));
      minInt184 = -(2n ** (184n - 1n));
      minInt192 = -(2n ** (192n - 1n));
      minInt200 = -(2n ** (200n - 1n));
      minInt208 = -(2n ** (208n - 1n));
      minInt216 = -(2n ** (216n - 1n));
      minInt224 = -(2n ** (224n - 1n));
      minInt232 = -(2n ** (232n - 1n));
      minInt240 = -(2n ** (240n - 1n));
      minInt248 = -(2n ** (248n - 1n));
      minInt256 = -(2n ** (256n - 1n));
      maxUint8 = 2n ** 8n - 1n;
      maxUint16 = 2n ** 16n - 1n;
      maxUint24 = 2n ** 24n - 1n;
      maxUint32 = 2n ** 32n - 1n;
      maxUint40 = 2n ** 40n - 1n;
      maxUint48 = 2n ** 48n - 1n;
      maxUint56 = 2n ** 56n - 1n;
      maxUint64 = 2n ** 64n - 1n;
      maxUint72 = 2n ** 72n - 1n;
      maxUint80 = 2n ** 80n - 1n;
      maxUint88 = 2n ** 88n - 1n;
      maxUint96 = 2n ** 96n - 1n;
      maxUint104 = 2n ** 104n - 1n;
      maxUint112 = 2n ** 112n - 1n;
      maxUint120 = 2n ** 120n - 1n;
      maxUint128 = 2n ** 128n - 1n;
      maxUint136 = 2n ** 136n - 1n;
      maxUint144 = 2n ** 144n - 1n;
      maxUint152 = 2n ** 152n - 1n;
      maxUint160 = 2n ** 160n - 1n;
      maxUint168 = 2n ** 168n - 1n;
      maxUint176 = 2n ** 176n - 1n;
      maxUint184 = 2n ** 184n - 1n;
      maxUint192 = 2n ** 192n - 1n;
      maxUint200 = 2n ** 200n - 1n;
      maxUint208 = 2n ** 208n - 1n;
      maxUint216 = 2n ** 216n - 1n;
      maxUint224 = 2n ** 224n - 1n;
      maxUint232 = 2n ** 232n - 1n;
      maxUint240 = 2n ** 240n - 1n;
      maxUint248 = 2n ** 248n - 1n;
      maxUint256 = 2n ** 256n - 1n;
    }
  });

  // node_modules/viem/_esm/utils/transaction/assertRequest.js
  function assertRequest(args) {
    const { account: account_, gasPrice, maxFeePerGas, maxPriorityFeePerGas, to } = args;
    const account = account_ ? parseAccount(account_) : void 0;
    if (account && !isAddress2(account.address))
      throw new InvalidAddressError({ address: account.address });
    if (to && !isAddress2(to))
      throw new InvalidAddressError({ address: to });
    if (typeof gasPrice !== "undefined" && (typeof maxFeePerGas !== "undefined" || typeof maxPriorityFeePerGas !== "undefined"))
      throw new FeeConflictError();
    if (maxFeePerGas && maxFeePerGas > maxUint256)
      throw new FeeCapTooHighError({ maxFeePerGas });
    if (maxPriorityFeePerGas && maxFeePerGas && maxPriorityFeePerGas > maxFeePerGas)
      throw new TipAboveFeeCapError({ maxFeePerGas, maxPriorityFeePerGas });
  }
  var init_assertRequest = __esm({
    "node_modules/viem/_esm/utils/transaction/assertRequest.js"() {
      init_parseAccount();
      init_number2();
      init_address5();
      init_node();
      init_transaction3();
      init_isAddress();
    }
  });

  // node_modules/viem/_esm/errors/fee.js
  var BaseFeeScalarError, Eip1559FeesNotSupportedError, MaxFeePerGasTooLowError;
  var init_fee = __esm({
    "node_modules/viem/_esm/errors/fee.js"() {
      init_formatGwei();
      init_base();
      BaseFeeScalarError = class extends BaseError2 {
        constructor() {
          super("`baseFeeMultiplier` must be greater than 1.", {
            name: "BaseFeeScalarError"
          });
        }
      };
      Eip1559FeesNotSupportedError = class extends BaseError2 {
        constructor() {
          super("Chain does not support EIP-1559 fees.", {
            name: "Eip1559FeesNotSupportedError"
          });
        }
      };
      MaxFeePerGasTooLowError = class extends BaseError2 {
        constructor({ maxPriorityFeePerGas }) {
          super(`\`maxFeePerGas\` cannot be less than the \`maxPriorityFeePerGas\` (${formatGwei(maxPriorityFeePerGas)} gwei).`, { name: "MaxFeePerGasTooLowError" });
        }
      };
    }
  });

  // node_modules/viem/_esm/errors/block.js
  var BlockNotFoundError;
  var init_block = __esm({
    "node_modules/viem/_esm/errors/block.js"() {
      init_base();
      BlockNotFoundError = class extends BaseError2 {
        constructor({ blockHash, blockNumber }) {
          let identifier = "Block";
          if (blockHash)
            identifier = `Block at hash "${blockHash}"`;
          if (blockNumber)
            identifier = `Block at number "${blockNumber}"`;
          super(`${identifier} could not be found.`, { name: "BlockNotFoundError" });
        }
      };
    }
  });

  // node_modules/viem/_esm/utils/formatters/transaction.js
  function formatTransaction(transaction) {
    const transaction_ = {
      ...transaction,
      blockHash: transaction.blockHash ? transaction.blockHash : null,
      blockNumber: transaction.blockNumber ? BigInt(transaction.blockNumber) : null,
      chainId: transaction.chainId ? hexToNumber2(transaction.chainId) : void 0,
      gas: transaction.gas ? BigInt(transaction.gas) : void 0,
      gasPrice: transaction.gasPrice ? BigInt(transaction.gasPrice) : void 0,
      maxFeePerBlobGas: transaction.maxFeePerBlobGas ? BigInt(transaction.maxFeePerBlobGas) : void 0,
      maxFeePerGas: transaction.maxFeePerGas ? BigInt(transaction.maxFeePerGas) : void 0,
      maxPriorityFeePerGas: transaction.maxPriorityFeePerGas ? BigInt(transaction.maxPriorityFeePerGas) : void 0,
      nonce: transaction.nonce ? hexToNumber2(transaction.nonce) : void 0,
      to: transaction.to ? transaction.to : null,
      transactionIndex: transaction.transactionIndex ? Number(transaction.transactionIndex) : null,
      type: transaction.type ? transactionType[transaction.type] : void 0,
      typeHex: transaction.type ? transaction.type : void 0,
      value: transaction.value ? BigInt(transaction.value) : void 0,
      v: transaction.v ? BigInt(transaction.v) : void 0
    };
    if (transaction.authorizationList)
      transaction_.authorizationList = formatAuthorizationList3(transaction.authorizationList);
    transaction_.yParity = (() => {
      if (transaction.yParity)
        return Number(transaction.yParity);
      if (typeof transaction_.v === "bigint") {
        if (transaction_.v === 0n || transaction_.v === 27n)
          return 0;
        if (transaction_.v === 1n || transaction_.v === 28n)
          return 1;
        if (transaction_.v >= 35n)
          return transaction_.v % 2n === 0n ? 1 : 0;
      }
      return void 0;
    })();
    if (transaction_.type === "legacy") {
      delete transaction_.accessList;
      delete transaction_.maxFeePerBlobGas;
      delete transaction_.maxFeePerGas;
      delete transaction_.maxPriorityFeePerGas;
      delete transaction_.yParity;
    }
    if (transaction_.type === "eip2930") {
      delete transaction_.maxFeePerBlobGas;
      delete transaction_.maxFeePerGas;
      delete transaction_.maxPriorityFeePerGas;
    }
    if (transaction_.type === "eip1559") {
      delete transaction_.maxFeePerBlobGas;
    }
    return transaction_;
  }
  function formatAuthorizationList3(authorizationList) {
    return authorizationList.map((authorization) => ({
      address: authorization.address,
      chainId: Number(authorization.chainId),
      nonce: Number(authorization.nonce),
      r: authorization.r,
      s: authorization.s,
      yParity: Number(authorization.yParity)
    }));
  }
  var transactionType, defineTransaction;
  var init_transaction4 = __esm({
    "node_modules/viem/_esm/utils/formatters/transaction.js"() {
      init_fromHex();
      init_formatter();
      transactionType = {
        "0x0": "legacy",
        "0x1": "eip2930",
        "0x2": "eip1559",
        "0x3": "eip4844",
        "0x4": "eip7702"
      };
      defineTransaction = /* @__PURE__ */ defineFormatter("transaction", formatTransaction);
    }
  });

  // node_modules/viem/_esm/utils/formatters/block.js
  function formatBlock2(block) {
    const transactions = (block.transactions ?? []).map((transaction) => {
      if (typeof transaction === "string")
        return transaction;
      return formatTransaction(transaction);
    });
    return {
      ...block,
      baseFeePerGas: block.baseFeePerGas ? BigInt(block.baseFeePerGas) : null,
      blobGasUsed: block.blobGasUsed ? BigInt(block.blobGasUsed) : void 0,
      difficulty: block.difficulty ? BigInt(block.difficulty) : void 0,
      excessBlobGas: block.excessBlobGas ? BigInt(block.excessBlobGas) : void 0,
      gasLimit: block.gasLimit ? BigInt(block.gasLimit) : void 0,
      gasUsed: block.gasUsed ? BigInt(block.gasUsed) : void 0,
      hash: block.hash ? block.hash : null,
      logsBloom: block.logsBloom ? block.logsBloom : null,
      nonce: block.nonce ? block.nonce : null,
      number: block.number ? BigInt(block.number) : null,
      size: block.size ? BigInt(block.size) : void 0,
      timestamp: block.timestamp ? BigInt(block.timestamp) : void 0,
      transactions,
      totalDifficulty: block.totalDifficulty ? BigInt(block.totalDifficulty) : null
    };
  }
  var defineBlock;
  var init_block2 = __esm({
    "node_modules/viem/_esm/utils/formatters/block.js"() {
      init_formatter();
      init_transaction4();
      defineBlock = /* @__PURE__ */ defineFormatter("block", formatBlock2);
    }
  });

  // node_modules/viem/_esm/actions/public/getBlock.js
  async function getBlock(client, { blockHash, blockNumber, blockTag: blockTag_, includeTransactions: includeTransactions_ } = {}) {
    const blockTag = blockTag_ ?? "latest";
    const includeTransactions = includeTransactions_ ?? false;
    const blockNumberHex = blockNumber !== void 0 ? numberToHex(blockNumber) : void 0;
    let block = null;
    if (blockHash) {
      block = await client.request({
        method: "eth_getBlockByHash",
        params: [blockHash, includeTransactions]
      }, { dedupe: true });
    } else {
      block = await client.request({
        method: "eth_getBlockByNumber",
        params: [blockNumberHex || blockTag, includeTransactions]
      }, { dedupe: Boolean(blockNumberHex) });
    }
    if (!block)
      throw new BlockNotFoundError({ blockHash, blockNumber });
    const format = client.chain?.formatters?.block?.format || formatBlock2;
    return format(block);
  }
  var init_getBlock = __esm({
    "node_modules/viem/_esm/actions/public/getBlock.js"() {
      init_block();
      init_toHex();
      init_block2();
    }
  });

  // node_modules/viem/_esm/actions/public/getGasPrice.js
  async function getGasPrice(client) {
    const gasPrice = await client.request({
      method: "eth_gasPrice"
    });
    return BigInt(gasPrice);
  }
  var init_getGasPrice = __esm({
    "node_modules/viem/_esm/actions/public/getGasPrice.js"() {
    }
  });

  // node_modules/viem/_esm/actions/public/estimateMaxPriorityFeePerGas.js
  async function estimateMaxPriorityFeePerGas(client, args) {
    return internal_estimateMaxPriorityFeePerGas(client, args);
  }
  async function internal_estimateMaxPriorityFeePerGas(client, args) {
    const { block: block_, chain = client.chain, request } = args || {};
    try {
      const maxPriorityFeePerGas = chain?.fees?.maxPriorityFeePerGas ?? chain?.fees?.defaultPriorityFee;
      if (typeof maxPriorityFeePerGas === "function") {
        const block = block_ || await getAction(client, getBlock, "getBlock")({});
        const maxPriorityFeePerGas_ = await maxPriorityFeePerGas({
          block,
          client,
          request
        });
        if (maxPriorityFeePerGas_ === null)
          throw new Error();
        return maxPriorityFeePerGas_;
      }
      if (typeof maxPriorityFeePerGas !== "undefined")
        return maxPriorityFeePerGas;
      const maxPriorityFeePerGasHex = await client.request({
        method: "eth_maxPriorityFeePerGas"
      });
      return hexToBigInt(maxPriorityFeePerGasHex);
    } catch {
      const [block, gasPrice] = await Promise.all([
        block_ ? Promise.resolve(block_) : getAction(client, getBlock, "getBlock")({}),
        getAction(client, getGasPrice, "getGasPrice")({})
      ]);
      if (typeof block.baseFeePerGas !== "bigint")
        throw new Eip1559FeesNotSupportedError();
      const maxPriorityFeePerGas = gasPrice - block.baseFeePerGas;
      if (maxPriorityFeePerGas < 0n)
        return 0n;
      return maxPriorityFeePerGas;
    }
  }
  var init_estimateMaxPriorityFeePerGas = __esm({
    "node_modules/viem/_esm/actions/public/estimateMaxPriorityFeePerGas.js"() {
      init_fee();
      init_fromHex();
      init_getAction();
      init_getBlock();
      init_getGasPrice();
    }
  });

  // node_modules/viem/_esm/actions/public/estimateFeesPerGas.js
  async function estimateFeesPerGas(client, args) {
    return internal_estimateFeesPerGas(client, args);
  }
  async function internal_estimateFeesPerGas(client, args) {
    const { block: block_, chain = client.chain, request, type = "eip1559" } = args || {};
    const baseFeeMultiplier = await (async () => {
      if (typeof chain?.fees?.baseFeeMultiplier === "function")
        return chain.fees.baseFeeMultiplier({
          block: block_,
          client,
          request
        });
      return chain?.fees?.baseFeeMultiplier ?? 1.2;
    })();
    if (baseFeeMultiplier < 1)
      throw new BaseFeeScalarError();
    const decimals = baseFeeMultiplier.toString().split(".")[1]?.length ?? 0;
    const denominator = 10 ** decimals;
    const multiply = (base) => base * BigInt(Math.ceil(baseFeeMultiplier * denominator)) / BigInt(denominator);
    const block = block_ ? block_ : await getAction(client, getBlock, "getBlock")({});
    if (typeof chain?.fees?.estimateFeesPerGas === "function") {
      const fees = await chain.fees.estimateFeesPerGas({
        block: block_,
        client,
        multiply,
        request,
        type
      });
      if (fees !== null)
        return fees;
    }
    if (type === "eip1559") {
      if (typeof block.baseFeePerGas !== "bigint")
        throw new Eip1559FeesNotSupportedError();
      const maxPriorityFeePerGas = typeof request?.maxPriorityFeePerGas === "bigint" ? request.maxPriorityFeePerGas : await internal_estimateMaxPriorityFeePerGas(client, {
        block,
        chain,
        request
      });
      const baseFeePerGas = multiply(block.baseFeePerGas);
      const maxFeePerGas = request?.maxFeePerGas ?? baseFeePerGas + maxPriorityFeePerGas;
      return {
        maxFeePerGas,
        maxPriorityFeePerGas
      };
    }
    const gasPrice = request?.gasPrice ?? multiply(await getAction(client, getGasPrice, "getGasPrice")({}));
    return {
      gasPrice
    };
  }
  var init_estimateFeesPerGas = __esm({
    "node_modules/viem/_esm/actions/public/estimateFeesPerGas.js"() {
      init_fee();
      init_getAction();
      init_estimateMaxPriorityFeePerGas();
      init_getBlock();
      init_getGasPrice();
    }
  });

  // node_modules/viem/_esm/actions/public/getTransactionCount.js
  async function getTransactionCount(client, { address, blockTag = "latest", blockNumber }) {
    const count = await client.request({
      method: "eth_getTransactionCount",
      params: [
        address,
        typeof blockNumber === "bigint" ? numberToHex(blockNumber) : blockTag
      ]
    }, {
      dedupe: Boolean(blockNumber)
    });
    return hexToNumber2(count);
  }
  var init_getTransactionCount = __esm({
    "node_modules/viem/_esm/actions/public/getTransactionCount.js"() {
      init_fromHex();
      init_toHex();
    }
  });

  // node_modules/viem/_esm/utils/blob/blobsToCommitments.js
  function blobsToCommitments(parameters) {
    const { kzg } = parameters;
    const to = parameters.to ?? (typeof parameters.blobs[0] === "string" ? "hex" : "bytes");
    const blobs = typeof parameters.blobs[0] === "string" ? parameters.blobs.map((x) => hexToBytes2(x)) : parameters.blobs;
    const commitments = [];
    for (const blob of blobs)
      commitments.push(Uint8Array.from(kzg.blobToKzgCommitment(blob)));
    return to === "bytes" ? commitments : commitments.map((x) => bytesToHex2(x));
  }
  var init_blobsToCommitments = __esm({
    "node_modules/viem/_esm/utils/blob/blobsToCommitments.js"() {
      init_toBytes();
      init_toHex();
    }
  });

  // node_modules/viem/_esm/utils/blob/blobsToProofs.js
  function blobsToProofs(parameters) {
    const { kzg } = parameters;
    const to = parameters.to ?? (typeof parameters.blobs[0] === "string" ? "hex" : "bytes");
    const blobs = typeof parameters.blobs[0] === "string" ? parameters.blobs.map((x) => hexToBytes2(x)) : parameters.blobs;
    const commitments = typeof parameters.commitments[0] === "string" ? parameters.commitments.map((x) => hexToBytes2(x)) : parameters.commitments;
    const proofs = [];
    for (let i = 0; i < blobs.length; i++) {
      const blob = blobs[i];
      const commitment = commitments[i];
      proofs.push(Uint8Array.from(kzg.computeBlobKzgProof(blob, commitment)));
    }
    return to === "bytes" ? proofs : proofs.map((x) => bytesToHex2(x));
  }
  var init_blobsToProofs = __esm({
    "node_modules/viem/_esm/utils/blob/blobsToProofs.js"() {
      init_toBytes();
      init_toHex();
    }
  });

  // node_modules/viem/node_modules/@noble/hashes/esm/sha256.js
  var sha2564;
  var init_sha2562 = __esm({
    "node_modules/viem/node_modules/@noble/hashes/esm/sha256.js"() {
      init_sha23();
      sha2564 = sha2563;
    }
  });

  // node_modules/viem/_esm/utils/hash/sha256.js
  function sha2565(value, to_) {
    const to = to_ || "hex";
    const bytes2 = sha2564(isHex(value, { strict: false }) ? toBytes2(value) : value);
    if (to === "bytes")
      return bytes2;
    return toHex(bytes2);
  }
  var init_sha2563 = __esm({
    "node_modules/viem/_esm/utils/hash/sha256.js"() {
      init_sha2562();
      init_isHex();
      init_toBytes();
      init_toHex();
    }
  });

  // node_modules/viem/_esm/utils/blob/commitmentToVersionedHash.js
  function commitmentToVersionedHash(parameters) {
    const { commitment, version: version5 = 1 } = parameters;
    const to = parameters.to ?? (typeof commitment === "string" ? "hex" : "bytes");
    const versionedHash = sha2565(commitment, "bytes");
    versionedHash.set([version5], 0);
    return to === "bytes" ? versionedHash : bytesToHex2(versionedHash);
  }
  var init_commitmentToVersionedHash = __esm({
    "node_modules/viem/_esm/utils/blob/commitmentToVersionedHash.js"() {
      init_toHex();
      init_sha2563();
    }
  });

  // node_modules/viem/_esm/utils/blob/commitmentsToVersionedHashes.js
  function commitmentsToVersionedHashes(parameters) {
    const { commitments, version: version5 } = parameters;
    const to = parameters.to ?? (typeof commitments[0] === "string" ? "hex" : "bytes");
    const hashes = [];
    for (const commitment of commitments) {
      hashes.push(commitmentToVersionedHash({
        commitment,
        to,
        version: version5
      }));
    }
    return hashes;
  }
  var init_commitmentsToVersionedHashes = __esm({
    "node_modules/viem/_esm/utils/blob/commitmentsToVersionedHashes.js"() {
      init_commitmentToVersionedHash();
    }
  });

  // node_modules/viem/_esm/constants/blob.js
  var blobsPerTransaction, bytesPerFieldElement, fieldElementsPerBlob, bytesPerBlob, maxBytesPerTransaction;
  var init_blob = __esm({
    "node_modules/viem/_esm/constants/blob.js"() {
      blobsPerTransaction = 6;
      bytesPerFieldElement = 32;
      fieldElementsPerBlob = 4096;
      bytesPerBlob = bytesPerFieldElement * fieldElementsPerBlob;
      maxBytesPerTransaction = bytesPerBlob * blobsPerTransaction - // terminator byte (0x80).
      1 - // zero byte (0x00) appended to each field element.
      1 * fieldElementsPerBlob * blobsPerTransaction;
    }
  });

  // node_modules/viem/_esm/constants/kzg.js
  var versionedHashVersionKzg;
  var init_kzg = __esm({
    "node_modules/viem/_esm/constants/kzg.js"() {
      versionedHashVersionKzg = 1;
    }
  });

  // node_modules/viem/_esm/errors/blob.js
  var BlobSizeTooLargeError, EmptyBlobError, InvalidVersionedHashSizeError, InvalidVersionedHashVersionError;
  var init_blob2 = __esm({
    "node_modules/viem/_esm/errors/blob.js"() {
      init_kzg();
      init_base();
      BlobSizeTooLargeError = class extends BaseError2 {
        constructor({ maxSize, size: size5 }) {
          super("Blob size is too large.", {
            metaMessages: [`Max: ${maxSize} bytes`, `Given: ${size5} bytes`],
            name: "BlobSizeTooLargeError"
          });
        }
      };
      EmptyBlobError = class extends BaseError2 {
        constructor() {
          super("Blob data must not be empty.", { name: "EmptyBlobError" });
        }
      };
      InvalidVersionedHashSizeError = class extends BaseError2 {
        constructor({ hash: hash3, size: size5 }) {
          super(`Versioned hash "${hash3}" size is invalid.`, {
            metaMessages: ["Expected: 32", `Received: ${size5}`],
            name: "InvalidVersionedHashSizeError"
          });
        }
      };
      InvalidVersionedHashVersionError = class extends BaseError2 {
        constructor({ hash: hash3, version: version5 }) {
          super(`Versioned hash "${hash3}" version is invalid.`, {
            metaMessages: [
              `Expected: ${versionedHashVersionKzg}`,
              `Received: ${version5}`
            ],
            name: "InvalidVersionedHashVersionError"
          });
        }
      };
    }
  });

  // node_modules/viem/_esm/utils/blob/toBlobs.js
  function toBlobs(parameters) {
    const to = parameters.to ?? (typeof parameters.data === "string" ? "hex" : "bytes");
    const data = typeof parameters.data === "string" ? hexToBytes2(parameters.data) : parameters.data;
    const size_ = size(data);
    if (!size_)
      throw new EmptyBlobError();
    if (size_ > maxBytesPerTransaction)
      throw new BlobSizeTooLargeError({
        maxSize: maxBytesPerTransaction,
        size: size_
      });
    const blobs = [];
    let active = true;
    let position = 0;
    while (active) {
      const blob = createCursor(new Uint8Array(bytesPerBlob));
      let size5 = 0;
      while (size5 < fieldElementsPerBlob) {
        const bytes2 = data.slice(position, position + (bytesPerFieldElement - 1));
        blob.pushByte(0);
        blob.pushBytes(bytes2);
        if (bytes2.length < 31) {
          blob.pushByte(128);
          active = false;
          break;
        }
        size5++;
        position += 31;
      }
      blobs.push(blob);
    }
    return to === "bytes" ? blobs.map((x) => x.bytes) : blobs.map((x) => bytesToHex2(x.bytes));
  }
  var init_toBlobs = __esm({
    "node_modules/viem/_esm/utils/blob/toBlobs.js"() {
      init_blob();
      init_blob2();
      init_cursor2();
      init_size();
      init_toBytes();
      init_toHex();
    }
  });

  // node_modules/viem/_esm/utils/blob/toBlobSidecars.js
  function toBlobSidecars(parameters) {
    const { data, kzg, to } = parameters;
    const blobs = parameters.blobs ?? toBlobs({ data, to });
    const commitments = parameters.commitments ?? blobsToCommitments({ blobs, kzg, to });
    const proofs = parameters.proofs ?? blobsToProofs({ blobs, commitments, kzg, to });
    const sidecars = [];
    for (let i = 0; i < blobs.length; i++)
      sidecars.push({
        blob: blobs[i],
        commitment: commitments[i],
        proof: proofs[i]
      });
    return sidecars;
  }
  var init_toBlobSidecars = __esm({
    "node_modules/viem/_esm/utils/blob/toBlobSidecars.js"() {
      init_blobsToCommitments();
      init_blobsToProofs();
      init_toBlobs();
    }
  });

  // node_modules/viem/_esm/utils/transaction/getTransactionType.js
  function getTransactionType(transaction) {
    if (transaction.type)
      return transaction.type;
    if (typeof transaction.authorizationList !== "undefined")
      return "eip7702";
    if (typeof transaction.blobs !== "undefined" || typeof transaction.blobVersionedHashes !== "undefined" || typeof transaction.maxFeePerBlobGas !== "undefined" || typeof transaction.sidecars !== "undefined")
      return "eip4844";
    if (typeof transaction.maxFeePerGas !== "undefined" || typeof transaction.maxPriorityFeePerGas !== "undefined") {
      return "eip1559";
    }
    if (typeof transaction.gasPrice !== "undefined") {
      if (typeof transaction.accessList !== "undefined")
        return "eip2930";
      return "legacy";
    }
    throw new InvalidSerializableTransactionError({ transaction });
  }
  var init_getTransactionType = __esm({
    "node_modules/viem/_esm/utils/transaction/getTransactionType.js"() {
      init_transaction3();
    }
  });

  // node_modules/viem/_esm/actions/public/getChainId.js
  async function getChainId(client) {
    const chainIdHex = await client.request({
      method: "eth_chainId"
    }, { dedupe: true });
    return hexToNumber2(chainIdHex);
  }
  var init_getChainId = __esm({
    "node_modules/viem/_esm/actions/public/getChainId.js"() {
      init_fromHex();
    }
  });

  // node_modules/viem/_esm/actions/wallet/prepareTransactionRequest.js
  async function prepareTransactionRequest(client, args) {
    const { account: account_ = client.account, blobs, chain, gas, kzg, nonce, nonceManager: nonceManager2, parameters = defaultParameters, type } = args;
    const account = account_ ? parseAccount(account_) : account_;
    const request = { ...args, ...account ? { from: account?.address } : {} };
    let block;
    async function getBlock2() {
      if (block)
        return block;
      block = await getAction(client, getBlock, "getBlock")({ blockTag: "latest" });
      return block;
    }
    let chainId;
    async function getChainId2() {
      if (chainId)
        return chainId;
      if (chain)
        return chain.id;
      if (typeof args.chainId !== "undefined")
        return args.chainId;
      const chainId_ = await getAction(client, getChainId, "getChainId")({});
      chainId = chainId_;
      return chainId;
    }
    if (parameters.includes("nonce") && typeof nonce === "undefined" && account) {
      if (nonceManager2) {
        const chainId2 = await getChainId2();
        request.nonce = await nonceManager2.consume({
          address: account.address,
          chainId: chainId2,
          client
        });
      } else {
        request.nonce = await getAction(client, getTransactionCount, "getTransactionCount")({
          address: account.address,
          blockTag: "pending"
        });
      }
    }
    if ((parameters.includes("blobVersionedHashes") || parameters.includes("sidecars")) && blobs && kzg) {
      const commitments = blobsToCommitments({ blobs, kzg });
      if (parameters.includes("blobVersionedHashes")) {
        const versionedHashes = commitmentsToVersionedHashes({
          commitments,
          to: "hex"
        });
        request.blobVersionedHashes = versionedHashes;
      }
      if (parameters.includes("sidecars")) {
        const proofs = blobsToProofs({ blobs, commitments, kzg });
        const sidecars = toBlobSidecars({
          blobs,
          commitments,
          proofs,
          to: "hex"
        });
        request.sidecars = sidecars;
      }
    }
    if (parameters.includes("chainId"))
      request.chainId = await getChainId2();
    if ((parameters.includes("fees") || parameters.includes("type")) && typeof type === "undefined") {
      try {
        request.type = getTransactionType(request);
      } catch {
        let isEip1559Network = eip1559NetworkCache.get(client.uid);
        if (typeof isEip1559Network === "undefined") {
          const block2 = await getBlock2();
          isEip1559Network = typeof block2?.baseFeePerGas === "bigint";
          eip1559NetworkCache.set(client.uid, isEip1559Network);
        }
        request.type = isEip1559Network ? "eip1559" : "legacy";
      }
    }
    if (parameters.includes("fees")) {
      if (request.type !== "legacy" && request.type !== "eip2930") {
        if (typeof request.maxFeePerGas === "undefined" || typeof request.maxPriorityFeePerGas === "undefined") {
          const block2 = await getBlock2();
          const { maxFeePerGas, maxPriorityFeePerGas } = await internal_estimateFeesPerGas(client, {
            block: block2,
            chain,
            request
          });
          if (typeof args.maxPriorityFeePerGas === "undefined" && args.maxFeePerGas && args.maxFeePerGas < maxPriorityFeePerGas)
            throw new MaxFeePerGasTooLowError({
              maxPriorityFeePerGas
            });
          request.maxPriorityFeePerGas = maxPriorityFeePerGas;
          request.maxFeePerGas = maxFeePerGas;
        }
      } else {
        if (typeof args.maxFeePerGas !== "undefined" || typeof args.maxPriorityFeePerGas !== "undefined")
          throw new Eip1559FeesNotSupportedError();
        if (typeof args.gasPrice === "undefined") {
          const block2 = await getBlock2();
          const { gasPrice: gasPrice_ } = await internal_estimateFeesPerGas(client, {
            block: block2,
            chain,
            request,
            type: "legacy"
          });
          request.gasPrice = gasPrice_;
        }
      }
    }
    if (parameters.includes("gas") && typeof gas === "undefined")
      request.gas = await getAction(client, estimateGas, "estimateGas")({
        ...request,
        account: account ? { address: account.address, type: "json-rpc" } : account
      });
    assertRequest(request);
    delete request.parameters;
    return request;
  }
  var defaultParameters, eip1559NetworkCache;
  var init_prepareTransactionRequest = __esm({
    "node_modules/viem/_esm/actions/wallet/prepareTransactionRequest.js"() {
      init_parseAccount();
      init_estimateFeesPerGas();
      init_estimateGas2();
      init_getBlock();
      init_getTransactionCount();
      init_fee();
      init_blobsToCommitments();
      init_blobsToProofs();
      init_commitmentsToVersionedHashes();
      init_toBlobSidecars();
      init_getAction();
      init_assertRequest();
      init_getTransactionType();
      init_getChainId();
      defaultParameters = [
        "blobVersionedHashes",
        "chainId",
        "fees",
        "gas",
        "nonce",
        "type"
      ];
      eip1559NetworkCache = /* @__PURE__ */ new Map();
    }
  });

  // node_modules/viem/_esm/actions/public/getBalance.js
  async function getBalance(client, { address, blockNumber, blockTag = "latest" }) {
    const blockNumberHex = typeof blockNumber === "bigint" ? numberToHex(blockNumber) : void 0;
    const balance = await client.request({
      method: "eth_getBalance",
      params: [address, blockNumberHex || blockTag]
    });
    return BigInt(balance);
  }
  var init_getBalance = __esm({
    "node_modules/viem/_esm/actions/public/getBalance.js"() {
      init_toHex();
    }
  });

  // node_modules/viem/_esm/actions/public/estimateGas.js
  async function estimateGas(client, args) {
    const { account: account_ = client.account } = args;
    const account = account_ ? parseAccount(account_) : void 0;
    try {
      let estimateGas_rpc = function(parameters) {
        const { block: block2, request: request2, rpcStateOverride: rpcStateOverride2 } = parameters;
        return client.request({
          method: "eth_estimateGas",
          params: rpcStateOverride2 ? [request2, block2 ?? "latest", rpcStateOverride2] : block2 ? [request2, block2] : [request2]
        });
      };
      const { accessList, authorizationList, blobs, blobVersionedHashes, blockNumber, blockTag, data, gas, gasPrice, maxFeePerBlobGas, maxFeePerGas, maxPriorityFeePerGas, nonce, value, stateOverride, ...rest } = await prepareTransactionRequest(client, {
        ...args,
        parameters: (
          // Some RPC Providers do not compute versioned hashes from blobs. We will need
          // to compute them.
          account?.type === "local" ? void 0 : ["blobVersionedHashes"]
        )
      });
      const blockNumberHex = typeof blockNumber === "bigint" ? numberToHex(blockNumber) : void 0;
      const block = blockNumberHex || blockTag;
      const rpcStateOverride = serializeStateOverride(stateOverride);
      const to = await (async () => {
        if (rest.to)
          return rest.to;
        if (authorizationList && authorizationList.length > 0)
          return await recoverAuthorizationAddress({
            authorization: authorizationList[0]
          }).catch(() => {
            throw new BaseError2("`to` is required. Could not infer from `authorizationList`");
          });
        return void 0;
      })();
      assertRequest(args);
      const chainFormat = client.chain?.formatters?.transactionRequest?.format;
      const format = chainFormat || formatTransactionRequest;
      const request = format({
        // Pick out extra data that might exist on the chain's transaction request type.
        ...extract(rest, { format: chainFormat }),
        from: account?.address,
        accessList,
        authorizationList,
        blobs,
        blobVersionedHashes,
        data,
        gas,
        gasPrice,
        maxFeePerBlobGas,
        maxFeePerGas,
        maxPriorityFeePerGas,
        nonce,
        to,
        value
      });
      let estimate = BigInt(await estimateGas_rpc({ block, request, rpcStateOverride }));
      if (authorizationList) {
        const value2 = await getBalance(client, { address: request.from });
        const estimates = await Promise.all(authorizationList.map(async (authorization) => {
          const { address } = authorization;
          const estimate2 = await estimateGas_rpc({
            block,
            request: {
              authorizationList: void 0,
              data,
              from: account?.address,
              to: address,
              value: numberToHex(value2)
            },
            rpcStateOverride
          }).catch(() => 100000n);
          return 2n * BigInt(estimate2);
        }));
        estimate += estimates.reduce((acc, curr) => acc + curr, 0n);
      }
      return estimate;
    } catch (err) {
      throw getEstimateGasError(err, {
        ...args,
        account,
        chain: client.chain
      });
    }
  }
  var init_estimateGas2 = __esm({
    "node_modules/viem/_esm/actions/public/estimateGas.js"() {
      init_parseAccount();
      init_base();
      init_recoverAuthorizationAddress();
      init_toHex();
      init_getEstimateGasError();
      init_extract();
      init_transactionRequest();
      init_stateOverride2();
      init_assertRequest();
      init_prepareTransactionRequest();
      init_getBalance();
    }
  });

  // node_modules/viem/_esm/actions/public/estimateContractGas.js
  async function estimateContractGas(client, parameters) {
    const { abi: abi2, address, args, functionName, dataSuffix, ...request } = parameters;
    const data = encodeFunctionData({
      abi: abi2,
      args,
      functionName
    });
    try {
      const gas = await getAction(client, estimateGas, "estimateGas")({
        data: `${data}${dataSuffix ? dataSuffix.replace("0x", "") : ""}`,
        to: address,
        ...request
      });
      return gas;
    } catch (error) {
      const account = request.account ? parseAccount(request.account) : void 0;
      throw getContractError(error, {
        abi: abi2,
        address,
        args,
        docsPath: "/docs/contract/estimateContractGas",
        functionName,
        sender: account?.address
      });
    }
  }
  var init_estimateContractGas = __esm({
    "node_modules/viem/_esm/actions/public/estimateContractGas.js"() {
      init_parseAccount();
      init_encodeFunctionData();
      init_getContractError();
      init_getAction();
      init_estimateGas2();
    }
  });

  // node_modules/viem/_esm/utils/address/isAddressEqual.js
  function isAddressEqual(a, b2) {
    if (!isAddress2(a, { strict: false }))
      throw new InvalidAddressError({ address: a });
    if (!isAddress2(b2, { strict: false }))
      throw new InvalidAddressError({ address: b2 });
    return a.toLowerCase() === b2.toLowerCase();
  }
  var init_isAddressEqual = __esm({
    "node_modules/viem/_esm/utils/address/isAddressEqual.js"() {
      init_address5();
      init_isAddress();
    }
  });

  // node_modules/viem/_esm/utils/abi/decodeEventLog.js
  function decodeEventLog(parameters) {
    const { abi: abi2, data, strict: strict_, topics } = parameters;
    const strict = strict_ ?? true;
    const [signature, ...argTopics] = topics;
    if (!signature)
      throw new AbiEventSignatureEmptyTopicsError({ docsPath: docsPath3 });
    const abiItem = abi2.find((x) => x.type === "event" && signature === toEventSelector(formatAbiItem2(x)));
    if (!(abiItem && "name" in abiItem) || abiItem.type !== "event")
      throw new AbiEventSignatureNotFoundError(signature, { docsPath: docsPath3 });
    const { name, inputs } = abiItem;
    const isUnnamed = inputs?.some((x) => !("name" in x && x.name));
    const args = isUnnamed ? [] : {};
    const indexedInputs = inputs.map((x, i) => [x, i]).filter(([x]) => "indexed" in x && x.indexed);
    for (let i = 0; i < indexedInputs.length; i++) {
      const [param, argIndex] = indexedInputs[i];
      const topic = argTopics[i];
      if (!topic)
        throw new DecodeLogTopicsMismatch({
          abiItem,
          param
        });
      args[isUnnamed ? argIndex : param.name || argIndex] = decodeTopic({
        param,
        value: topic
      });
    }
    const nonIndexedInputs = inputs.filter((x) => !("indexed" in x && x.indexed));
    if (nonIndexedInputs.length > 0) {
      if (data && data !== "0x") {
        try {
          const decodedData = decodeAbiParameters(nonIndexedInputs, data);
          if (decodedData) {
            if (isUnnamed)
              for (let i = 0; i < inputs.length; i++)
                args[i] = args[i] ?? decodedData.shift();
            else
              for (let i = 0; i < nonIndexedInputs.length; i++)
                args[nonIndexedInputs[i].name] = decodedData[i];
          }
        } catch (err) {
          if (strict) {
            if (err instanceof AbiDecodingDataSizeTooSmallError || err instanceof PositionOutOfBoundsError)
              throw new DecodeLogDataMismatch({
                abiItem,
                data,
                params: nonIndexedInputs,
                size: size(data)
              });
            throw err;
          }
        }
      } else if (strict) {
        throw new DecodeLogDataMismatch({
          abiItem,
          data: "0x",
          params: nonIndexedInputs,
          size: 0
        });
      }
    }
    return {
      eventName: name,
      args: Object.values(args).length > 0 ? args : void 0
    };
  }
  function decodeTopic({ param, value }) {
    if (param.type === "string" || param.type === "bytes" || param.type === "tuple" || param.type.match(/^(.*)\[(\d+)?\]$/))
      return value;
    const decodedArg = decodeAbiParameters([param], value) || [];
    return decodedArg[0];
  }
  var docsPath3;
  var init_decodeEventLog = __esm({
    "node_modules/viem/_esm/utils/abi/decodeEventLog.js"() {
      init_abi2();
      init_size();
      init_toEventSelector();
      init_cursor();
      init_decodeAbiParameters();
      init_formatAbiItem2();
      docsPath3 = "/docs/contract/decodeEventLog";
    }
  });

  // node_modules/viem/_esm/utils/abi/parseEventLogs.js
  function parseEventLogs(parameters) {
    const { abi: abi2, args, logs, strict = true } = parameters;
    const eventName = (() => {
      if (!parameters.eventName)
        return void 0;
      if (Array.isArray(parameters.eventName))
        return parameters.eventName;
      return [parameters.eventName];
    })();
    return logs.map((log) => {
      try {
        const abiItem = abi2.find((abiItem2) => abiItem2.type === "event" && log.topics[0] === toEventSelector(abiItem2));
        if (!abiItem)
          return null;
        const event = decodeEventLog({
          ...log,
          abi: [abiItem],
          strict
        });
        if (eventName && !eventName.includes(event.eventName))
          return null;
        if (!includesArgs({
          args: event.args,
          inputs: abiItem.inputs,
          matchArgs: args
        }))
          return null;
        return { ...event, ...log };
      } catch (err) {
        let eventName2;
        let isUnnamed;
        if (err instanceof AbiEventSignatureNotFoundError)
          return null;
        if (err instanceof DecodeLogDataMismatch || err instanceof DecodeLogTopicsMismatch) {
          if (strict)
            return null;
          eventName2 = err.abiItem.name;
          isUnnamed = err.abiItem.inputs?.some((x) => !("name" in x && x.name));
        }
        return { ...log, args: isUnnamed ? [] : {}, eventName: eventName2 };
      }
    }).filter(Boolean);
  }
  function includesArgs(parameters) {
    const { args, inputs, matchArgs } = parameters;
    if (!matchArgs)
      return true;
    if (!args)
      return false;
    function isEqual(input, value, arg) {
      try {
        if (input.type === "address")
          return isAddressEqual(value, arg);
        if (input.type === "string" || input.type === "bytes")
          return keccak2562(toBytes2(value)) === arg;
        return value === arg;
      } catch {
        return false;
      }
    }
    if (Array.isArray(args) && Array.isArray(matchArgs)) {
      return matchArgs.every((value, index2) => {
        if (value === null || value === void 0)
          return true;
        const input = inputs[index2];
        if (!input)
          return false;
        const value_ = Array.isArray(value) ? value : [value];
        return value_.some((value2) => isEqual(input, value2, args[index2]));
      });
    }
    if (typeof args === "object" && !Array.isArray(args) && typeof matchArgs === "object" && !Array.isArray(matchArgs))
      return Object.entries(matchArgs).every(([key, value]) => {
        if (value === null || value === void 0)
          return true;
        const input = inputs.find((input2) => input2.name === key);
        if (!input)
          return false;
        const value_ = Array.isArray(value) ? value : [value];
        return value_.some((value2) => isEqual(input, value2, args[key]));
      });
    return false;
  }
  var init_parseEventLogs = __esm({
    "node_modules/viem/_esm/utils/abi/parseEventLogs.js"() {
      init_abi2();
      init_isAddressEqual();
      init_toBytes();
      init_keccak256();
      init_toEventSelector();
      init_decodeEventLog();
    }
  });

  // node_modules/viem/_esm/utils/formatters/log.js
  function formatLog2(log, { args, eventName } = {}) {
    return {
      ...log,
      blockHash: log.blockHash ? log.blockHash : null,
      blockNumber: log.blockNumber ? BigInt(log.blockNumber) : null,
      logIndex: log.logIndex ? Number(log.logIndex) : null,
      transactionHash: log.transactionHash ? log.transactionHash : null,
      transactionIndex: log.transactionIndex ? Number(log.transactionIndex) : null,
      ...eventName ? { args, eventName } : {}
    };
  }
  var init_log2 = __esm({
    "node_modules/viem/_esm/utils/formatters/log.js"() {
    }
  });

  // node_modules/viem/_esm/actions/public/getLogs.js
  async function getLogs(client, { address, blockHash, fromBlock, toBlock, event, events: events_, args, strict: strict_ } = {}) {
    const strict = strict_ ?? false;
    const events = events_ ?? (event ? [event] : void 0);
    let topics = [];
    if (events) {
      const encoded = events.flatMap((event2) => encodeEventTopics({
        abi: [event2],
        eventName: event2.name,
        args: events_ ? void 0 : args
      }));
      topics = [encoded];
      if (event)
        topics = topics[0];
    }
    let logs;
    if (blockHash) {
      logs = await client.request({
        method: "eth_getLogs",
        params: [{ address, topics, blockHash }]
      });
    } else {
      logs = await client.request({
        method: "eth_getLogs",
        params: [
          {
            address,
            topics,
            fromBlock: typeof fromBlock === "bigint" ? numberToHex(fromBlock) : fromBlock,
            toBlock: typeof toBlock === "bigint" ? numberToHex(toBlock) : toBlock
          }
        ]
      });
    }
    const formattedLogs = logs.map((log) => formatLog2(log));
    if (!events)
      return formattedLogs;
    return parseEventLogs({
      abi: events,
      args,
      logs: formattedLogs,
      strict
    });
  }
  var init_getLogs = __esm({
    "node_modules/viem/_esm/actions/public/getLogs.js"() {
      init_encodeEventTopics();
      init_parseEventLogs();
      init_toHex();
      init_log2();
    }
  });

  // node_modules/viem/_esm/actions/public/getContractEvents.js
  async function getContractEvents(client, parameters) {
    const { abi: abi2, address, args, blockHash, eventName, fromBlock, toBlock, strict } = parameters;
    const event = eventName ? getAbiItem({ abi: abi2, name: eventName }) : void 0;
    const events = !event ? abi2.filter((x) => x.type === "event") : void 0;
    return getAction(client, getLogs, "getLogs")({
      address,
      args,
      blockHash,
      event,
      events,
      fromBlock,
      toBlock,
      strict
    });
  }
  var init_getContractEvents = __esm({
    "node_modules/viem/_esm/actions/public/getContractEvents.js"() {
      init_getAbiItem();
      init_getAction();
      init_getLogs();
    }
  });

  // node_modules/viem/_esm/utils/abi/decodeFunctionResult.js
  function decodeFunctionResult(parameters) {
    const { abi: abi2, args, functionName, data } = parameters;
    let abiItem = abi2[0];
    if (functionName) {
      const item = getAbiItem({ abi: abi2, args, name: functionName });
      if (!item)
        throw new AbiFunctionNotFoundError(functionName, { docsPath: docsPath4 });
      abiItem = item;
    }
    if (abiItem.type !== "function")
      throw new AbiFunctionNotFoundError(void 0, { docsPath: docsPath4 });
    if (!abiItem.outputs)
      throw new AbiFunctionOutputsNotFoundError(abiItem.name, { docsPath: docsPath4 });
    const values = decodeAbiParameters(abiItem.outputs, data);
    if (values && values.length > 1)
      return values;
    if (values && values.length === 1)
      return values[0];
    return void 0;
  }
  var docsPath4;
  var init_decodeFunctionResult = __esm({
    "node_modules/viem/_esm/utils/abi/decodeFunctionResult.js"() {
      init_abi2();
      init_decodeAbiParameters();
      init_getAbiItem();
      docsPath4 = "/docs/contract/decodeFunctionResult";
    }
  });

  // node_modules/ox/node_modules/@noble/hashes/esm/utils.js
  function isBytes2(a) {
    return a instanceof Uint8Array || ArrayBuffer.isView(a) && a.constructor.name === "Uint8Array";
  }
  function anumber2(n2) {
    if (!Number.isSafeInteger(n2) || n2 < 0)
      throw new Error("positive integer expected, got " + n2);
  }
  function abytes2(b2, ...lengths) {
    if (!isBytes2(b2))
      throw new Error("Uint8Array expected");
    if (lengths.length > 0 && !lengths.includes(b2.length))
      throw new Error("Uint8Array expected of length " + lengths + ", got length=" + b2.length);
  }
  function aexists2(instance, checkFinished = true) {
    if (instance.destroyed)
      throw new Error("Hash instance has been destroyed");
    if (checkFinished && instance.finished)
      throw new Error("Hash#digest() has already been called");
  }
  function aoutput2(out, instance) {
    abytes2(out);
    const min = instance.outputLen;
    if (out.length < min) {
      throw new Error("digestInto() expects output buffer of length at least " + min);
    }
  }
  function u323(arr) {
    return new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
  }
  function clean2(...arrays) {
    for (let i = 0; i < arrays.length; i++) {
      arrays[i].fill(0);
    }
  }
  function byteSwap2(word) {
    return word << 24 & 4278190080 | word << 8 & 16711680 | word >>> 8 & 65280 | word >>> 24 & 255;
  }
  function byteSwap322(arr) {
    for (let i = 0; i < arr.length; i++) {
      arr[i] = byteSwap2(arr[i]);
    }
    return arr;
  }
  function utf8ToBytes4(str) {
    if (typeof str !== "string")
      throw new Error("string expected");
    return new Uint8Array(new TextEncoder().encode(str));
  }
  function toBytes4(data) {
    if (typeof data === "string")
      data = utf8ToBytes4(data);
    abytes2(data);
    return data;
  }
  function createHasher3(hashCons) {
    const hashC = (msg) => hashCons().update(toBytes4(msg)).digest();
    const tmp = hashCons();
    hashC.outputLen = tmp.outputLen;
    hashC.blockLen = tmp.blockLen;
    hashC.create = () => hashCons();
    return hashC;
  }
  var isLE3, swap32IfBE2, Hash3;
  var init_utils9 = __esm({
    "node_modules/ox/node_modules/@noble/hashes/esm/utils.js"() {
      isLE3 = /* @__PURE__ */ (() => new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68)();
      swap32IfBE2 = isLE3 ? (u) => u : byteSwap322;
      Hash3 = class {
      };
    }
  });

  // node_modules/ox/_esm/core/version.js
  var version4;
  var init_version4 = __esm({
    "node_modules/ox/_esm/core/version.js"() {
      version4 = "0.1.1";
    }
  });

  // node_modules/ox/_esm/core/internal/errors.js
  function getVersion() {
    return version4;
  }
  var init_errors3 = __esm({
    "node_modules/ox/_esm/core/internal/errors.js"() {
      init_version4();
    }
  });

  // node_modules/ox/_esm/core/Errors.js
  function walk2(err, fn) {
    if (fn?.(err))
      return err;
    if (err && typeof err === "object" && "cause" in err && err.cause)
      return walk2(err.cause, fn);
    return fn ? null : err;
  }
  var BaseError3;
  var init_Errors = __esm({
    "node_modules/ox/_esm/core/Errors.js"() {
      init_errors3();
      BaseError3 = class _BaseError extends Error {
        constructor(shortMessage, options = {}) {
          const details = (() => {
            if (options.cause instanceof _BaseError) {
              if (options.cause.details)
                return options.cause.details;
              if (options.cause.shortMessage)
                return options.cause.shortMessage;
            }
            if (options.cause && "details" in options.cause && typeof options.cause.details === "string")
              return options.cause.details;
            if (options.cause?.message)
              return options.cause.message;
            return options.details;
          })();
          const docsPath8 = (() => {
            if (options.cause instanceof _BaseError)
              return options.cause.docsPath || options.docsPath;
            return options.docsPath;
          })();
          const docsBaseUrl = "https://oxlib.sh";
          const docs = `${docsBaseUrl}${docsPath8 ?? ""}`;
          const message = [
            shortMessage || "An error occurred.",
            ...options.metaMessages ? ["", ...options.metaMessages] : [],
            ...details || docsPath8 ? [
              "",
              details ? `Details: ${details}` : void 0,
              docsPath8 ? `See: ${docs}` : void 0
            ] : []
          ].filter((x) => typeof x === "string").join("\n");
          super(message, options.cause ? { cause: options.cause } : void 0);
          Object.defineProperty(this, "details", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
          });
          Object.defineProperty(this, "docs", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
          });
          Object.defineProperty(this, "docsPath", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
          });
          Object.defineProperty(this, "shortMessage", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
          });
          Object.defineProperty(this, "cause", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
          });
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "BaseError"
          });
          Object.defineProperty(this, "version", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: `ox@${getVersion()}`
          });
          this.cause = options.cause;
          this.details = details;
          this.docs = docs;
          this.docsPath = docsPath8;
          this.shortMessage = shortMessage;
        }
        walk(fn) {
          return walk2(this, fn);
        }
      };
    }
  });

  // node_modules/ox/_esm/core/Json.js
  function stringify4(value, replacer, space) {
    return JSON.stringify(value, (key, value2) => {
      if (typeof replacer === "function")
        return replacer(key, value2);
      if (typeof value2 === "bigint")
        return value2.toString() + bigIntSuffix;
      return value2;
    }, space);
  }
  var bigIntSuffix;
  var init_Json = __esm({
    "node_modules/ox/_esm/core/Json.js"() {
      bigIntSuffix = "#__bigint";
    }
  });

  // node_modules/ox/_esm/core/internal/bytes.js
  function assertSize2(bytes2, size_) {
    if (size2(bytes2) > size_)
      throw new SizeOverflowError2({
        givenSize: size2(bytes2),
        maxSize: size_
      });
  }
  function charCodeToBase162(char) {
    if (char >= charCodeMap2.zero && char <= charCodeMap2.nine)
      return char - charCodeMap2.zero;
    if (char >= charCodeMap2.A && char <= charCodeMap2.F)
      return char - (charCodeMap2.A - 10);
    if (char >= charCodeMap2.a && char <= charCodeMap2.f)
      return char - (charCodeMap2.a - 10);
    return void 0;
  }
  function pad2(bytes2, options = {}) {
    const { dir, size: size5 = 32 } = options;
    if (size5 === 0)
      return bytes2;
    if (bytes2.length > size5)
      throw new SizeExceedsPaddingSizeError2({
        size: bytes2.length,
        targetSize: size5,
        type: "Bytes"
      });
    const paddedBytes = new Uint8Array(size5);
    for (let i = 0; i < size5; i++) {
      const padEnd = dir === "right";
      paddedBytes[padEnd ? i : size5 - i - 1] = bytes2[padEnd ? i : bytes2.length - i - 1];
    }
    return paddedBytes;
  }
  var charCodeMap2;
  var init_bytes2 = __esm({
    "node_modules/ox/_esm/core/internal/bytes.js"() {
      init_Bytes();
      charCodeMap2 = {
        zero: 48,
        nine: 57,
        A: 65,
        F: 70,
        a: 97,
        f: 102
      };
    }
  });

  // node_modules/ox/_esm/core/internal/hex.js
  function assertSize3(hex, size_) {
    if (size3(hex) > size_)
      throw new SizeOverflowError3({
        givenSize: size3(hex),
        maxSize: size_
      });
  }
  function assertStartOffset2(value, start) {
    if (typeof start === "number" && start > 0 && start > size3(value) - 1)
      throw new SliceOffsetOutOfBoundsError3({
        offset: start,
        position: "start",
        size: size3(value)
      });
  }
  function assertEndOffset2(value, start, end) {
    if (typeof start === "number" && typeof end === "number" && size3(value) !== end - start) {
      throw new SliceOffsetOutOfBoundsError3({
        offset: end,
        position: "end",
        size: size3(value)
      });
    }
  }
  function pad3(hex_, options = {}) {
    const { dir, size: size5 = 32 } = options;
    if (size5 === 0)
      return hex_;
    const hex = hex_.replace("0x", "");
    if (hex.length > size5 * 2)
      throw new SizeExceedsPaddingSizeError3({
        size: Math.ceil(hex.length / 2),
        targetSize: size5,
        type: "Hex"
      });
    return `0x${hex[dir === "right" ? "padEnd" : "padStart"](size5 * 2, "0")}`;
  }
  var init_hex = __esm({
    "node_modules/ox/_esm/core/internal/hex.js"() {
      init_Hex();
    }
  });

  // node_modules/ox/_esm/core/Bytes.js
  function from(value) {
    if (value instanceof Uint8Array)
      return value;
    if (typeof value === "string")
      return fromHex(value);
    return fromArray(value);
  }
  function fromArray(value) {
    return value instanceof Uint8Array ? value : new Uint8Array(value);
  }
  function fromHex(value, options = {}) {
    const { size: size5 } = options;
    let hex = value;
    if (size5) {
      assertSize3(value, size5);
      hex = padRight(value, size5);
    }
    let hexString = hex.slice(2);
    if (hexString.length % 2)
      hexString = `0${hexString}`;
    const length = hexString.length / 2;
    const bytes2 = new Uint8Array(length);
    for (let index2 = 0, j = 0; index2 < length; index2++) {
      const nibbleLeft = charCodeToBase162(hexString.charCodeAt(j++));
      const nibbleRight = charCodeToBase162(hexString.charCodeAt(j++));
      if (nibbleLeft === void 0 || nibbleRight === void 0) {
        throw new BaseError3(`Invalid byte sequence ("${hexString[j - 2]}${hexString[j - 1]}" in "${hexString}").`);
      }
      bytes2[index2] = nibbleLeft * 16 + nibbleRight;
    }
    return bytes2;
  }
  function fromString(value, options = {}) {
    const { size: size5 } = options;
    const bytes2 = encoder3.encode(value);
    if (typeof size5 === "number") {
      assertSize2(bytes2, size5);
      return padRight2(bytes2, size5);
    }
    return bytes2;
  }
  function padRight2(value, size5) {
    return pad2(value, { dir: "right", size: size5 });
  }
  function size2(value) {
    return value.length;
  }
  var encoder3, SizeOverflowError2, SizeExceedsPaddingSizeError2;
  var init_Bytes = __esm({
    "node_modules/ox/_esm/core/Bytes.js"() {
      init_Errors();
      init_Hex();
      init_bytes2();
      init_hex();
      encoder3 = /* @__PURE__ */ new TextEncoder();
      SizeOverflowError2 = class extends BaseError3 {
        constructor({ givenSize, maxSize }) {
          super(`Size cannot exceed \`${maxSize}\` bytes. Given size: \`${givenSize}\` bytes.`);
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "Bytes.SizeOverflowError"
          });
        }
      };
      SizeExceedsPaddingSizeError2 = class extends BaseError3 {
        constructor({ size: size5, targetSize, type }) {
          super(`${type.charAt(0).toUpperCase()}${type.slice(1).toLowerCase()} size (\`${size5}\`) exceeds padding size (\`${targetSize}\`).`);
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "Bytes.SizeExceedsPaddingSizeError"
          });
        }
      };
    }
  });

  // node_modules/ox/_esm/core/Hex.js
  function assert2(value, options = {}) {
    const { strict = false } = options;
    if (!value)
      throw new InvalidHexTypeError(value);
    if (typeof value !== "string")
      throw new InvalidHexTypeError(value);
    if (strict) {
      if (!/^0x[0-9a-fA-F]*$/.test(value))
        throw new InvalidHexValueError(value);
    }
    if (!value.startsWith("0x"))
      throw new InvalidHexValueError(value);
  }
  function concat3(...values) {
    return `0x${values.reduce((acc, x) => acc + x.replace("0x", ""), "")}`;
  }
  function fromBoolean(value, options = {}) {
    const hex = `0x${Number(value)}`;
    if (typeof options.size === "number") {
      assertSize3(hex, options.size);
      return padLeft(hex, options.size);
    }
    return hex;
  }
  function fromBytes(value, options = {}) {
    let string = "";
    for (let i = 0; i < value.length; i++)
      string += hexes4[value[i]];
    const hex = `0x${string}`;
    if (typeof options.size === "number") {
      assertSize3(hex, options.size);
      return padRight(hex, options.size);
    }
    return hex;
  }
  function fromNumber(value, options = {}) {
    const { signed: signed2, size: size5 } = options;
    const value_ = BigInt(value);
    let maxValue2;
    if (size5) {
      if (signed2)
        maxValue2 = (1n << BigInt(size5) * 8n - 1n) - 1n;
      else
        maxValue2 = 2n ** (BigInt(size5) * 8n) - 1n;
    } else if (typeof value === "number") {
      maxValue2 = BigInt(Number.MAX_SAFE_INTEGER);
    }
    const minValue = typeof maxValue2 === "bigint" && signed2 ? -maxValue2 - 1n : 0;
    if (maxValue2 && value_ > maxValue2 || value_ < minValue) {
      const suffix = typeof value === "bigint" ? "n" : "";
      throw new IntegerOutOfRangeError2({
        max: maxValue2 ? `${maxValue2}${suffix}` : void 0,
        min: `${minValue}${suffix}`,
        signed: signed2,
        size: size5,
        value: `${value}${suffix}`
      });
    }
    const stringValue = (signed2 && value_ < 0 ? (1n << BigInt(size5 * 8)) + BigInt(value_) : value_).toString(16);
    const hex = `0x${stringValue}`;
    if (size5)
      return padLeft(hex, size5);
    return hex;
  }
  function fromString2(value, options = {}) {
    return fromBytes(encoder4.encode(value), options);
  }
  function padLeft(value, size5) {
    return pad3(value, { dir: "left", size: size5 });
  }
  function padRight(value, size5) {
    return pad3(value, { dir: "right", size: size5 });
  }
  function slice2(value, start, end, options = {}) {
    const { strict } = options;
    assertStartOffset2(value, start);
    const value_ = `0x${value.replace("0x", "").slice((start ?? 0) * 2, (end ?? value.length) * 2)}`;
    if (strict)
      assertEndOffset2(value_, start, end);
    return value_;
  }
  function size3(value) {
    return Math.ceil((value.length - 2) / 2);
  }
  function validate(value, options = {}) {
    const { strict = false } = options;
    try {
      assert2(value, { strict });
      return true;
    } catch {
      return false;
    }
  }
  var encoder4, hexes4, IntegerOutOfRangeError2, InvalidHexTypeError, InvalidHexValueError, SizeOverflowError3, SliceOffsetOutOfBoundsError3, SizeExceedsPaddingSizeError3;
  var init_Hex = __esm({
    "node_modules/ox/_esm/core/Hex.js"() {
      init_Errors();
      init_Json();
      init_hex();
      encoder4 = /* @__PURE__ */ new TextEncoder();
      hexes4 = /* @__PURE__ */ Array.from({ length: 256 }, (_v2, i) => i.toString(16).padStart(2, "0"));
      IntegerOutOfRangeError2 = class extends BaseError3 {
        constructor({ max, min, signed: signed2, size: size5, value }) {
          super(`Number \`${value}\` is not in safe${size5 ? ` ${size5 * 8}-bit` : ""}${signed2 ? " signed" : " unsigned"} integer range ${max ? `(\`${min}\` to \`${max}\`)` : `(above \`${min}\`)`}`);
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "Hex.IntegerOutOfRangeError"
          });
        }
      };
      InvalidHexTypeError = class extends BaseError3 {
        constructor(value) {
          super(`Value \`${typeof value === "object" ? stringify4(value) : value}\` of type \`${typeof value}\` is an invalid hex type.`, {
            metaMessages: ['Hex types must be represented as `"0x${string}"`.']
          });
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "Hex.InvalidHexTypeError"
          });
        }
      };
      InvalidHexValueError = class extends BaseError3 {
        constructor(value) {
          super(`Value \`${value}\` is an invalid hex value.`, {
            metaMessages: [
              'Hex values must start with `"0x"` and contain only hexadecimal characters (0-9, a-f, A-F).'
            ]
          });
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "Hex.InvalidHexValueError"
          });
        }
      };
      SizeOverflowError3 = class extends BaseError3 {
        constructor({ givenSize, maxSize }) {
          super(`Size cannot exceed \`${maxSize}\` bytes. Given size: \`${givenSize}\` bytes.`);
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "Hex.SizeOverflowError"
          });
        }
      };
      SliceOffsetOutOfBoundsError3 = class extends BaseError3 {
        constructor({ offset, position, size: size5 }) {
          super(`Slice ${position === "start" ? "starting" : "ending"} at offset \`${offset}\` is out-of-bounds (size: \`${size5}\`).`);
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "Hex.SliceOffsetOutOfBoundsError"
          });
        }
      };
      SizeExceedsPaddingSizeError3 = class extends BaseError3 {
        constructor({ size: size5, targetSize, type }) {
          super(`${type.charAt(0).toUpperCase()}${type.slice(1).toLowerCase()} size (\`${size5}\`) exceeds padding size (\`${targetSize}\`).`);
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "Hex.SizeExceedsPaddingSizeError"
          });
        }
      };
    }
  });

  // node_modules/ox/_esm/core/Withdrawal.js
  function toRpc(withdrawal) {
    return {
      address: withdrawal.address,
      amount: fromNumber(withdrawal.amount),
      index: fromNumber(withdrawal.index),
      validatorIndex: fromNumber(withdrawal.validatorIndex)
    };
  }
  var init_Withdrawal = __esm({
    "node_modules/ox/_esm/core/Withdrawal.js"() {
      init_Hex();
    }
  });

  // node_modules/ox/_esm/core/BlockOverrides.js
  function toRpc2(blockOverrides) {
    return {
      ...typeof blockOverrides.baseFeePerGas === "bigint" && {
        baseFeePerGas: fromNumber(blockOverrides.baseFeePerGas)
      },
      ...typeof blockOverrides.blobBaseFee === "bigint" && {
        blobBaseFee: fromNumber(blockOverrides.blobBaseFee)
      },
      ...typeof blockOverrides.feeRecipient === "string" && {
        feeRecipient: blockOverrides.feeRecipient
      },
      ...typeof blockOverrides.gasLimit === "bigint" && {
        gasLimit: fromNumber(blockOverrides.gasLimit)
      },
      ...typeof blockOverrides.number === "bigint" && {
        number: fromNumber(blockOverrides.number)
      },
      ...typeof blockOverrides.prevRandao === "bigint" && {
        prevRandao: fromNumber(blockOverrides.prevRandao)
      },
      ...typeof blockOverrides.time === "bigint" && {
        time: fromNumber(blockOverrides.time)
      },
      ...blockOverrides.withdrawals && {
        withdrawals: blockOverrides.withdrawals.map(toRpc)
      }
    };
  }
  var init_BlockOverrides = __esm({
    "node_modules/ox/_esm/core/BlockOverrides.js"() {
      init_Hex();
      init_Withdrawal();
    }
  });

  // node_modules/viem/_esm/constants/abis.js
  var multicall3Abi, batchGatewayAbi, universalResolverErrors, universalResolverResolveAbi, universalResolverReverseAbi, textResolverAbi, addressResolverAbi, universalSignatureValidatorAbi;
  var init_abis = __esm({
    "node_modules/viem/_esm/constants/abis.js"() {
      multicall3Abi = [
        {
          inputs: [
            {
              components: [
                {
                  name: "target",
                  type: "address"
                },
                {
                  name: "allowFailure",
                  type: "bool"
                },
                {
                  name: "callData",
                  type: "bytes"
                }
              ],
              name: "calls",
              type: "tuple[]"
            }
          ],
          name: "aggregate3",
          outputs: [
            {
              components: [
                {
                  name: "success",
                  type: "bool"
                },
                {
                  name: "returnData",
                  type: "bytes"
                }
              ],
              name: "returnData",
              type: "tuple[]"
            }
          ],
          stateMutability: "view",
          type: "function"
        }
      ];
      batchGatewayAbi = [
        {
          name: "query",
          type: "function",
          stateMutability: "view",
          inputs: [
            {
              type: "tuple[]",
              name: "queries",
              components: [
                {
                  type: "address",
                  name: "sender"
                },
                {
                  type: "string[]",
                  name: "urls"
                },
                {
                  type: "bytes",
                  name: "data"
                }
              ]
            }
          ],
          outputs: [
            {
              type: "bool[]",
              name: "failures"
            },
            {
              type: "bytes[]",
              name: "responses"
            }
          ]
        },
        {
          name: "HttpError",
          type: "error",
          inputs: [
            {
              type: "uint16",
              name: "status"
            },
            {
              type: "string",
              name: "message"
            }
          ]
        }
      ];
      universalResolverErrors = [
        {
          inputs: [],
          name: "ResolverNotFound",
          type: "error"
        },
        {
          inputs: [],
          name: "ResolverWildcardNotSupported",
          type: "error"
        },
        {
          inputs: [],
          name: "ResolverNotContract",
          type: "error"
        },
        {
          inputs: [
            {
              name: "returnData",
              type: "bytes"
            }
          ],
          name: "ResolverError",
          type: "error"
        },
        {
          inputs: [
            {
              components: [
                {
                  name: "status",
                  type: "uint16"
                },
                {
                  name: "message",
                  type: "string"
                }
              ],
              name: "errors",
              type: "tuple[]"
            }
          ],
          name: "HttpError",
          type: "error"
        }
      ];
      universalResolverResolveAbi = [
        ...universalResolverErrors,
        {
          name: "resolve",
          type: "function",
          stateMutability: "view",
          inputs: [
            { name: "name", type: "bytes" },
            { name: "data", type: "bytes" }
          ],
          outputs: [
            { name: "", type: "bytes" },
            { name: "address", type: "address" }
          ]
        },
        {
          name: "resolve",
          type: "function",
          stateMutability: "view",
          inputs: [
            { name: "name", type: "bytes" },
            { name: "data", type: "bytes" },
            { name: "gateways", type: "string[]" }
          ],
          outputs: [
            { name: "", type: "bytes" },
            { name: "address", type: "address" }
          ]
        }
      ];
      universalResolverReverseAbi = [
        ...universalResolverErrors,
        {
          name: "reverse",
          type: "function",
          stateMutability: "view",
          inputs: [{ type: "bytes", name: "reverseName" }],
          outputs: [
            { type: "string", name: "resolvedName" },
            { type: "address", name: "resolvedAddress" },
            { type: "address", name: "reverseResolver" },
            { type: "address", name: "resolver" }
          ]
        },
        {
          name: "reverse",
          type: "function",
          stateMutability: "view",
          inputs: [
            { type: "bytes", name: "reverseName" },
            { type: "string[]", name: "gateways" }
          ],
          outputs: [
            { type: "string", name: "resolvedName" },
            { type: "address", name: "resolvedAddress" },
            { type: "address", name: "reverseResolver" },
            { type: "address", name: "resolver" }
          ]
        }
      ];
      textResolverAbi = [
        {
          name: "text",
          type: "function",
          stateMutability: "view",
          inputs: [
            { name: "name", type: "bytes32" },
            { name: "key", type: "string" }
          ],
          outputs: [{ name: "", type: "string" }]
        }
      ];
      addressResolverAbi = [
        {
          name: "addr",
          type: "function",
          stateMutability: "view",
          inputs: [{ name: "name", type: "bytes32" }],
          outputs: [{ name: "", type: "address" }]
        },
        {
          name: "addr",
          type: "function",
          stateMutability: "view",
          inputs: [
            { name: "name", type: "bytes32" },
            { name: "coinType", type: "uint256" }
          ],
          outputs: [{ name: "", type: "bytes" }]
        }
      ];
      universalSignatureValidatorAbi = [
        {
          inputs: [
            {
              name: "_signer",
              type: "address"
            },
            {
              name: "_hash",
              type: "bytes32"
            },
            {
              name: "_signature",
              type: "bytes"
            }
          ],
          stateMutability: "nonpayable",
          type: "constructor"
        },
        {
          inputs: [
            {
              name: "_signer",
              type: "address"
            },
            {
              name: "_hash",
              type: "bytes32"
            },
            {
              name: "_signature",
              type: "bytes"
            }
          ],
          outputs: [
            {
              type: "bool"
            }
          ],
          stateMutability: "nonpayable",
          type: "function",
          name: "isValidSig"
        }
      ];
    }
  });

  // node_modules/viem/_esm/constants/contract.js
  var aggregate3Signature;
  var init_contract4 = __esm({
    "node_modules/viem/_esm/constants/contract.js"() {
      aggregate3Signature = "0x82ad56cb";
    }
  });

  // node_modules/viem/_esm/constants/contracts.js
  var deploylessCallViaBytecodeBytecode, deploylessCallViaFactoryBytecode, universalSignatureValidatorByteCode;
  var init_contracts = __esm({
    "node_modules/viem/_esm/constants/contracts.js"() {
      deploylessCallViaBytecodeBytecode = "0x608060405234801561001057600080fd5b5060405161018e38038061018e83398101604081905261002f91610124565b6000808351602085016000f59050803b61004857600080fd5b6000808351602085016000855af16040513d6000823e81610067573d81fd5b3d81f35b634e487b7160e01b600052604160045260246000fd5b600082601f83011261009257600080fd5b81516001600160401b038111156100ab576100ab61006b565b604051601f8201601f19908116603f011681016001600160401b03811182821017156100d9576100d961006b565b6040528181528382016020018510156100f157600080fd5b60005b82811015610110576020818601810151838301820152016100f4565b506000918101602001919091529392505050565b6000806040838503121561013757600080fd5b82516001600160401b0381111561014d57600080fd5b61015985828601610081565b602085015190935090506001600160401b0381111561017757600080fd5b61018385828601610081565b915050925092905056fe";
      deploylessCallViaFactoryBytecode = "0x608060405234801561001057600080fd5b506040516102c03803806102c083398101604081905261002f916101e6565b836001600160a01b03163b6000036100e457600080836001600160a01b03168360405161005c9190610270565b6000604051808303816000865af19150503d8060008114610099576040519150601f19603f3d011682016040523d82523d6000602084013e61009e565b606091505b50915091508115806100b857506001600160a01b0386163b155b156100e1578060405163101bb98d60e01b81526004016100d8919061028c565b60405180910390fd5b50505b6000808451602086016000885af16040513d6000823e81610103573d81fd5b3d81f35b80516001600160a01b038116811461011e57600080fd5b919050565b634e487b7160e01b600052604160045260246000fd5b60005b8381101561015457818101518382015260200161013c565b50506000910152565b600082601f83011261016e57600080fd5b81516001600160401b0381111561018757610187610123565b604051601f8201601f19908116603f011681016001600160401b03811182821017156101b5576101b5610123565b6040528181528382016020018510156101cd57600080fd5b6101de826020830160208701610139565b949350505050565b600080600080608085870312156101fc57600080fd5b61020585610107565b60208601519094506001600160401b0381111561022157600080fd5b61022d8782880161015d565b93505061023c60408601610107565b60608601519092506001600160401b0381111561025857600080fd5b6102648782880161015d565b91505092959194509250565b60008251610282818460208701610139565b9190910192915050565b60208152600082518060208401526102ab816040850160208701610139565b601f01601f1916919091016040019291505056fe";
      universalSignatureValidatorByteCode = "0x608060405234801561001057600080fd5b5060405161069438038061069483398101604081905261002f9161051e565b600061003c848484610048565b9050806000526001601ff35b60007f64926492649264926492649264926492649264926492649264926492649264926100748361040c565b036101e7576000606080848060200190518101906100929190610577565b60405192955090935091506000906001600160a01b038516906100b69085906105dd565b6000604051808303816000865af19150503d80600081146100f3576040519150601f19603f3d011682016040523d82523d6000602084013e6100f8565b606091505b50509050876001600160a01b03163b60000361016057806101605760405162461bcd60e51b815260206004820152601e60248201527f5369676e617475726556616c696461746f723a206465706c6f796d656e74000060448201526064015b60405180910390fd5b604051630b135d3f60e11b808252906001600160a01b038a1690631626ba7e90610190908b9087906004016105f9565b602060405180830381865afa1580156101ad573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906101d19190610633565b6001600160e01b03191614945050505050610405565b6001600160a01b0384163b1561027a57604051630b135d3f60e11b808252906001600160a01b03861690631626ba7e9061022790879087906004016105f9565b602060405180830381865afa158015610244573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906102689190610633565b6001600160e01b031916149050610405565b81516041146102df5760405162461bcd60e51b815260206004820152603a602482015260008051602061067483398151915260448201527f3a20696e76616c6964207369676e6174757265206c656e6774680000000000006064820152608401610157565b6102e7610425565b5060208201516040808401518451859392600091859190811061030c5761030c61065d565b016020015160f81c9050601b811480159061032b57508060ff16601c14155b1561038c5760405162461bcd60e51b815260206004820152603b602482015260008051602061067483398151915260448201527f3a20696e76616c6964207369676e617475726520762076616c756500000000006064820152608401610157565b60408051600081526020810180835289905260ff83169181019190915260608101849052608081018390526001600160a01b0389169060019060a0016020604051602081039080840390855afa1580156103ea573d6000803e3d6000fd5b505050602060405103516001600160a01b0316149450505050505b9392505050565b600060208251101561041d57600080fd5b508051015190565b60405180606001604052806003906020820280368337509192915050565b6001600160a01b038116811461045857600080fd5b50565b634e487b7160e01b600052604160045260246000fd5b60005b8381101561048c578181015183820152602001610474565b50506000910152565b600082601f8301126104a657600080fd5b81516001600160401b038111156104bf576104bf61045b565b604051601f8201601f19908116603f011681016001600160401b03811182821017156104ed576104ed61045b565b60405281815283820160200185101561050557600080fd5b610516826020830160208701610471565b949350505050565b60008060006060848603121561053357600080fd5b835161053e81610443565b6020850151604086015191945092506001600160401b0381111561056157600080fd5b61056d86828701610495565b9150509250925092565b60008060006060848603121561058c57600080fd5b835161059781610443565b60208501519093506001600160401b038111156105b357600080fd5b6105bf86828701610495565b604086015190935090506001600160401b0381111561056157600080fd5b600082516105ef818460208701610471565b9190910192915050565b828152604060208201526000825180604084015261061e816060850160208701610471565b601f01601f1916919091016060019392505050565b60006020828403121561064557600080fd5b81516001600160e01b03198116811461040557600080fd5b634e487b7160e01b600052603260045260246000fdfe5369676e617475726556616c696461746f72237265636f7665725369676e6572";
    }
  });

  // node_modules/viem/_esm/errors/chain.js
  var ChainDoesNotSupportContract, ChainMismatchError, ChainNotFoundError, ClientChainNotConfiguredError, InvalidChainIdError;
  var init_chain = __esm({
    "node_modules/viem/_esm/errors/chain.js"() {
      init_base();
      ChainDoesNotSupportContract = class extends BaseError2 {
        constructor({ blockNumber, chain, contract }) {
          super(`Chain "${chain.name}" does not support contract "${contract.name}".`, {
            metaMessages: [
              "This could be due to any of the following:",
              ...blockNumber && contract.blockCreated && contract.blockCreated > blockNumber ? [
                `- The contract "${contract.name}" was not deployed until block ${contract.blockCreated} (current block ${blockNumber}).`
              ] : [
                `- The chain does not have the contract "${contract.name}" configured.`
              ]
            ],
            name: "ChainDoesNotSupportContract"
          });
        }
      };
      ChainMismatchError = class extends BaseError2 {
        constructor({ chain, currentChainId }) {
          super(`The current chain of the wallet (id: ${currentChainId}) does not match the target chain for the transaction (id: ${chain.id} \u2013 ${chain.name}).`, {
            metaMessages: [
              `Current Chain ID:  ${currentChainId}`,
              `Expected Chain ID: ${chain.id} \u2013 ${chain.name}`
            ],
            name: "ChainMismatchError"
          });
        }
      };
      ChainNotFoundError = class extends BaseError2 {
        constructor() {
          super([
            "No chain was provided to the request.",
            "Please provide a chain with the `chain` argument on the Action, or by supplying a `chain` to WalletClient."
          ].join("\n"), {
            name: "ChainNotFoundError"
          });
        }
      };
      ClientChainNotConfiguredError = class extends BaseError2 {
        constructor() {
          super("No chain was provided to the Client.", {
            name: "ClientChainNotConfiguredError"
          });
        }
      };
      InvalidChainIdError = class extends BaseError2 {
        constructor({ chainId }) {
          super(typeof chainId === "number" ? `Chain ID "${chainId}" is invalid.` : "Chain ID is invalid.", { name: "InvalidChainIdError" });
        }
      };
    }
  });

  // node_modules/viem/_esm/utils/abi/encodeDeployData.js
  function encodeDeployData(parameters) {
    const { abi: abi2, args, bytecode } = parameters;
    if (!args || args.length === 0)
      return bytecode;
    const description = abi2.find((x) => "type" in x && x.type === "constructor");
    if (!description)
      throw new AbiConstructorNotFoundError({ docsPath: docsPath5 });
    if (!("inputs" in description))
      throw new AbiConstructorParamsNotFoundError({ docsPath: docsPath5 });
    if (!description.inputs || description.inputs.length === 0)
      throw new AbiConstructorParamsNotFoundError({ docsPath: docsPath5 });
    const data = encodeAbiParameters(description.inputs, args);
    return concatHex([bytecode, data]);
  }
  var docsPath5;
  var init_encodeDeployData = __esm({
    "node_modules/viem/_esm/utils/abi/encodeDeployData.js"() {
      init_abi2();
      init_concat();
      init_encodeAbiParameters();
      docsPath5 = "/docs/contract/encodeDeployData";
    }
  });

  // node_modules/viem/_esm/utils/chain/getChainContractAddress.js
  function getChainContractAddress({ blockNumber, chain, contract: name }) {
    const contract = chain?.contracts?.[name];
    if (!contract)
      throw new ChainDoesNotSupportContract({
        chain,
        contract: { name }
      });
    if (blockNumber && contract.blockCreated && contract.blockCreated > blockNumber)
      throw new ChainDoesNotSupportContract({
        blockNumber,
        chain,
        contract: {
          name,
          blockCreated: contract.blockCreated
        }
      });
    return contract.address;
  }
  var init_getChainContractAddress = __esm({
    "node_modules/viem/_esm/utils/chain/getChainContractAddress.js"() {
      init_chain();
    }
  });

  // node_modules/viem/_esm/utils/errors/getCallError.js
  function getCallError(err, { docsPath: docsPath8, ...args }) {
    const cause = (() => {
      const cause2 = getNodeError(err, args);
      if (cause2 instanceof UnknownNodeError)
        return err;
      return cause2;
    })();
    return new CallExecutionError(cause, {
      docsPath: docsPath8,
      ...args
    });
  }
  var init_getCallError = __esm({
    "node_modules/viem/_esm/utils/errors/getCallError.js"() {
      init_contract3();
      init_node();
      init_getNodeError();
    }
  });

  // node_modules/viem/_esm/utils/promise/withResolvers.js
  function withResolvers() {
    let resolve = () => void 0;
    let reject = () => void 0;
    const promise = new Promise((resolve_, reject_) => {
      resolve = resolve_;
      reject = reject_;
    });
    return { promise, resolve, reject };
  }
  var init_withResolvers = __esm({
    "node_modules/viem/_esm/utils/promise/withResolvers.js"() {
    }
  });

  // node_modules/viem/_esm/utils/promise/createBatchScheduler.js
  function createBatchScheduler({ fn, id: id2, shouldSplitBatch, wait: wait3 = 0, sort }) {
    const exec = async () => {
      const scheduler = getScheduler();
      flush();
      const args = scheduler.map(({ args: args2 }) => args2);
      if (args.length === 0)
        return;
      fn(args).then((data) => {
        if (sort && Array.isArray(data))
          data.sort(sort);
        for (let i = 0; i < scheduler.length; i++) {
          const { resolve } = scheduler[i];
          resolve?.([data[i], data]);
        }
      }).catch((err) => {
        for (let i = 0; i < scheduler.length; i++) {
          const { reject } = scheduler[i];
          reject?.(err);
        }
      });
    };
    const flush = () => schedulerCache.delete(id2);
    const getBatchedArgs = () => getScheduler().map(({ args }) => args);
    const getScheduler = () => schedulerCache.get(id2) || [];
    const setScheduler = (item) => schedulerCache.set(id2, [...getScheduler(), item]);
    return {
      flush,
      async schedule(args) {
        const { promise, resolve, reject } = withResolvers();
        const split5 = shouldSplitBatch?.([...getBatchedArgs(), args]);
        if (split5)
          exec();
        const hasActiveScheduler = getScheduler().length > 0;
        if (hasActiveScheduler) {
          setScheduler({ args, resolve, reject });
          return promise;
        }
        setScheduler({ args, resolve, reject });
        setTimeout(exec, wait3);
        return promise;
      }
    };
  }
  var schedulerCache;
  var init_createBatchScheduler = __esm({
    "node_modules/viem/_esm/utils/promise/createBatchScheduler.js"() {
      init_withResolvers();
      schedulerCache = /* @__PURE__ */ new Map();
    }
  });

  // node_modules/viem/_esm/errors/ccip.js
  var OffchainLookupError, OffchainLookupResponseMalformedError, OffchainLookupSenderMismatchError;
  var init_ccip = __esm({
    "node_modules/viem/_esm/errors/ccip.js"() {
      init_stringify();
      init_base();
      init_utils7();
      OffchainLookupError = class extends BaseError2 {
        constructor({ callbackSelector, cause, data, extraData, sender, urls }) {
          super(cause.shortMessage || "An error occurred while fetching for an offchain result.", {
            cause,
            metaMessages: [
              ...cause.metaMessages || [],
              cause.metaMessages?.length ? "" : [],
              "Offchain Gateway Call:",
              urls && [
                "  Gateway URL(s):",
                ...urls.map((url) => `    ${getUrl2(url)}`)
              ],
              `  Sender: ${sender}`,
              `  Data: ${data}`,
              `  Callback selector: ${callbackSelector}`,
              `  Extra data: ${extraData}`
            ].flat(),
            name: "OffchainLookupError"
          });
        }
      };
      OffchainLookupResponseMalformedError = class extends BaseError2 {
        constructor({ result, url }) {
          super("Offchain gateway response is malformed. Response data must be a hex value.", {
            metaMessages: [
              `Gateway URL: ${getUrl2(url)}`,
              `Response: ${stringify3(result)}`
            ],
            name: "OffchainLookupResponseMalformedError"
          });
        }
      };
      OffchainLookupSenderMismatchError = class extends BaseError2 {
        constructor({ sender, to }) {
          super("Reverted sender address does not match target contract address (`to`).", {
            metaMessages: [
              `Contract address: ${to}`,
              `OffchainLookup sender address: ${sender}`
            ],
            name: "OffchainLookupSenderMismatchError"
          });
        }
      };
    }
  });

  // node_modules/viem/_esm/utils/abi/decodeFunctionData.js
  function decodeFunctionData(parameters) {
    const { abi: abi2, data } = parameters;
    const signature = slice(data, 0, 4);
    const description = abi2.find((x) => x.type === "function" && signature === toFunctionSelector(formatAbiItem2(x)));
    if (!description)
      throw new AbiFunctionSignatureNotFoundError(signature, {
        docsPath: "/docs/contract/decodeFunctionData"
      });
    return {
      functionName: description.name,
      args: "inputs" in description && description.inputs && description.inputs.length > 0 ? decodeAbiParameters(description.inputs, slice(data, 4)) : void 0
    };
  }
  var init_decodeFunctionData = __esm({
    "node_modules/viem/_esm/utils/abi/decodeFunctionData.js"() {
      init_abi2();
      init_slice();
      init_toFunctionSelector();
      init_decodeAbiParameters();
      init_formatAbiItem2();
    }
  });

  // node_modules/viem/_esm/utils/abi/encodeErrorResult.js
  function encodeErrorResult(parameters) {
    const { abi: abi2, errorName, args } = parameters;
    let abiItem = abi2[0];
    if (errorName) {
      const item = getAbiItem({ abi: abi2, args, name: errorName });
      if (!item)
        throw new AbiErrorNotFoundError(errorName, { docsPath: docsPath6 });
      abiItem = item;
    }
    if (abiItem.type !== "error")
      throw new AbiErrorNotFoundError(void 0, { docsPath: docsPath6 });
    const definition = formatAbiItem2(abiItem);
    const signature = toFunctionSelector(definition);
    let data = "0x";
    if (args && args.length > 0) {
      if (!abiItem.inputs)
        throw new AbiErrorInputsNotFoundError(abiItem.name, { docsPath: docsPath6 });
      data = encodeAbiParameters(abiItem.inputs, args);
    }
    return concatHex([signature, data]);
  }
  var docsPath6;
  var init_encodeErrorResult = __esm({
    "node_modules/viem/_esm/utils/abi/encodeErrorResult.js"() {
      init_abi2();
      init_concat();
      init_toFunctionSelector();
      init_encodeAbiParameters();
      init_formatAbiItem2();
      init_getAbiItem();
      docsPath6 = "/docs/contract/encodeErrorResult";
    }
  });

  // node_modules/viem/_esm/utils/abi/encodeFunctionResult.js
  function encodeFunctionResult(parameters) {
    const { abi: abi2, functionName, result } = parameters;
    let abiItem = abi2[0];
    if (functionName) {
      const item = getAbiItem({ abi: abi2, name: functionName });
      if (!item)
        throw new AbiFunctionNotFoundError(functionName, { docsPath: docsPath7 });
      abiItem = item;
    }
    if (abiItem.type !== "function")
      throw new AbiFunctionNotFoundError(void 0, { docsPath: docsPath7 });
    if (!abiItem.outputs)
      throw new AbiFunctionOutputsNotFoundError(abiItem.name, { docsPath: docsPath7 });
    const values = (() => {
      if (abiItem.outputs.length === 0)
        return [];
      if (abiItem.outputs.length === 1)
        return [result];
      if (Array.isArray(result))
        return result;
      throw new InvalidArrayError(result);
    })();
    return encodeAbiParameters(abiItem.outputs, values);
  }
  var docsPath7;
  var init_encodeFunctionResult = __esm({
    "node_modules/viem/_esm/utils/abi/encodeFunctionResult.js"() {
      init_abi2();
      init_encodeAbiParameters();
      init_getAbiItem();
      docsPath7 = "/docs/contract/encodeFunctionResult";
    }
  });

  // node_modules/viem/_esm/utils/ens/localBatchGatewayRequest.js
  async function localBatchGatewayRequest(parameters) {
    const { data, ccipRequest: ccipRequest2 } = parameters;
    const { args: [queries] } = decodeFunctionData({ abi: batchGatewayAbi, data });
    const failures = [];
    const responses = [];
    await Promise.all(queries.map(async (query, i) => {
      try {
        responses[i] = query.urls.includes(localBatchGatewayUrl) ? await localBatchGatewayRequest({ data: query.data, ccipRequest: ccipRequest2 }) : await ccipRequest2(query);
        failures[i] = false;
      } catch (err) {
        failures[i] = true;
        responses[i] = encodeError(err);
      }
    }));
    return encodeFunctionResult({
      abi: batchGatewayAbi,
      functionName: "query",
      result: [failures, responses]
    });
  }
  function encodeError(error) {
    if (error.name === "HttpRequestError" && error.status)
      return encodeErrorResult({
        abi: batchGatewayAbi,
        errorName: "HttpError",
        args: [error.status, error.shortMessage]
      });
    return encodeErrorResult({
      abi: [solidityError],
      errorName: "Error",
      args: ["shortMessage" in error ? error.shortMessage : error.message]
    });
  }
  var localBatchGatewayUrl;
  var init_localBatchGatewayRequest = __esm({
    "node_modules/viem/_esm/utils/ens/localBatchGatewayRequest.js"() {
      init_abis();
      init_solidity2();
      init_decodeFunctionData();
      init_encodeErrorResult();
      init_encodeFunctionResult();
      localBatchGatewayUrl = "x-batch-gateway:true";
    }
  });

  // node_modules/viem/_esm/utils/ccip.js
  var ccip_exports = {};
  __export(ccip_exports, {
    ccipRequest: () => ccipRequest,
    offchainLookup: () => offchainLookup,
    offchainLookupAbiItem: () => offchainLookupAbiItem,
    offchainLookupSignature: () => offchainLookupSignature
  });
  async function offchainLookup(client, { blockNumber, blockTag, data, to }) {
    const { args } = decodeErrorResult({
      data,
      abi: [offchainLookupAbiItem]
    });
    const [sender, urls, callData, callbackSelector, extraData] = args;
    const { ccipRead } = client;
    const ccipRequest_ = ccipRead && typeof ccipRead?.request === "function" ? ccipRead.request : ccipRequest;
    try {
      if (!isAddressEqual(to, sender))
        throw new OffchainLookupSenderMismatchError({ sender, to });
      const result = urls.includes(localBatchGatewayUrl) ? await localBatchGatewayRequest({
        data: callData,
        ccipRequest: ccipRequest_
      }) : await ccipRequest_({ data: callData, sender, urls });
      const { data: data_ } = await call(client, {
        blockNumber,
        blockTag,
        data: concat2([
          callbackSelector,
          encodeAbiParameters([{ type: "bytes" }, { type: "bytes" }], [result, extraData])
        ]),
        to
      });
      return data_;
    } catch (err) {
      throw new OffchainLookupError({
        callbackSelector,
        cause: err,
        data,
        extraData,
        sender,
        urls
      });
    }
  }
  async function ccipRequest({ data, sender, urls }) {
    let error = new Error("An unknown error occurred.");
    for (let i = 0; i < urls.length; i++) {
      const url = urls[i];
      const method = url.includes("{data}") ? "GET" : "POST";
      const body = method === "POST" ? { data, sender } : void 0;
      const headers = method === "POST" ? { "Content-Type": "application/json" } : {};
      try {
        const response = await fetch(url.replace("{sender}", sender.toLowerCase()).replace("{data}", data), {
          body: JSON.stringify(body),
          headers,
          method
        });
        let result;
        if (response.headers.get("Content-Type")?.startsWith("application/json")) {
          result = (await response.json()).data;
        } else {
          result = await response.text();
        }
        if (!response.ok) {
          error = new HttpRequestError({
            body,
            details: result?.error ? stringify3(result.error) : response.statusText,
            headers: response.headers,
            status: response.status,
            url
          });
          continue;
        }
        if (!isHex(result)) {
          error = new OffchainLookupResponseMalformedError({
            result,
            url
          });
          continue;
        }
        return result;
      } catch (err) {
        error = new HttpRequestError({
          body,
          details: err.message,
          url
        });
      }
    }
    throw error;
  }
  var offchainLookupSignature, offchainLookupAbiItem;
  var init_ccip2 = __esm({
    "node_modules/viem/_esm/utils/ccip.js"() {
      init_call();
      init_ccip();
      init_request();
      init_decodeErrorResult();
      init_encodeAbiParameters();
      init_isAddressEqual();
      init_concat();
      init_isHex();
      init_localBatchGatewayRequest();
      init_stringify();
      offchainLookupSignature = "0x556f1830";
      offchainLookupAbiItem = {
        name: "OffchainLookup",
        type: "error",
        inputs: [
          {
            name: "sender",
            type: "address"
          },
          {
            name: "urls",
            type: "string[]"
          },
          {
            name: "callData",
            type: "bytes"
          },
          {
            name: "callbackFunction",
            type: "bytes4"
          },
          {
            name: "extraData",
            type: "bytes"
          }
        ]
      };
    }
  });

  // node_modules/viem/_esm/actions/public/call.js
  async function call(client, args) {
    const { account: account_ = client.account, authorizationList, batch = Boolean(client.batch?.multicall), blockNumber, blockTag = "latest", accessList, blobs, blockOverrides, code, data: data_, factory, factoryData, gas, gasPrice, maxFeePerBlobGas, maxFeePerGas, maxPriorityFeePerGas, nonce, to, value, stateOverride, ...rest } = args;
    const account = account_ ? parseAccount(account_) : void 0;
    if (code && (factory || factoryData))
      throw new BaseError2("Cannot provide both `code` & `factory`/`factoryData` as parameters.");
    if (code && to)
      throw new BaseError2("Cannot provide both `code` & `to` as parameters.");
    const deploylessCallViaBytecode = code && data_;
    const deploylessCallViaFactory = factory && factoryData && to && data_;
    const deploylessCall = deploylessCallViaBytecode || deploylessCallViaFactory;
    const data = (() => {
      if (deploylessCallViaBytecode)
        return toDeploylessCallViaBytecodeData({
          code,
          data: data_
        });
      if (deploylessCallViaFactory)
        return toDeploylessCallViaFactoryData({
          data: data_,
          factory,
          factoryData,
          to
        });
      return data_;
    })();
    try {
      assertRequest(args);
      const blockNumberHex = typeof blockNumber === "bigint" ? numberToHex(blockNumber) : void 0;
      const block = blockNumberHex || blockTag;
      const rpcBlockOverrides = blockOverrides ? toRpc2(blockOverrides) : void 0;
      const rpcStateOverride = serializeStateOverride(stateOverride);
      const chainFormat = client.chain?.formatters?.transactionRequest?.format;
      const format = chainFormat || formatTransactionRequest;
      const request = format({
        // Pick out extra data that might exist on the chain's transaction request type.
        ...extract(rest, { format: chainFormat }),
        from: account?.address,
        accessList,
        authorizationList,
        blobs,
        data,
        gas,
        gasPrice,
        maxFeePerBlobGas,
        maxFeePerGas,
        maxPriorityFeePerGas,
        nonce,
        to: deploylessCall ? void 0 : to,
        value
      });
      if (batch && shouldPerformMulticall({ request }) && !rpcStateOverride && !rpcBlockOverrides) {
        try {
          return await scheduleMulticall(client, {
            ...request,
            blockNumber,
            blockTag
          });
        } catch (err) {
          if (!(err instanceof ClientChainNotConfiguredError) && !(err instanceof ChainDoesNotSupportContract))
            throw err;
        }
      }
      const params = (() => {
        const base = [
          request,
          block
        ];
        if (rpcStateOverride && rpcBlockOverrides)
          return [...base, rpcStateOverride, rpcBlockOverrides];
        if (rpcStateOverride)
          return [...base, rpcStateOverride];
        if (rpcBlockOverrides)
          return [...base, {}, rpcBlockOverrides];
        return base;
      })();
      const response = await client.request({
        method: "eth_call",
        params
      });
      if (response === "0x")
        return { data: void 0 };
      return { data: response };
    } catch (err) {
      const data2 = getRevertErrorData(err);
      const { offchainLookup: offchainLookup2, offchainLookupSignature: offchainLookupSignature2 } = await Promise.resolve().then(() => (init_ccip2(), ccip_exports));
      if (client.ccipRead !== false && data2?.slice(0, 10) === offchainLookupSignature2 && to)
        return { data: await offchainLookup2(client, { data: data2, to }) };
      if (deploylessCall && data2?.slice(0, 10) === "0x101bb98d")
        throw new CounterfactualDeploymentFailedError({ factory });
      throw getCallError(err, {
        ...args,
        account,
        chain: client.chain
      });
    }
  }
  function shouldPerformMulticall({ request }) {
    const { data, to, ...request_ } = request;
    if (!data)
      return false;
    if (data.startsWith(aggregate3Signature))
      return false;
    if (!to)
      return false;
    if (Object.values(request_).filter((x) => typeof x !== "undefined").length > 0)
      return false;
    return true;
  }
  async function scheduleMulticall(client, args) {
    const { batchSize = 1024, wait: wait3 = 0 } = typeof client.batch?.multicall === "object" ? client.batch.multicall : {};
    const { blockNumber, blockTag = "latest", data, multicallAddress: multicallAddress_, to } = args;
    let multicallAddress = multicallAddress_;
    if (!multicallAddress) {
      if (!client.chain)
        throw new ClientChainNotConfiguredError();
      multicallAddress = getChainContractAddress({
        blockNumber,
        chain: client.chain,
        contract: "multicall3"
      });
    }
    const blockNumberHex = typeof blockNumber === "bigint" ? numberToHex(blockNumber) : void 0;
    const block = blockNumberHex || blockTag;
    const { schedule } = createBatchScheduler({
      id: `${client.uid}.${block}`,
      wait: wait3,
      shouldSplitBatch(args2) {
        const size5 = args2.reduce((size6, { data: data2 }) => size6 + (data2.length - 2), 0);
        return size5 > batchSize * 2;
      },
      fn: async (requests) => {
        const calls = requests.map((request) => ({
          allowFailure: true,
          callData: request.data,
          target: request.to
        }));
        const calldata = encodeFunctionData({
          abi: multicall3Abi,
          args: [calls],
          functionName: "aggregate3"
        });
        const data2 = await client.request({
          method: "eth_call",
          params: [
            {
              data: calldata,
              to: multicallAddress
            },
            block
          ]
        });
        return decodeFunctionResult({
          abi: multicall3Abi,
          args: [calls],
          functionName: "aggregate3",
          data: data2 || "0x"
        });
      }
    });
    const [{ returnData, success }] = await schedule({ data, to });
    if (!success)
      throw new RawContractError({ data: returnData });
    if (returnData === "0x")
      return { data: void 0 };
    return { data: returnData };
  }
  function toDeploylessCallViaBytecodeData(parameters) {
    const { code, data } = parameters;
    return encodeDeployData({
      abi: parseAbi(["constructor(bytes, bytes)"]),
      bytecode: deploylessCallViaBytecodeBytecode,
      args: [code, data]
    });
  }
  function toDeploylessCallViaFactoryData(parameters) {
    const { data, factory, factoryData, to } = parameters;
    return encodeDeployData({
      abi: parseAbi(["constructor(address, bytes, address, bytes)"]),
      bytecode: deploylessCallViaFactoryBytecode,
      args: [to, data, factory, factoryData]
    });
  }
  function getRevertErrorData(err) {
    if (!(err instanceof BaseError2))
      return void 0;
    const error = err.walk();
    return typeof error?.data === "object" ? error.data?.data : error.data;
  }
  var init_call = __esm({
    "node_modules/viem/_esm/actions/public/call.js"() {
      init_exports();
      init_BlockOverrides();
      init_parseAccount();
      init_abis();
      init_contract4();
      init_contracts();
      init_base();
      init_chain();
      init_contract3();
      init_decodeFunctionResult();
      init_encodeDeployData();
      init_encodeFunctionData();
      init_getChainContractAddress();
      init_toHex();
      init_getCallError();
      init_extract();
      init_transactionRequest();
      init_createBatchScheduler();
      init_stateOverride2();
      init_assertRequest();
    }
  });

  // node_modules/viem/_esm/actions/public/readContract.js
  async function readContract(client, parameters) {
    const { abi: abi2, address, args, functionName, ...rest } = parameters;
    const calldata = encodeFunctionData({
      abi: abi2,
      args,
      functionName
    });
    try {
      const { data } = await getAction(client, call, "call")({
        ...rest,
        data: calldata,
        to: address
      });
      return decodeFunctionResult({
        abi: abi2,
        args,
        functionName,
        data: data || "0x"
      });
    } catch (error) {
      throw getContractError(error, {
        abi: abi2,
        address,
        args,
        docsPath: "/docs/contract/readContract",
        functionName
      });
    }
  }
  var init_readContract = __esm({
    "node_modules/viem/_esm/actions/public/readContract.js"() {
      init_decodeFunctionResult();
      init_encodeFunctionData();
      init_getContractError();
      init_getAction();
      init_call();
    }
  });

  // node_modules/viem/_esm/actions/public/simulateContract.js
  async function simulateContract(client, parameters) {
    const { abi: abi2, address, args, dataSuffix, functionName, ...callRequest } = parameters;
    const account = callRequest.account ? parseAccount(callRequest.account) : client.account;
    const calldata = encodeFunctionData({ abi: abi2, args, functionName });
    try {
      const { data } = await getAction(client, call, "call")({
        batch: false,
        data: `${calldata}${dataSuffix ? dataSuffix.replace("0x", "") : ""}`,
        to: address,
        ...callRequest,
        account
      });
      const result = decodeFunctionResult({
        abi: abi2,
        args,
        functionName,
        data: data || "0x"
      });
      const minimizedAbi = abi2.filter((abiItem) => "name" in abiItem && abiItem.name === parameters.functionName);
      return {
        result,
        request: {
          abi: minimizedAbi,
          address,
          args,
          dataSuffix,
          functionName,
          ...callRequest,
          account
        }
      };
    } catch (error) {
      throw getContractError(error, {
        abi: abi2,
        address,
        args,
        docsPath: "/docs/contract/simulateContract",
        functionName,
        sender: account?.address
      });
    }
  }
  var init_simulateContract = __esm({
    "node_modules/viem/_esm/actions/public/simulateContract.js"() {
      init_parseAccount();
      init_decodeFunctionResult();
      init_encodeFunctionData();
      init_getContractError();
      init_getAction();
      init_call();
    }
  });

  // node_modules/viem/_esm/utils/observe.js
  function observe(observerId, callbacks, fn) {
    const callbackId = ++callbackCount;
    const getListeners = () => listenersCache.get(observerId) || [];
    const unsubscribe = () => {
      const listeners2 = getListeners();
      listenersCache.set(observerId, listeners2.filter((cb) => cb.id !== callbackId));
    };
    const unwatch = () => {
      const listeners2 = getListeners();
      if (!listeners2.some((cb) => cb.id === callbackId))
        return;
      const cleanup2 = cleanupCache.get(observerId);
      if (listeners2.length === 1 && cleanup2) {
        const p = cleanup2();
        if (p instanceof Promise)
          p.catch(() => {
          });
      }
      unsubscribe();
    };
    const listeners = getListeners();
    listenersCache.set(observerId, [
      ...listeners,
      { id: callbackId, fns: callbacks }
    ]);
    if (listeners && listeners.length > 0)
      return unwatch;
    const emit2 = {};
    for (const key in callbacks) {
      emit2[key] = (...args) => {
        const listeners2 = getListeners();
        if (listeners2.length === 0)
          return;
        for (const listener of listeners2)
          listener.fns[key]?.(...args);
      };
    }
    const cleanup = fn(emit2);
    if (typeof cleanup === "function")
      cleanupCache.set(observerId, cleanup);
    return unwatch;
  }
  var listenersCache, cleanupCache, callbackCount;
  var init_observe = __esm({
    "node_modules/viem/_esm/utils/observe.js"() {
      listenersCache = /* @__PURE__ */ new Map();
      cleanupCache = /* @__PURE__ */ new Map();
      callbackCount = 0;
    }
  });

  // node_modules/viem/_esm/utils/wait.js
  async function wait2(time) {
    return new Promise((res) => setTimeout(res, time));
  }
  var init_wait = __esm({
    "node_modules/viem/_esm/utils/wait.js"() {
    }
  });

  // node_modules/viem/_esm/utils/poll.js
  function poll(fn, { emitOnBegin, initialWaitTime, interval }) {
    let active = true;
    const unwatch = () => active = false;
    const watch = async () => {
      let data = void 0;
      if (emitOnBegin)
        data = await fn({ unpoll: unwatch });
      const initialWait = await initialWaitTime?.(data) ?? interval;
      await wait2(initialWait);
      const poll2 = async () => {
        if (!active)
          return;
        await fn({ unpoll: unwatch });
        await wait2(interval);
        poll2();
      };
      poll2();
    };
    watch();
    return unwatch;
  }
  var init_poll = __esm({
    "node_modules/viem/_esm/utils/poll.js"() {
      init_wait();
    }
  });

  // node_modules/viem/_esm/utils/promise/withCache.js
  function getCache(cacheKey2) {
    const buildCache = (cacheKey3, cache) => ({
      clear: () => cache.delete(cacheKey3),
      get: () => cache.get(cacheKey3),
      set: (data) => cache.set(cacheKey3, data)
    });
    const promise = buildCache(cacheKey2, promiseCache);
    const response = buildCache(cacheKey2, responseCache);
    return {
      clear: () => {
        promise.clear();
        response.clear();
      },
      promise,
      response
    };
  }
  async function withCache(fn, { cacheKey: cacheKey2, cacheTime = Number.POSITIVE_INFINITY }) {
    const cache = getCache(cacheKey2);
    const response = cache.response.get();
    if (response && cacheTime > 0) {
      const age = (/* @__PURE__ */ new Date()).getTime() - response.created.getTime();
      if (age < cacheTime)
        return response.data;
    }
    let promise = cache.promise.get();
    if (!promise) {
      promise = fn();
      cache.promise.set(promise);
    }
    try {
      const data = await promise;
      cache.response.set({ created: /* @__PURE__ */ new Date(), data });
      return data;
    } finally {
      cache.promise.clear();
    }
  }
  var promiseCache, responseCache;
  var init_withCache = __esm({
    "node_modules/viem/_esm/utils/promise/withCache.js"() {
      promiseCache = /* @__PURE__ */ new Map();
      responseCache = /* @__PURE__ */ new Map();
    }
  });

  // node_modules/viem/_esm/actions/public/getBlockNumber.js
  async function getBlockNumber(client, { cacheTime = client.cacheTime } = {}) {
    const blockNumberHex = await withCache(() => client.request({
      method: "eth_blockNumber"
    }), { cacheKey: cacheKey(client.uid), cacheTime });
    return BigInt(blockNumberHex);
  }
  var cacheKey;
  var init_getBlockNumber = __esm({
    "node_modules/viem/_esm/actions/public/getBlockNumber.js"() {
      init_withCache();
      cacheKey = (id2) => `blockNumber.${id2}`;
    }
  });

  // node_modules/viem/_esm/actions/public/getFilterChanges.js
  async function getFilterChanges(_client, { filter }) {
    const strict = "strict" in filter && filter.strict;
    const logs = await filter.request({
      method: "eth_getFilterChanges",
      params: [filter.id]
    });
    if (typeof logs[0] === "string")
      return logs;
    const formattedLogs = logs.map((log) => formatLog2(log));
    if (!("abi" in filter) || !filter.abi)
      return formattedLogs;
    return parseEventLogs({
      abi: filter.abi,
      logs: formattedLogs,
      strict
    });
  }
  var init_getFilterChanges = __esm({
    "node_modules/viem/_esm/actions/public/getFilterChanges.js"() {
      init_parseEventLogs();
      init_log2();
    }
  });

  // node_modules/viem/_esm/actions/public/uninstallFilter.js
  async function uninstallFilter(_client, { filter }) {
    return filter.request({
      method: "eth_uninstallFilter",
      params: [filter.id]
    });
  }
  var init_uninstallFilter = __esm({
    "node_modules/viem/_esm/actions/public/uninstallFilter.js"() {
    }
  });

  // node_modules/viem/_esm/actions/public/watchContractEvent.js
  function watchContractEvent(client, parameters) {
    const { abi: abi2, address, args, batch = true, eventName, fromBlock, onError, onLogs, poll: poll_, pollingInterval = client.pollingInterval, strict: strict_ } = parameters;
    const enablePolling = (() => {
      if (typeof poll_ !== "undefined")
        return poll_;
      if (typeof fromBlock === "bigint")
        return true;
      if (client.transport.type === "webSocket" || client.transport.type === "ipc")
        return false;
      if (client.transport.type === "fallback" && (client.transport.transports[0].config.type === "webSocket" || client.transport.transports[0].config.type === "ipc"))
        return false;
      return true;
    })();
    const pollContractEvent = () => {
      const strict = strict_ ?? false;
      const observerId = stringify3([
        "watchContractEvent",
        address,
        args,
        batch,
        client.uid,
        eventName,
        pollingInterval,
        strict,
        fromBlock
      ]);
      return observe(observerId, { onLogs, onError }, (emit2) => {
        let previousBlockNumber;
        if (fromBlock !== void 0)
          previousBlockNumber = fromBlock - 1n;
        let filter;
        let initialized = false;
        const unwatch = poll(async () => {
          if (!initialized) {
            try {
              filter = await getAction(client, createContractEventFilter, "createContractEventFilter")({
                abi: abi2,
                address,
                args,
                eventName,
                strict,
                fromBlock
              });
            } catch {
            }
            initialized = true;
            return;
          }
          try {
            let logs;
            if (filter) {
              logs = await getAction(client, getFilterChanges, "getFilterChanges")({ filter });
            } else {
              const blockNumber = await getAction(client, getBlockNumber, "getBlockNumber")({});
              if (previousBlockNumber && previousBlockNumber < blockNumber) {
                logs = await getAction(client, getContractEvents, "getContractEvents")({
                  abi: abi2,
                  address,
                  args,
                  eventName,
                  fromBlock: previousBlockNumber + 1n,
                  toBlock: blockNumber,
                  strict
                });
              } else {
                logs = [];
              }
              previousBlockNumber = blockNumber;
            }
            if (logs.length === 0)
              return;
            if (batch)
              emit2.onLogs(logs);
            else
              for (const log of logs)
                emit2.onLogs([log]);
          } catch (err) {
            if (filter && err instanceof InvalidInputRpcError)
              initialized = false;
            emit2.onError?.(err);
          }
        }, {
          emitOnBegin: true,
          interval: pollingInterval
        });
        return async () => {
          if (filter)
            await getAction(client, uninstallFilter, "uninstallFilter")({ filter });
          unwatch();
        };
      });
    };
    const subscribeContractEvent = () => {
      const strict = strict_ ?? false;
      const observerId = stringify3([
        "watchContractEvent",
        address,
        args,
        batch,
        client.uid,
        eventName,
        pollingInterval,
        strict
      ]);
      let active = true;
      let unsubscribe = () => active = false;
      return observe(observerId, { onLogs, onError }, (emit2) => {
        ;
        (async () => {
          try {
            const transport = (() => {
              if (client.transport.type === "fallback") {
                const transport2 = client.transport.transports.find((transport3) => transport3.config.type === "webSocket" || transport3.config.type === "ipc");
                if (!transport2)
                  return client.transport;
                return transport2.value;
              }
              return client.transport;
            })();
            const topics = eventName ? encodeEventTopics({
              abi: abi2,
              eventName,
              args
            }) : [];
            const { unsubscribe: unsubscribe_ } = await transport.subscribe({
              params: ["logs", { address, topics }],
              onData(data) {
                if (!active)
                  return;
                const log = data.result;
                try {
                  const { eventName: eventName2, args: args2 } = decodeEventLog({
                    abi: abi2,
                    data: log.data,
                    topics: log.topics,
                    strict: strict_
                  });
                  const formatted = formatLog2(log, {
                    args: args2,
                    eventName: eventName2
                  });
                  emit2.onLogs([formatted]);
                } catch (err) {
                  let eventName2;
                  let isUnnamed;
                  if (err instanceof DecodeLogDataMismatch || err instanceof DecodeLogTopicsMismatch) {
                    if (strict_)
                      return;
                    eventName2 = err.abiItem.name;
                    isUnnamed = err.abiItem.inputs?.some((x) => !("name" in x && x.name));
                  }
                  const formatted = formatLog2(log, {
                    args: isUnnamed ? [] : {},
                    eventName: eventName2
                  });
                  emit2.onLogs([formatted]);
                }
              },
              onError(error) {
                emit2.onError?.(error);
              }
            });
            unsubscribe = unsubscribe_;
            if (!active)
              unsubscribe();
          } catch (err) {
            onError?.(err);
          }
        })();
        return () => unsubscribe();
      });
    };
    return enablePolling ? pollContractEvent() : subscribeContractEvent();
  }
  var init_watchContractEvent = __esm({
    "node_modules/viem/_esm/actions/public/watchContractEvent.js"() {
      init_abi2();
      init_rpc();
      init_decodeEventLog();
      init_encodeEventTopics();
      init_log2();
      init_getAction();
      init_observe();
      init_poll();
      init_stringify();
      init_createContractEventFilter();
      init_getBlockNumber();
      init_getContractEvents();
      init_getFilterChanges();
      init_uninstallFilter();
    }
  });

  // node_modules/viem/_esm/errors/account.js
  var AccountNotFoundError, AccountTypeNotSupportedError;
  var init_account = __esm({
    "node_modules/viem/_esm/errors/account.js"() {
      init_base();
      AccountNotFoundError = class extends BaseError2 {
        constructor({ docsPath: docsPath8 } = {}) {
          super([
            "Could not find an Account to execute with this Action.",
            "Please provide an Account with the `account` argument on the Action, or by supplying an `account` to the Client."
          ].join("\n"), {
            docsPath: docsPath8,
            docsSlug: "account",
            name: "AccountNotFoundError"
          });
        }
      };
      AccountTypeNotSupportedError = class extends BaseError2 {
        constructor({ docsPath: docsPath8, metaMessages, type }) {
          super(`Account type "${type}" is not supported.`, {
            docsPath: docsPath8,
            metaMessages,
            name: "AccountTypeNotSupportedError"
          });
        }
      };
    }
  });

  // node_modules/viem/_esm/utils/chain/assertCurrentChain.js
  function assertCurrentChain({ chain, currentChainId }) {
    if (!chain)
      throw new ChainNotFoundError();
    if (currentChainId !== chain.id)
      throw new ChainMismatchError({ chain, currentChainId });
  }
  var init_assertCurrentChain = __esm({
    "node_modules/viem/_esm/utils/chain/assertCurrentChain.js"() {
      init_chain();
    }
  });

  // node_modules/viem/_esm/utils/errors/getTransactionError.js
  function getTransactionError(err, { docsPath: docsPath8, ...args }) {
    const cause = (() => {
      const cause2 = getNodeError(err, args);
      if (cause2 instanceof UnknownNodeError)
        return err;
      return cause2;
    })();
    return new TransactionExecutionError(cause, {
      docsPath: docsPath8,
      ...args
    });
  }
  var init_getTransactionError = __esm({
    "node_modules/viem/_esm/utils/errors/getTransactionError.js"() {
      init_node();
      init_transaction3();
      init_getNodeError();
    }
  });

  // node_modules/viem/_esm/actions/wallet/sendRawTransaction.js
  async function sendRawTransaction(client, { serializedTransaction }) {
    return client.request({
      method: "eth_sendRawTransaction",
      params: [serializedTransaction]
    }, { retryCount: 0 });
  }
  var init_sendRawTransaction = __esm({
    "node_modules/viem/_esm/actions/wallet/sendRawTransaction.js"() {
    }
  });

  // node_modules/viem/_esm/actions/wallet/sendTransaction.js
  async function sendTransaction(client, parameters) {
    const { account: account_ = client.account, chain = client.chain, accessList, authorizationList, blobs, data, gas, gasPrice, maxFeePerBlobGas, maxFeePerGas, maxPriorityFeePerGas, nonce, type, value, ...rest } = parameters;
    if (typeof account_ === "undefined")
      throw new AccountNotFoundError({
        docsPath: "/docs/actions/wallet/sendTransaction"
      });
    const account = account_ ? parseAccount(account_) : null;
    try {
      assertRequest(parameters);
      const to = await (async () => {
        if (parameters.to)
          return parameters.to;
        if (parameters.to === null)
          return void 0;
        if (authorizationList && authorizationList.length > 0)
          return await recoverAuthorizationAddress({
            authorization: authorizationList[0]
          }).catch(() => {
            throw new BaseError2("`to` is required. Could not infer from `authorizationList`.");
          });
        return void 0;
      })();
      if (account?.type === "json-rpc" || account === null) {
        let chainId;
        if (chain !== null) {
          chainId = await getAction(client, getChainId, "getChainId")({});
          assertCurrentChain({
            currentChainId: chainId,
            chain
          });
        }
        const chainFormat = client.chain?.formatters?.transactionRequest?.format;
        const format = chainFormat || formatTransactionRequest;
        const request = format({
          // Pick out extra data that might exist on the chain's transaction request type.
          ...extract(rest, { format: chainFormat }),
          accessList,
          authorizationList,
          blobs,
          chainId,
          data,
          from: account?.address,
          gas,
          gasPrice,
          maxFeePerBlobGas,
          maxFeePerGas,
          maxPriorityFeePerGas,
          nonce,
          to,
          type,
          value
        });
        const isWalletNamespaceSupported = supportsWalletNamespace.get(client.uid);
        const method = isWalletNamespaceSupported ? "wallet_sendTransaction" : "eth_sendTransaction";
        try {
          return await client.request({
            method,
            params: [request]
          }, { retryCount: 0 });
        } catch (e) {
          if (isWalletNamespaceSupported === false)
            throw e;
          const error = e;
          if (error.name === "InvalidInputRpcError" || error.name === "InvalidParamsRpcError" || error.name === "MethodNotFoundRpcError" || error.name === "MethodNotSupportedRpcError") {
            return await client.request({
              method: "wallet_sendTransaction",
              params: [request]
            }, { retryCount: 0 }).then((hash3) => {
              supportsWalletNamespace.set(client.uid, true);
              return hash3;
            }).catch((e2) => {
              const walletNamespaceError = e2;
              if (walletNamespaceError.name === "MethodNotFoundRpcError" || walletNamespaceError.name === "MethodNotSupportedRpcError") {
                supportsWalletNamespace.set(client.uid, false);
                throw error;
              }
              throw walletNamespaceError;
            });
          }
          throw error;
        }
      }
      if (account?.type === "local") {
        const request = await getAction(client, prepareTransactionRequest, "prepareTransactionRequest")({
          account,
          accessList,
          authorizationList,
          blobs,
          chain,
          data,
          gas,
          gasPrice,
          maxFeePerBlobGas,
          maxFeePerGas,
          maxPriorityFeePerGas,
          nonce,
          nonceManager: account.nonceManager,
          parameters: [...defaultParameters, "sidecars"],
          type,
          value,
          ...rest,
          to
        });
        const serializer = chain?.serializers?.transaction;
        const serializedTransaction = await account.signTransaction(request, {
          serializer
        });
        return await getAction(client, sendRawTransaction, "sendRawTransaction")({
          serializedTransaction
        });
      }
      if (account?.type === "smart")
        throw new AccountTypeNotSupportedError({
          metaMessages: [
            "Consider using the `sendUserOperation` Action instead."
          ],
          docsPath: "/docs/actions/bundler/sendUserOperation",
          type: "smart"
        });
      throw new AccountTypeNotSupportedError({
        docsPath: "/docs/actions/wallet/sendTransaction",
        type: account?.type
      });
    } catch (err) {
      if (err instanceof AccountTypeNotSupportedError)
        throw err;
      throw getTransactionError(err, {
        ...parameters,
        account,
        chain: parameters.chain || void 0
      });
    }
  }
  var supportsWalletNamespace;
  var init_sendTransaction = __esm({
    "node_modules/viem/_esm/actions/wallet/sendTransaction.js"() {
      init_parseAccount();
      init_account();
      init_base();
      init_recoverAuthorizationAddress();
      init_assertCurrentChain();
      init_getTransactionError();
      init_extract();
      init_transactionRequest();
      init_getAction();
      init_lru();
      init_assertRequest();
      init_getChainId();
      init_prepareTransactionRequest();
      init_sendRawTransaction();
      supportsWalletNamespace = new LruMap(128);
    }
  });

  // node_modules/viem/_esm/actions/wallet/writeContract.js
  async function writeContract(client, parameters) {
    const { abi: abi2, account: account_ = client.account, address, args, dataSuffix, functionName, ...request } = parameters;
    if (typeof account_ === "undefined")
      throw new AccountNotFoundError({
        docsPath: "/docs/contract/writeContract"
      });
    const account = account_ ? parseAccount(account_) : null;
    const data = encodeFunctionData({
      abi: abi2,
      args,
      functionName
    });
    try {
      return await getAction(client, sendTransaction, "sendTransaction")({
        data: `${data}${dataSuffix ? dataSuffix.replace("0x", "") : ""}`,
        to: address,
        account,
        ...request
      });
    } catch (error) {
      throw getContractError(error, {
        abi: abi2,
        address,
        args,
        docsPath: "/docs/contract/writeContract",
        functionName,
        sender: account?.address
      });
    }
  }
  var init_writeContract = __esm({
    "node_modules/viem/_esm/actions/wallet/writeContract.js"() {
      init_parseAccount();
      init_account();
      init_encodeFunctionData();
      init_getContractError();
      init_getAction();
      init_sendTransaction();
    }
  });

  // node_modules/viem/_esm/utils/formatters/transactionReceipt.js
  function formatTransactionReceipt2(transactionReceipt) {
    const receipt = {
      ...transactionReceipt,
      blockNumber: transactionReceipt.blockNumber ? BigInt(transactionReceipt.blockNumber) : null,
      contractAddress: transactionReceipt.contractAddress ? transactionReceipt.contractAddress : null,
      cumulativeGasUsed: transactionReceipt.cumulativeGasUsed ? BigInt(transactionReceipt.cumulativeGasUsed) : null,
      effectiveGasPrice: transactionReceipt.effectiveGasPrice ? BigInt(transactionReceipt.effectiveGasPrice) : null,
      gasUsed: transactionReceipt.gasUsed ? BigInt(transactionReceipt.gasUsed) : null,
      logs: transactionReceipt.logs ? transactionReceipt.logs.map((log) => formatLog2(log)) : null,
      to: transactionReceipt.to ? transactionReceipt.to : null,
      transactionIndex: transactionReceipt.transactionIndex ? hexToNumber2(transactionReceipt.transactionIndex) : null,
      status: transactionReceipt.status ? receiptStatuses[transactionReceipt.status] : null,
      type: transactionReceipt.type ? transactionType[transactionReceipt.type] || transactionReceipt.type : null
    };
    if (transactionReceipt.blobGasPrice)
      receipt.blobGasPrice = BigInt(transactionReceipt.blobGasPrice);
    if (transactionReceipt.blobGasUsed)
      receipt.blobGasUsed = BigInt(transactionReceipt.blobGasUsed);
    return receipt;
  }
  var receiptStatuses, defineTransactionReceipt;
  var init_transactionReceipt = __esm({
    "node_modules/viem/_esm/utils/formatters/transactionReceipt.js"() {
      init_fromHex();
      init_formatter();
      init_log2();
      init_transaction4();
      receiptStatuses = {
        "0x0": "reverted",
        "0x1": "success"
      };
      defineTransactionReceipt = /* @__PURE__ */ defineFormatter("transactionReceipt", formatTransactionReceipt2);
    }
  });

  // node_modules/viem/_esm/actions/wallet/sendCalls.js
  async function sendCalls(client, parameters) {
    const { account: account_ = client.account, capabilities, chain = client.chain, experimental_fallback, experimental_fallbackDelay = 32, forceAtomic = false, id: id2, version: version5 = "2.0.0" } = parameters;
    const account = account_ ? parseAccount(account_) : null;
    const calls = parameters.calls.map((call_) => {
      const call2 = call_;
      const data = call2.abi ? encodeFunctionData({
        abi: call2.abi,
        functionName: call2.functionName,
        args: call2.args
      }) : call2.data;
      return {
        data: call2.dataSuffix && data ? concat2([data, call2.dataSuffix]) : data,
        to: call2.to,
        value: call2.value ? numberToHex(call2.value) : void 0
      };
    });
    try {
      const response = await client.request({
        method: "wallet_sendCalls",
        params: [
          {
            atomicRequired: forceAtomic,
            calls,
            capabilities,
            chainId: numberToHex(chain.id),
            from: account?.address,
            id: id2,
            version: version5
          }
        ]
      }, { retryCount: 0 });
      if (typeof response === "string")
        return { id: response };
      return response;
    } catch (err) {
      const error = err;
      if (experimental_fallback && (error.name === "MethodNotFoundRpcError" || error.name === "MethodNotSupportedRpcError" || error.name === "UnknownRpcError" || error.details.toLowerCase().includes("does not exist / is not available") || error.details.toLowerCase().includes("missing or invalid. request()") || error.details.toLowerCase().includes("did not match any variant of untagged enum") || error.details.toLowerCase().includes("account upgraded to unsupported contract") || error.details.toLowerCase().includes("eip-7702 not supported") || error.details.toLowerCase().includes("unsupported wc_ method"))) {
        if (capabilities) {
          const hasNonOptionalCapability = Object.values(capabilities).some((capability) => !capability.optional);
          if (hasNonOptionalCapability) {
            const message = "non-optional `capabilities` are not supported on fallback to `eth_sendTransaction`.";
            throw new UnsupportedNonOptionalCapabilityError(new BaseError2(message, {
              details: message
            }));
          }
        }
        if (forceAtomic && calls.length > 1) {
          const message = "`forceAtomic` is not supported on fallback to `eth_sendTransaction`.";
          throw new AtomicityNotSupportedError(new BaseError2(message, {
            details: message
          }));
        }
        const promises = [];
        for (const call2 of calls) {
          const promise = sendTransaction(client, {
            account,
            chain,
            data: call2.data,
            to: call2.to,
            value: call2.value ? hexToBigInt(call2.value) : void 0
          });
          promises.push(promise);
          if (experimental_fallbackDelay > 0)
            await new Promise((resolve) => setTimeout(resolve, experimental_fallbackDelay));
        }
        const results = await Promise.allSettled(promises);
        if (results.every((r) => r.status === "rejected"))
          throw results[0].reason;
        const hashes = results.map((result) => {
          if (result.status === "fulfilled")
            return result.value;
          return fallbackTransactionErrorMagicIdentifier;
        });
        return {
          id: concat2([
            ...hashes,
            numberToHex(chain.id, { size: 32 }),
            fallbackMagicIdentifier
          ])
        };
      }
      throw getTransactionError(err, {
        ...parameters,
        account,
        chain: parameters.chain
      });
    }
  }
  var fallbackMagicIdentifier, fallbackTransactionErrorMagicIdentifier;
  var init_sendCalls = __esm({
    "node_modules/viem/_esm/actions/wallet/sendCalls.js"() {
      init_parseAccount();
      init_base();
      init_rpc();
      init_encodeFunctionData();
      init_concat();
      init_fromHex();
      init_toHex();
      init_getTransactionError();
      init_sendTransaction();
      fallbackMagicIdentifier = "0x5792579257925792579257925792579257925792579257925792579257925792";
      fallbackTransactionErrorMagicIdentifier = numberToHex(0, {
        size: 32
      });
    }
  });

  // node_modules/viem/_esm/actions/wallet/getCallsStatus.js
  async function getCallsStatus(client, parameters) {
    async function getStatus(id2) {
      const isTransactions = id2.endsWith(fallbackMagicIdentifier.slice(2));
      if (isTransactions) {
        const chainId2 = trim(sliceHex(id2, -64, -32));
        const hashes = sliceHex(id2, 0, -64).slice(2).match(/.{1,64}/g);
        const receipts2 = await Promise.all(hashes.map((hash3) => fallbackTransactionErrorMagicIdentifier.slice(2) !== hash3 ? client.request({
          method: "eth_getTransactionReceipt",
          params: [`0x${hash3}`]
        }, { dedupe: true }) : void 0));
        const status2 = (() => {
          if (receipts2.some((r) => r === null))
            return 100;
          if (receipts2.every((r) => r?.status === "0x1"))
            return 200;
          if (receipts2.every((r) => r?.status === "0x0"))
            return 500;
          return 600;
        })();
        return {
          atomic: false,
          chainId: hexToNumber2(chainId2),
          receipts: receipts2.filter(Boolean),
          status: status2,
          version: "2.0.0"
        };
      }
      return client.request({
        method: "wallet_getCallsStatus",
        params: [id2]
      });
    }
    const { atomic = false, chainId, receipts, version: version5 = "2.0.0", ...response } = await getStatus(parameters.id);
    const [status, statusCode] = (() => {
      const statusCode2 = response.status;
      if (statusCode2 >= 100 && statusCode2 < 200)
        return ["pending", statusCode2];
      if (statusCode2 >= 200 && statusCode2 < 300)
        return ["success", statusCode2];
      if (statusCode2 >= 300 && statusCode2 < 700)
        return ["failure", statusCode2];
      if (statusCode2 === "CONFIRMED")
        return ["success", 200];
      if (statusCode2 === "PENDING")
        return ["pending", 100];
      return [void 0, statusCode2];
    })();
    return {
      ...response,
      atomic,
      // @ts-expect-error: for backwards compatibility
      chainId: chainId ? hexToNumber2(chainId) : void 0,
      receipts: receipts?.map((receipt) => ({
        ...receipt,
        blockNumber: hexToBigInt(receipt.blockNumber),
        gasUsed: hexToBigInt(receipt.gasUsed),
        status: receiptStatuses[receipt.status]
      })) ?? [],
      statusCode,
      status,
      version: version5
    };
  }
  var init_getCallsStatus = __esm({
    "node_modules/viem/_esm/actions/wallet/getCallsStatus.js"() {
      init_slice();
      init_trim();
      init_fromHex();
      init_transactionReceipt();
      init_sendCalls();
    }
  });

  // node_modules/viem/_esm/actions/wallet/waitForCallsStatus.js
  async function waitForCallsStatus(client, parameters) {
    const { id: id2, pollingInterval = client.pollingInterval, status = ({ statusCode }) => statusCode >= 200, timeout = 6e4 } = parameters;
    const observerId = stringify3(["waitForCallsStatus", client.uid, id2]);
    const { promise, resolve, reject } = withResolvers();
    let timer = void 0;
    const unobserve = observe(observerId, { resolve, reject }, (emit2) => {
      const unpoll = poll(async () => {
        const done = (fn) => {
          clearTimeout(timer);
          unpoll();
          fn();
          unobserve();
        };
        try {
          const result = await getCallsStatus(client, { id: id2 });
          if (!status(result))
            return;
          done(() => emit2.resolve(result));
        } catch (error) {
          done(() => emit2.reject(error));
        }
      }, {
        interval: pollingInterval,
        emitOnBegin: true
      });
      return unpoll;
    });
    timer = timeout ? setTimeout(() => {
      unobserve();
      clearTimeout(timer);
      reject(new WaitForCallsStatusTimeoutError({ id: id2 }));
    }, timeout) : void 0;
    return await promise;
  }
  var WaitForCallsStatusTimeoutError;
  var init_waitForCallsStatus = __esm({
    "node_modules/viem/_esm/actions/wallet/waitForCallsStatus.js"() {
      init_base();
      init_observe();
      init_poll();
      init_withResolvers();
      init_stringify();
      init_getCallsStatus();
      WaitForCallsStatusTimeoutError = class extends BaseError2 {
        constructor({ id: id2 }) {
          super(`Timed out while waiting for call bundle with id "${id2}" to be confirmed.`, { name: "WaitForCallsStatusTimeoutError" });
        }
      };
    }
  });

  // node_modules/viem/_esm/utils/uid.js
  function uid(length = 11) {
    if (!buffer || index + length > size4 * 2) {
      buffer = "";
      index = 0;
      for (let i = 0; i < size4; i++) {
        buffer += (256 + Math.random() * 256 | 0).toString(16).substring(1);
      }
    }
    return buffer.substring(index, index++ + length);
  }
  var size4, index, buffer;
  var init_uid = __esm({
    "node_modules/viem/_esm/utils/uid.js"() {
      size4 = 256;
      index = size4;
    }
  });

  // node_modules/viem/_esm/clients/createClient.js
  function createClient(parameters) {
    const { batch, chain, ccipRead, key = "base", name = "Base Client", type = "base" } = parameters;
    const blockTime = chain?.blockTime ?? 12e3;
    const defaultPollingInterval = Math.min(Math.max(Math.floor(blockTime / 2), 500), 4e3);
    const pollingInterval = parameters.pollingInterval ?? defaultPollingInterval;
    const cacheTime = parameters.cacheTime ?? pollingInterval;
    const account = parameters.account ? parseAccount(parameters.account) : void 0;
    const { config, request, value } = parameters.transport({
      chain,
      pollingInterval
    });
    const transport = { ...config, ...value };
    const client = {
      account,
      batch,
      cacheTime,
      ccipRead,
      chain,
      key,
      name,
      pollingInterval,
      request,
      transport,
      type,
      uid: uid()
    };
    function extend(base) {
      return (extendFn) => {
        const extended = extendFn(base);
        for (const key2 in client)
          delete extended[key2];
        const combined = { ...base, ...extended };
        return Object.assign(combined, { extend: extend(combined) });
      };
    }
    return Object.assign(client, { extend: extend(client) });
  }
  var init_createClient = __esm({
    "node_modules/viem/_esm/clients/createClient.js"() {
      init_parseAccount();
      init_uid();
    }
  });

  // node_modules/viem/_esm/utils/promise/withDedupe.js
  function withDedupe(fn, { enabled = true, id: id2 }) {
    if (!enabled || !id2)
      return fn();
    if (promiseCache2.get(id2))
      return promiseCache2.get(id2);
    const promise = fn().finally(() => promiseCache2.delete(id2));
    promiseCache2.set(id2, promise);
    return promise;
  }
  var promiseCache2;
  var init_withDedupe = __esm({
    "node_modules/viem/_esm/utils/promise/withDedupe.js"() {
      init_lru();
      promiseCache2 = /* @__PURE__ */ new LruMap(8192);
    }
  });

  // node_modules/viem/_esm/utils/promise/withRetry.js
  function withRetry(fn, { delay: delay_ = 100, retryCount = 2, shouldRetry: shouldRetry2 = () => true } = {}) {
    return new Promise((resolve, reject) => {
      const attemptRetry = async ({ count = 0 } = {}) => {
        const retry = async ({ error }) => {
          const delay = typeof delay_ === "function" ? delay_({ count, error }) : delay_;
          if (delay)
            await wait2(delay);
          attemptRetry({ count: count + 1 });
        };
        try {
          const data = await fn();
          resolve(data);
        } catch (err) {
          if (count < retryCount && await shouldRetry2({ count, error: err }))
            return retry({ error: err });
          reject(err);
        }
      };
      attemptRetry();
    });
  }
  var init_withRetry = __esm({
    "node_modules/viem/_esm/utils/promise/withRetry.js"() {
      init_wait();
    }
  });

  // node_modules/viem/_esm/utils/buildRequest.js
  function buildRequest(request, options = {}) {
    return async (args, overrideOptions = {}) => {
      const { dedupe = false, methods, retryDelay = 150, retryCount = 3, uid: uid2 } = {
        ...options,
        ...overrideOptions
      };
      const { method } = args;
      if (methods?.exclude?.includes(method))
        throw new MethodNotSupportedRpcError(new Error("method not supported"), {
          method
        });
      if (methods?.include && !methods.include.includes(method))
        throw new MethodNotSupportedRpcError(new Error("method not supported"), {
          method
        });
      const requestId = dedupe ? stringToHex(`${uid2}.${stringify3(args)}`) : void 0;
      return withDedupe(() => withRetry(async () => {
        try {
          return await request(args);
        } catch (err_) {
          const err = err_;
          switch (err.code) {
            // -32700
            case ParseRpcError.code:
              throw new ParseRpcError(err);
            // -32600
            case InvalidRequestRpcError.code:
              throw new InvalidRequestRpcError(err);
            // -32601
            case MethodNotFoundRpcError.code:
              throw new MethodNotFoundRpcError(err, { method: args.method });
            // -32602
            case InvalidParamsRpcError.code:
              throw new InvalidParamsRpcError(err);
            // -32603
            case InternalRpcError.code:
              throw new InternalRpcError(err);
            // -32000
            case InvalidInputRpcError.code:
              throw new InvalidInputRpcError(err);
            // -32001
            case ResourceNotFoundRpcError.code:
              throw new ResourceNotFoundRpcError(err);
            // -32002
            case ResourceUnavailableRpcError.code:
              throw new ResourceUnavailableRpcError(err);
            // -32003
            case TransactionRejectedRpcError.code:
              throw new TransactionRejectedRpcError(err);
            // -32004
            case MethodNotSupportedRpcError.code:
              throw new MethodNotSupportedRpcError(err, {
                method: args.method
              });
            // -32005
            case LimitExceededRpcError.code:
              throw new LimitExceededRpcError(err);
            // -32006
            case JsonRpcVersionUnsupportedError.code:
              throw new JsonRpcVersionUnsupportedError(err);
            // 4001
            case UserRejectedRequestError.code:
              throw new UserRejectedRequestError(err);
            // 4100
            case UnauthorizedProviderError.code:
              throw new UnauthorizedProviderError(err);
            // 4200
            case UnsupportedProviderMethodError.code:
              throw new UnsupportedProviderMethodError(err);
            // 4900
            case ProviderDisconnectedError.code:
              throw new ProviderDisconnectedError(err);
            // 4901
            case ChainDisconnectedError.code:
              throw new ChainDisconnectedError(err);
            // 4902
            case SwitchChainError.code:
              throw new SwitchChainError(err);
            // 5700
            case UnsupportedNonOptionalCapabilityError.code:
              throw new UnsupportedNonOptionalCapabilityError(err);
            // 5710
            case UnsupportedChainIdError.code:
              throw new UnsupportedChainIdError(err);
            // 5720
            case DuplicateIdError.code:
              throw new DuplicateIdError(err);
            // 5730
            case UnknownBundleIdError.code:
              throw new UnknownBundleIdError(err);
            // 5740
            case BundleTooLargeError.code:
              throw new BundleTooLargeError(err);
            // 5750
            case AtomicReadyWalletRejectedUpgradeError.code:
              throw new AtomicReadyWalletRejectedUpgradeError(err);
            // 5760
            case AtomicityNotSupportedError.code:
              throw new AtomicityNotSupportedError(err);
            // CAIP-25: User Rejected Error
            // https://docs.walletconnect.com/2.0/specs/clients/sign/error-codes#rejected-caip-25
            case 5e3:
              throw new UserRejectedRequestError(err);
            default:
              if (err_ instanceof BaseError2)
                throw err_;
              throw new UnknownRpcError(err);
          }
        }
      }, {
        delay: ({ count, error }) => {
          if (error && error instanceof HttpRequestError) {
            const retryAfter = error?.headers?.get("Retry-After");
            if (retryAfter?.match(/\d/))
              return Number.parseInt(retryAfter) * 1e3;
          }
          return ~~(1 << count) * retryDelay;
        },
        retryCount,
        shouldRetry: ({ error }) => shouldRetry(error)
      }), { enabled: dedupe, id: requestId });
    };
  }
  function shouldRetry(error) {
    if ("code" in error && typeof error.code === "number") {
      if (error.code === -1)
        return true;
      if (error.code === LimitExceededRpcError.code)
        return true;
      if (error.code === InternalRpcError.code)
        return true;
      return false;
    }
    if (error instanceof HttpRequestError && error.status) {
      if (error.status === 403)
        return true;
      if (error.status === 408)
        return true;
      if (error.status === 413)
        return true;
      if (error.status === 429)
        return true;
      if (error.status === 500)
        return true;
      if (error.status === 502)
        return true;
      if (error.status === 503)
        return true;
      if (error.status === 504)
        return true;
      return false;
    }
    return true;
  }
  var init_buildRequest = __esm({
    "node_modules/viem/_esm/utils/buildRequest.js"() {
      init_base();
      init_request();
      init_rpc();
      init_toHex();
      init_withDedupe();
      init_withRetry();
      init_stringify();
    }
  });

  // node_modules/viem/_esm/clients/transports/createTransport.js
  function createTransport({ key, methods, name, request, retryCount = 3, retryDelay = 150, timeout, type }, value) {
    const uid2 = uid();
    return {
      config: {
        key,
        methods,
        name,
        request,
        retryCount,
        retryDelay,
        timeout,
        type
      },
      request: buildRequest(request, { methods, retryCount, retryDelay, uid: uid2 }),
      value
    };
  }
  var init_createTransport = __esm({
    "node_modules/viem/_esm/clients/transports/createTransport.js"() {
      init_buildRequest();
      init_uid();
    }
  });

  // node_modules/viem/_esm/errors/transport.js
  var UrlRequiredError;
  var init_transport = __esm({
    "node_modules/viem/_esm/errors/transport.js"() {
      init_base();
      UrlRequiredError = class extends BaseError2 {
        constructor() {
          super("No URL was provided to the Transport. Please provide a valid RPC URL to the Transport.", {
            docsPath: "/docs/clients/intro",
            name: "UrlRequiredError"
          });
        }
      };
    }
  });

  // node_modules/viem/_esm/utils/promise/withTimeout.js
  function withTimeout(fn, { errorInstance = new Error("timed out"), timeout, signal }) {
    return new Promise((resolve, reject) => {
      ;
      (async () => {
        let timeoutId;
        try {
          const controller = new AbortController();
          if (timeout > 0) {
            timeoutId = setTimeout(() => {
              if (signal) {
                controller.abort();
              } else {
                reject(errorInstance);
              }
            }, timeout);
          }
          resolve(await fn({ signal: controller?.signal || null }));
        } catch (err) {
          if (err?.name === "AbortError")
            reject(errorInstance);
          reject(err);
        } finally {
          clearTimeout(timeoutId);
        }
      })();
    });
  }
  var init_withTimeout = __esm({
    "node_modules/viem/_esm/utils/promise/withTimeout.js"() {
    }
  });

  // node_modules/viem/_esm/utils/rpc/id.js
  function createIdStore() {
    return {
      current: 0,
      take() {
        return this.current++;
      },
      reset() {
        this.current = 0;
      }
    };
  }
  var idCache;
  var init_id2 = __esm({
    "node_modules/viem/_esm/utils/rpc/id.js"() {
      idCache = /* @__PURE__ */ createIdStore();
    }
  });

  // node_modules/viem/_esm/utils/rpc/http.js
  function getHttpRpcClient(url, options = {}) {
    return {
      async request(params) {
        const { body, onRequest = options.onRequest, onResponse = options.onResponse, timeout = options.timeout ?? 1e4 } = params;
        const fetchOptions = {
          ...options.fetchOptions ?? {},
          ...params.fetchOptions ?? {}
        };
        const { headers, method, signal: signal_ } = fetchOptions;
        try {
          const response = await withTimeout(async ({ signal }) => {
            const init2 = {
              ...fetchOptions,
              body: Array.isArray(body) ? stringify3(body.map((body2) => ({
                jsonrpc: "2.0",
                id: body2.id ?? idCache.take(),
                ...body2
              }))) : stringify3({
                jsonrpc: "2.0",
                id: body.id ?? idCache.take(),
                ...body
              }),
              headers: {
                "Content-Type": "application/json",
                ...headers
              },
              method: method || "POST",
              signal: signal_ || (timeout > 0 ? signal : null)
            };
            const request = new Request(url, init2);
            const args = await onRequest?.(request, init2) ?? { ...init2, url };
            const response2 = await fetch(args.url ?? url, args);
            return response2;
          }, {
            errorInstance: new TimeoutError({ body, url }),
            timeout,
            signal: true
          });
          if (onResponse)
            await onResponse(response);
          let data;
          if (response.headers.get("Content-Type")?.startsWith("application/json"))
            data = await response.json();
          else {
            data = await response.text();
            try {
              data = JSON.parse(data || "{}");
            } catch (err) {
              if (response.ok)
                throw err;
              data = { error: data };
            }
          }
          if (!response.ok) {
            throw new HttpRequestError({
              body,
              details: stringify3(data.error) || response.statusText,
              headers: response.headers,
              status: response.status,
              url
            });
          }
          return data;
        } catch (err) {
          if (err instanceof HttpRequestError)
            throw err;
          if (err instanceof TimeoutError)
            throw err;
          throw new HttpRequestError({
            body,
            cause: err,
            url
          });
        }
      }
    };
  }
  var init_http = __esm({
    "node_modules/viem/_esm/utils/rpc/http.js"() {
      init_request();
      init_withTimeout();
      init_stringify();
      init_id2();
    }
  });

  // node_modules/viem/_esm/clients/transports/http.js
  function http(url, config = {}) {
    const { batch, fetchOptions, key = "http", methods, name = "HTTP JSON-RPC", onFetchRequest, onFetchResponse, retryDelay, raw } = config;
    return ({ chain, retryCount: retryCount_, timeout: timeout_ }) => {
      const { batchSize = 1e3, wait: wait3 = 0 } = typeof batch === "object" ? batch : {};
      const retryCount = config.retryCount ?? retryCount_;
      const timeout = timeout_ ?? config.timeout ?? 1e4;
      const url_ = url || chain?.rpcUrls.default.http[0];
      if (!url_)
        throw new UrlRequiredError();
      const rpcClient = getHttpRpcClient(url_, {
        fetchOptions,
        onRequest: onFetchRequest,
        onResponse: onFetchResponse,
        timeout
      });
      return createTransport({
        key,
        methods,
        name,
        async request({ method, params }) {
          const body = { method, params };
          const { schedule } = createBatchScheduler({
            id: url_,
            wait: wait3,
            shouldSplitBatch(requests) {
              return requests.length > batchSize;
            },
            fn: (body2) => rpcClient.request({
              body: body2
            }),
            sort: (a, b2) => a.id - b2.id
          });
          const fn = async (body2) => batch ? schedule(body2) : [
            await rpcClient.request({
              body: body2
            })
          ];
          const [{ error, result }] = await fn(body);
          if (raw)
            return { error, result };
          if (error)
            throw new RpcRequestError({
              body,
              error,
              url: url_
            });
          return result;
        },
        retryCount,
        retryDelay,
        timeout,
        type: "http"
      }, {
        fetchOptions,
        url: url_
      });
    };
  }
  var init_http2 = __esm({
    "node_modules/viem/_esm/clients/transports/http.js"() {
      init_request();
      init_transport();
      init_createBatchScheduler();
      init_http();
      init_createTransport();
    }
  });

  // node_modules/viem/_esm/utils/ens/errors.js
  function isNullUniversalResolverError(err, callType) {
    if (!(err instanceof BaseError2))
      return false;
    const cause = err.walk((e) => e instanceof ContractFunctionRevertedError);
    if (!(cause instanceof ContractFunctionRevertedError))
      return false;
    if (cause.data?.errorName === "ResolverNotFound")
      return true;
    if (cause.data?.errorName === "ResolverWildcardNotSupported")
      return true;
    if (cause.data?.errorName === "ResolverNotContract")
      return true;
    if (cause.data?.errorName === "ResolverError")
      return true;
    if (cause.data?.errorName === "HttpError")
      return true;
    if (cause.reason?.includes("Wildcard on non-extended resolvers is not supported"))
      return true;
    if (callType === "reverse" && cause.reason === panicReasons[50])
      return true;
    return false;
  }
  var init_errors4 = __esm({
    "node_modules/viem/_esm/utils/ens/errors.js"() {
      init_solidity2();
      init_base();
      init_contract3();
    }
  });

  // node_modules/viem/_esm/utils/ens/encodedLabelToLabelhash.js
  function encodedLabelToLabelhash(label) {
    if (label.length !== 66)
      return null;
    if (label.indexOf("[") !== 0)
      return null;
    if (label.indexOf("]") !== 65)
      return null;
    const hash3 = `0x${label.slice(1, 65)}`;
    if (!isHex(hash3))
      return null;
    return hash3;
  }
  var init_encodedLabelToLabelhash = __esm({
    "node_modules/viem/_esm/utils/ens/encodedLabelToLabelhash.js"() {
      init_isHex();
    }
  });

  // node_modules/viem/_esm/utils/ens/namehash.js
  function namehash2(name) {
    let result = new Uint8Array(32).fill(0);
    if (!name)
      return bytesToHex2(result);
    const labels = name.split(".");
    for (let i = labels.length - 1; i >= 0; i -= 1) {
      const hashFromEncodedLabel = encodedLabelToLabelhash(labels[i]);
      const hashed = hashFromEncodedLabel ? toBytes2(hashFromEncodedLabel) : keccak2562(stringToBytes(labels[i]), "bytes");
      result = keccak2562(concat2([result, hashed]), "bytes");
    }
    return bytesToHex2(result);
  }
  var init_namehash2 = __esm({
    "node_modules/viem/_esm/utils/ens/namehash.js"() {
      init_concat();
      init_toBytes();
      init_toHex();
      init_keccak256();
      init_encodedLabelToLabelhash();
    }
  });

  // node_modules/viem/_esm/utils/ens/encodeLabelhash.js
  function encodeLabelhash(hash3) {
    return `[${hash3.slice(2)}]`;
  }
  var init_encodeLabelhash = __esm({
    "node_modules/viem/_esm/utils/ens/encodeLabelhash.js"() {
    }
  });

  // node_modules/viem/_esm/utils/ens/labelhash.js
  function labelhash(label) {
    const result = new Uint8Array(32).fill(0);
    if (!label)
      return bytesToHex2(result);
    return encodedLabelToLabelhash(label) || keccak2562(stringToBytes(label));
  }
  var init_labelhash = __esm({
    "node_modules/viem/_esm/utils/ens/labelhash.js"() {
      init_toBytes();
      init_toHex();
      init_keccak256();
      init_encodedLabelToLabelhash();
    }
  });

  // node_modules/viem/_esm/utils/ens/packetToBytes.js
  function packetToBytes(packet) {
    const value = packet.replace(/^\.|\.$/gm, "");
    if (value.length === 0)
      return new Uint8Array(1);
    const bytes2 = new Uint8Array(stringToBytes(value).byteLength + 2);
    let offset = 0;
    const list = value.split(".");
    for (let i = 0; i < list.length; i++) {
      let encoded = stringToBytes(list[i]);
      if (encoded.byteLength > 255)
        encoded = stringToBytes(encodeLabelhash(labelhash(list[i])));
      bytes2[offset] = encoded.length;
      bytes2.set(encoded, offset + 1);
      offset += encoded.length + 1;
    }
    if (bytes2.byteLength !== offset + 1)
      return bytes2.slice(0, offset + 1);
    return bytes2;
  }
  var init_packetToBytes = __esm({
    "node_modules/viem/_esm/utils/ens/packetToBytes.js"() {
      init_toBytes();
      init_encodeLabelhash();
      init_labelhash();
    }
  });

  // node_modules/viem/_esm/actions/ens/getEnsAddress.js
  async function getEnsAddress(client, parameters) {
    const { blockNumber, blockTag, coinType, name, gatewayUrls, strict } = parameters;
    const { chain } = client;
    const universalResolverAddress = (() => {
      if (parameters.universalResolverAddress)
        return parameters.universalResolverAddress;
      if (!chain)
        throw new Error("client chain not configured. universalResolverAddress is required.");
      return getChainContractAddress({
        blockNumber,
        chain,
        contract: "ensUniversalResolver"
      });
    })();
    const tlds = chain?.ensTlds;
    if (tlds && !tlds.some((tld) => name.endsWith(tld)))
      return null;
    try {
      const functionData = encodeFunctionData({
        abi: addressResolverAbi,
        functionName: "addr",
        ...coinType != null ? { args: [namehash2(name), BigInt(coinType)] } : { args: [namehash2(name)] }
      });
      const readContractParameters = {
        address: universalResolverAddress,
        abi: universalResolverResolveAbi,
        functionName: "resolve",
        args: [
          toHex(packetToBytes(name)),
          functionData,
          gatewayUrls ?? [localBatchGatewayUrl]
        ],
        blockNumber,
        blockTag
      };
      const readContractAction = getAction(client, readContract, "readContract");
      const res = await readContractAction(readContractParameters);
      if (res[0] === "0x")
        return null;
      const address = decodeFunctionResult({
        abi: addressResolverAbi,
        args: coinType != null ? [namehash2(name), BigInt(coinType)] : void 0,
        functionName: "addr",
        data: res[0]
      });
      if (address === "0x")
        return null;
      if (trim(address) === "0x00")
        return null;
      return address;
    } catch (err) {
      if (strict)
        throw err;
      if (isNullUniversalResolverError(err, "resolve"))
        return null;
      throw err;
    }
  }
  var init_getEnsAddress = __esm({
    "node_modules/viem/_esm/actions/ens/getEnsAddress.js"() {
      init_abis();
      init_decodeFunctionResult();
      init_encodeFunctionData();
      init_getChainContractAddress();
      init_trim();
      init_toHex();
      init_errors4();
      init_localBatchGatewayRequest();
      init_namehash2();
      init_packetToBytes();
      init_getAction();
      init_readContract();
    }
  });

  // node_modules/viem/_esm/errors/ens.js
  var EnsAvatarInvalidMetadataError, EnsAvatarInvalidNftUriError, EnsAvatarUriResolutionError, EnsAvatarUnsupportedNamespaceError;
  var init_ens = __esm({
    "node_modules/viem/_esm/errors/ens.js"() {
      init_base();
      EnsAvatarInvalidMetadataError = class extends BaseError2 {
        constructor({ data }) {
          super("Unable to extract image from metadata. The metadata may be malformed or invalid.", {
            metaMessages: [
              "- Metadata must be a JSON object with at least an `image`, `image_url` or `image_data` property.",
              "",
              `Provided data: ${JSON.stringify(data)}`
            ],
            name: "EnsAvatarInvalidMetadataError"
          });
        }
      };
      EnsAvatarInvalidNftUriError = class extends BaseError2 {
        constructor({ reason }) {
          super(`ENS NFT avatar URI is invalid. ${reason}`, {
            name: "EnsAvatarInvalidNftUriError"
          });
        }
      };
      EnsAvatarUriResolutionError = class extends BaseError2 {
        constructor({ uri }) {
          super(`Unable to resolve ENS avatar URI "${uri}". The URI may be malformed, invalid, or does not respond with a valid image.`, { name: "EnsAvatarUriResolutionError" });
        }
      };
      EnsAvatarUnsupportedNamespaceError = class extends BaseError2 {
        constructor({ namespace }) {
          super(`ENS NFT avatar namespace "${namespace}" is not supported. Must be "erc721" or "erc1155".`, { name: "EnsAvatarUnsupportedNamespaceError" });
        }
      };
    }
  });

  // node_modules/viem/_esm/utils/ens/avatar/utils.js
  async function isImageUri(uri) {
    try {
      const res = await fetch(uri, { method: "HEAD" });
      if (res.status === 200) {
        const contentType = res.headers.get("content-type");
        return contentType?.startsWith("image/");
      }
      return false;
    } catch (error) {
      if (typeof error === "object" && typeof error.response !== "undefined") {
        return false;
      }
      if (!globalThis.hasOwnProperty("Image"))
        return false;
      return new Promise((resolve) => {
        const img = new Image();
        img.onload = () => {
          resolve(true);
        };
        img.onerror = () => {
          resolve(false);
        };
        img.src = uri;
      });
    }
  }
  function getGateway(custom, defaultGateway) {
    if (!custom)
      return defaultGateway;
    if (custom.endsWith("/"))
      return custom.slice(0, -1);
    return custom;
  }
  function resolveAvatarUri({ uri, gatewayUrls }) {
    const isEncoded = base64Regex.test(uri);
    if (isEncoded)
      return { uri, isOnChain: true, isEncoded };
    const ipfsGateway = getGateway(gatewayUrls?.ipfs, "https://ipfs.io");
    const arweaveGateway = getGateway(gatewayUrls?.arweave, "https://arweave.net");
    const networkRegexMatch = uri.match(networkRegex);
    const { protocol, subpath, target, subtarget = "" } = networkRegexMatch?.groups || {};
    const isIPNS = protocol === "ipns:/" || subpath === "ipns/";
    const isIPFS = protocol === "ipfs:/" || subpath === "ipfs/" || ipfsHashRegex.test(uri);
    if (uri.startsWith("http") && !isIPNS && !isIPFS) {
      let replacedUri = uri;
      if (gatewayUrls?.arweave)
        replacedUri = uri.replace(/https:\/\/arweave.net/g, gatewayUrls?.arweave);
      return { uri: replacedUri, isOnChain: false, isEncoded: false };
    }
    if ((isIPNS || isIPFS) && target) {
      return {
        uri: `${ipfsGateway}/${isIPNS ? "ipns" : "ipfs"}/${target}${subtarget}`,
        isOnChain: false,
        isEncoded: false
      };
    }
    if (protocol === "ar:/" && target) {
      return {
        uri: `${arweaveGateway}/${target}${subtarget || ""}`,
        isOnChain: false,
        isEncoded: false
      };
    }
    let parsedUri = uri.replace(dataURIRegex, "");
    if (parsedUri.startsWith("<svg")) {
      parsedUri = `data:image/svg+xml;base64,${btoa(parsedUri)}`;
    }
    if (parsedUri.startsWith("data:") || parsedUri.startsWith("{")) {
      return {
        uri: parsedUri,
        isOnChain: true,
        isEncoded: false
      };
    }
    throw new EnsAvatarUriResolutionError({ uri });
  }
  function getJsonImage(data) {
    if (typeof data !== "object" || !("image" in data) && !("image_url" in data) && !("image_data" in data)) {
      throw new EnsAvatarInvalidMetadataError({ data });
    }
    return data.image || data.image_url || data.image_data;
  }
  async function getMetadataAvatarUri({ gatewayUrls, uri }) {
    try {
      const res = await fetch(uri).then((res2) => res2.json());
      const image = await parseAvatarUri({
        gatewayUrls,
        uri: getJsonImage(res)
      });
      return image;
    } catch {
      throw new EnsAvatarUriResolutionError({ uri });
    }
  }
  async function parseAvatarUri({ gatewayUrls, uri }) {
    const { uri: resolvedURI, isOnChain } = resolveAvatarUri({ uri, gatewayUrls });
    if (isOnChain)
      return resolvedURI;
    const isImage = await isImageUri(resolvedURI);
    if (isImage)
      return resolvedURI;
    throw new EnsAvatarUriResolutionError({ uri });
  }
  function parseNftUri(uri_) {
    let uri = uri_;
    if (uri.startsWith("did:nft:")) {
      uri = uri.replace("did:nft:", "").replace(/_/g, "/");
    }
    const [reference, asset_namespace, tokenID] = uri.split("/");
    const [eip_namespace, chainID] = reference.split(":");
    const [erc_namespace, contractAddress] = asset_namespace.split(":");
    if (!eip_namespace || eip_namespace.toLowerCase() !== "eip155")
      throw new EnsAvatarInvalidNftUriError({ reason: "Only EIP-155 supported" });
    if (!chainID)
      throw new EnsAvatarInvalidNftUriError({ reason: "Chain ID not found" });
    if (!contractAddress)
      throw new EnsAvatarInvalidNftUriError({
        reason: "Contract address not found"
      });
    if (!tokenID)
      throw new EnsAvatarInvalidNftUriError({ reason: "Token ID not found" });
    if (!erc_namespace)
      throw new EnsAvatarInvalidNftUriError({ reason: "ERC namespace not found" });
    return {
      chainID: Number.parseInt(chainID),
      namespace: erc_namespace.toLowerCase(),
      contractAddress,
      tokenID
    };
  }
  async function getNftTokenUri(client, { nft }) {
    if (nft.namespace === "erc721") {
      return readContract(client, {
        address: nft.contractAddress,
        abi: [
          {
            name: "tokenURI",
            type: "function",
            stateMutability: "view",
            inputs: [{ name: "tokenId", type: "uint256" }],
            outputs: [{ name: "", type: "string" }]
          }
        ],
        functionName: "tokenURI",
        args: [BigInt(nft.tokenID)]
      });
    }
    if (nft.namespace === "erc1155") {
      return readContract(client, {
        address: nft.contractAddress,
        abi: [
          {
            name: "uri",
            type: "function",
            stateMutability: "view",
            inputs: [{ name: "_id", type: "uint256" }],
            outputs: [{ name: "", type: "string" }]
          }
        ],
        functionName: "uri",
        args: [BigInt(nft.tokenID)]
      });
    }
    throw new EnsAvatarUnsupportedNamespaceError({ namespace: nft.namespace });
  }
  var networkRegex, ipfsHashRegex, base64Regex, dataURIRegex;
  var init_utils10 = __esm({
    "node_modules/viem/_esm/utils/ens/avatar/utils.js"() {
      init_readContract();
      init_ens();
      networkRegex = /(?<protocol>https?:\/\/[^\/]*|ipfs:\/|ipns:\/|ar:\/)?(?<root>\/)?(?<subpath>ipfs\/|ipns\/)?(?<target>[\w\-.]+)(?<subtarget>\/.*)?/;
      ipfsHashRegex = /^(Qm[1-9A-HJ-NP-Za-km-z]{44,}|b[A-Za-z2-7]{58,}|B[A-Z2-7]{58,}|z[1-9A-HJ-NP-Za-km-z]{48,}|F[0-9A-F]{50,})(\/(?<target>[\w\-.]+))?(?<subtarget>\/.*)?$/;
      base64Regex = /^data:([a-zA-Z\-/+]*);base64,([^"].*)/;
      dataURIRegex = /^data:([a-zA-Z\-/+]*)?(;[a-zA-Z0-9].*?)?(,)/;
    }
  });

  // node_modules/viem/_esm/utils/ens/avatar/parseAvatarRecord.js
  async function parseAvatarRecord(client, { gatewayUrls, record }) {
    if (/eip155:/i.test(record))
      return parseNftAvatarUri(client, { gatewayUrls, record });
    return parseAvatarUri({ uri: record, gatewayUrls });
  }
  async function parseNftAvatarUri(client, { gatewayUrls, record }) {
    const nft = parseNftUri(record);
    const nftUri = await getNftTokenUri(client, { nft });
    const { uri: resolvedNftUri, isOnChain, isEncoded } = resolveAvatarUri({ uri: nftUri, gatewayUrls });
    if (isOnChain && (resolvedNftUri.includes("data:application/json;base64,") || resolvedNftUri.startsWith("{"))) {
      const encodedJson = isEncoded ? (
        // if it is encoded, decode it
        atob(resolvedNftUri.replace("data:application/json;base64,", ""))
      ) : (
        // if it isn't encoded assume it is a JSON string, but it could be anything (it will error if it is)
        resolvedNftUri
      );
      const decoded = JSON.parse(encodedJson);
      return parseAvatarUri({ uri: getJsonImage(decoded), gatewayUrls });
    }
    let uriTokenId = nft.tokenID;
    if (nft.namespace === "erc1155")
      uriTokenId = uriTokenId.replace("0x", "").padStart(64, "0");
    return getMetadataAvatarUri({
      gatewayUrls,
      uri: resolvedNftUri.replace(/(?:0x)?{id}/, uriTokenId)
    });
  }
  var init_parseAvatarRecord = __esm({
    "node_modules/viem/_esm/utils/ens/avatar/parseAvatarRecord.js"() {
      init_utils10();
    }
  });

  // node_modules/viem/_esm/actions/ens/getEnsText.js
  async function getEnsText(client, parameters) {
    const { blockNumber, blockTag, key, name, gatewayUrls, strict } = parameters;
    const { chain } = client;
    const universalResolverAddress = (() => {
      if (parameters.universalResolverAddress)
        return parameters.universalResolverAddress;
      if (!chain)
        throw new Error("client chain not configured. universalResolverAddress is required.");
      return getChainContractAddress({
        blockNumber,
        chain,
        contract: "ensUniversalResolver"
      });
    })();
    const tlds = chain?.ensTlds;
    if (tlds && !tlds.some((tld) => name.endsWith(tld)))
      return null;
    try {
      const readContractParameters = {
        address: universalResolverAddress,
        abi: universalResolverResolveAbi,
        functionName: "resolve",
        args: [
          toHex(packetToBytes(name)),
          encodeFunctionData({
            abi: textResolverAbi,
            functionName: "text",
            args: [namehash2(name), key]
          }),
          gatewayUrls ?? [localBatchGatewayUrl]
        ],
        blockNumber,
        blockTag
      };
      const readContractAction = getAction(client, readContract, "readContract");
      const res = await readContractAction(readContractParameters);
      if (res[0] === "0x")
        return null;
      const record = decodeFunctionResult({
        abi: textResolverAbi,
        functionName: "text",
        data: res[0]
      });
      return record === "" ? null : record;
    } catch (err) {
      if (strict)
        throw err;
      if (isNullUniversalResolverError(err, "resolve"))
        return null;
      throw err;
    }
  }
  var init_getEnsText = __esm({
    "node_modules/viem/_esm/actions/ens/getEnsText.js"() {
      init_abis();
      init_decodeFunctionResult();
      init_encodeFunctionData();
      init_getChainContractAddress();
      init_toHex();
      init_errors4();
      init_localBatchGatewayRequest();
      init_namehash2();
      init_packetToBytes();
      init_getAction();
      init_readContract();
    }
  });

  // node_modules/viem/_esm/actions/ens/getEnsAvatar.js
  async function getEnsAvatar(client, { blockNumber, blockTag, assetGatewayUrls, name, gatewayUrls, strict, universalResolverAddress }) {
    const record = await getAction(client, getEnsText, "getEnsText")({
      blockNumber,
      blockTag,
      key: "avatar",
      name,
      universalResolverAddress,
      gatewayUrls,
      strict
    });
    if (!record)
      return null;
    try {
      return await parseAvatarRecord(client, {
        record,
        gatewayUrls: assetGatewayUrls
      });
    } catch {
      return null;
    }
  }
  var init_getEnsAvatar = __esm({
    "node_modules/viem/_esm/actions/ens/getEnsAvatar.js"() {
      init_parseAvatarRecord();
      init_getAction();
      init_getEnsText();
    }
  });

  // node_modules/viem/_esm/actions/ens/getEnsName.js
  async function getEnsName(client, { address, blockNumber, blockTag, gatewayUrls, strict, universalResolverAddress: universalResolverAddress_ }) {
    let universalResolverAddress = universalResolverAddress_;
    if (!universalResolverAddress) {
      if (!client.chain)
        throw new Error("client chain not configured. universalResolverAddress is required.");
      universalResolverAddress = getChainContractAddress({
        blockNumber,
        chain: client.chain,
        contract: "ensUniversalResolver"
      });
    }
    const reverseNode = `${address.toLowerCase().substring(2)}.addr.reverse`;
    try {
      const readContractParameters = {
        address: universalResolverAddress,
        abi: universalResolverReverseAbi,
        functionName: "reverse",
        args: [toHex(packetToBytes(reverseNode))],
        blockNumber,
        blockTag
      };
      const readContractAction = getAction(client, readContract, "readContract");
      const [name, resolvedAddress] = gatewayUrls ? await readContractAction({
        ...readContractParameters,
        args: [...readContractParameters.args, gatewayUrls]
      }) : await readContractAction(readContractParameters);
      if (address.toLowerCase() !== resolvedAddress.toLowerCase())
        return null;
      return name;
    } catch (err) {
      if (strict)
        throw err;
      if (isNullUniversalResolverError(err, "reverse"))
        return null;
      throw err;
    }
  }
  var init_getEnsName = __esm({
    "node_modules/viem/_esm/actions/ens/getEnsName.js"() {
      init_abis();
      init_getChainContractAddress();
      init_toHex();
      init_errors4();
      init_packetToBytes();
      init_getAction();
      init_readContract();
    }
  });

  // node_modules/viem/_esm/actions/ens/getEnsResolver.js
  async function getEnsResolver(client, parameters) {
    const { blockNumber, blockTag, name } = parameters;
    const { chain } = client;
    const universalResolverAddress = (() => {
      if (parameters.universalResolverAddress)
        return parameters.universalResolverAddress;
      if (!chain)
        throw new Error("client chain not configured. universalResolverAddress is required.");
      return getChainContractAddress({
        blockNumber,
        chain,
        contract: "ensUniversalResolver"
      });
    })();
    const tlds = chain?.ensTlds;
    if (tlds && !tlds.some((tld) => name.endsWith(tld)))
      throw new Error(`${name} is not a valid ENS TLD (${tlds?.join(", ")}) for chain "${chain.name}" (id: ${chain.id}).`);
    const [resolverAddress] = await getAction(client, readContract, "readContract")({
      address: universalResolverAddress,
      abi: [
        {
          inputs: [{ type: "bytes" }],
          name: "findResolver",
          outputs: [{ type: "address" }, { type: "bytes32" }],
          stateMutability: "view",
          type: "function"
        }
      ],
      functionName: "findResolver",
      args: [toHex(packetToBytes(name))],
      blockNumber,
      blockTag
    });
    return resolverAddress;
  }
  var init_getEnsResolver = __esm({
    "node_modules/viem/_esm/actions/ens/getEnsResolver.js"() {
      init_getChainContractAddress();
      init_toHex();
      init_packetToBytes();
      init_getAction();
      init_readContract();
    }
  });

  // node_modules/viem/_esm/actions/public/createAccessList.js
  async function createAccessList(client, args) {
    const { account: account_ = client.account, blockNumber, blockTag = "latest", blobs, data, gas, gasPrice, maxFeePerBlobGas, maxFeePerGas, maxPriorityFeePerGas, to, value, ...rest } = args;
    const account = account_ ? parseAccount(account_) : void 0;
    try {
      assertRequest(args);
      const blockNumberHex = typeof blockNumber === "bigint" ? numberToHex(blockNumber) : void 0;
      const block = blockNumberHex || blockTag;
      const chainFormat = client.chain?.formatters?.transactionRequest?.format;
      const format = chainFormat || formatTransactionRequest;
      const request = format({
        // Pick out extra data that might exist on the chain's transaction request type.
        ...extract(rest, { format: chainFormat }),
        from: account?.address,
        blobs,
        data,
        gas,
        gasPrice,
        maxFeePerBlobGas,
        maxFeePerGas,
        maxPriorityFeePerGas,
        to,
        value
      });
      const response = await client.request({
        method: "eth_createAccessList",
        params: [request, block]
      });
      return {
        accessList: response.accessList,
        gasUsed: BigInt(response.gasUsed)
      };
    } catch (err) {
      throw getCallError(err, {
        ...args,
        account,
        chain: client.chain
      });
    }
  }
  var init_createAccessList = __esm({
    "node_modules/viem/_esm/actions/public/createAccessList.js"() {
      init_parseAccount();
      init_toHex();
      init_getCallError();
      init_extract();
      init_transactionRequest();
      init_assertRequest();
    }
  });

  // node_modules/viem/_esm/actions/public/createBlockFilter.js
  async function createBlockFilter(client) {
    const getRequest = createFilterRequestScope(client, {
      method: "eth_newBlockFilter"
    });
    const id2 = await client.request({
      method: "eth_newBlockFilter"
    });
    return { id: id2, request: getRequest(id2), type: "block" };
  }
  var init_createBlockFilter = __esm({
    "node_modules/viem/_esm/actions/public/createBlockFilter.js"() {
      init_createFilterRequestScope();
    }
  });

  // node_modules/viem/_esm/actions/public/createEventFilter.js
  async function createEventFilter(client, { address, args, event, events: events_, fromBlock, strict, toBlock } = {}) {
    const events = events_ ?? (event ? [event] : void 0);
    const getRequest = createFilterRequestScope(client, {
      method: "eth_newFilter"
    });
    let topics = [];
    if (events) {
      const encoded = events.flatMap((event2) => encodeEventTopics({
        abi: [event2],
        eventName: event2.name,
        args
      }));
      topics = [encoded];
      if (event)
        topics = topics[0];
    }
    const id2 = await client.request({
      method: "eth_newFilter",
      params: [
        {
          address,
          fromBlock: typeof fromBlock === "bigint" ? numberToHex(fromBlock) : fromBlock,
          toBlock: typeof toBlock === "bigint" ? numberToHex(toBlock) : toBlock,
          ...topics.length ? { topics } : {}
        }
      ]
    });
    return {
      abi: events,
      args,
      eventName: event ? event.name : void 0,
      fromBlock,
      id: id2,
      request: getRequest(id2),
      strict: Boolean(strict),
      toBlock,
      type: "event"
    };
  }
  var init_createEventFilter = __esm({
    "node_modules/viem/_esm/actions/public/createEventFilter.js"() {
      init_encodeEventTopics();
      init_toHex();
      init_createFilterRequestScope();
    }
  });

  // node_modules/viem/_esm/actions/public/createPendingTransactionFilter.js
  async function createPendingTransactionFilter(client) {
    const getRequest = createFilterRequestScope(client, {
      method: "eth_newPendingTransactionFilter"
    });
    const id2 = await client.request({
      method: "eth_newPendingTransactionFilter"
    });
    return { id: id2, request: getRequest(id2), type: "transaction" };
  }
  var init_createPendingTransactionFilter = __esm({
    "node_modules/viem/_esm/actions/public/createPendingTransactionFilter.js"() {
      init_createFilterRequestScope();
    }
  });

  // node_modules/viem/_esm/actions/public/getBlobBaseFee.js
  async function getBlobBaseFee(client) {
    const baseFee = await client.request({
      method: "eth_blobBaseFee"
    });
    return BigInt(baseFee);
  }
  var init_getBlobBaseFee = __esm({
    "node_modules/viem/_esm/actions/public/getBlobBaseFee.js"() {
    }
  });

  // node_modules/viem/_esm/actions/public/getBlockTransactionCount.js
  async function getBlockTransactionCount(client, { blockHash, blockNumber, blockTag = "latest" } = {}) {
    const blockNumberHex = blockNumber !== void 0 ? numberToHex(blockNumber) : void 0;
    let count;
    if (blockHash) {
      count = await client.request({
        method: "eth_getBlockTransactionCountByHash",
        params: [blockHash]
      }, { dedupe: true });
    } else {
      count = await client.request({
        method: "eth_getBlockTransactionCountByNumber",
        params: [blockNumberHex || blockTag]
      }, { dedupe: Boolean(blockNumberHex) });
    }
    return hexToNumber2(count);
  }
  var init_getBlockTransactionCount = __esm({
    "node_modules/viem/_esm/actions/public/getBlockTransactionCount.js"() {
      init_fromHex();
      init_toHex();
    }
  });

  // node_modules/viem/_esm/actions/public/getCode.js
  async function getCode(client, { address, blockNumber, blockTag = "latest" }) {
    const blockNumberHex = blockNumber !== void 0 ? numberToHex(blockNumber) : void 0;
    const hex = await client.request({
      method: "eth_getCode",
      params: [address, blockNumberHex || blockTag]
    }, { dedupe: Boolean(blockNumberHex) });
    if (hex === "0x")
      return void 0;
    return hex;
  }
  var init_getCode = __esm({
    "node_modules/viem/_esm/actions/public/getCode.js"() {
      init_toHex();
    }
  });

  // node_modules/viem/_esm/errors/eip712.js
  var Eip712DomainNotFoundError;
  var init_eip712 = __esm({
    "node_modules/viem/_esm/errors/eip712.js"() {
      init_base();
      Eip712DomainNotFoundError = class extends BaseError2 {
        constructor({ address }) {
          super(`No EIP-712 domain found on contract "${address}".`, {
            metaMessages: [
              "Ensure that:",
              `- The contract is deployed at the address "${address}".`,
              "- `eip712Domain()` function exists on the contract.",
              "- `eip712Domain()` function matches signature to ERC-5267 specification."
            ],
            name: "Eip712DomainNotFoundError"
          });
        }
      };
    }
  });

  // node_modules/viem/_esm/actions/public/getEip712Domain.js
  async function getEip712Domain(client, parameters) {
    const { address, factory, factoryData } = parameters;
    try {
      const [fields, name, version5, chainId, verifyingContract, salt, extensions] = await getAction(client, readContract, "readContract")({
        abi,
        address,
        functionName: "eip712Domain",
        factory,
        factoryData
      });
      return {
        domain: {
          name,
          version: version5,
          chainId: Number(chainId),
          verifyingContract,
          salt
        },
        extensions,
        fields
      };
    } catch (e) {
      const error = e;
      if (error.name === "ContractFunctionExecutionError" && error.cause.name === "ContractFunctionZeroDataError") {
        throw new Eip712DomainNotFoundError({ address });
      }
      throw error;
    }
  }
  var abi;
  var init_getEip712Domain = __esm({
    "node_modules/viem/_esm/actions/public/getEip712Domain.js"() {
      init_eip712();
      init_getAction();
      init_readContract();
      abi = [
        {
          inputs: [],
          name: "eip712Domain",
          outputs: [
            { name: "fields", type: "bytes1" },
            { name: "name", type: "string" },
            { name: "version", type: "string" },
            { name: "chainId", type: "uint256" },
            { name: "verifyingContract", type: "address" },
            { name: "salt", type: "bytes32" },
            { name: "extensions", type: "uint256[]" }
          ],
          stateMutability: "view",
          type: "function"
        }
      ];
    }
  });

  // node_modules/viem/_esm/utils/formatters/feeHistory.js
  function formatFeeHistory(feeHistory) {
    return {
      baseFeePerGas: feeHistory.baseFeePerGas.map((value) => BigInt(value)),
      gasUsedRatio: feeHistory.gasUsedRatio,
      oldestBlock: BigInt(feeHistory.oldestBlock),
      reward: feeHistory.reward?.map((reward) => reward.map((value) => BigInt(value)))
    };
  }
  var init_feeHistory = __esm({
    "node_modules/viem/_esm/utils/formatters/feeHistory.js"() {
    }
  });

  // node_modules/viem/_esm/actions/public/getFeeHistory.js
  async function getFeeHistory(client, { blockCount, blockNumber, blockTag = "latest", rewardPercentiles }) {
    const blockNumberHex = typeof blockNumber === "bigint" ? numberToHex(blockNumber) : void 0;
    const feeHistory = await client.request({
      method: "eth_feeHistory",
      params: [
        numberToHex(blockCount),
        blockNumberHex || blockTag,
        rewardPercentiles
      ]
    }, { dedupe: Boolean(blockNumberHex) });
    return formatFeeHistory(feeHistory);
  }
  var init_getFeeHistory = __esm({
    "node_modules/viem/_esm/actions/public/getFeeHistory.js"() {
      init_toHex();
      init_feeHistory();
    }
  });

  // node_modules/viem/_esm/actions/public/getFilterLogs.js
  async function getFilterLogs(_client, { filter }) {
    const strict = filter.strict ?? false;
    const logs = await filter.request({
      method: "eth_getFilterLogs",
      params: [filter.id]
    });
    const formattedLogs = logs.map((log) => formatLog2(log));
    if (!filter.abi)
      return formattedLogs;
    return parseEventLogs({
      abi: filter.abi,
      logs: formattedLogs,
      strict
    });
  }
  var init_getFilterLogs = __esm({
    "node_modules/viem/_esm/actions/public/getFilterLogs.js"() {
      init_parseEventLogs();
      init_log2();
    }
  });

  // node_modules/viem/_esm/utils/chain/defineChain.js
  function defineChain(chain) {
    return {
      formatters: void 0,
      fees: void 0,
      serializers: void 0,
      ...chain
    };
  }
  var init_defineChain = __esm({
    "node_modules/viem/_esm/utils/chain/defineChain.js"() {
    }
  });

  // node_modules/viem/_esm/errors/typedData.js
  var InvalidDomainError, InvalidPrimaryTypeError, InvalidStructTypeError;
  var init_typedData = __esm({
    "node_modules/viem/_esm/errors/typedData.js"() {
      init_stringify();
      init_base();
      InvalidDomainError = class extends BaseError2 {
        constructor({ domain }) {
          super(`Invalid domain "${stringify3(domain)}".`, {
            metaMessages: ["Must be a valid EIP-712 domain."]
          });
        }
      };
      InvalidPrimaryTypeError = class extends BaseError2 {
        constructor({ primaryType, types }) {
          super(`Invalid primary type \`${primaryType}\` must be one of \`${JSON.stringify(Object.keys(types))}\`.`, {
            docsPath: "/api/glossary/Errors#typeddatainvalidprimarytypeerror",
            metaMessages: ["Check that the primary type is a key in `types`."]
          });
        }
      };
      InvalidStructTypeError = class extends BaseError2 {
        constructor({ type }) {
          super(`Struct type "${type}" is invalid.`, {
            metaMessages: ["Struct type must not be a Solidity type."],
            name: "InvalidStructTypeError"
          });
        }
      };
    }
  });

  // node_modules/viem/_esm/utils/signature/hashTypedData.js
  function hashTypedData(parameters) {
    const { domain = {}, message, primaryType } = parameters;
    const types = {
      EIP712Domain: getTypesForEIP712Domain({ domain }),
      ...parameters.types
    };
    validateTypedData({
      domain,
      message,
      primaryType,
      types
    });
    const parts = ["0x1901"];
    if (domain)
      parts.push(hashDomain({
        domain,
        types
      }));
    if (primaryType !== "EIP712Domain")
      parts.push(hashStruct({
        data: message,
        primaryType,
        types
      }));
    return keccak2562(concat2(parts));
  }
  function hashDomain({ domain, types }) {
    return hashStruct({
      data: domain,
      primaryType: "EIP712Domain",
      types
    });
  }
  function hashStruct({ data, primaryType, types }) {
    const encoded = encodeData({
      data,
      primaryType,
      types
    });
    return keccak2562(encoded);
  }
  function encodeData({ data, primaryType, types }) {
    const encodedTypes = [{ type: "bytes32" }];
    const encodedValues = [hashType({ primaryType, types })];
    for (const field of types[primaryType]) {
      const [type, value] = encodeField({
        types,
        name: field.name,
        type: field.type,
        value: data[field.name]
      });
      encodedTypes.push(type);
      encodedValues.push(value);
    }
    return encodeAbiParameters(encodedTypes, encodedValues);
  }
  function hashType({ primaryType, types }) {
    const encodedHashType = toHex(encodeType2({ primaryType, types }));
    return keccak2562(encodedHashType);
  }
  function encodeType2({ primaryType, types }) {
    let result = "";
    const unsortedDeps = findTypeDependencies({ primaryType, types });
    unsortedDeps.delete(primaryType);
    const deps = [primaryType, ...Array.from(unsortedDeps).sort()];
    for (const type of deps) {
      result += `${type}(${types[type].map(({ name, type: t }) => `${t} ${name}`).join(",")})`;
    }
    return result;
  }
  function findTypeDependencies({ primaryType: primaryType_, types }, results = /* @__PURE__ */ new Set()) {
    const match = primaryType_.match(/^\w*/u);
    const primaryType = match?.[0];
    if (results.has(primaryType) || types[primaryType] === void 0) {
      return results;
    }
    results.add(primaryType);
    for (const field of types[primaryType]) {
      findTypeDependencies({ primaryType: field.type, types }, results);
    }
    return results;
  }
  function encodeField({ types, name, type, value }) {
    if (types[type] !== void 0) {
      return [
        { type: "bytes32" },
        keccak2562(encodeData({ data: value, primaryType: type, types }))
      ];
    }
    if (type === "bytes") {
      const prepend = value.length % 2 ? "0" : "";
      value = `0x${prepend + value.slice(2)}`;
      return [{ type: "bytes32" }, keccak2562(value)];
    }
    if (type === "string")
      return [{ type: "bytes32" }, keccak2562(toHex(value))];
    if (type.lastIndexOf("]") === type.length - 1) {
      const parsedType = type.slice(0, type.lastIndexOf("["));
      const typeValuePairs = value.map((item) => encodeField({
        name,
        type: parsedType,
        types,
        value: item
      }));
      return [
        { type: "bytes32" },
        keccak2562(encodeAbiParameters(typeValuePairs.map(([t]) => t), typeValuePairs.map(([, v]) => v)))
      ];
    }
    return [{ type }, value];
  }
  var init_hashTypedData = __esm({
    "node_modules/viem/_esm/utils/signature/hashTypedData.js"() {
      init_encodeAbiParameters();
      init_concat();
      init_toHex();
      init_keccak256();
      init_typedData2();
    }
  });

  // node_modules/viem/_esm/utils/typedData.js
  function serializeTypedData(parameters) {
    const { domain: domain_, message: message_, primaryType, types } = parameters;
    const normalizeData = (struct, data_) => {
      const data = { ...data_ };
      for (const param of struct) {
        const { name, type } = param;
        if (type === "address")
          data[name] = data[name].toLowerCase();
      }
      return data;
    };
    const domain = (() => {
      if (!types.EIP712Domain)
        return {};
      if (!domain_)
        return {};
      return normalizeData(types.EIP712Domain, domain_);
    })();
    const message = (() => {
      if (primaryType === "EIP712Domain")
        return void 0;
      return normalizeData(types[primaryType], message_);
    })();
    return stringify3({ domain, message, primaryType, types });
  }
  function validateTypedData(parameters) {
    const { domain, message, primaryType, types } = parameters;
    const validateData = (struct, data) => {
      for (const param of struct) {
        const { name, type } = param;
        const value = data[name];
        const integerMatch = type.match(integerRegex2);
        if (integerMatch && (typeof value === "number" || typeof value === "bigint")) {
          const [_type2, base, size_] = integerMatch;
          numberToHex(value, {
            signed: base === "int",
            size: Number.parseInt(size_) / 8
          });
        }
        if (type === "address" && typeof value === "string" && !isAddress2(value))
          throw new InvalidAddressError({ address: value });
        const bytesMatch = type.match(bytesRegex2);
        if (bytesMatch) {
          const [_type2, size_] = bytesMatch;
          if (size_ && size(value) !== Number.parseInt(size_))
            throw new BytesSizeMismatchError({
              expectedSize: Number.parseInt(size_),
              givenSize: size(value)
            });
        }
        const struct2 = types[type];
        if (struct2) {
          validateReference(type);
          validateData(struct2, value);
        }
      }
    };
    if (types.EIP712Domain && domain) {
      if (typeof domain !== "object")
        throw new InvalidDomainError({ domain });
      validateData(types.EIP712Domain, domain);
    }
    if (primaryType !== "EIP712Domain") {
      if (types[primaryType])
        validateData(types[primaryType], message);
      else
        throw new InvalidPrimaryTypeError({ primaryType, types });
    }
  }
  function getTypesForEIP712Domain({ domain }) {
    return [
      typeof domain?.name === "string" && { name: "name", type: "string" },
      domain?.version && { name: "version", type: "string" },
      (typeof domain?.chainId === "number" || typeof domain?.chainId === "bigint") && {
        name: "chainId",
        type: "uint256"
      },
      domain?.verifyingContract && {
        name: "verifyingContract",
        type: "address"
      },
      domain?.salt && { name: "salt", type: "bytes32" }
    ].filter(Boolean);
  }
  function validateReference(type) {
    if (type === "address" || type === "bool" || type === "string" || type.startsWith("bytes") || type.startsWith("uint") || type.startsWith("int"))
      throw new InvalidStructTypeError({ type });
  }
  var init_typedData2 = __esm({
    "node_modules/viem/_esm/utils/typedData.js"() {
      init_abi2();
      init_address5();
      init_typedData();
      init_isAddress();
      init_size();
      init_toHex();
      init_regex2();
      init_stringify();
    }
  });

  // node_modules/viem/_esm/utils/transaction/assertTransaction.js
  function assertTransactionEIP7702(transaction) {
    const { authorizationList } = transaction;
    if (authorizationList) {
      for (const authorization of authorizationList) {
        const { chainId } = authorization;
        const address = authorization.address;
        if (!isAddress2(address))
          throw new InvalidAddressError({ address });
        if (chainId < 0)
          throw new InvalidChainIdError({ chainId });
      }
    }
    assertTransactionEIP1559(transaction);
  }
  function assertTransactionEIP4844(transaction) {
    const { blobVersionedHashes } = transaction;
    if (blobVersionedHashes) {
      if (blobVersionedHashes.length === 0)
        throw new EmptyBlobError();
      for (const hash3 of blobVersionedHashes) {
        const size_ = size(hash3);
        const version5 = hexToNumber2(slice(hash3, 0, 1));
        if (size_ !== 32)
          throw new InvalidVersionedHashSizeError({ hash: hash3, size: size_ });
        if (version5 !== versionedHashVersionKzg)
          throw new InvalidVersionedHashVersionError({
            hash: hash3,
            version: version5
          });
      }
    }
    assertTransactionEIP1559(transaction);
  }
  function assertTransactionEIP1559(transaction) {
    const { chainId, maxPriorityFeePerGas, maxFeePerGas, to } = transaction;
    if (chainId <= 0)
      throw new InvalidChainIdError({ chainId });
    if (to && !isAddress2(to))
      throw new InvalidAddressError({ address: to });
    if (maxFeePerGas && maxFeePerGas > maxUint256)
      throw new FeeCapTooHighError({ maxFeePerGas });
    if (maxPriorityFeePerGas && maxFeePerGas && maxPriorityFeePerGas > maxFeePerGas)
      throw new TipAboveFeeCapError({ maxFeePerGas, maxPriorityFeePerGas });
  }
  function assertTransactionEIP2930(transaction) {
    const { chainId, maxPriorityFeePerGas, gasPrice, maxFeePerGas, to } = transaction;
    if (chainId <= 0)
      throw new InvalidChainIdError({ chainId });
    if (to && !isAddress2(to))
      throw new InvalidAddressError({ address: to });
    if (maxPriorityFeePerGas || maxFeePerGas)
      throw new BaseError2("`maxFeePerGas`/`maxPriorityFeePerGas` is not a valid EIP-2930 Transaction attribute.");
    if (gasPrice && gasPrice > maxUint256)
      throw new FeeCapTooHighError({ maxFeePerGas: gasPrice });
  }
  function assertTransactionLegacy(transaction) {
    const { chainId, maxPriorityFeePerGas, gasPrice, maxFeePerGas, to } = transaction;
    if (to && !isAddress2(to))
      throw new InvalidAddressError({ address: to });
    if (typeof chainId !== "undefined" && chainId <= 0)
      throw new InvalidChainIdError({ chainId });
    if (maxPriorityFeePerGas || maxFeePerGas)
      throw new BaseError2("`maxFeePerGas`/`maxPriorityFeePerGas` is not a valid Legacy Transaction attribute.");
    if (gasPrice && gasPrice > maxUint256)
      throw new FeeCapTooHighError({ maxFeePerGas: gasPrice });
  }
  var init_assertTransaction = __esm({
    "node_modules/viem/_esm/utils/transaction/assertTransaction.js"() {
      init_kzg();
      init_number2();
      init_address5();
      init_base();
      init_blob2();
      init_chain();
      init_node();
      init_isAddress();
      init_size();
      init_slice();
      init_fromHex();
    }
  });

  // node_modules/viem/_esm/utils/transaction/serializeAccessList.js
  function serializeAccessList(accessList) {
    if (!accessList || accessList.length === 0)
      return [];
    const serializedAccessList = [];
    for (let i = 0; i < accessList.length; i++) {
      const { address, storageKeys } = accessList[i];
      for (let j = 0; j < storageKeys.length; j++) {
        if (storageKeys[j].length - 2 !== 64) {
          throw new InvalidStorageKeySizeError({ storageKey: storageKeys[j] });
        }
      }
      if (!isAddress2(address, { strict: false })) {
        throw new InvalidAddressError({ address });
      }
      serializedAccessList.push([address, storageKeys]);
    }
    return serializedAccessList;
  }
  var init_serializeAccessList = __esm({
    "node_modules/viem/_esm/utils/transaction/serializeAccessList.js"() {
      init_address5();
      init_transaction3();
      init_isAddress();
    }
  });

  // node_modules/viem/_esm/utils/transaction/serializeTransaction.js
  function serializeTransaction(transaction, signature) {
    const type = getTransactionType(transaction);
    if (type === "eip1559")
      return serializeTransactionEIP1559(transaction, signature);
    if (type === "eip2930")
      return serializeTransactionEIP2930(transaction, signature);
    if (type === "eip4844")
      return serializeTransactionEIP4844(transaction, signature);
    if (type === "eip7702")
      return serializeTransactionEIP7702(transaction, signature);
    return serializeTransactionLegacy(transaction, signature);
  }
  function serializeTransactionEIP7702(transaction, signature) {
    const { authorizationList, chainId, gas, nonce, to, value, maxFeePerGas, maxPriorityFeePerGas, accessList, data } = transaction;
    assertTransactionEIP7702(transaction);
    const serializedAccessList = serializeAccessList(accessList);
    const serializedAuthorizationList = serializeAuthorizationList(authorizationList);
    return concatHex([
      "0x04",
      toRlp([
        numberToHex(chainId),
        nonce ? numberToHex(nonce) : "0x",
        maxPriorityFeePerGas ? numberToHex(maxPriorityFeePerGas) : "0x",
        maxFeePerGas ? numberToHex(maxFeePerGas) : "0x",
        gas ? numberToHex(gas) : "0x",
        to ?? "0x",
        value ? numberToHex(value) : "0x",
        data ?? "0x",
        serializedAccessList,
        serializedAuthorizationList,
        ...toYParitySignatureArray(transaction, signature)
      ])
    ]);
  }
  function serializeTransactionEIP4844(transaction, signature) {
    const { chainId, gas, nonce, to, value, maxFeePerBlobGas, maxFeePerGas, maxPriorityFeePerGas, accessList, data } = transaction;
    assertTransactionEIP4844(transaction);
    let blobVersionedHashes = transaction.blobVersionedHashes;
    let sidecars = transaction.sidecars;
    if (transaction.blobs && (typeof blobVersionedHashes === "undefined" || typeof sidecars === "undefined")) {
      const blobs2 = typeof transaction.blobs[0] === "string" ? transaction.blobs : transaction.blobs.map((x) => bytesToHex2(x));
      const kzg = transaction.kzg;
      const commitments2 = blobsToCommitments({
        blobs: blobs2,
        kzg
      });
      if (typeof blobVersionedHashes === "undefined")
        blobVersionedHashes = commitmentsToVersionedHashes({
          commitments: commitments2
        });
      if (typeof sidecars === "undefined") {
        const proofs2 = blobsToProofs({ blobs: blobs2, commitments: commitments2, kzg });
        sidecars = toBlobSidecars({ blobs: blobs2, commitments: commitments2, proofs: proofs2 });
      }
    }
    const serializedAccessList = serializeAccessList(accessList);
    const serializedTransaction = [
      numberToHex(chainId),
      nonce ? numberToHex(nonce) : "0x",
      maxPriorityFeePerGas ? numberToHex(maxPriorityFeePerGas) : "0x",
      maxFeePerGas ? numberToHex(maxFeePerGas) : "0x",
      gas ? numberToHex(gas) : "0x",
      to ?? "0x",
      value ? numberToHex(value) : "0x",
      data ?? "0x",
      serializedAccessList,
      maxFeePerBlobGas ? numberToHex(maxFeePerBlobGas) : "0x",
      blobVersionedHashes ?? [],
      ...toYParitySignatureArray(transaction, signature)
    ];
    const blobs = [];
    const commitments = [];
    const proofs = [];
    if (sidecars)
      for (let i = 0; i < sidecars.length; i++) {
        const { blob, commitment, proof } = sidecars[i];
        blobs.push(blob);
        commitments.push(commitment);
        proofs.push(proof);
      }
    return concatHex([
      "0x03",
      sidecars ? (
        // If sidecars are enabled, envelope turns into a "wrapper":
        toRlp([serializedTransaction, blobs, commitments, proofs])
      ) : (
        // If sidecars are disabled, standard envelope is used:
        toRlp(serializedTransaction)
      )
    ]);
  }
  function serializeTransactionEIP1559(transaction, signature) {
    const { chainId, gas, nonce, to, value, maxFeePerGas, maxPriorityFeePerGas, accessList, data } = transaction;
    assertTransactionEIP1559(transaction);
    const serializedAccessList = serializeAccessList(accessList);
    const serializedTransaction = [
      numberToHex(chainId),
      nonce ? numberToHex(nonce) : "0x",
      maxPriorityFeePerGas ? numberToHex(maxPriorityFeePerGas) : "0x",
      maxFeePerGas ? numberToHex(maxFeePerGas) : "0x",
      gas ? numberToHex(gas) : "0x",
      to ?? "0x",
      value ? numberToHex(value) : "0x",
      data ?? "0x",
      serializedAccessList,
      ...toYParitySignatureArray(transaction, signature)
    ];
    return concatHex([
      "0x02",
      toRlp(serializedTransaction)
    ]);
  }
  function serializeTransactionEIP2930(transaction, signature) {
    const { chainId, gas, data, nonce, to, value, accessList, gasPrice } = transaction;
    assertTransactionEIP2930(transaction);
    const serializedAccessList = serializeAccessList(accessList);
    const serializedTransaction = [
      numberToHex(chainId),
      nonce ? numberToHex(nonce) : "0x",
      gasPrice ? numberToHex(gasPrice) : "0x",
      gas ? numberToHex(gas) : "0x",
      to ?? "0x",
      value ? numberToHex(value) : "0x",
      data ?? "0x",
      serializedAccessList,
      ...toYParitySignatureArray(transaction, signature)
    ];
    return concatHex([
      "0x01",
      toRlp(serializedTransaction)
    ]);
  }
  function serializeTransactionLegacy(transaction, signature) {
    const { chainId = 0, gas, data, nonce, to, value, gasPrice } = transaction;
    assertTransactionLegacy(transaction);
    let serializedTransaction = [
      nonce ? numberToHex(nonce) : "0x",
      gasPrice ? numberToHex(gasPrice) : "0x",
      gas ? numberToHex(gas) : "0x",
      to ?? "0x",
      value ? numberToHex(value) : "0x",
      data ?? "0x"
    ];
    if (signature) {
      const v = (() => {
        if (signature.v >= 35n) {
          const inferredChainId = (signature.v - 35n) / 2n;
          if (inferredChainId > 0)
            return signature.v;
          return 27n + (signature.v === 35n ? 0n : 1n);
        }
        if (chainId > 0)
          return BigInt(chainId * 2) + BigInt(35n + signature.v - 27n);
        const v2 = 27n + (signature.v === 27n ? 0n : 1n);
        if (signature.v !== v2)
          throw new InvalidLegacyVError({ v: signature.v });
        return v2;
      })();
      const r = trim(signature.r);
      const s = trim(signature.s);
      serializedTransaction = [
        ...serializedTransaction,
        numberToHex(v),
        r === "0x00" ? "0x" : r,
        s === "0x00" ? "0x" : s
      ];
    } else if (chainId > 0) {
      serializedTransaction = [
        ...serializedTransaction,
        numberToHex(chainId),
        "0x",
        "0x"
      ];
    }
    return toRlp(serializedTransaction);
  }
  function toYParitySignatureArray(transaction, signature_) {
    const signature = signature_ ?? transaction;
    const { v, yParity } = signature;
    if (typeof signature.r === "undefined")
      return [];
    if (typeof signature.s === "undefined")
      return [];
    if (typeof v === "undefined" && typeof yParity === "undefined")
      return [];
    const r = trim(signature.r);
    const s = trim(signature.s);
    const yParity_ = (() => {
      if (typeof yParity === "number")
        return yParity ? numberToHex(1) : "0x";
      if (v === 0n)
        return "0x";
      if (v === 1n)
        return numberToHex(1);
      return v === 27n ? "0x" : numberToHex(1);
    })();
    return [yParity_, r === "0x00" ? "0x" : r, s === "0x00" ? "0x" : s];
  }
  var init_serializeTransaction = __esm({
    "node_modules/viem/_esm/utils/transaction/serializeTransaction.js"() {
      init_transaction3();
      init_serializeAuthorizationList();
      init_blobsToCommitments();
      init_blobsToProofs();
      init_commitmentsToVersionedHashes();
      init_toBlobSidecars();
      init_concat();
      init_trim();
      init_toHex();
      init_toRlp();
      init_assertTransaction();
      init_getTransactionType();
      init_serializeAccessList();
    }
  });

  // node_modules/viem/_esm/utils/authorization/serializeAuthorizationList.js
  function serializeAuthorizationList(authorizationList) {
    if (!authorizationList || authorizationList.length === 0)
      return [];
    const serializedAuthorizationList = [];
    for (const authorization of authorizationList) {
      const { chainId, nonce, ...signature } = authorization;
      const contractAddress = authorization.address;
      serializedAuthorizationList.push([
        chainId ? toHex(chainId) : "0x",
        contractAddress,
        nonce ? toHex(nonce) : "0x",
        ...toYParitySignatureArray({}, signature)
      ]);
    }
    return serializedAuthorizationList;
  }
  var init_serializeAuthorizationList = __esm({
    "node_modules/viem/_esm/utils/authorization/serializeAuthorizationList.js"() {
      init_toHex();
      init_serializeTransaction();
    }
  });

  // node_modules/viem/_esm/constants/strings.js
  var presignMessagePrefix;
  var init_strings2 = __esm({
    "node_modules/viem/_esm/constants/strings.js"() {
      presignMessagePrefix = "Ethereum Signed Message:\n";
    }
  });

  // node_modules/viem/_esm/utils/signature/toPrefixedMessage.js
  function toPrefixedMessage(message_) {
    const message = (() => {
      if (typeof message_ === "string")
        return stringToHex(message_);
      if (typeof message_.raw === "string")
        return message_.raw;
      return bytesToHex2(message_.raw);
    })();
    const prefix = stringToHex(`${presignMessagePrefix}${size(message)}`);
    return concat2([prefix, message]);
  }
  var init_toPrefixedMessage = __esm({
    "node_modules/viem/_esm/utils/signature/toPrefixedMessage.js"() {
      init_strings2();
      init_concat();
      init_size();
      init_toHex();
    }
  });

  // node_modules/viem/_esm/utils/signature/hashMessage.js
  function hashMessage2(message, to_) {
    return keccak2562(toPrefixedMessage(message), to_);
  }
  var init_hashMessage = __esm({
    "node_modules/viem/_esm/utils/signature/hashMessage.js"() {
      init_keccak256();
      init_toPrefixedMessage();
    }
  });

  // node_modules/viem/_esm/constants/bytes.js
  var erc6492MagicBytes;
  var init_bytes3 = __esm({
    "node_modules/viem/_esm/constants/bytes.js"() {
      erc6492MagicBytes = "0x6492649264926492649264926492649264926492649264926492649264926492";
    }
  });

  // node_modules/viem/_esm/utils/signature/isErc6492Signature.js
  function isErc6492Signature(signature) {
    return sliceHex(signature, -32) === erc6492MagicBytes;
  }
  var init_isErc6492Signature = __esm({
    "node_modules/viem/_esm/utils/signature/isErc6492Signature.js"() {
      init_bytes3();
      init_slice();
    }
  });

  // node_modules/viem/_esm/utils/signature/serializeErc6492Signature.js
  function serializeErc6492Signature(parameters) {
    const { address, data, signature, to = "hex" } = parameters;
    const signature_ = concatHex([
      encodeAbiParameters([{ type: "address" }, { type: "bytes" }, { type: "bytes" }], [address, data, signature]),
      erc6492MagicBytes
    ]);
    if (to === "hex")
      return signature_;
    return hexToBytes2(signature_);
  }
  var init_serializeErc6492Signature = __esm({
    "node_modules/viem/_esm/utils/signature/serializeErc6492Signature.js"() {
      init_bytes3();
      init_encodeAbiParameters();
      init_concat();
      init_toBytes();
    }
  });

  // node_modules/viem/_esm/errors/unit.js
  var InvalidDecimalNumberError;
  var init_unit2 = __esm({
    "node_modules/viem/_esm/errors/unit.js"() {
      init_base();
      InvalidDecimalNumberError = class extends BaseError2 {
        constructor({ value }) {
          super(`Number \`${value}\` is not a valid decimal number.`, {
            name: "InvalidDecimalNumberError"
          });
        }
      };
    }
  });

  // node_modules/viem/_esm/utils/unit/parseUnits.js
  function parseUnits3(value, decimals) {
    if (!/^(-?)([0-9]*)\.?([0-9]*)$/.test(value))
      throw new InvalidDecimalNumberError({ value });
    let [integer, fraction = "0"] = value.split(".");
    const negative = integer.startsWith("-");
    if (negative)
      integer = integer.slice(1);
    fraction = fraction.replace(/(0+)$/, "");
    if (decimals === 0) {
      if (Math.round(Number(`.${fraction}`)) === 1)
        integer = `${BigInt(integer) + 1n}`;
      fraction = "";
    } else if (fraction.length > decimals) {
      const [left, unit, right] = [
        fraction.slice(0, decimals - 1),
        fraction.slice(decimals - 1, decimals),
        fraction.slice(decimals)
      ];
      const rounded = Math.round(Number(`${unit}.${right}`));
      if (rounded > 9)
        fraction = `${BigInt(left) + BigInt(1)}0`.padStart(left.length + 1, "0");
      else
        fraction = `${left}${rounded}`;
      if (fraction.length > decimals) {
        fraction = fraction.slice(1);
        integer = `${BigInt(integer) + 1n}`;
      }
      fraction = fraction.slice(0, decimals);
    } else {
      fraction = fraction.padEnd(decimals, "0");
    }
    return BigInt(`${negative ? "-" : ""}${integer}${fraction}`);
  }
  var init_parseUnits = __esm({
    "node_modules/viem/_esm/utils/unit/parseUnits.js"() {
      init_unit2();
    }
  });

  // node_modules/viem/_esm/utils/unit/parseEther.js
  function parseEther2(ether, unit = "wei") {
    return parseUnits3(ether, etherUnits[unit]);
  }
  var init_parseEther = __esm({
    "node_modules/viem/_esm/utils/unit/parseEther.js"() {
      init_unit();
      init_parseUnits();
    }
  });

  // node_modules/viem/_esm/utils/nonceManager.js
  function createNonceManager(parameters) {
    const { source } = parameters;
    const deltaMap = /* @__PURE__ */ new Map();
    const nonceMap = new LruMap(8192);
    const promiseMap = /* @__PURE__ */ new Map();
    const getKey = ({ address, chainId }) => `${address}.${chainId}`;
    return {
      async consume({ address, chainId, client }) {
        const key = getKey({ address, chainId });
        const promise = this.get({ address, chainId, client });
        this.increment({ address, chainId });
        const nonce = await promise;
        await source.set({ address, chainId }, nonce);
        nonceMap.set(key, nonce);
        return nonce;
      },
      async increment({ address, chainId }) {
        const key = getKey({ address, chainId });
        const delta = deltaMap.get(key) ?? 0;
        deltaMap.set(key, delta + 1);
      },
      async get({ address, chainId, client }) {
        const key = getKey({ address, chainId });
        let promise = promiseMap.get(key);
        if (!promise) {
          promise = (async () => {
            try {
              const nonce = await source.get({ address, chainId, client });
              const previousNonce = nonceMap.get(key) ?? 0;
              if (previousNonce > 0 && nonce <= previousNonce)
                return previousNonce + 1;
              nonceMap.delete(key);
              return nonce;
            } finally {
              this.reset({ address, chainId });
            }
          })();
          promiseMap.set(key, promise);
        }
        const delta = deltaMap.get(key) ?? 0;
        return delta + await promise;
      },
      reset({ address, chainId }) {
        const key = getKey({ address, chainId });
        deltaMap.delete(key);
        promiseMap.delete(key);
      }
    };
  }
  function jsonRpc() {
    return {
      async get(parameters) {
        const { address, client } = parameters;
        return getTransactionCount(client, {
          address,
          blockTag: "pending"
        });
      },
      set() {
      }
    };
  }
  var nonceManager;
  var init_nonceManager = __esm({
    "node_modules/viem/_esm/utils/nonceManager.js"() {
      init_getTransactionCount();
      init_lru();
      nonceManager = /* @__PURE__ */ createNonceManager({
        source: jsonRpc()
      });
    }
  });

  // node_modules/viem/_esm/utils/index.js
  var init_utils11 = __esm({
    "node_modules/viem/_esm/utils/index.js"() {
      init_encodeFunctionData();
      init_fromHex();
    }
  });

  // node_modules/viem/_esm/utils/formatters/proof.js
  function formatStorageProof(storageProof) {
    return storageProof.map((proof) => ({
      ...proof,
      value: BigInt(proof.value)
    }));
  }
  function formatProof(proof) {
    return {
      ...proof,
      balance: proof.balance ? BigInt(proof.balance) : void 0,
      nonce: proof.nonce ? hexToNumber2(proof.nonce) : void 0,
      storageProof: proof.storageProof ? formatStorageProof(proof.storageProof) : void 0
    };
  }
  var init_proof = __esm({
    "node_modules/viem/_esm/utils/formatters/proof.js"() {
      init_utils11();
    }
  });

  // node_modules/viem/_esm/actions/public/getProof.js
  async function getProof(client, { address, blockNumber, blockTag: blockTag_, storageKeys }) {
    const blockTag = blockTag_ ?? "latest";
    const blockNumberHex = blockNumber !== void 0 ? numberToHex(blockNumber) : void 0;
    const proof = await client.request({
      method: "eth_getProof",
      params: [address, storageKeys, blockNumberHex || blockTag]
    });
    return formatProof(proof);
  }
  var init_getProof = __esm({
    "node_modules/viem/_esm/actions/public/getProof.js"() {
      init_toHex();
      init_proof();
    }
  });

  // node_modules/viem/_esm/actions/public/getStorageAt.js
  async function getStorageAt(client, { address, blockNumber, blockTag = "latest", slot }) {
    const blockNumberHex = blockNumber !== void 0 ? numberToHex(blockNumber) : void 0;
    const data = await client.request({
      method: "eth_getStorageAt",
      params: [address, slot, blockNumberHex || blockTag]
    });
    return data;
  }
  var init_getStorageAt = __esm({
    "node_modules/viem/_esm/actions/public/getStorageAt.js"() {
      init_toHex();
    }
  });

  // node_modules/viem/_esm/actions/public/getTransaction.js
  async function getTransaction(client, { blockHash, blockNumber, blockTag: blockTag_, hash: hash3, index: index2 }) {
    const blockTag = blockTag_ || "latest";
    const blockNumberHex = blockNumber !== void 0 ? numberToHex(blockNumber) : void 0;
    let transaction = null;
    if (hash3) {
      transaction = await client.request({
        method: "eth_getTransactionByHash",
        params: [hash3]
      }, { dedupe: true });
    } else if (blockHash) {
      transaction = await client.request({
        method: "eth_getTransactionByBlockHashAndIndex",
        params: [blockHash, numberToHex(index2)]
      }, { dedupe: true });
    } else if (blockNumberHex || blockTag) {
      transaction = await client.request({
        method: "eth_getTransactionByBlockNumberAndIndex",
        params: [blockNumberHex || blockTag, numberToHex(index2)]
      }, { dedupe: Boolean(blockNumberHex) });
    }
    if (!transaction)
      throw new TransactionNotFoundError({
        blockHash,
        blockNumber,
        blockTag,
        hash: hash3,
        index: index2
      });
    const format = client.chain?.formatters?.transaction?.format || formatTransaction;
    return format(transaction);
  }
  var init_getTransaction = __esm({
    "node_modules/viem/_esm/actions/public/getTransaction.js"() {
      init_transaction3();
      init_toHex();
      init_transaction4();
    }
  });

  // node_modules/viem/_esm/actions/public/getTransactionConfirmations.js
  async function getTransactionConfirmations(client, { hash: hash3, transactionReceipt }) {
    const [blockNumber, transaction] = await Promise.all([
      getAction(client, getBlockNumber, "getBlockNumber")({}),
      hash3 ? getAction(client, getTransaction, "getTransaction")({ hash: hash3 }) : void 0
    ]);
    const transactionBlockNumber = transactionReceipt?.blockNumber || transaction?.blockNumber;
    if (!transactionBlockNumber)
      return 0n;
    return blockNumber - transactionBlockNumber + 1n;
  }
  var init_getTransactionConfirmations = __esm({
    "node_modules/viem/_esm/actions/public/getTransactionConfirmations.js"() {
      init_getAction();
      init_getBlockNumber();
      init_getTransaction();
    }
  });

  // node_modules/viem/_esm/actions/public/getTransactionReceipt.js
  async function getTransactionReceipt(client, { hash: hash3 }) {
    const receipt = await client.request({
      method: "eth_getTransactionReceipt",
      params: [hash3]
    }, { dedupe: true });
    if (!receipt)
      throw new TransactionReceiptNotFoundError({ hash: hash3 });
    const format = client.chain?.formatters?.transactionReceipt?.format || formatTransactionReceipt2;
    return format(receipt);
  }
  var init_getTransactionReceipt = __esm({
    "node_modules/viem/_esm/actions/public/getTransactionReceipt.js"() {
      init_transaction3();
      init_transactionReceipt();
    }
  });

  // node_modules/viem/_esm/actions/public/multicall.js
  async function multicall(client, parameters) {
    const { account, allowFailure = true, batchSize: batchSize_, blockNumber, blockTag, multicallAddress: multicallAddress_, stateOverride } = parameters;
    const contracts2 = parameters.contracts;
    const batchSize = batchSize_ ?? (typeof client.batch?.multicall === "object" && client.batch.multicall.batchSize || 1024);
    let multicallAddress = multicallAddress_;
    if (!multicallAddress) {
      if (!client.chain)
        throw new Error("client chain not configured. multicallAddress is required.");
      multicallAddress = getChainContractAddress({
        blockNumber,
        chain: client.chain,
        contract: "multicall3"
      });
    }
    const chunkedCalls = [[]];
    let currentChunk = 0;
    let currentChunkSize = 0;
    for (let i = 0; i < contracts2.length; i++) {
      const { abi: abi2, address, args, functionName } = contracts2[i];
      try {
        const callData = encodeFunctionData({ abi: abi2, args, functionName });
        currentChunkSize += (callData.length - 2) / 2;
        if (
          // Check if batching is enabled.
          batchSize > 0 && // Check if the current size of the batch exceeds the size limit.
          currentChunkSize > batchSize && // Check if the current chunk is not already empty.
          chunkedCalls[currentChunk].length > 0
        ) {
          currentChunk++;
          currentChunkSize = (callData.length - 2) / 2;
          chunkedCalls[currentChunk] = [];
        }
        chunkedCalls[currentChunk] = [
          ...chunkedCalls[currentChunk],
          {
            allowFailure: true,
            callData,
            target: address
          }
        ];
      } catch (err) {
        const error = getContractError(err, {
          abi: abi2,
          address,
          args,
          docsPath: "/docs/contract/multicall",
          functionName,
          sender: account
        });
        if (!allowFailure)
          throw error;
        chunkedCalls[currentChunk] = [
          ...chunkedCalls[currentChunk],
          {
            allowFailure: true,
            callData: "0x",
            target: address
          }
        ];
      }
    }
    const aggregate3Results = await Promise.allSettled(chunkedCalls.map((calls) => getAction(client, readContract, "readContract")({
      abi: multicall3Abi,
      account,
      address: multicallAddress,
      args: [calls],
      blockNumber,
      blockTag,
      functionName: "aggregate3",
      stateOverride
    })));
    const results = [];
    for (let i = 0; i < aggregate3Results.length; i++) {
      const result = aggregate3Results[i];
      if (result.status === "rejected") {
        if (!allowFailure)
          throw result.reason;
        for (let j = 0; j < chunkedCalls[i].length; j++) {
          results.push({
            status: "failure",
            error: result.reason,
            result: void 0
          });
        }
        continue;
      }
      const aggregate3Result = result.value;
      for (let j = 0; j < aggregate3Result.length; j++) {
        const { returnData, success } = aggregate3Result[j];
        const { callData } = chunkedCalls[i][j];
        const { abi: abi2, address, functionName, args } = contracts2[results.length];
        try {
          if (callData === "0x")
            throw new AbiDecodingZeroDataError();
          if (!success)
            throw new RawContractError({ data: returnData });
          const result2 = decodeFunctionResult({
            abi: abi2,
            args,
            data: returnData,
            functionName
          });
          results.push(allowFailure ? { result: result2, status: "success" } : result2);
        } catch (err) {
          const error = getContractError(err, {
            abi: abi2,
            address,
            args,
            docsPath: "/docs/contract/multicall",
            functionName
          });
          if (!allowFailure)
            throw error;
          results.push({ error, result: void 0, status: "failure" });
        }
      }
    }
    if (results.length !== contracts2.length)
      throw new BaseError2("multicall results mismatch");
    return results;
  }
  var init_multicall = __esm({
    "node_modules/viem/_esm/actions/public/multicall.js"() {
      init_abis();
      init_abi2();
      init_base();
      init_contract3();
      init_decodeFunctionResult();
      init_encodeFunctionData();
      init_getChainContractAddress();
      init_getContractError();
      init_getAction();
      init_readContract();
    }
  });

  // node_modules/viem/_esm/actions/public/simulateBlocks.js
  async function simulateBlocks(client, parameters) {
    const { blockNumber, blockTag = "latest", blocks, returnFullTransactions, traceTransfers, validation } = parameters;
    try {
      const blockStateCalls = [];
      for (const block2 of blocks) {
        const blockOverrides = block2.blockOverrides ? toRpc2(block2.blockOverrides) : void 0;
        const calls = block2.calls.map((call_) => {
          const call2 = call_;
          const account = call2.account ? parseAccount(call2.account) : void 0;
          const data = call2.abi ? encodeFunctionData(call2) : call2.data;
          const request = {
            ...call2,
            data: call2.dataSuffix ? concat2([data || "0x", call2.dataSuffix]) : data,
            from: call2.from ?? account?.address
          };
          assertRequest(request);
          return formatTransactionRequest(request);
        });
        const stateOverrides = block2.stateOverrides ? serializeStateOverride(block2.stateOverrides) : void 0;
        blockStateCalls.push({
          blockOverrides,
          calls,
          stateOverrides
        });
      }
      const blockNumberHex = typeof blockNumber === "bigint" ? numberToHex(blockNumber) : void 0;
      const block = blockNumberHex || blockTag;
      const result = await client.request({
        method: "eth_simulateV1",
        params: [
          { blockStateCalls, returnFullTransactions, traceTransfers, validation },
          block
        ]
      });
      return result.map((block2, i) => ({
        ...formatBlock2(block2),
        calls: block2.calls.map((call2, j) => {
          const { abi: abi2, args, functionName, to } = blocks[i].calls[j];
          const data = call2.error?.data ?? call2.returnData;
          const gasUsed = BigInt(call2.gasUsed);
          const logs = call2.logs?.map((log) => formatLog2(log));
          const status = call2.status === "0x1" ? "success" : "failure";
          const result2 = abi2 && status === "success" && data !== "0x" ? decodeFunctionResult({
            abi: abi2,
            data,
            functionName
          }) : null;
          const error = (() => {
            if (status === "success")
              return void 0;
            let error2 = void 0;
            if (call2.error?.data === "0x")
              error2 = new AbiDecodingZeroDataError();
            else if (call2.error)
              error2 = new RawContractError(call2.error);
            if (!error2)
              return void 0;
            return getContractError(error2, {
              abi: abi2 ?? [],
              address: to ?? "0x",
              args,
              functionName: functionName ?? "<unknown>"
            });
          })();
          return {
            data,
            gasUsed,
            logs,
            status,
            ...status === "success" ? {
              result: result2
            } : {
              error
            }
          };
        })
      }));
    } catch (e) {
      const cause = e;
      const error = getNodeError(cause, {});
      if (error instanceof UnknownNodeError)
        throw cause;
      throw error;
    }
  }
  var init_simulateBlocks = __esm({
    "node_modules/viem/_esm/actions/public/simulateBlocks.js"() {
      init_BlockOverrides();
      init_parseAccount();
      init_abi2();
      init_contract3();
      init_node();
      init_decodeFunctionResult();
      init_encodeFunctionData();
      init_concat();
      init_toHex();
      init_getContractError();
      init_getNodeError();
      init_block2();
      init_log2();
      init_transactionRequest();
      init_stateOverride2();
      init_assertRequest();
    }
  });

  // node_modules/ox/node_modules/@noble/hashes/esm/_u64.js
  function fromBig3(n2, le = false) {
    if (le)
      return { h: Number(n2 & U32_MASK643), l: Number(n2 >> _32n3 & U32_MASK643) };
    return { h: Number(n2 >> _32n3 & U32_MASK643) | 0, l: Number(n2 & U32_MASK643) | 0 };
  }
  function split4(lst, le = false) {
    const len = lst.length;
    let Ah = new Uint32Array(len);
    let Al = new Uint32Array(len);
    for (let i = 0; i < len; i++) {
      const { h, l } = fromBig3(lst[i], le);
      [Ah[i], Al[i]] = [h, l];
    }
    return [Ah, Al];
  }
  var U32_MASK643, _32n3, rotlSH3, rotlSL3, rotlBH3, rotlBL3;
  var init_u643 = __esm({
    "node_modules/ox/node_modules/@noble/hashes/esm/_u64.js"() {
      U32_MASK643 = /* @__PURE__ */ BigInt(2 ** 32 - 1);
      _32n3 = /* @__PURE__ */ BigInt(32);
      rotlSH3 = (h, l, s) => h << s | l >>> 32 - s;
      rotlSL3 = (h, l, s) => l << s | h >>> 32 - s;
      rotlBH3 = (h, l, s) => l << s - 32 | h >>> 64 - s;
      rotlBL3 = (h, l, s) => h << s - 32 | l >>> 64 - s;
    }
  });

  // node_modules/ox/node_modules/@noble/hashes/esm/sha3.js
  function keccakP3(s, rounds = 24) {
    const B = new Uint32Array(5 * 2);
    for (let round = 24 - rounds; round < 24; round++) {
      for (let x = 0; x < 10; x++)
        B[x] = s[x] ^ s[x + 10] ^ s[x + 20] ^ s[x + 30] ^ s[x + 40];
      for (let x = 0; x < 10; x += 2) {
        const idx1 = (x + 8) % 10;
        const idx0 = (x + 2) % 10;
        const B0 = B[idx0];
        const B1 = B[idx0 + 1];
        const Th = rotlH3(B0, B1, 1) ^ B[idx1];
        const Tl = rotlL3(B0, B1, 1) ^ B[idx1 + 1];
        for (let y = 0; y < 50; y += 10) {
          s[x + y] ^= Th;
          s[x + y + 1] ^= Tl;
        }
      }
      let curH = s[2];
      let curL = s[3];
      for (let t = 0; t < 24; t++) {
        const shift = SHA3_ROTL3[t];
        const Th = rotlH3(curH, curL, shift);
        const Tl = rotlL3(curH, curL, shift);
        const PI = SHA3_PI3[t];
        curH = s[PI];
        curL = s[PI + 1];
        s[PI] = Th;
        s[PI + 1] = Tl;
      }
      for (let y = 0; y < 50; y += 10) {
        for (let x = 0; x < 10; x++)
          B[x] = s[y + x];
        for (let x = 0; x < 10; x++)
          s[y + x] ^= ~B[(x + 2) % 10] & B[(x + 4) % 10];
      }
      s[0] ^= SHA3_IOTA_H3[round];
      s[1] ^= SHA3_IOTA_L3[round];
    }
    clean2(B);
  }
  var _0n13, _1n13, _2n10, _7n3, _256n3, _0x71n3, SHA3_PI3, SHA3_ROTL3, _SHA3_IOTA3, IOTAS2, SHA3_IOTA_H3, SHA3_IOTA_L3, rotlH3, rotlL3, Keccak3, gen3, keccak_2563;
  var init_sha33 = __esm({
    "node_modules/ox/node_modules/@noble/hashes/esm/sha3.js"() {
      init_u643();
      init_utils9();
      _0n13 = BigInt(0);
      _1n13 = BigInt(1);
      _2n10 = BigInt(2);
      _7n3 = BigInt(7);
      _256n3 = BigInt(256);
      _0x71n3 = BigInt(113);
      SHA3_PI3 = [];
      SHA3_ROTL3 = [];
      _SHA3_IOTA3 = [];
      for (let round = 0, R = _1n13, x = 1, y = 0; round < 24; round++) {
        [x, y] = [y, (2 * x + 3 * y) % 5];
        SHA3_PI3.push(2 * (5 * y + x));
        SHA3_ROTL3.push((round + 1) * (round + 2) / 2 % 64);
        let t = _0n13;
        for (let j = 0; j < 7; j++) {
          R = (R << _1n13 ^ (R >> _7n3) * _0x71n3) % _256n3;
          if (R & _2n10)
            t ^= _1n13 << (_1n13 << /* @__PURE__ */ BigInt(j)) - _1n13;
        }
        _SHA3_IOTA3.push(t);
      }
      IOTAS2 = split4(_SHA3_IOTA3, true);
      SHA3_IOTA_H3 = IOTAS2[0];
      SHA3_IOTA_L3 = IOTAS2[1];
      rotlH3 = (h, l, s) => s > 32 ? rotlBH3(h, l, s) : rotlSH3(h, l, s);
      rotlL3 = (h, l, s) => s > 32 ? rotlBL3(h, l, s) : rotlSL3(h, l, s);
      Keccak3 = class _Keccak extends Hash3 {
        // NOTE: we accept arguments in bytes instead of bits here.
        constructor(blockLen, suffix, outputLen, enableXOF = false, rounds = 24) {
          super();
          this.pos = 0;
          this.posOut = 0;
          this.finished = false;
          this.destroyed = false;
          this.enableXOF = false;
          this.blockLen = blockLen;
          this.suffix = suffix;
          this.outputLen = outputLen;
          this.enableXOF = enableXOF;
          this.rounds = rounds;
          anumber2(outputLen);
          if (!(0 < blockLen && blockLen < 200))
            throw new Error("only keccak-f1600 function is supported");
          this.state = new Uint8Array(200);
          this.state32 = u323(this.state);
        }
        clone() {
          return this._cloneInto();
        }
        keccak() {
          swap32IfBE2(this.state32);
          keccakP3(this.state32, this.rounds);
          swap32IfBE2(this.state32);
          this.posOut = 0;
          this.pos = 0;
        }
        update(data) {
          aexists2(this);
          data = toBytes4(data);
          abytes2(data);
          const { blockLen, state } = this;
          const len = data.length;
          for (let pos = 0; pos < len; ) {
            const take = Math.min(blockLen - this.pos, len - pos);
            for (let i = 0; i < take; i++)
              state[this.pos++] ^= data[pos++];
            if (this.pos === blockLen)
              this.keccak();
          }
          return this;
        }
        finish() {
          if (this.finished)
            return;
          this.finished = true;
          const { state, suffix, pos, blockLen } = this;
          state[pos] ^= suffix;
          if ((suffix & 128) !== 0 && pos === blockLen - 1)
            this.keccak();
          state[blockLen - 1] ^= 128;
          this.keccak();
        }
        writeInto(out) {
          aexists2(this, false);
          abytes2(out);
          this.finish();
          const bufferOut = this.state;
          const { blockLen } = this;
          for (let pos = 0, len = out.length; pos < len; ) {
            if (this.posOut >= blockLen)
              this.keccak();
            const take = Math.min(blockLen - this.posOut, len - pos);
            out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);
            this.posOut += take;
            pos += take;
          }
          return out;
        }
        xofInto(out) {
          if (!this.enableXOF)
            throw new Error("XOF is not possible for this instance");
          return this.writeInto(out);
        }
        xof(bytes2) {
          anumber2(bytes2);
          return this.xofInto(new Uint8Array(bytes2));
        }
        digestInto(out) {
          aoutput2(out, this);
          if (this.finished)
            throw new Error("digest() was already called");
          this.writeInto(out);
          this.destroy();
          return out;
        }
        digest() {
          return this.digestInto(new Uint8Array(this.outputLen));
        }
        destroy() {
          this.destroyed = true;
          clean2(this.state);
        }
        _cloneInto(to) {
          const { blockLen, suffix, outputLen, rounds, enableXOF } = this;
          to || (to = new _Keccak(blockLen, suffix, outputLen, enableXOF, rounds));
          to.state32.set(this.state32);
          to.pos = this.pos;
          to.posOut = this.posOut;
          to.finished = this.finished;
          to.rounds = rounds;
          to.suffix = suffix;
          to.outputLen = outputLen;
          to.enableXOF = enableXOF;
          to.destroyed = this.destroyed;
          return to;
        }
      };
      gen3 = (suffix, blockLen, outputLen) => createHasher3(() => new Keccak3(blockLen, suffix, outputLen));
      keccak_2563 = /* @__PURE__ */ (() => gen3(1, 136, 256 / 8))();
    }
  });

  // node_modules/ox/_esm/core/Hash.js
  function keccak2563(value, options = {}) {
    const { as = typeof value === "string" ? "Hex" : "Bytes" } = options;
    const bytes2 = keccak_2563(from(value));
    if (as === "Bytes")
      return bytes2;
    return fromBytes(bytes2);
  }
  var init_Hash = __esm({
    "node_modules/ox/_esm/core/Hash.js"() {
      init_sha33();
      init_Bytes();
      init_Hex();
    }
  });

  // node_modules/ox/_esm/core/internal/lru.js
  var LruMap2;
  var init_lru2 = __esm({
    "node_modules/ox/_esm/core/internal/lru.js"() {
      LruMap2 = class extends Map {
        constructor(size5) {
          super();
          Object.defineProperty(this, "maxSize", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
          });
          this.maxSize = size5;
        }
        get(key) {
          const value = super.get(key);
          if (super.has(key) && value !== void 0) {
            this.delete(key);
            super.set(key, value);
          }
          return value;
        }
        set(key, value) {
          super.set(key, value);
          if (this.maxSize && this.size > this.maxSize) {
            const firstKey = this.keys().next().value;
            if (firstKey)
              this.delete(firstKey);
          }
          return this;
        }
      };
    }
  });

  // node_modules/ox/_esm/core/Caches.js
  var caches, checksum2;
  var init_Caches = __esm({
    "node_modules/ox/_esm/core/Caches.js"() {
      init_lru2();
      caches = {
        checksum: /* @__PURE__ */ new LruMap2(8192)
      };
      checksum2 = caches.checksum;
    }
  });

  // node_modules/ox/_esm/core/Address.js
  function assert3(value, options = {}) {
    const { strict = true } = options;
    if (!addressRegex2.test(value))
      throw new InvalidAddressError2({
        address: value,
        cause: new InvalidInputError()
      });
    if (strict) {
      if (value.toLowerCase() === value)
        return;
      if (checksum3(value) !== value)
        throw new InvalidAddressError2({
          address: value,
          cause: new InvalidChecksumError()
        });
    }
  }
  function checksum3(address) {
    if (checksum2.has(address))
      return checksum2.get(address);
    assert3(address, { strict: false });
    const hexAddress = address.substring(2).toLowerCase();
    const hash3 = keccak2563(fromString(hexAddress), { as: "Bytes" });
    const characters = hexAddress.split("");
    for (let i = 0; i < 40; i += 2) {
      if (hash3[i >> 1] >> 4 >= 8 && characters[i]) {
        characters[i] = characters[i].toUpperCase();
      }
      if ((hash3[i >> 1] & 15) >= 8 && characters[i + 1]) {
        characters[i + 1] = characters[i + 1].toUpperCase();
      }
    }
    const result = `0x${characters.join("")}`;
    checksum2.set(address, result);
    return result;
  }
  function validate2(address, options = {}) {
    const { strict = true } = options ?? {};
    try {
      assert3(address, { strict });
      return true;
    } catch {
      return false;
    }
  }
  var addressRegex2, InvalidAddressError2, InvalidInputError, InvalidChecksumError;
  var init_Address = __esm({
    "node_modules/ox/_esm/core/Address.js"() {
      init_Bytes();
      init_Caches();
      init_Errors();
      init_Hash();
      addressRegex2 = /^0x[a-fA-F0-9]{40}$/;
      InvalidAddressError2 = class extends BaseError3 {
        constructor({ address, cause }) {
          super(`Address "${address}" is invalid.`, {
            cause
          });
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "Address.InvalidAddressError"
          });
        }
      };
      InvalidInputError = class extends BaseError3 {
        constructor() {
          super("Address is not a 20 byte (40 hexadecimal character) value.");
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "Address.InvalidInputError"
          });
        }
      };
      InvalidChecksumError = class extends BaseError3 {
        constructor() {
          super("Address does not match its checksum counterpart.");
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "Address.InvalidChecksumError"
          });
        }
      };
    }
  });

  // node_modules/ox/_esm/core/internal/abiItem.js
  function normalizeSignature2(signature) {
    let active = true;
    let current = "";
    let level = 0;
    let result = "";
    let valid = false;
    for (let i = 0; i < signature.length; i++) {
      const char = signature[i];
      if (["(", ")", ","].includes(char))
        active = true;
      if (char === "(")
        level++;
      if (char === ")")
        level--;
      if (!active)
        continue;
      if (level === 0) {
        if (char === " " && ["event", "function", "error", ""].includes(result))
          result = "";
        else {
          result += char;
          if (char === ")") {
            valid = true;
            break;
          }
        }
        continue;
      }
      if (char === " ") {
        if (signature[i - 1] !== "," && current !== "," && current !== ",(") {
          current = "";
          active = false;
        }
        continue;
      }
      result += char;
      current += char;
    }
    if (!valid)
      throw new BaseError3("Unable to normalize signature.");
    return result;
  }
  function isArgOfType2(arg, abiParameter) {
    const argType = typeof arg;
    const abiParameterType = abiParameter.type;
    switch (abiParameterType) {
      case "address":
        return validate2(arg, { strict: false });
      case "bool":
        return argType === "boolean";
      case "function":
        return argType === "string";
      case "string":
        return argType === "string";
      default: {
        if (abiParameterType === "tuple" && "components" in abiParameter)
          return Object.values(abiParameter.components).every((component, index2) => {
            return isArgOfType2(Object.values(arg)[index2], component);
          });
        if (/^u?int(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/.test(abiParameterType))
          return argType === "number" || argType === "bigint";
        if (/^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/.test(abiParameterType))
          return argType === "string" || arg instanceof Uint8Array;
        if (/[a-z]+[1-9]{0,3}(\[[0-9]{0,}\])+$/.test(abiParameterType)) {
          return Array.isArray(arg) && arg.every((x) => isArgOfType2(x, {
            ...abiParameter,
            // Pop off `[]` or `[M]` from end of type
            type: abiParameterType.replace(/(\[[0-9]{0,}\])$/, "")
          }));
        }
        return false;
      }
    }
  }
  function getAmbiguousTypes2(sourceParameters, targetParameters, args) {
    for (const parameterIndex in sourceParameters) {
      const sourceParameter = sourceParameters[parameterIndex];
      const targetParameter = targetParameters[parameterIndex];
      if (sourceParameter.type === "tuple" && targetParameter.type === "tuple" && "components" in sourceParameter && "components" in targetParameter)
        return getAmbiguousTypes2(sourceParameter.components, targetParameter.components, args[parameterIndex]);
      const types = [sourceParameter.type, targetParameter.type];
      const ambiguous = (() => {
        if (types.includes("address") && types.includes("bytes20"))
          return true;
        if (types.includes("address") && types.includes("string"))
          return validate2(args[parameterIndex], {
            strict: false
          });
        if (types.includes("address") && types.includes("bytes"))
          return validate2(args[parameterIndex], {
            strict: false
          });
        return false;
      })();
      if (ambiguous)
        return types;
    }
    return;
  }
  var init_abiItem2 = __esm({
    "node_modules/ox/_esm/core/internal/abiItem.js"() {
      init_Address();
      init_Errors();
    }
  });

  // node_modules/ox/_esm/core/AbiItem.js
  function from2(abiItem, options = {}) {
    const { prepare = true } = options;
    const item = (() => {
      if (Array.isArray(abiItem))
        return parseAbiItem(abiItem);
      if (typeof abiItem === "string")
        return parseAbiItem(abiItem);
      return abiItem;
    })();
    return {
      ...item,
      ...prepare ? { hash: getSignatureHash(item) } : {}
    };
  }
  function fromAbi(abi2, name, options) {
    const { args = [], prepare = true } = options ?? {};
    const isSelector = validate(name, { strict: false });
    const abiItems = abi2.filter((abiItem2) => {
      if (isSelector) {
        if (abiItem2.type === "function" || abiItem2.type === "error")
          return getSelector(abiItem2) === slice2(name, 0, 4);
        if (abiItem2.type === "event")
          return getSignatureHash(abiItem2) === name;
        return false;
      }
      return "name" in abiItem2 && abiItem2.name === name;
    });
    if (abiItems.length === 0)
      throw new NotFoundError({ name });
    if (abiItems.length === 1)
      return {
        ...abiItems[0],
        ...prepare ? { hash: getSignatureHash(abiItems[0]) } : {}
      };
    let matchedAbiItem = void 0;
    for (const abiItem2 of abiItems) {
      if (!("inputs" in abiItem2))
        continue;
      if (!args || args.length === 0) {
        if (!abiItem2.inputs || abiItem2.inputs.length === 0)
          return {
            ...abiItem2,
            ...prepare ? { hash: getSignatureHash(abiItem2) } : {}
          };
        continue;
      }
      if (!abiItem2.inputs)
        continue;
      if (abiItem2.inputs.length === 0)
        continue;
      if (abiItem2.inputs.length !== args.length)
        continue;
      const matched = args.every((arg, index2) => {
        const abiParameter = "inputs" in abiItem2 && abiItem2.inputs[index2];
        if (!abiParameter)
          return false;
        return isArgOfType2(arg, abiParameter);
      });
      if (matched) {
        if (matchedAbiItem && "inputs" in matchedAbiItem && matchedAbiItem.inputs) {
          const ambiguousTypes = getAmbiguousTypes2(abiItem2.inputs, matchedAbiItem.inputs, args);
          if (ambiguousTypes)
            throw new AmbiguityError({
              abiItem: abiItem2,
              type: ambiguousTypes[0]
            }, {
              abiItem: matchedAbiItem,
              type: ambiguousTypes[1]
            });
        }
        matchedAbiItem = abiItem2;
      }
    }
    const abiItem = (() => {
      if (matchedAbiItem)
        return matchedAbiItem;
      const [abiItem2, ...overloads] = abiItems;
      return { ...abiItem2, overloads };
    })();
    if (!abiItem)
      throw new NotFoundError({ name });
    return {
      ...abiItem,
      ...prepare ? { hash: getSignatureHash(abiItem) } : {}
    };
  }
  function getSelector(abiItem) {
    return slice2(getSignatureHash(abiItem), 0, 4);
  }
  function getSignature(abiItem) {
    const signature = (() => {
      if (typeof abiItem === "string")
        return abiItem;
      return formatAbiItem(abiItem);
    })();
    return normalizeSignature2(signature);
  }
  function getSignatureHash(abiItem) {
    if (typeof abiItem !== "string" && "hash" in abiItem && abiItem.hash)
      return abiItem.hash;
    return keccak2563(fromString2(getSignature(abiItem)));
  }
  var AmbiguityError, NotFoundError;
  var init_AbiItem = __esm({
    "node_modules/ox/_esm/core/AbiItem.js"() {
      init_exports();
      init_Errors();
      init_Hash();
      init_Hex();
      init_abiItem2();
      AmbiguityError = class extends BaseError3 {
        constructor(x, y) {
          super("Found ambiguous types in overloaded ABI Items.", {
            metaMessages: [
              // TODO: abitype to add support for signature-formatted ABI items.
              `\`${x.type}\` in \`${normalizeSignature2(formatAbiItem(x.abiItem))}\`, and`,
              `\`${y.type}\` in \`${normalizeSignature2(formatAbiItem(y.abiItem))}\``,
              "",
              "These types encode differently and cannot be distinguished at runtime.",
              "Remove one of the ambiguous items in the ABI."
            ]
          });
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "AbiItem.AmbiguityError"
          });
        }
      };
      NotFoundError = class extends BaseError3 {
        constructor({ name, data, type = "item" }) {
          const selector = (() => {
            if (name)
              return ` with name "${name}"`;
            if (data)
              return ` with data "${data}"`;
            return "";
          })();
          super(`ABI ${type}${selector} not found.`);
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "AbiItem.NotFoundError"
          });
        }
      };
    }
  });

  // node_modules/ox/_esm/core/Solidity.js
  var arrayRegex, bytesRegex3, integerRegex3, maxInt82, maxInt162, maxInt242, maxInt322, maxInt402, maxInt482, maxInt562, maxInt642, maxInt722, maxInt802, maxInt882, maxInt962, maxInt1042, maxInt1122, maxInt1202, maxInt1282, maxInt1362, maxInt1442, maxInt1522, maxInt1602, maxInt1682, maxInt1762, maxInt1842, maxInt1922, maxInt2002, maxInt2082, maxInt2162, maxInt2242, maxInt2322, maxInt2402, maxInt2482, maxInt2562, minInt82, minInt162, minInt242, minInt322, minInt402, minInt482, minInt562, minInt642, minInt722, minInt802, minInt882, minInt962, minInt1042, minInt1122, minInt1202, minInt1282, minInt1362, minInt1442, minInt1522, minInt1602, minInt1682, minInt1762, minInt1842, minInt1922, minInt2002, minInt2082, minInt2162, minInt2242, minInt2322, minInt2402, minInt2482, minInt2562, maxUint82, maxUint162, maxUint242, maxUint322, maxUint402, maxUint482, maxUint562, maxUint642, maxUint722, maxUint802, maxUint882, maxUint962, maxUint1042, maxUint1122, maxUint1202, maxUint1282, maxUint1362, maxUint1442, maxUint1522, maxUint1602, maxUint1682, maxUint1762, maxUint1842, maxUint1922, maxUint2002, maxUint2082, maxUint2162, maxUint2242, maxUint2322, maxUint2402, maxUint2482, maxUint2562;
  var init_Solidity = __esm({
    "node_modules/ox/_esm/core/Solidity.js"() {
      arrayRegex = /^(.*)\[([0-9]*)\]$/;
      bytesRegex3 = /^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/;
      integerRegex3 = /^(u?int)(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/;
      maxInt82 = 2n ** (8n - 1n) - 1n;
      maxInt162 = 2n ** (16n - 1n) - 1n;
      maxInt242 = 2n ** (24n - 1n) - 1n;
      maxInt322 = 2n ** (32n - 1n) - 1n;
      maxInt402 = 2n ** (40n - 1n) - 1n;
      maxInt482 = 2n ** (48n - 1n) - 1n;
      maxInt562 = 2n ** (56n - 1n) - 1n;
      maxInt642 = 2n ** (64n - 1n) - 1n;
      maxInt722 = 2n ** (72n - 1n) - 1n;
      maxInt802 = 2n ** (80n - 1n) - 1n;
      maxInt882 = 2n ** (88n - 1n) - 1n;
      maxInt962 = 2n ** (96n - 1n) - 1n;
      maxInt1042 = 2n ** (104n - 1n) - 1n;
      maxInt1122 = 2n ** (112n - 1n) - 1n;
      maxInt1202 = 2n ** (120n - 1n) - 1n;
      maxInt1282 = 2n ** (128n - 1n) - 1n;
      maxInt1362 = 2n ** (136n - 1n) - 1n;
      maxInt1442 = 2n ** (144n - 1n) - 1n;
      maxInt1522 = 2n ** (152n - 1n) - 1n;
      maxInt1602 = 2n ** (160n - 1n) - 1n;
      maxInt1682 = 2n ** (168n - 1n) - 1n;
      maxInt1762 = 2n ** (176n - 1n) - 1n;
      maxInt1842 = 2n ** (184n - 1n) - 1n;
      maxInt1922 = 2n ** (192n - 1n) - 1n;
      maxInt2002 = 2n ** (200n - 1n) - 1n;
      maxInt2082 = 2n ** (208n - 1n) - 1n;
      maxInt2162 = 2n ** (216n - 1n) - 1n;
      maxInt2242 = 2n ** (224n - 1n) - 1n;
      maxInt2322 = 2n ** (232n - 1n) - 1n;
      maxInt2402 = 2n ** (240n - 1n) - 1n;
      maxInt2482 = 2n ** (248n - 1n) - 1n;
      maxInt2562 = 2n ** (256n - 1n) - 1n;
      minInt82 = -(2n ** (8n - 1n));
      minInt162 = -(2n ** (16n - 1n));
      minInt242 = -(2n ** (24n - 1n));
      minInt322 = -(2n ** (32n - 1n));
      minInt402 = -(2n ** (40n - 1n));
      minInt482 = -(2n ** (48n - 1n));
      minInt562 = -(2n ** (56n - 1n));
      minInt642 = -(2n ** (64n - 1n));
      minInt722 = -(2n ** (72n - 1n));
      minInt802 = -(2n ** (80n - 1n));
      minInt882 = -(2n ** (88n - 1n));
      minInt962 = -(2n ** (96n - 1n));
      minInt1042 = -(2n ** (104n - 1n));
      minInt1122 = -(2n ** (112n - 1n));
      minInt1202 = -(2n ** (120n - 1n));
      minInt1282 = -(2n ** (128n - 1n));
      minInt1362 = -(2n ** (136n - 1n));
      minInt1442 = -(2n ** (144n - 1n));
      minInt1522 = -(2n ** (152n - 1n));
      minInt1602 = -(2n ** (160n - 1n));
      minInt1682 = -(2n ** (168n - 1n));
      minInt1762 = -(2n ** (176n - 1n));
      minInt1842 = -(2n ** (184n - 1n));
      minInt1922 = -(2n ** (192n - 1n));
      minInt2002 = -(2n ** (200n - 1n));
      minInt2082 = -(2n ** (208n - 1n));
      minInt2162 = -(2n ** (216n - 1n));
      minInt2242 = -(2n ** (224n - 1n));
      minInt2322 = -(2n ** (232n - 1n));
      minInt2402 = -(2n ** (240n - 1n));
      minInt2482 = -(2n ** (248n - 1n));
      minInt2562 = -(2n ** (256n - 1n));
      maxUint82 = 2n ** 8n - 1n;
      maxUint162 = 2n ** 16n - 1n;
      maxUint242 = 2n ** 24n - 1n;
      maxUint322 = 2n ** 32n - 1n;
      maxUint402 = 2n ** 40n - 1n;
      maxUint482 = 2n ** 48n - 1n;
      maxUint562 = 2n ** 56n - 1n;
      maxUint642 = 2n ** 64n - 1n;
      maxUint722 = 2n ** 72n - 1n;
      maxUint802 = 2n ** 80n - 1n;
      maxUint882 = 2n ** 88n - 1n;
      maxUint962 = 2n ** 96n - 1n;
      maxUint1042 = 2n ** 104n - 1n;
      maxUint1122 = 2n ** 112n - 1n;
      maxUint1202 = 2n ** 120n - 1n;
      maxUint1282 = 2n ** 128n - 1n;
      maxUint1362 = 2n ** 136n - 1n;
      maxUint1442 = 2n ** 144n - 1n;
      maxUint1522 = 2n ** 152n - 1n;
      maxUint1602 = 2n ** 160n - 1n;
      maxUint1682 = 2n ** 168n - 1n;
      maxUint1762 = 2n ** 176n - 1n;
      maxUint1842 = 2n ** 184n - 1n;
      maxUint1922 = 2n ** 192n - 1n;
      maxUint2002 = 2n ** 200n - 1n;
      maxUint2082 = 2n ** 208n - 1n;
      maxUint2162 = 2n ** 216n - 1n;
      maxUint2242 = 2n ** 224n - 1n;
      maxUint2322 = 2n ** 232n - 1n;
      maxUint2402 = 2n ** 240n - 1n;
      maxUint2482 = 2n ** 248n - 1n;
      maxUint2562 = 2n ** 256n - 1n;
    }
  });

  // node_modules/ox/_esm/core/internal/abiParameters.js
  function prepareParameters({ checksumAddress: checksumAddress2, parameters, values }) {
    const preparedParameters = [];
    for (let i = 0; i < parameters.length; i++) {
      preparedParameters.push(prepareParameter({
        checksumAddress: checksumAddress2,
        parameter: parameters[i],
        value: values[i]
      }));
    }
    return preparedParameters;
  }
  function prepareParameter({ checksumAddress: checksumAddress2 = false, parameter: parameter_, value }) {
    const parameter = parameter_;
    const arrayComponents = getArrayComponents2(parameter.type);
    if (arrayComponents) {
      const [length, type] = arrayComponents;
      return encodeArray2(value, {
        checksumAddress: checksumAddress2,
        length,
        parameter: {
          ...parameter,
          type
        }
      });
    }
    if (parameter.type === "tuple") {
      return encodeTuple2(value, {
        checksumAddress: checksumAddress2,
        parameter
      });
    }
    if (parameter.type === "address") {
      return encodeAddress2(value, {
        checksum: checksumAddress2
      });
    }
    if (parameter.type === "bool") {
      return encodeBoolean(value);
    }
    if (parameter.type.startsWith("uint") || parameter.type.startsWith("int")) {
      const signed2 = parameter.type.startsWith("int");
      const [, , size5 = "256"] = integerRegex3.exec(parameter.type) ?? [];
      return encodeNumber2(value, {
        signed: signed2,
        size: Number(size5)
      });
    }
    if (parameter.type.startsWith("bytes")) {
      return encodeBytes3(value, { type: parameter.type });
    }
    if (parameter.type === "string") {
      return encodeString2(value);
    }
    throw new InvalidTypeError(parameter.type);
  }
  function encode(preparedParameters) {
    let staticSize = 0;
    for (let i = 0; i < preparedParameters.length; i++) {
      const { dynamic, encoded } = preparedParameters[i];
      if (dynamic)
        staticSize += 32;
      else
        staticSize += size3(encoded);
    }
    const staticParameters = [];
    const dynamicParameters = [];
    let dynamicSize = 0;
    for (let i = 0; i < preparedParameters.length; i++) {
      const { dynamic, encoded } = preparedParameters[i];
      if (dynamic) {
        staticParameters.push(fromNumber(staticSize + dynamicSize, { size: 32 }));
        dynamicParameters.push(encoded);
        dynamicSize += size3(encoded);
      } else {
        staticParameters.push(encoded);
      }
    }
    return concat3(...staticParameters, ...dynamicParameters);
  }
  function encodeAddress2(value, options) {
    const { checksum: checksum4 = false } = options;
    assert3(value, { strict: checksum4 });
    return {
      dynamic: false,
      encoded: padLeft(value.toLowerCase())
    };
  }
  function encodeArray2(value, options) {
    const { checksumAddress: checksumAddress2, length, parameter } = options;
    const dynamic = length === null;
    if (!Array.isArray(value))
      throw new InvalidArrayError2(value);
    if (!dynamic && value.length !== length)
      throw new ArrayLengthMismatchError({
        expectedLength: length,
        givenLength: value.length,
        type: `${parameter.type}[${length}]`
      });
    let dynamicChild = false;
    const preparedParameters = [];
    for (let i = 0; i < value.length; i++) {
      const preparedParam = prepareParameter({
        checksumAddress: checksumAddress2,
        parameter,
        value: value[i]
      });
      if (preparedParam.dynamic)
        dynamicChild = true;
      preparedParameters.push(preparedParam);
    }
    if (dynamic || dynamicChild) {
      const data = encode(preparedParameters);
      if (dynamic) {
        const length2 = fromNumber(preparedParameters.length, { size: 32 });
        return {
          dynamic: true,
          encoded: preparedParameters.length > 0 ? concat3(length2, data) : length2
        };
      }
      if (dynamicChild)
        return { dynamic: true, encoded: data };
    }
    return {
      dynamic: false,
      encoded: concat3(...preparedParameters.map(({ encoded }) => encoded))
    };
  }
  function encodeBytes3(value, { type }) {
    const [, parametersize] = type.split("bytes");
    const bytesSize = size3(value);
    if (!parametersize) {
      let value_ = value;
      if (bytesSize % 32 !== 0)
        value_ = padRight(value_, Math.ceil((value.length - 2) / 2 / 32) * 32);
      return {
        dynamic: true,
        encoded: concat3(padLeft(fromNumber(bytesSize, { size: 32 })), value_)
      };
    }
    if (bytesSize !== Number.parseInt(parametersize))
      throw new BytesSizeMismatchError2({
        expectedSize: Number.parseInt(parametersize),
        value
      });
    return { dynamic: false, encoded: padRight(value) };
  }
  function encodeBoolean(value) {
    if (typeof value !== "boolean")
      throw new BaseError3(`Invalid boolean value: "${value}" (type: ${typeof value}). Expected: \`true\` or \`false\`.`);
    return { dynamic: false, encoded: padLeft(fromBoolean(value)) };
  }
  function encodeNumber2(value, { signed: signed2, size: size5 }) {
    if (typeof size5 === "number") {
      const max = 2n ** (BigInt(size5) - (signed2 ? 1n : 0n)) - 1n;
      const min = signed2 ? -max - 1n : 0n;
      if (value > max || value < min)
        throw new IntegerOutOfRangeError2({
          max: max.toString(),
          min: min.toString(),
          signed: signed2,
          size: size5 / 8,
          value: value.toString()
        });
    }
    return {
      dynamic: false,
      encoded: fromNumber(value, {
        size: 32,
        signed: signed2
      })
    };
  }
  function encodeString2(value) {
    const hexValue = fromString2(value);
    const partsLength = Math.ceil(size3(hexValue) / 32);
    const parts = [];
    for (let i = 0; i < partsLength; i++) {
      parts.push(padRight(slice2(hexValue, i * 32, (i + 1) * 32)));
    }
    return {
      dynamic: true,
      encoded: concat3(padRight(fromNumber(size3(hexValue), { size: 32 })), ...parts)
    };
  }
  function encodeTuple2(value, options) {
    const { checksumAddress: checksumAddress2, parameter } = options;
    let dynamic = false;
    const preparedParameters = [];
    for (let i = 0; i < parameter.components.length; i++) {
      const param_ = parameter.components[i];
      const index2 = Array.isArray(value) ? i : param_.name;
      const preparedParam = prepareParameter({
        checksumAddress: checksumAddress2,
        parameter: param_,
        value: value[index2]
      });
      preparedParameters.push(preparedParam);
      if (preparedParam.dynamic)
        dynamic = true;
    }
    return {
      dynamic,
      encoded: dynamic ? encode(preparedParameters) : concat3(...preparedParameters.map(({ encoded }) => encoded))
    };
  }
  function getArrayComponents2(type) {
    const matches = type.match(/^(.*)\[(\d+)?\]$/);
    return matches ? (
      // Return `null` if the array is dynamic.
      [matches[2] ? Number(matches[2]) : null, matches[1]]
    ) : void 0;
  }
  var init_abiParameters = __esm({
    "node_modules/ox/_esm/core/internal/abiParameters.js"() {
      init_AbiParameters();
      init_Address();
      init_Errors();
      init_Hex();
      init_Solidity();
    }
  });

  // node_modules/ox/_esm/core/AbiParameters.js
  function encode2(parameters, values, options) {
    const { checksumAddress: checksumAddress2 = false } = options ?? {};
    if (parameters.length !== values.length)
      throw new LengthMismatchError({
        expectedLength: parameters.length,
        givenLength: values.length
      });
    const preparedParameters = prepareParameters({
      checksumAddress: checksumAddress2,
      parameters,
      values
    });
    const data = encode(preparedParameters);
    if (data.length === 0)
      return "0x";
    return data;
  }
  function encodePacked(types, values) {
    if (types.length !== values.length)
      throw new LengthMismatchError({
        expectedLength: types.length,
        givenLength: values.length
      });
    const data = [];
    for (let i = 0; i < types.length; i++) {
      const type = types[i];
      const value = values[i];
      data.push(encodePacked.encode(type, value));
    }
    return concat3(...data);
  }
  var ArrayLengthMismatchError, BytesSizeMismatchError2, LengthMismatchError, InvalidArrayError2, InvalidTypeError;
  var init_AbiParameters = __esm({
    "node_modules/ox/_esm/core/AbiParameters.js"() {
      init_Address();
      init_Errors();
      init_Hex();
      init_Solidity();
      init_abiParameters();
      (function(encodePacked2) {
        function encode4(type, value, isArray = false) {
          if (type === "address") {
            const address = value;
            assert3(address);
            return padLeft(address.toLowerCase(), isArray ? 32 : 0);
          }
          if (type === "string")
            return fromString2(value);
          if (type === "bytes")
            return value;
          if (type === "bool")
            return padLeft(fromBoolean(value), isArray ? 32 : 1);
          const intMatch = type.match(integerRegex3);
          if (intMatch) {
            const [_type2, baseType, bits = "256"] = intMatch;
            const size5 = Number.parseInt(bits) / 8;
            return fromNumber(value, {
              size: isArray ? 32 : size5,
              signed: baseType === "int"
            });
          }
          const bytesMatch = type.match(bytesRegex3);
          if (bytesMatch) {
            const [_type2, size5] = bytesMatch;
            if (Number.parseInt(size5) !== (value.length - 2) / 2)
              throw new BytesSizeMismatchError2({
                expectedSize: Number.parseInt(size5),
                value
              });
            return padRight(value, isArray ? 32 : 0);
          }
          const arrayMatch = type.match(arrayRegex);
          if (arrayMatch && Array.isArray(value)) {
            const [_type2, childType] = arrayMatch;
            const data = [];
            for (let i = 0; i < value.length; i++) {
              data.push(encode4(childType, value[i], true));
            }
            if (data.length === 0)
              return "0x";
            return concat3(...data);
          }
          throw new InvalidTypeError(type);
        }
        encodePacked2.encode = encode4;
      })(encodePacked || (encodePacked = {}));
      ArrayLengthMismatchError = class extends BaseError3 {
        constructor({ expectedLength, givenLength, type }) {
          super(`Array length mismatch for type \`${type}\`. Expected: \`${expectedLength}\`. Given: \`${givenLength}\`.`);
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "AbiParameters.ArrayLengthMismatchError"
          });
        }
      };
      BytesSizeMismatchError2 = class extends BaseError3 {
        constructor({ expectedSize, value }) {
          super(`Size of bytes "${value}" (bytes${size3(value)}) does not match expected size (bytes${expectedSize}).`);
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "AbiParameters.BytesSizeMismatchError"
          });
        }
      };
      LengthMismatchError = class extends BaseError3 {
        constructor({ expectedLength, givenLength }) {
          super([
            "ABI encoding parameters/values length mismatch.",
            `Expected length (parameters): ${expectedLength}`,
            `Given length (values): ${givenLength}`
          ].join("\n"));
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "AbiParameters.LengthMismatchError"
          });
        }
      };
      InvalidArrayError2 = class extends BaseError3 {
        constructor(value) {
          super(`Value \`${value}\` is not a valid array.`);
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "AbiParameters.InvalidArrayError"
          });
        }
      };
      InvalidTypeError = class extends BaseError3 {
        constructor(type) {
          super(`Type \`${type}\` is not a valid ABI Type.`);
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "AbiParameters.InvalidTypeError"
          });
        }
      };
    }
  });

  // node_modules/ox/_esm/core/AbiConstructor.js
  function encode3(abiConstructor, options) {
    const { bytecode, args } = options;
    return concat3(bytecode, abiConstructor.inputs?.length && args?.length ? encode2(abiConstructor.inputs, args) : "0x");
  }
  function from3(abiConstructor) {
    return from2(abiConstructor);
  }
  var init_AbiConstructor = __esm({
    "node_modules/ox/_esm/core/AbiConstructor.js"() {
      init_AbiItem();
      init_AbiParameters();
      init_Hex();
    }
  });

  // node_modules/ox/_esm/core/AbiFunction.js
  function encodeData2(abiFunction, ...args) {
    const { overloads } = abiFunction;
    const item = overloads ? fromAbi2([abiFunction, ...overloads], abiFunction.name, {
      args: args[0]
    }) : abiFunction;
    const selector = getSelector2(item);
    const data = args.length > 0 ? encode2(item.inputs, args[0]) : void 0;
    return data ? concat3(selector, data) : selector;
  }
  function from4(abiFunction, options = {}) {
    return from2(abiFunction, options);
  }
  function fromAbi2(abi2, name, options) {
    const item = fromAbi(abi2, name, options);
    if (item.type !== "function")
      throw new NotFoundError({ name, type: "function" });
    return item;
  }
  function getSelector2(abiItem) {
    return getSelector(abiItem);
  }
  var init_AbiFunction = __esm({
    "node_modules/ox/_esm/core/AbiFunction.js"() {
      init_AbiItem();
      init_AbiParameters();
      init_Hex();
    }
  });

  // node_modules/viem/_esm/constants/address.js
  var ethAddress, zeroAddress;
  var init_address6 = __esm({
    "node_modules/viem/_esm/constants/address.js"() {
      ethAddress = "0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee";
      zeroAddress = "0x0000000000000000000000000000000000000000";
    }
  });

  // node_modules/viem/_esm/actions/public/simulateCalls.js
  async function simulateCalls(client, parameters) {
    const { blockNumber, blockTag, calls, stateOverrides, traceAssetChanges, traceTransfers, validation } = parameters;
    const account = parameters.account ? parseAccount(parameters.account) : void 0;
    if (traceAssetChanges && !account)
      throw new BaseError2("`account` is required when `traceAssetChanges` is true");
    const getBalanceData = account ? encode3(from3("constructor(bytes, bytes)"), {
      bytecode: deploylessCallViaBytecodeBytecode,
      args: [
        getBalanceCode,
        encodeData2(from4("function getBalance(address)"), [account.address])
      ]
    }) : void 0;
    const assetAddresses = traceAssetChanges ? await Promise.all(parameters.calls.map(async (call2) => {
      if (!call2.data && !call2.abi)
        return;
      const { accessList } = await createAccessList(client, {
        account: account.address,
        ...call2,
        data: call2.abi ? encodeFunctionData(call2) : call2.data
      });
      return accessList.map(({ address, storageKeys }) => storageKeys.length > 0 ? address : null);
    })).then((x) => x.flat().filter(Boolean)) : [];
    const blocks = await simulateBlocks(client, {
      blockNumber,
      blockTag,
      blocks: [
        ...traceAssetChanges ? [
          // ETH pre balances
          {
            calls: [{ data: getBalanceData }],
            stateOverrides
          },
          // Asset pre balances
          {
            calls: assetAddresses.map((address, i) => ({
              abi: [
                from4("function balanceOf(address) returns (uint256)")
              ],
              functionName: "balanceOf",
              args: [account.address],
              to: address,
              from: zeroAddress,
              nonce: i
            })),
            stateOverrides: [
              {
                address: zeroAddress,
                nonce: 0
              }
            ]
          }
        ] : [],
        {
          calls: [...calls, {}].map((call2) => ({
            ...call2,
            from: account?.address
          })),
          stateOverrides
        },
        ...traceAssetChanges ? [
          // ETH post balances
          {
            calls: [{ data: getBalanceData }]
          },
          // Asset post balances
          {
            calls: assetAddresses.map((address, i) => ({
              abi: [
                from4("function balanceOf(address) returns (uint256)")
              ],
              functionName: "balanceOf",
              args: [account.address],
              to: address,
              from: zeroAddress,
              nonce: i
            })),
            stateOverrides: [
              {
                address: zeroAddress,
                nonce: 0
              }
            ]
          },
          // Decimals
          {
            calls: assetAddresses.map((address, i) => ({
              to: address,
              abi: [
                from4("function decimals() returns (uint256)")
              ],
              functionName: "decimals",
              from: zeroAddress,
              nonce: i
            })),
            stateOverrides: [
              {
                address: zeroAddress,
                nonce: 0
              }
            ]
          },
          // Token URI
          {
            calls: assetAddresses.map((address, i) => ({
              to: address,
              abi: [
                from4("function tokenURI(uint256) returns (string)")
              ],
              functionName: "tokenURI",
              args: [0n],
              from: zeroAddress,
              nonce: i
            })),
            stateOverrides: [
              {
                address: zeroAddress,
                nonce: 0
              }
            ]
          },
          // Symbols
          {
            calls: assetAddresses.map((address, i) => ({
              to: address,
              abi: [from4("function symbol() returns (string)")],
              functionName: "symbol",
              from: zeroAddress,
              nonce: i
            })),
            stateOverrides: [
              {
                address: zeroAddress,
                nonce: 0
              }
            ]
          }
        ] : []
      ],
      traceTransfers,
      validation
    });
    const block_results = traceAssetChanges ? blocks[2] : blocks[0];
    const [block_ethPre, block_assetsPre, , block_ethPost, block_assetsPost, block_decimals, block_tokenURI, block_symbols] = traceAssetChanges ? blocks : [];
    const { calls: block_calls, ...block } = block_results;
    const results = block_calls.slice(0, -1) ?? [];
    const ethPre = block_ethPre?.calls ?? [];
    const assetsPre = block_assetsPre?.calls ?? [];
    const balancesPre = [...ethPre, ...assetsPre].map((call2) => call2.status === "success" ? hexToBigInt(call2.data) : null);
    const ethPost = block_ethPost?.calls ?? [];
    const assetsPost = block_assetsPost?.calls ?? [];
    const balancesPost = [...ethPost, ...assetsPost].map((call2) => call2.status === "success" ? hexToBigInt(call2.data) : null);
    const decimals = (block_decimals?.calls ?? []).map((x) => x.status === "success" ? x.result : null);
    const symbols = (block_symbols?.calls ?? []).map((x) => x.status === "success" ? x.result : null);
    const tokenURI = (block_tokenURI?.calls ?? []).map((x) => x.status === "success" ? x.result : null);
    const changes = [];
    for (const [i, balancePost] of balancesPost.entries()) {
      const balancePre = balancesPre[i];
      if (typeof balancePost !== "bigint")
        continue;
      if (typeof balancePre !== "bigint")
        continue;
      const decimals_ = decimals[i - 1];
      const symbol_ = symbols[i - 1];
      const tokenURI_ = tokenURI[i - 1];
      const token = (() => {
        if (i === 0)
          return {
            address: ethAddress,
            decimals: 18,
            symbol: "ETH"
          };
        return {
          address: assetAddresses[i - 1],
          decimals: tokenURI_ || decimals_ ? Number(decimals_ ?? 1) : void 0,
          symbol: symbol_ ?? void 0
        };
      })();
      if (changes.some((change) => change.token.address === token.address))
        continue;
      changes.push({
        token,
        value: {
          pre: balancePre,
          post: balancePost,
          diff: balancePost - balancePre
        }
      });
    }
    return {
      assetChanges: changes,
      block,
      results
    };
  }
  var getBalanceCode;
  var init_simulateCalls = __esm({
    "node_modules/viem/_esm/actions/public/simulateCalls.js"() {
      init_AbiConstructor();
      init_AbiFunction();
      init_parseAccount();
      init_address6();
      init_contracts();
      init_base();
      init_encodeFunctionData();
      init_utils11();
      init_createAccessList();
      init_simulateBlocks();
      getBalanceCode = "0x6080604052348015600e575f80fd5b5061016d8061001c5f395ff3fe608060405234801561000f575f80fd5b5060043610610029575f3560e01c8063f8b2cb4f1461002d575b5f80fd5b610047600480360381019061004291906100db565b61005d565b604051610054919061011e565b60405180910390f35b5f8173ffffffffffffffffffffffffffffffffffffffff16319050919050565b5f80fd5b5f73ffffffffffffffffffffffffffffffffffffffff82169050919050565b5f6100aa82610081565b9050919050565b6100ba816100a0565b81146100c4575f80fd5b50565b5f813590506100d5816100b1565b92915050565b5f602082840312156100f0576100ef61007d565b5b5f6100fd848285016100c7565b91505092915050565b5f819050919050565b61011881610106565b82525050565b5f6020820190506101315f83018461010f565b9291505056fea26469706673582212203b9fe929fe995c7cf9887f0bdba8a36dd78e8b73f149b17d2d9ad7cd09d2dc6264736f6c634300081a0033";
    }
  });

  // node_modules/viem/_esm/utils/signature/serializeSignature.js
  function serializeSignature({ r, s, to = "hex", v, yParity }) {
    const yParity_ = (() => {
      if (yParity === 0 || yParity === 1)
        return yParity;
      if (v && (v === 27n || v === 28n || v >= 35n))
        return v % 2n === 0n ? 1 : 0;
      throw new Error("Invalid `v` or `yParity` value");
    })();
    const signature = `0x${new secp256k12.Signature(hexToBigInt(r), hexToBigInt(s)).toCompactHex()}${yParity_ === 0 ? "1b" : "1c"}`;
    if (to === "hex")
      return signature;
    return hexToBytes2(signature);
  }
  var init_serializeSignature = __esm({
    "node_modules/viem/_esm/utils/signature/serializeSignature.js"() {
      init_secp256k12();
      init_fromHex();
      init_toBytes();
    }
  });

  // node_modules/viem/_esm/actions/public/verifyHash.js
  async function verifyHash(client, parameters) {
    const { address, factory, factoryData, hash: hash3, signature, universalSignatureVerifierAddress = client.chain?.contracts?.universalSignatureVerifier?.address, ...rest } = parameters;
    const signatureHex = (() => {
      if (isHex(signature))
        return signature;
      if (typeof signature === "object" && "r" in signature && "s" in signature)
        return serializeSignature(signature);
      return bytesToHex2(signature);
    })();
    const wrappedSignature = await (async () => {
      if (!factory && !factoryData)
        return signatureHex;
      if (isErc6492Signature(signatureHex))
        return signatureHex;
      return serializeErc6492Signature({
        address: factory,
        data: factoryData,
        signature: signatureHex
      });
    })();
    try {
      const args = universalSignatureVerifierAddress ? {
        to: universalSignatureVerifierAddress,
        data: encodeFunctionData({
          abi: universalSignatureValidatorAbi,
          functionName: "isValidSig",
          args: [address, hash3, wrappedSignature]
        }),
        ...rest
      } : {
        data: encodeDeployData({
          abi: universalSignatureValidatorAbi,
          args: [address, hash3, wrappedSignature],
          bytecode: universalSignatureValidatorByteCode
        }),
        ...rest
      };
      const { data } = await getAction(client, call, "call")(args);
      return hexToBool(data ?? "0x0");
    } catch (error) {
      try {
        const verified = isAddressEqual(getAddress2(address), await recoverAddress2({ hash: hash3, signature }));
        if (verified)
          return true;
      } catch {
      }
      if (error instanceof CallExecutionError) {
        return false;
      }
      throw error;
    }
  }
  var init_verifyHash = __esm({
    "node_modules/viem/_esm/actions/public/verifyHash.js"() {
      init_abis();
      init_contracts();
      init_contract3();
      init_encodeDeployData();
      init_getAddress();
      init_isAddressEqual();
      init_isHex();
      init_toHex();
      init_getAction();
      init_utils11();
      init_isErc6492Signature();
      init_recoverAddress();
      init_serializeErc6492Signature();
      init_serializeSignature();
      init_call();
    }
  });

  // node_modules/viem/_esm/actions/public/verifyMessage.js
  async function verifyMessage2(client, { address, message, factory, factoryData, signature, ...callRequest }) {
    const hash3 = hashMessage2(message);
    return verifyHash(client, {
      address,
      factory,
      factoryData,
      hash: hash3,
      signature,
      ...callRequest
    });
  }
  var init_verifyMessage = __esm({
    "node_modules/viem/_esm/actions/public/verifyMessage.js"() {
      init_hashMessage();
      init_verifyHash();
    }
  });

  // node_modules/viem/_esm/actions/public/verifyTypedData.js
  async function verifyTypedData2(client, parameters) {
    const { address, factory, factoryData, signature, message, primaryType, types, domain, ...callRequest } = parameters;
    const hash3 = hashTypedData({ message, primaryType, types, domain });
    return verifyHash(client, {
      address,
      factory,
      factoryData,
      hash: hash3,
      signature,
      ...callRequest
    });
  }
  var init_verifyTypedData = __esm({
    "node_modules/viem/_esm/actions/public/verifyTypedData.js"() {
      init_hashTypedData();
      init_verifyHash();
    }
  });

  // node_modules/viem/_esm/actions/public/watchBlockNumber.js
  function watchBlockNumber(client, { emitOnBegin = false, emitMissed = false, onBlockNumber, onError, poll: poll_, pollingInterval = client.pollingInterval }) {
    const enablePolling = (() => {
      if (typeof poll_ !== "undefined")
        return poll_;
      if (client.transport.type === "webSocket" || client.transport.type === "ipc")
        return false;
      if (client.transport.type === "fallback" && (client.transport.transports[0].config.type === "webSocket" || client.transport.transports[0].config.type === "ipc"))
        return false;
      return true;
    })();
    let prevBlockNumber;
    const pollBlockNumber = () => {
      const observerId = stringify3([
        "watchBlockNumber",
        client.uid,
        emitOnBegin,
        emitMissed,
        pollingInterval
      ]);
      return observe(observerId, { onBlockNumber, onError }, (emit2) => poll(async () => {
        try {
          const blockNumber = await getAction(client, getBlockNumber, "getBlockNumber")({ cacheTime: 0 });
          if (prevBlockNumber) {
            if (blockNumber === prevBlockNumber)
              return;
            if (blockNumber - prevBlockNumber > 1 && emitMissed) {
              for (let i = prevBlockNumber + 1n; i < blockNumber; i++) {
                emit2.onBlockNumber(i, prevBlockNumber);
                prevBlockNumber = i;
              }
            }
          }
          if (!prevBlockNumber || blockNumber > prevBlockNumber) {
            emit2.onBlockNumber(blockNumber, prevBlockNumber);
            prevBlockNumber = blockNumber;
          }
        } catch (err) {
          emit2.onError?.(err);
        }
      }, {
        emitOnBegin,
        interval: pollingInterval
      }));
    };
    const subscribeBlockNumber = () => {
      const observerId = stringify3([
        "watchBlockNumber",
        client.uid,
        emitOnBegin,
        emitMissed
      ]);
      return observe(observerId, { onBlockNumber, onError }, (emit2) => {
        let active = true;
        let unsubscribe = () => active = false;
        (async () => {
          try {
            const transport = (() => {
              if (client.transport.type === "fallback") {
                const transport2 = client.transport.transports.find((transport3) => transport3.config.type === "webSocket" || transport3.config.type === "ipc");
                if (!transport2)
                  return client.transport;
                return transport2.value;
              }
              return client.transport;
            })();
            const { unsubscribe: unsubscribe_ } = await transport.subscribe({
              params: ["newHeads"],
              onData(data) {
                if (!active)
                  return;
                const blockNumber = hexToBigInt(data.result?.number);
                emit2.onBlockNumber(blockNumber, prevBlockNumber);
                prevBlockNumber = blockNumber;
              },
              onError(error) {
                emit2.onError?.(error);
              }
            });
            unsubscribe = unsubscribe_;
            if (!active)
              unsubscribe();
          } catch (err) {
            onError?.(err);
          }
        })();
        return () => unsubscribe();
      });
    };
    return enablePolling ? pollBlockNumber() : subscribeBlockNumber();
  }
  var init_watchBlockNumber = __esm({
    "node_modules/viem/_esm/actions/public/watchBlockNumber.js"() {
      init_fromHex();
      init_getAction();
      init_observe();
      init_poll();
      init_stringify();
      init_getBlockNumber();
    }
  });

  // node_modules/viem/_esm/actions/public/waitForTransactionReceipt.js
  async function waitForTransactionReceipt(client, {
    confirmations = 1,
    hash: hash3,
    onReplaced,
    pollingInterval = client.pollingInterval,
    retryCount = 6,
    retryDelay = ({ count }) => ~~(1 << count) * 200,
    // exponential backoff
    timeout = 18e4
  }) {
    const observerId = stringify3(["waitForTransactionReceipt", client.uid, hash3]);
    let transaction;
    let replacedTransaction;
    let receipt;
    let retrying = false;
    let _unobserve;
    let _unwatch;
    const { promise, resolve, reject } = withResolvers();
    const timer = timeout ? setTimeout(() => {
      _unwatch();
      _unobserve();
      reject(new WaitForTransactionReceiptTimeoutError({ hash: hash3 }));
    }, timeout) : void 0;
    _unobserve = observe(observerId, { onReplaced, resolve, reject }, (emit2) => {
      _unwatch = getAction(client, watchBlockNumber, "watchBlockNumber")({
        emitMissed: true,
        emitOnBegin: true,
        poll: true,
        pollingInterval,
        async onBlockNumber(blockNumber_) {
          const done = (fn) => {
            clearTimeout(timer);
            _unwatch();
            fn();
            _unobserve();
          };
          let blockNumber = blockNumber_;
          if (retrying)
            return;
          try {
            if (receipt) {
              if (confirmations > 1 && (!receipt.blockNumber || blockNumber - receipt.blockNumber + 1n < confirmations))
                return;
              done(() => emit2.resolve(receipt));
              return;
            }
            if (!transaction) {
              retrying = true;
              await withRetry(async () => {
                transaction = await getAction(client, getTransaction, "getTransaction")({ hash: hash3 });
                if (transaction.blockNumber)
                  blockNumber = transaction.blockNumber;
              }, {
                delay: retryDelay,
                retryCount
              });
              retrying = false;
            }
            receipt = await getAction(client, getTransactionReceipt, "getTransactionReceipt")({ hash: hash3 });
            if (confirmations > 1 && (!receipt.blockNumber || blockNumber - receipt.blockNumber + 1n < confirmations))
              return;
            done(() => emit2.resolve(receipt));
          } catch (err) {
            if (err instanceof TransactionNotFoundError || err instanceof TransactionReceiptNotFoundError) {
              if (!transaction) {
                retrying = false;
                return;
              }
              try {
                replacedTransaction = transaction;
                retrying = true;
                const block = await withRetry(() => getAction(client, getBlock, "getBlock")({
                  blockNumber,
                  includeTransactions: true
                }), {
                  delay: retryDelay,
                  retryCount,
                  shouldRetry: ({ error }) => error instanceof BlockNotFoundError
                });
                retrying = false;
                const replacementTransaction = block.transactions.find(({ from: from5, nonce }) => from5 === replacedTransaction.from && nonce === replacedTransaction.nonce);
                if (!replacementTransaction)
                  return;
                receipt = await getAction(client, getTransactionReceipt, "getTransactionReceipt")({
                  hash: replacementTransaction.hash
                });
                if (confirmations > 1 && (!receipt.blockNumber || blockNumber - receipt.blockNumber + 1n < confirmations))
                  return;
                let reason = "replaced";
                if (replacementTransaction.to === replacedTransaction.to && replacementTransaction.value === replacedTransaction.value && replacementTransaction.input === replacedTransaction.input) {
                  reason = "repriced";
                } else if (replacementTransaction.from === replacementTransaction.to && replacementTransaction.value === 0n) {
                  reason = "cancelled";
                }
                done(() => {
                  emit2.onReplaced?.({
                    reason,
                    replacedTransaction,
                    transaction: replacementTransaction,
                    transactionReceipt: receipt
                  });
                  emit2.resolve(receipt);
                });
              } catch (err_) {
                done(() => emit2.reject(err_));
              }
            } else {
              done(() => emit2.reject(err));
            }
          }
        }
      });
    });
    return promise;
  }
  var init_waitForTransactionReceipt = __esm({
    "node_modules/viem/_esm/actions/public/waitForTransactionReceipt.js"() {
      init_block();
      init_transaction3();
      init_getAction();
      init_observe();
      init_withResolvers();
      init_withRetry();
      init_stringify();
      init_getBlock();
      init_getTransaction();
      init_getTransactionReceipt();
      init_watchBlockNumber();
    }
  });

  // node_modules/viem/_esm/actions/public/watchBlocks.js
  function watchBlocks(client, { blockTag = "latest", emitMissed = false, emitOnBegin = false, onBlock, onError, includeTransactions: includeTransactions_, poll: poll_, pollingInterval = client.pollingInterval }) {
    const enablePolling = (() => {
      if (typeof poll_ !== "undefined")
        return poll_;
      if (client.transport.type === "webSocket" || client.transport.type === "ipc")
        return false;
      if (client.transport.type === "fallback" && (client.transport.transports[0].config.type === "webSocket" || client.transport.transports[0].config.type === "ipc"))
        return false;
      return true;
    })();
    const includeTransactions = includeTransactions_ ?? false;
    let prevBlock;
    const pollBlocks = () => {
      const observerId = stringify3([
        "watchBlocks",
        client.uid,
        blockTag,
        emitMissed,
        emitOnBegin,
        includeTransactions,
        pollingInterval
      ]);
      return observe(observerId, { onBlock, onError }, (emit2) => poll(async () => {
        try {
          const block = await getAction(client, getBlock, "getBlock")({
            blockTag,
            includeTransactions
          });
          if (block.number !== null && prevBlock?.number != null) {
            if (block.number === prevBlock.number)
              return;
            if (block.number - prevBlock.number > 1 && emitMissed) {
              for (let i = prevBlock?.number + 1n; i < block.number; i++) {
                const block2 = await getAction(client, getBlock, "getBlock")({
                  blockNumber: i,
                  includeTransactions
                });
                emit2.onBlock(block2, prevBlock);
                prevBlock = block2;
              }
            }
          }
          if (
            // If no previous block exists, emit.
            prevBlock?.number == null || // If the block tag is "pending" with no block number, emit.
            blockTag === "pending" && block?.number == null || // If the next block number is greater than the previous block number, emit.
            // We don't want to emit blocks in the past.
            block.number !== null && block.number > prevBlock.number
          ) {
            emit2.onBlock(block, prevBlock);
            prevBlock = block;
          }
        } catch (err) {
          emit2.onError?.(err);
        }
      }, {
        emitOnBegin,
        interval: pollingInterval
      }));
    };
    const subscribeBlocks = () => {
      let active = true;
      let emitFetched = true;
      let unsubscribe = () => active = false;
      (async () => {
        try {
          if (emitOnBegin) {
            getAction(client, getBlock, "getBlock")({
              blockTag,
              includeTransactions
            }).then((block) => {
              if (!active)
                return;
              if (!emitFetched)
                return;
              onBlock(block, void 0);
              emitFetched = false;
            }).catch(onError);
          }
          const transport = (() => {
            if (client.transport.type === "fallback") {
              const transport2 = client.transport.transports.find((transport3) => transport3.config.type === "webSocket" || transport3.config.type === "ipc");
              if (!transport2)
                return client.transport;
              return transport2.value;
            }
            return client.transport;
          })();
          const { unsubscribe: unsubscribe_ } = await transport.subscribe({
            params: ["newHeads"],
            async onData(data) {
              if (!active)
                return;
              const block = await getAction(client, getBlock, "getBlock")({
                blockNumber: data.result?.number,
                includeTransactions
              }).catch(() => {
              });
              if (!active)
                return;
              onBlock(block, prevBlock);
              emitFetched = false;
              prevBlock = block;
            },
            onError(error) {
              onError?.(error);
            }
          });
          unsubscribe = unsubscribe_;
          if (!active)
            unsubscribe();
        } catch (err) {
          onError?.(err);
        }
      })();
      return () => unsubscribe();
    };
    return enablePolling ? pollBlocks() : subscribeBlocks();
  }
  var init_watchBlocks = __esm({
    "node_modules/viem/_esm/actions/public/watchBlocks.js"() {
      init_getAction();
      init_observe();
      init_poll();
      init_stringify();
      init_getBlock();
    }
  });

  // node_modules/viem/_esm/actions/public/watchEvent.js
  function watchEvent(client, { address, args, batch = true, event, events, fromBlock, onError, onLogs, poll: poll_, pollingInterval = client.pollingInterval, strict: strict_ }) {
    const enablePolling = (() => {
      if (typeof poll_ !== "undefined")
        return poll_;
      if (typeof fromBlock === "bigint")
        return true;
      if (client.transport.type === "webSocket" || client.transport.type === "ipc")
        return false;
      if (client.transport.type === "fallback" && (client.transport.transports[0].config.type === "webSocket" || client.transport.transports[0].config.type === "ipc"))
        return false;
      return true;
    })();
    const strict = strict_ ?? false;
    const pollEvent = () => {
      const observerId = stringify3([
        "watchEvent",
        address,
        args,
        batch,
        client.uid,
        event,
        pollingInterval,
        fromBlock
      ]);
      return observe(observerId, { onLogs, onError }, (emit2) => {
        let previousBlockNumber;
        if (fromBlock !== void 0)
          previousBlockNumber = fromBlock - 1n;
        let filter;
        let initialized = false;
        const unwatch = poll(async () => {
          if (!initialized) {
            try {
              filter = await getAction(client, createEventFilter, "createEventFilter")({
                address,
                args,
                event,
                events,
                strict,
                fromBlock
              });
            } catch {
            }
            initialized = true;
            return;
          }
          try {
            let logs;
            if (filter) {
              logs = await getAction(client, getFilterChanges, "getFilterChanges")({ filter });
            } else {
              const blockNumber = await getAction(client, getBlockNumber, "getBlockNumber")({});
              if (previousBlockNumber && previousBlockNumber !== blockNumber) {
                logs = await getAction(client, getLogs, "getLogs")({
                  address,
                  args,
                  event,
                  events,
                  fromBlock: previousBlockNumber + 1n,
                  toBlock: blockNumber
                });
              } else {
                logs = [];
              }
              previousBlockNumber = blockNumber;
            }
            if (logs.length === 0)
              return;
            if (batch)
              emit2.onLogs(logs);
            else
              for (const log of logs)
                emit2.onLogs([log]);
          } catch (err) {
            if (filter && err instanceof InvalidInputRpcError)
              initialized = false;
            emit2.onError?.(err);
          }
        }, {
          emitOnBegin: true,
          interval: pollingInterval
        });
        return async () => {
          if (filter)
            await getAction(client, uninstallFilter, "uninstallFilter")({ filter });
          unwatch();
        };
      });
    };
    const subscribeEvent = () => {
      let active = true;
      let unsubscribe = () => active = false;
      (async () => {
        try {
          const transport = (() => {
            if (client.transport.type === "fallback") {
              const transport2 = client.transport.transports.find((transport3) => transport3.config.type === "webSocket" || transport3.config.type === "ipc");
              if (!transport2)
                return client.transport;
              return transport2.value;
            }
            return client.transport;
          })();
          const events_ = events ?? (event ? [event] : void 0);
          let topics = [];
          if (events_) {
            const encoded = events_.flatMap((event2) => encodeEventTopics({
              abi: [event2],
              eventName: event2.name,
              args
            }));
            topics = [encoded];
            if (event)
              topics = topics[0];
          }
          const { unsubscribe: unsubscribe_ } = await transport.subscribe({
            params: ["logs", { address, topics }],
            onData(data) {
              if (!active)
                return;
              const log = data.result;
              try {
                const { eventName, args: args2 } = decodeEventLog({
                  abi: events_ ?? [],
                  data: log.data,
                  topics: log.topics,
                  strict
                });
                const formatted = formatLog2(log, { args: args2, eventName });
                onLogs([formatted]);
              } catch (err) {
                let eventName;
                let isUnnamed;
                if (err instanceof DecodeLogDataMismatch || err instanceof DecodeLogTopicsMismatch) {
                  if (strict_)
                    return;
                  eventName = err.abiItem.name;
                  isUnnamed = err.abiItem.inputs?.some((x) => !("name" in x && x.name));
                }
                const formatted = formatLog2(log, {
                  args: isUnnamed ? [] : {},
                  eventName
                });
                onLogs([formatted]);
              }
            },
            onError(error) {
              onError?.(error);
            }
          });
          unsubscribe = unsubscribe_;
          if (!active)
            unsubscribe();
        } catch (err) {
          onError?.(err);
        }
      })();
      return () => unsubscribe();
    };
    return enablePolling ? pollEvent() : subscribeEvent();
  }
  var init_watchEvent = __esm({
    "node_modules/viem/_esm/actions/public/watchEvent.js"() {
      init_encodeEventTopics();
      init_observe();
      init_poll();
      init_stringify();
      init_abi2();
      init_rpc();
      init_decodeEventLog();
      init_log2();
      init_getAction();
      init_createEventFilter();
      init_getBlockNumber();
      init_getFilterChanges();
      init_getLogs();
      init_uninstallFilter();
    }
  });

  // node_modules/viem/_esm/actions/public/watchPendingTransactions.js
  function watchPendingTransactions(client, { batch = true, onError, onTransactions, poll: poll_, pollingInterval = client.pollingInterval }) {
    const enablePolling = typeof poll_ !== "undefined" ? poll_ : client.transport.type !== "webSocket" && client.transport.type !== "ipc";
    const pollPendingTransactions = () => {
      const observerId = stringify3([
        "watchPendingTransactions",
        client.uid,
        batch,
        pollingInterval
      ]);
      return observe(observerId, { onTransactions, onError }, (emit2) => {
        let filter;
        const unwatch = poll(async () => {
          try {
            if (!filter) {
              try {
                filter = await getAction(client, createPendingTransactionFilter, "createPendingTransactionFilter")({});
                return;
              } catch (err) {
                unwatch();
                throw err;
              }
            }
            const hashes = await getAction(client, getFilterChanges, "getFilterChanges")({ filter });
            if (hashes.length === 0)
              return;
            if (batch)
              emit2.onTransactions(hashes);
            else
              for (const hash3 of hashes)
                emit2.onTransactions([hash3]);
          } catch (err) {
            emit2.onError?.(err);
          }
        }, {
          emitOnBegin: true,
          interval: pollingInterval
        });
        return async () => {
          if (filter)
            await getAction(client, uninstallFilter, "uninstallFilter")({ filter });
          unwatch();
        };
      });
    };
    const subscribePendingTransactions = () => {
      let active = true;
      let unsubscribe = () => active = false;
      (async () => {
        try {
          const { unsubscribe: unsubscribe_ } = await client.transport.subscribe({
            params: ["newPendingTransactions"],
            onData(data) {
              if (!active)
                return;
              const transaction = data.result;
              onTransactions([transaction]);
            },
            onError(error) {
              onError?.(error);
            }
          });
          unsubscribe = unsubscribe_;
          if (!active)
            unsubscribe();
        } catch (err) {
          onError?.(err);
        }
      })();
      return () => unsubscribe();
    };
    return enablePolling ? pollPendingTransactions() : subscribePendingTransactions();
  }
  var init_watchPendingTransactions = __esm({
    "node_modules/viem/_esm/actions/public/watchPendingTransactions.js"() {
      init_getAction();
      init_observe();
      init_poll();
      init_stringify();
      init_createPendingTransactionFilter();
      init_getFilterChanges();
      init_uninstallFilter();
    }
  });

  // node_modules/viem/_esm/utils/siwe/parseSiweMessage.js
  function parseSiweMessage(message) {
    const { scheme, statement, ...prefix } = message.match(prefixRegex)?.groups ?? {};
    const { chainId, expirationTime, issuedAt, notBefore, requestId, ...suffix } = message.match(suffixRegex)?.groups ?? {};
    const resources = message.split("Resources:")[1]?.split("\n- ").slice(1);
    return {
      ...prefix,
      ...suffix,
      ...chainId ? { chainId: Number(chainId) } : {},
      ...expirationTime ? { expirationTime: new Date(expirationTime) } : {},
      ...issuedAt ? { issuedAt: new Date(issuedAt) } : {},
      ...notBefore ? { notBefore: new Date(notBefore) } : {},
      ...requestId ? { requestId } : {},
      ...resources ? { resources } : {},
      ...scheme ? { scheme } : {},
      ...statement ? { statement } : {}
    };
  }
  var prefixRegex, suffixRegex;
  var init_parseSiweMessage = __esm({
    "node_modules/viem/_esm/utils/siwe/parseSiweMessage.js"() {
      prefixRegex = /^(?:(?<scheme>[a-zA-Z][a-zA-Z0-9+-.]*):\/\/)?(?<domain>[a-zA-Z0-9+-.]*(?::[0-9]{1,5})?) (?:wants you to sign in with your Ethereum account:\n)(?<address>0x[a-fA-F0-9]{40})\n\n(?:(?<statement>.*)\n\n)?/;
      suffixRegex = /(?:URI: (?<uri>.+))\n(?:Version: (?<version>.+))\n(?:Chain ID: (?<chainId>\d+))\n(?:Nonce: (?<nonce>[a-zA-Z0-9]+))\n(?:Issued At: (?<issuedAt>.+))(?:\nExpiration Time: (?<expirationTime>.+))?(?:\nNot Before: (?<notBefore>.+))?(?:\nRequest ID: (?<requestId>.+))?/;
    }
  });

  // node_modules/viem/_esm/utils/siwe/validateSiweMessage.js
  function validateSiweMessage(parameters) {
    const { address, domain, message, nonce, scheme, time = /* @__PURE__ */ new Date() } = parameters;
    if (domain && message.domain !== domain)
      return false;
    if (nonce && message.nonce !== nonce)
      return false;
    if (scheme && message.scheme !== scheme)
      return false;
    if (message.expirationTime && time >= message.expirationTime)
      return false;
    if (message.notBefore && time < message.notBefore)
      return false;
    try {
      if (!message.address)
        return false;
      if (!isAddress2(message.address, { strict: false }))
        return false;
      if (address && !isAddressEqual(message.address, address))
        return false;
    } catch {
      return false;
    }
    return true;
  }
  var init_validateSiweMessage = __esm({
    "node_modules/viem/_esm/utils/siwe/validateSiweMessage.js"() {
      init_isAddress();
      init_isAddressEqual();
    }
  });

  // node_modules/viem/_esm/actions/siwe/verifySiweMessage.js
  async function verifySiweMessage(client, parameters) {
    const { address, domain, message, nonce, scheme, signature, time = /* @__PURE__ */ new Date(), ...callRequest } = parameters;
    const parsed = parseSiweMessage(message);
    if (!parsed.address)
      return false;
    const isValid = validateSiweMessage({
      address,
      domain,
      message: parsed,
      nonce,
      scheme,
      time
    });
    if (!isValid)
      return false;
    const hash3 = hashMessage2(message);
    return verifyHash(client, {
      address: parsed.address,
      hash: hash3,
      signature,
      ...callRequest
    });
  }
  var init_verifySiweMessage = __esm({
    "node_modules/viem/_esm/actions/siwe/verifySiweMessage.js"() {
      init_hashMessage();
      init_parseSiweMessage();
      init_validateSiweMessage();
      init_verifyHash();
    }
  });

  // node_modules/viem/_esm/clients/decorators/public.js
  function publicActions(client) {
    return {
      call: (args) => call(client, args),
      createAccessList: (args) => createAccessList(client, args),
      createBlockFilter: () => createBlockFilter(client),
      createContractEventFilter: (args) => createContractEventFilter(client, args),
      createEventFilter: (args) => createEventFilter(client, args),
      createPendingTransactionFilter: () => createPendingTransactionFilter(client),
      estimateContractGas: (args) => estimateContractGas(client, args),
      estimateGas: (args) => estimateGas(client, args),
      getBalance: (args) => getBalance(client, args),
      getBlobBaseFee: () => getBlobBaseFee(client),
      getBlock: (args) => getBlock(client, args),
      getBlockNumber: (args) => getBlockNumber(client, args),
      getBlockTransactionCount: (args) => getBlockTransactionCount(client, args),
      getBytecode: (args) => getCode(client, args),
      getChainId: () => getChainId(client),
      getCode: (args) => getCode(client, args),
      getContractEvents: (args) => getContractEvents(client, args),
      getEip712Domain: (args) => getEip712Domain(client, args),
      getEnsAddress: (args) => getEnsAddress(client, args),
      getEnsAvatar: (args) => getEnsAvatar(client, args),
      getEnsName: (args) => getEnsName(client, args),
      getEnsResolver: (args) => getEnsResolver(client, args),
      getEnsText: (args) => getEnsText(client, args),
      getFeeHistory: (args) => getFeeHistory(client, args),
      estimateFeesPerGas: (args) => estimateFeesPerGas(client, args),
      getFilterChanges: (args) => getFilterChanges(client, args),
      getFilterLogs: (args) => getFilterLogs(client, args),
      getGasPrice: () => getGasPrice(client),
      getLogs: (args) => getLogs(client, args),
      getProof: (args) => getProof(client, args),
      estimateMaxPriorityFeePerGas: (args) => estimateMaxPriorityFeePerGas(client, args),
      getStorageAt: (args) => getStorageAt(client, args),
      getTransaction: (args) => getTransaction(client, args),
      getTransactionConfirmations: (args) => getTransactionConfirmations(client, args),
      getTransactionCount: (args) => getTransactionCount(client, args),
      getTransactionReceipt: (args) => getTransactionReceipt(client, args),
      multicall: (args) => multicall(client, args),
      prepareTransactionRequest: (args) => prepareTransactionRequest(client, args),
      readContract: (args) => readContract(client, args),
      sendRawTransaction: (args) => sendRawTransaction(client, args),
      simulate: (args) => simulateBlocks(client, args),
      simulateBlocks: (args) => simulateBlocks(client, args),
      simulateCalls: (args) => simulateCalls(client, args),
      simulateContract: (args) => simulateContract(client, args),
      verifyMessage: (args) => verifyMessage2(client, args),
      verifySiweMessage: (args) => verifySiweMessage(client, args),
      verifyTypedData: (args) => verifyTypedData2(client, args),
      uninstallFilter: (args) => uninstallFilter(client, args),
      waitForTransactionReceipt: (args) => waitForTransactionReceipt(client, args),
      watchBlocks: (args) => watchBlocks(client, args),
      watchBlockNumber: (args) => watchBlockNumber(client, args),
      watchContractEvent: (args) => watchContractEvent(client, args),
      watchEvent: (args) => watchEvent(client, args),
      watchPendingTransactions: (args) => watchPendingTransactions(client, args)
    };
  }
  var init_public = __esm({
    "node_modules/viem/_esm/clients/decorators/public.js"() {
      init_getEnsAddress();
      init_getEnsAvatar();
      init_getEnsName();
      init_getEnsResolver();
      init_getEnsText();
      init_call();
      init_createAccessList();
      init_createBlockFilter();
      init_createContractEventFilter();
      init_createEventFilter();
      init_createPendingTransactionFilter();
      init_estimateContractGas();
      init_estimateFeesPerGas();
      init_estimateGas2();
      init_estimateMaxPriorityFeePerGas();
      init_getBalance();
      init_getBlobBaseFee();
      init_getBlock();
      init_getBlockNumber();
      init_getBlockTransactionCount();
      init_getChainId();
      init_getCode();
      init_getContractEvents();
      init_getEip712Domain();
      init_getFeeHistory();
      init_getFilterChanges();
      init_getFilterLogs();
      init_getGasPrice();
      init_getLogs();
      init_getProof();
      init_getStorageAt();
      init_getTransaction();
      init_getTransactionConfirmations();
      init_getTransactionCount();
      init_getTransactionReceipt();
      init_multicall();
      init_readContract();
      init_simulateBlocks();
      init_simulateCalls();
      init_simulateContract();
      init_uninstallFilter();
      init_verifyMessage();
      init_verifyTypedData();
      init_waitForTransactionReceipt();
      init_watchBlockNumber();
      init_watchBlocks();
      init_watchContractEvent();
      init_watchEvent();
      init_watchPendingTransactions();
      init_verifySiweMessage();
      init_prepareTransactionRequest();
      init_sendRawTransaction();
    }
  });

  // node_modules/viem/_esm/clients/createPublicClient.js
  function createPublicClient(parameters) {
    const { key = "public", name = "Public Client" } = parameters;
    const client = createClient({
      ...parameters,
      key,
      name,
      type: "publicClient"
    });
    return client.extend(publicActions);
  }
  var init_createPublicClient = __esm({
    "node_modules/viem/_esm/clients/createPublicClient.js"() {
      init_createClient();
      init_public();
    }
  });

  // node_modules/viem/_esm/actions/wallet/addChain.js
  async function addChain(client, { chain }) {
    const { id: id2, name, nativeCurrency, rpcUrls, blockExplorers } = chain;
    await client.request({
      method: "wallet_addEthereumChain",
      params: [
        {
          chainId: numberToHex(id2),
          chainName: name,
          nativeCurrency,
          rpcUrls: rpcUrls.default.http,
          blockExplorerUrls: blockExplorers ? Object.values(blockExplorers).map(({ url }) => url) : void 0
        }
      ]
    }, { dedupe: true, retryCount: 0 });
  }
  var init_addChain = __esm({
    "node_modules/viem/_esm/actions/wallet/addChain.js"() {
      init_toHex();
    }
  });

  // node_modules/viem/_esm/actions/wallet/deployContract.js
  function deployContract(walletClient, parameters) {
    const { abi: abi2, args, bytecode, ...request } = parameters;
    const calldata = encodeDeployData({ abi: abi2, args, bytecode });
    return sendTransaction(walletClient, {
      ...request,
      ...request.authorizationList ? { to: null } : {},
      data: calldata
    });
  }
  var init_deployContract = __esm({
    "node_modules/viem/_esm/actions/wallet/deployContract.js"() {
      init_encodeDeployData();
      init_sendTransaction();
    }
  });

  // node_modules/viem/_esm/actions/wallet/getAddresses.js
  async function getAddresses(client) {
    if (client.account?.type === "local")
      return [client.account.address];
    const addresses = await client.request({ method: "eth_accounts" }, { dedupe: true });
    return addresses.map((address) => checksumAddress(address));
  }
  var init_getAddresses = __esm({
    "node_modules/viem/_esm/actions/wallet/getAddresses.js"() {
      init_getAddress();
    }
  });

  // node_modules/viem/_esm/actions/wallet/getCapabilities.js
  async function getCapabilities(client, parameters = {}) {
    const { account = client.account, chainId } = parameters;
    const account_ = account ? parseAccount(account) : void 0;
    const params = chainId ? [account_?.address, [numberToHex(chainId)]] : [account_?.address];
    const capabilities_raw = await client.request({
      method: "wallet_getCapabilities",
      params
    });
    const capabilities = {};
    for (const [chainId2, capabilities_] of Object.entries(capabilities_raw)) {
      capabilities[Number(chainId2)] = {};
      for (let [key, value] of Object.entries(capabilities_)) {
        if (key === "addSubAccount")
          key = "unstable_addSubAccount";
        capabilities[Number(chainId2)][key] = value;
      }
    }
    return typeof chainId === "number" ? capabilities[chainId] : capabilities;
  }
  var init_getCapabilities = __esm({
    "node_modules/viem/_esm/actions/wallet/getCapabilities.js"() {
      init_parseAccount();
      init_toHex();
    }
  });

  // node_modules/viem/_esm/actions/wallet/getPermissions.js
  async function getPermissions(client) {
    const permissions = await client.request({ method: "wallet_getPermissions" }, { dedupe: true });
    return permissions;
  }
  var init_getPermissions = __esm({
    "node_modules/viem/_esm/actions/wallet/getPermissions.js"() {
    }
  });

  // node_modules/viem/_esm/actions/wallet/prepareAuthorization.js
  async function prepareAuthorization(client, parameters) {
    const { account: account_ = client.account, chainId, nonce } = parameters;
    if (!account_)
      throw new AccountNotFoundError({
        docsPath: "/docs/eip7702/prepareAuthorization"
      });
    const account = parseAccount(account_);
    const executor = (() => {
      if (!parameters.executor)
        return void 0;
      if (parameters.executor === "self")
        return parameters.executor;
      return parseAccount(parameters.executor);
    })();
    const authorization = {
      address: parameters.contractAddress ?? parameters.address,
      chainId,
      nonce
    };
    if (typeof authorization.chainId === "undefined")
      authorization.chainId = client.chain?.id ?? await getAction(client, getChainId, "getChainId")({});
    if (typeof authorization.nonce === "undefined") {
      authorization.nonce = await getAction(client, getTransactionCount, "getTransactionCount")({
        address: account.address,
        blockTag: "pending"
      });
      if (executor === "self" || executor?.address && isAddressEqual(executor.address, account.address))
        authorization.nonce += 1;
    }
    return authorization;
  }
  var init_prepareAuthorization = __esm({
    "node_modules/viem/_esm/actions/wallet/prepareAuthorization.js"() {
      init_parseAccount();
      init_account();
      init_isAddressEqual();
      init_getAction();
      init_getChainId();
      init_getTransactionCount();
    }
  });

  // node_modules/viem/_esm/actions/wallet/requestAddresses.js
  async function requestAddresses(client) {
    const addresses = await client.request({ method: "eth_requestAccounts" }, { dedupe: true, retryCount: 0 });
    return addresses.map((address) => getAddress2(address));
  }
  var init_requestAddresses = __esm({
    "node_modules/viem/_esm/actions/wallet/requestAddresses.js"() {
      init_getAddress();
    }
  });

  // node_modules/viem/_esm/actions/wallet/requestPermissions.js
  async function requestPermissions(client, permissions) {
    return client.request({
      method: "wallet_requestPermissions",
      params: [permissions]
    }, { retryCount: 0 });
  }
  var init_requestPermissions = __esm({
    "node_modules/viem/_esm/actions/wallet/requestPermissions.js"() {
    }
  });

  // node_modules/viem/_esm/actions/wallet/showCallsStatus.js
  async function showCallsStatus(client, parameters) {
    const { id: id2 } = parameters;
    await client.request({
      method: "wallet_showCallsStatus",
      params: [id2]
    });
    return;
  }
  var init_showCallsStatus = __esm({
    "node_modules/viem/_esm/actions/wallet/showCallsStatus.js"() {
    }
  });

  // node_modules/viem/_esm/actions/wallet/signAuthorization.js
  async function signAuthorization(client, parameters) {
    const { account: account_ = client.account } = parameters;
    if (!account_)
      throw new AccountNotFoundError({
        docsPath: "/docs/eip7702/signAuthorization"
      });
    const account = parseAccount(account_);
    if (!account.signAuthorization)
      throw new AccountTypeNotSupportedError({
        docsPath: "/docs/eip7702/signAuthorization",
        metaMessages: [
          "The `signAuthorization` Action does not support JSON-RPC Accounts."
        ],
        type: account.type
      });
    const authorization = await prepareAuthorization(client, parameters);
    return account.signAuthorization(authorization);
  }
  var init_signAuthorization = __esm({
    "node_modules/viem/_esm/actions/wallet/signAuthorization.js"() {
      init_parseAccount();
      init_account();
      init_prepareAuthorization();
    }
  });

  // node_modules/viem/_esm/actions/wallet/signMessage.js
  async function signMessage(client, { account: account_ = client.account, message }) {
    if (!account_)
      throw new AccountNotFoundError({
        docsPath: "/docs/actions/wallet/signMessage"
      });
    const account = parseAccount(account_);
    if (account.signMessage)
      return account.signMessage({ message });
    const message_ = (() => {
      if (typeof message === "string")
        return stringToHex(message);
      if (message.raw instanceof Uint8Array)
        return toHex(message.raw);
      return message.raw;
    })();
    return client.request({
      method: "personal_sign",
      params: [message_, account.address]
    }, { retryCount: 0 });
  }
  var init_signMessage = __esm({
    "node_modules/viem/_esm/actions/wallet/signMessage.js"() {
      init_parseAccount();
      init_account();
      init_toHex();
    }
  });

  // node_modules/viem/_esm/actions/wallet/signTransaction.js
  async function signTransaction(client, parameters) {
    const { account: account_ = client.account, chain = client.chain, ...transaction } = parameters;
    if (!account_)
      throw new AccountNotFoundError({
        docsPath: "/docs/actions/wallet/signTransaction"
      });
    const account = parseAccount(account_);
    assertRequest({
      account,
      ...parameters
    });
    const chainId = await getAction(client, getChainId, "getChainId")({});
    if (chain !== null)
      assertCurrentChain({
        currentChainId: chainId,
        chain
      });
    const formatters2 = chain?.formatters || client.chain?.formatters;
    const format = formatters2?.transactionRequest?.format || formatTransactionRequest;
    if (account.signTransaction)
      return account.signTransaction({
        ...transaction,
        chainId
      }, { serializer: client.chain?.serializers?.transaction });
    return await client.request({
      method: "eth_signTransaction",
      params: [
        {
          ...format(transaction),
          chainId: numberToHex(chainId),
          from: account.address
        }
      ]
    }, { retryCount: 0 });
  }
  var init_signTransaction = __esm({
    "node_modules/viem/_esm/actions/wallet/signTransaction.js"() {
      init_parseAccount();
      init_account();
      init_assertCurrentChain();
      init_toHex();
      init_transactionRequest();
      init_getAction();
      init_assertRequest();
      init_getChainId();
    }
  });

  // node_modules/viem/_esm/actions/wallet/signTypedData.js
  async function signTypedData(client, parameters) {
    const { account: account_ = client.account, domain, message, primaryType } = parameters;
    if (!account_)
      throw new AccountNotFoundError({
        docsPath: "/docs/actions/wallet/signTypedData"
      });
    const account = parseAccount(account_);
    const types = {
      EIP712Domain: getTypesForEIP712Domain({ domain }),
      ...parameters.types
    };
    validateTypedData({ domain, message, primaryType, types });
    if (account.signTypedData)
      return account.signTypedData({ domain, message, primaryType, types });
    const typedData = serializeTypedData({ domain, message, primaryType, types });
    return client.request({
      method: "eth_signTypedData_v4",
      params: [account.address, typedData]
    }, { retryCount: 0 });
  }
  var init_signTypedData = __esm({
    "node_modules/viem/_esm/actions/wallet/signTypedData.js"() {
      init_parseAccount();
      init_account();
      init_typedData2();
    }
  });

  // node_modules/viem/_esm/actions/wallet/switchChain.js
  async function switchChain(client, { id: id2 }) {
    await client.request({
      method: "wallet_switchEthereumChain",
      params: [
        {
          chainId: numberToHex(id2)
        }
      ]
    }, { retryCount: 0 });
  }
  var init_switchChain = __esm({
    "node_modules/viem/_esm/actions/wallet/switchChain.js"() {
      init_toHex();
    }
  });

  // node_modules/viem/_esm/actions/wallet/watchAsset.js
  async function watchAsset(client, params) {
    const added = await client.request({
      method: "wallet_watchAsset",
      params
    }, { retryCount: 0 });
    return added;
  }
  var init_watchAsset = __esm({
    "node_modules/viem/_esm/actions/wallet/watchAsset.js"() {
    }
  });

  // node_modules/viem/_esm/clients/decorators/wallet.js
  function walletActions(client) {
    return {
      addChain: (args) => addChain(client, args),
      deployContract: (args) => deployContract(client, args),
      getAddresses: () => getAddresses(client),
      getCallsStatus: (args) => getCallsStatus(client, args),
      getCapabilities: (args) => getCapabilities(client, args),
      getChainId: () => getChainId(client),
      getPermissions: () => getPermissions(client),
      prepareAuthorization: (args) => prepareAuthorization(client, args),
      prepareTransactionRequest: (args) => prepareTransactionRequest(client, args),
      requestAddresses: () => requestAddresses(client),
      requestPermissions: (args) => requestPermissions(client, args),
      sendCalls: (args) => sendCalls(client, args),
      sendRawTransaction: (args) => sendRawTransaction(client, args),
      sendTransaction: (args) => sendTransaction(client, args),
      showCallsStatus: (args) => showCallsStatus(client, args),
      signAuthorization: (args) => signAuthorization(client, args),
      signMessage: (args) => signMessage(client, args),
      signTransaction: (args) => signTransaction(client, args),
      signTypedData: (args) => signTypedData(client, args),
      switchChain: (args) => switchChain(client, args),
      waitForCallsStatus: (args) => waitForCallsStatus(client, args),
      watchAsset: (args) => watchAsset(client, args),
      writeContract: (args) => writeContract(client, args)
    };
  }
  var init_wallet3 = __esm({
    "node_modules/viem/_esm/clients/decorators/wallet.js"() {
      init_getChainId();
      init_addChain();
      init_deployContract();
      init_getAddresses();
      init_getCallsStatus();
      init_getCapabilities();
      init_getPermissions();
      init_prepareAuthorization();
      init_prepareTransactionRequest();
      init_requestAddresses();
      init_requestPermissions();
      init_sendCalls();
      init_sendRawTransaction();
      init_sendTransaction();
      init_showCallsStatus();
      init_signAuthorization();
      init_signMessage();
      init_signTransaction();
      init_signTypedData();
      init_switchChain();
      init_waitForCallsStatus();
      init_watchAsset();
      init_writeContract();
    }
  });

  // node_modules/viem/_esm/clients/createWalletClient.js
  function createWalletClient(parameters) {
    const { key = "wallet", name = "Wallet Client", transport } = parameters;
    const client = createClient({
      ...parameters,
      key,
      name,
      transport,
      type: "walletClient"
    });
    return client.extend(walletActions);
  }
  var init_createWalletClient = __esm({
    "node_modules/viem/_esm/clients/createWalletClient.js"() {
      init_createClient();
      init_wallet3();
    }
  });

  // node_modules/viem/_esm/index.js
  var init_esm = __esm({
    "node_modules/viem/_esm/index.js"() {
      init_http2();
      init_createPublicClient();
      init_createWalletClient();
      init_encodeFunctionData();
      init_defineChain();
      init_formatUnits();
      init_parseEther();
      init_parseUnits();
    }
  });

  // node_modules/viem/_esm/accounts/toAccount.js
  function toAccount(source) {
    if (typeof source === "string") {
      if (!isAddress2(source, { strict: false }))
        throw new InvalidAddressError({ address: source });
      return {
        address: source,
        type: "json-rpc"
      };
    }
    if (!isAddress2(source.address, { strict: false }))
      throw new InvalidAddressError({ address: source.address });
    return {
      address: source.address,
      nonceManager: source.nonceManager,
      sign: source.sign,
      signAuthorization: source.signAuthorization,
      signMessage: source.signMessage,
      signTransaction: source.signTransaction,
      signTypedData: source.signTypedData,
      source: "custom",
      type: "local"
    };
  }
  var init_toAccount = __esm({
    "node_modules/viem/_esm/accounts/toAccount.js"() {
      init_address5();
      init_isAddress();
    }
  });

  // node_modules/viem/_esm/accounts/utils/sign.js
  async function sign({ hash: hash3, privateKey, to = "object" }) {
    const { r, s, recovery } = secp256k12.sign(hash3.slice(2), privateKey.slice(2), { lowS: true, extraEntropy });
    const signature = {
      r: numberToHex(r, { size: 32 }),
      s: numberToHex(s, { size: 32 }),
      v: recovery ? 28n : 27n,
      yParity: recovery
    };
    return (() => {
      if (to === "bytes" || to === "hex")
        return serializeSignature({ ...signature, to });
      return signature;
    })();
  }
  var extraEntropy;
  var init_sign = __esm({
    "node_modules/viem/_esm/accounts/utils/sign.js"() {
      init_secp256k12();
      init_toHex();
      init_serializeSignature();
      extraEntropy = false;
    }
  });

  // node_modules/viem/_esm/accounts/utils/signAuthorization.js
  async function signAuthorization2(parameters) {
    const { chainId, nonce, privateKey, to = "object" } = parameters;
    const address = parameters.contractAddress ?? parameters.address;
    const signature = await sign({
      hash: hashAuthorization2({ address, chainId, nonce }),
      privateKey,
      to
    });
    if (to === "object")
      return {
        address,
        chainId,
        nonce,
        ...signature
      };
    return signature;
  }
  var init_signAuthorization2 = __esm({
    "node_modules/viem/_esm/accounts/utils/signAuthorization.js"() {
      init_hashAuthorization();
      init_sign();
    }
  });

  // node_modules/viem/_esm/accounts/utils/signMessage.js
  async function signMessage2({ message, privateKey }) {
    return await sign({ hash: hashMessage2(message), privateKey, to: "hex" });
  }
  var init_signMessage2 = __esm({
    "node_modules/viem/_esm/accounts/utils/signMessage.js"() {
      init_hashMessage();
      init_sign();
    }
  });

  // node_modules/viem/_esm/accounts/utils/signTransaction.js
  async function signTransaction2(parameters) {
    const { privateKey, transaction, serializer = serializeTransaction } = parameters;
    const signableTransaction = (() => {
      if (transaction.type === "eip4844")
        return {
          ...transaction,
          sidecars: false
        };
      return transaction;
    })();
    const signature = await sign({
      hash: keccak2562(serializer(signableTransaction)),
      privateKey
    });
    return serializer(transaction, signature);
  }
  var init_signTransaction2 = __esm({
    "node_modules/viem/_esm/accounts/utils/signTransaction.js"() {
      init_keccak256();
      init_serializeTransaction();
      init_sign();
    }
  });

  // node_modules/viem/_esm/accounts/utils/signTypedData.js
  async function signTypedData2(parameters) {
    const { privateKey, ...typedData } = parameters;
    return await sign({
      hash: hashTypedData(typedData),
      privateKey,
      to: "hex"
    });
  }
  var init_signTypedData2 = __esm({
    "node_modules/viem/_esm/accounts/utils/signTypedData.js"() {
      init_hashTypedData();
      init_sign();
    }
  });

  // node_modules/viem/_esm/accounts/privateKeyToAccount.js
  function privateKeyToAccount(privateKey, options = {}) {
    const { nonceManager: nonceManager2 } = options;
    const publicKey = toHex(secp256k12.getPublicKey(privateKey.slice(2), false));
    const address = publicKeyToAddress(publicKey);
    const account = toAccount({
      address,
      nonceManager: nonceManager2,
      async sign({ hash: hash3 }) {
        return sign({ hash: hash3, privateKey, to: "hex" });
      },
      async signAuthorization(authorization) {
        return signAuthorization2({ ...authorization, privateKey });
      },
      async signMessage({ message }) {
        return signMessage2({ message, privateKey });
      },
      async signTransaction(transaction, { serializer } = {}) {
        return signTransaction2({ privateKey, transaction, serializer });
      },
      async signTypedData(typedData) {
        return signTypedData2({ ...typedData, privateKey });
      }
    });
    return {
      ...account,
      publicKey,
      source: "privateKey"
    };
  }
  var init_privateKeyToAccount = __esm({
    "node_modules/viem/_esm/accounts/privateKeyToAccount.js"() {
      init_secp256k12();
      init_toHex();
      init_toAccount();
      init_publicKeyToAddress();
      init_sign();
      init_signAuthorization2();
      init_signMessage2();
      init_signTransaction2();
      init_signTypedData2();
    }
  });

  // node_modules/viem/_esm/accounts/index.js
  var init_accounts = __esm({
    "node_modules/viem/_esm/accounts/index.js"() {
      init_privateKeyToAccount();
      init_nonceManager();
    }
  });

  // node_modules/viem/_esm/op-stack/contracts.js
  var contracts;
  var init_contracts2 = __esm({
    "node_modules/viem/_esm/op-stack/contracts.js"() {
      contracts = {
        gasPriceOracle: { address: "0x420000000000000000000000000000000000000F" },
        l1Block: { address: "0x4200000000000000000000000000000000000015" },
        l2CrossDomainMessenger: {
          address: "0x4200000000000000000000000000000000000007"
        },
        l2Erc721Bridge: { address: "0x4200000000000000000000000000000000000014" },
        l2StandardBridge: { address: "0x4200000000000000000000000000000000000010" },
        l2ToL1MessagePasser: {
          address: "0x4200000000000000000000000000000000000016"
        }
      };
    }
  });

  // node_modules/viem/_esm/op-stack/formatters.js
  var formatters;
  var init_formatters = __esm({
    "node_modules/viem/_esm/op-stack/formatters.js"() {
      init_fromHex();
      init_block2();
      init_transaction4();
      init_transactionReceipt();
      formatters = {
        block: /* @__PURE__ */ defineBlock({
          format(args) {
            const transactions = args.transactions?.map((transaction) => {
              if (typeof transaction === "string")
                return transaction;
              const formatted = formatTransaction(transaction);
              if (formatted.typeHex === "0x7e") {
                formatted.isSystemTx = transaction.isSystemTx;
                formatted.mint = transaction.mint ? hexToBigInt(transaction.mint) : void 0;
                formatted.sourceHash = transaction.sourceHash;
                formatted.type = "deposit";
              }
              return formatted;
            });
            return {
              transactions,
              stateRoot: args.stateRoot
            };
          }
        }),
        transaction: /* @__PURE__ */ defineTransaction({
          format(args) {
            const transaction = {};
            if (args.type === "0x7e") {
              transaction.isSystemTx = args.isSystemTx;
              transaction.mint = args.mint ? hexToBigInt(args.mint) : void 0;
              transaction.sourceHash = args.sourceHash;
              transaction.type = "deposit";
            }
            return transaction;
          }
        }),
        transactionReceipt: /* @__PURE__ */ defineTransactionReceipt({
          format(args) {
            return {
              l1GasPrice: args.l1GasPrice ? hexToBigInt(args.l1GasPrice) : null,
              l1GasUsed: args.l1GasUsed ? hexToBigInt(args.l1GasUsed) : null,
              l1Fee: args.l1Fee ? hexToBigInt(args.l1Fee) : null,
              l1FeeScalar: args.l1FeeScalar ? Number(args.l1FeeScalar) : null
            };
          }
        })
      };
    }
  });

  // node_modules/viem/_esm/op-stack/serializers.js
  function serializeTransaction2(transaction, signature) {
    if (isDeposit(transaction))
      return serializeTransactionDeposit(transaction);
    return serializeTransaction(transaction, signature);
  }
  function serializeTransactionDeposit(transaction) {
    assertTransactionDeposit(transaction);
    const { sourceHash, data, from: from5, gas, isSystemTx, mint, to, value } = transaction;
    const serializedTransaction = [
      sourceHash,
      from5,
      to ?? "0x",
      mint ? toHex(mint) : "0x",
      value ? toHex(value) : "0x",
      gas ? toHex(gas) : "0x",
      isSystemTx ? "0x1" : "0x",
      data ?? "0x"
    ];
    return concatHex([
      "0x7e",
      toRlp(serializedTransaction)
    ]);
  }
  function isDeposit(transaction) {
    if (transaction.type === "deposit")
      return true;
    if (typeof transaction.sourceHash !== "undefined")
      return true;
    return false;
  }
  function assertTransactionDeposit(transaction) {
    const { from: from5, to } = transaction;
    if (from5 && !isAddress2(from5))
      throw new InvalidAddressError({ address: from5 });
    if (to && !isAddress2(to))
      throw new InvalidAddressError({ address: to });
  }
  var serializers;
  var init_serializers = __esm({
    "node_modules/viem/_esm/op-stack/serializers.js"() {
      init_address5();
      init_isAddress();
      init_concat();
      init_toHex();
      init_toRlp();
      init_serializeTransaction();
      serializers = {
        transaction: serializeTransaction2
      };
    }
  });

  // node_modules/viem/_esm/op-stack/chainConfig.js
  var chainConfig;
  var init_chainConfig = __esm({
    "node_modules/viem/_esm/op-stack/chainConfig.js"() {
      init_contracts2();
      init_formatters();
      init_serializers();
      chainConfig = {
        blockTime: 2e3,
        contracts,
        formatters,
        serializers
      };
    }
  });

  // node_modules/viem/_esm/chains/definitions/arbitrumSepolia.js
  var arbitrumSepolia;
  var init_arbitrumSepolia = __esm({
    "node_modules/viem/_esm/chains/definitions/arbitrumSepolia.js"() {
      init_defineChain();
      arbitrumSepolia = /* @__PURE__ */ defineChain({
        id: 421614,
        name: "Arbitrum Sepolia",
        nativeCurrency: {
          name: "Arbitrum Sepolia Ether",
          symbol: "ETH",
          decimals: 18
        },
        rpcUrls: {
          default: {
            http: ["https://sepolia-rollup.arbitrum.io/rpc"]
          }
        },
        blockExplorers: {
          default: {
            name: "Arbiscan",
            url: "https://sepolia.arbiscan.io",
            apiUrl: "https://api-sepolia.arbiscan.io/api"
          }
        },
        contracts: {
          multicall3: {
            address: "0xca11bde05977b3631167028862be2a173976ca11",
            blockCreated: 81930
          }
        },
        testnet: true
      });
    }
  });

  // node_modules/viem/_esm/chains/definitions/avalancheFuji.js
  var avalancheFuji;
  var init_avalancheFuji = __esm({
    "node_modules/viem/_esm/chains/definitions/avalancheFuji.js"() {
      init_defineChain();
      avalancheFuji = /* @__PURE__ */ defineChain({
        id: 43113,
        name: "Avalanche Fuji",
        nativeCurrency: {
          decimals: 18,
          name: "Avalanche Fuji",
          symbol: "AVAX"
        },
        rpcUrls: {
          default: { http: ["https://api.avax-test.network/ext/bc/C/rpc"] }
        },
        blockExplorers: {
          default: {
            name: "SnowTrace",
            url: "https://testnet.snowtrace.io",
            apiUrl: "https://api-testnet.snowtrace.io"
          }
        },
        contracts: {
          multicall3: {
            address: "0xca11bde05977b3631167028862be2a173976ca11",
            blockCreated: 7096959
          }
        },
        testnet: true
      });
    }
  });

  // node_modules/viem/_esm/chains/definitions/baseSepolia.js
  var sourceId, baseSepolia;
  var init_baseSepolia = __esm({
    "node_modules/viem/_esm/chains/definitions/baseSepolia.js"() {
      init_chainConfig();
      init_defineChain();
      sourceId = 11155111;
      baseSepolia = /* @__PURE__ */ defineChain({
        ...chainConfig,
        id: 84532,
        network: "base-sepolia",
        name: "Base Sepolia",
        nativeCurrency: { name: "Sepolia Ether", symbol: "ETH", decimals: 18 },
        rpcUrls: {
          default: {
            http: ["https://sepolia.base.org"]
          }
        },
        blockExplorers: {
          default: {
            name: "Basescan",
            url: "https://sepolia.basescan.org",
            apiUrl: "https://api-sepolia.basescan.org/api"
          }
        },
        contracts: {
          ...chainConfig.contracts,
          disputeGameFactory: {
            [sourceId]: {
              address: "0xd6E6dBf4F7EA0ac412fD8b65ED297e64BB7a06E1"
            }
          },
          l2OutputOracle: {
            [sourceId]: {
              address: "0x84457ca9D0163FbC4bbfe4Dfbb20ba46e48DF254"
            }
          },
          portal: {
            [sourceId]: {
              address: "0x49f53e41452c74589e85ca1677426ba426459e85",
              blockCreated: 4446677
            }
          },
          l1StandardBridge: {
            [sourceId]: {
              address: "0xfd0Bf71F60660E2f608ed56e1659C450eB113120",
              blockCreated: 4446677
            }
          },
          multicall3: {
            address: "0xca11bde05977b3631167028862be2a173976ca11",
            blockCreated: 1059647
          }
        },
        testnet: true,
        sourceId
      });
    }
  });

  // node_modules/viem/_esm/chains/definitions/polygonAmoy.js
  var polygonAmoy;
  var init_polygonAmoy = __esm({
    "node_modules/viem/_esm/chains/definitions/polygonAmoy.js"() {
      init_defineChain();
      polygonAmoy = /* @__PURE__ */ defineChain({
        id: 80002,
        name: "Polygon Amoy",
        nativeCurrency: { name: "POL", symbol: "POL", decimals: 18 },
        rpcUrls: {
          default: {
            http: ["https://rpc-amoy.polygon.technology"]
          }
        },
        blockExplorers: {
          default: {
            name: "PolygonScan",
            url: "https://amoy.polygonscan.com",
            apiUrl: "https://api-amoy.polygonscan.com/api"
          }
        },
        contracts: {
          multicall3: {
            address: "0xca11bde05977b3631167028862be2a173976ca11",
            blockCreated: 3127388
          }
        },
        testnet: true
      });
    }
  });

  // node_modules/viem/_esm/chains/definitions/sepolia.js
  var sepolia;
  var init_sepolia = __esm({
    "node_modules/viem/_esm/chains/definitions/sepolia.js"() {
      init_defineChain();
      sepolia = /* @__PURE__ */ defineChain({
        id: 11155111,
        name: "Sepolia",
        nativeCurrency: { name: "Sepolia Ether", symbol: "ETH", decimals: 18 },
        rpcUrls: {
          default: {
            http: ["https://sepolia.drpc.org"]
          }
        },
        blockExplorers: {
          default: {
            name: "Etherscan",
            url: "https://sepolia.etherscan.io",
            apiUrl: "https://api-sepolia.etherscan.io/api"
          }
        },
        contracts: {
          multicall3: {
            address: "0xca11bde05977b3631167028862be2a173976ca11",
            blockCreated: 751532
          },
          ensRegistry: { address: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e" },
          ensUniversalResolver: {
            address: "0xc8Af999e38273D658BE1b921b88A9Ddf005769cC",
            blockCreated: 5317080
          }
        },
        testnet: true
      });
    }
  });

  // node_modules/viem/_esm/chains/index.js
  var init_chains = __esm({
    "node_modules/viem/_esm/chains/index.js"() {
      init_arbitrumSepolia();
      init_avalancheFuji();
      init_baseSepolia();
      init_polygonAmoy();
      init_sepolia();
    }
  });

  // src/lib/ccipChains.ts
  var CCIP_CHAIN_SELECTORS, CCIP_ROUTER_ADDRESSES, CCIP_BNM_ADDRESSES, CCIP_USDC_ADDRESSES, CCIP_CHAIN_ID_TO_NAME, TOKEN_TRANSFEROR_ADDRESSES;
  var init_ccipChains = __esm({
    "src/lib/ccipChains.ts"() {
      "use strict";
      CCIP_CHAIN_SELECTORS = {
        [11155111 /* ETH_SEPOLIA */]: "16015286601757825753",
        [43113 /* AVAX_FUJI */]: "14767482510784806043",
        [84532 /* BASE_SEPOLIA */]: "10344971235874465080",
        [421614 /* ARB_SEPOLIA */]: "3478487238524512106",
        [80002 /* POLYGON_AMOY */]: "16281711391670634445",
        [2021 /* RONIN_SAIGON */]: "13116810400804392105"
      };
      CCIP_ROUTER_ADDRESSES = {
        [11155111 /* ETH_SEPOLIA */]: "0x0BF3dE8c5D3e8A2B34D2BEeB17ABfCeBaf363A59",
        [43113 /* AVAX_FUJI */]: "0xF694E193200268f9a4868e4Aa017A0118C9a8177",
        [84532 /* BASE_SEPOLIA */]: "0xD3b06cEbF099CE7DA4AcCf578aaebFDBd6e88a93",
        [421614 /* ARB_SEPOLIA */]: "0x2a9C5afB0d0e4BAb2BCdaE109EC4b0c4Be15a165",
        [80002 /* POLYGON_AMOY */]: "0x9C32fCB86BF0f4a1A8921a9Fe46de3198bb884B2",
        [2021 /* RONIN_SAIGON */]: "0x5C28C0C131ceD969FF8eacbc4a35B82C74CD7bb4"
        // Ronin Saigon CCIP Router
      };
      CCIP_BNM_ADDRESSES = {
        [11155111 /* ETH_SEPOLIA */]: "0xFd57b4ddBf88a4e07fF4e34C487b99af2Fe82a05",
        [43113 /* AVAX_FUJI */]: "0xD21341536c5cF5EB1bcb58f6723cE26e8D8E90e4",
        [84532 /* BASE_SEPOLIA */]: "0x88A2d74F47a237a62e7A51cdDa67270CE381555e",
        [421614 /* ARB_SEPOLIA */]: "0xA8C0c11bf64AF62CDCA6f93D3769B88BdD7cb93D",
        [80002 /* POLYGON_AMOY */]: "0xcab0EF91Bee323d1A617c0a027eE753aFd6997E4",
        [2021 /* RONIN_SAIGON */]: "0x1a5DB8aC65c7AE4b1BFD3b8cf9A40dF1dce3E33a"
        // Ronin Saigon CCIP-BnM
      };
      CCIP_USDC_ADDRESSES = {
        [11155111 /* ETH_SEPOLIA */]: "0x1c7D4B196Cb0C7B01d743Fbc6116a902379C7238",
        [43113 /* AVAX_FUJI */]: "0x5425890298aed601595a70AB815c96711a31Bc65",
        [84532 /* BASE_SEPOLIA */]: "0x036CbD53842c5426634e7929541eC2318f3dCF7e",
        [421614 /* ARB_SEPOLIA */]: "0x75faf114eafb1BDbe2F0316DF893fd58CE46AA4d",
        [80002 /* POLYGON_AMOY */]: "0x41E94Eb019C0762f9Bfcf9Fb1E58725BfB0e7582",
        [2021 /* RONIN_SAIGON */]: "0x067ea5b8De1D80d8C73E57A23048a11b0Cd8bbfd"
        // Ronin Saigon USDC
      };
      CCIP_CHAIN_ID_TO_NAME = {
        [11155111 /* ETH_SEPOLIA */]: "Ethereum Sepolia",
        [43113 /* AVAX_FUJI */]: "Avalanche Fuji",
        [84532 /* BASE_SEPOLIA */]: "Base Sepolia",
        [421614 /* ARB_SEPOLIA */]: "Arbitrum Sepolia",
        [80002 /* POLYGON_AMOY */]: "Polygon Amoy",
        [2021 /* RONIN_SAIGON */]: "Ronin Saigon"
      };
      TOKEN_TRANSFEROR_ADDRESSES = {
        [11155111 /* ETH_SEPOLIA */]: "0x25B958a21A0204CD56B75e243098F74e589a0C83"
      };
    }
  });

  // src/hooks/useCCIPTransfer.ts
  function useCCIPTransfer() {
    const [currentStep, setCurrentStep] = (0, import_react.useState)("idle");
    const [logs, setLogs] = (0, import_react.useState)([]);
    const [error, setError] = (0, import_react.useState)(null);
    const [messageId, setMessageId] = (0, import_react.useState)(null);
    const DEFAULT_DECIMALS = 6;
    const BNM_DECIMALS = 18;
    const addLog = (message) => setLogs((prev) => [
      ...prev,
      `[${(/* @__PURE__ */ new Date()).toLocaleTimeString()}] ${message}`
    ]);
    const getPublicClient = (chainId) => {
      return createPublicClient({
        chain: chains[chainId],
        transport: http()
      });
    };
    const getClients = (privateKey, chainId) => {
      const account = privateKeyToAccount(`0x${privateKey}`, { nonceManager });
      return createWalletClient({
        chain: chains[chainId],
        transport: http(),
        account
      });
    };
    const getTokenBalance = async (privateKey, chainId, tokenType = "USDC") => {
      const publicClient = getPublicClient(chainId);
      const account = privateKeyToAccount(`0x${privateKey}`, { nonceManager });
      const tokenAddress = tokenType === "USDC" ? CCIP_USDC_ADDRESSES[chainId] : CCIP_BNM_ADDRESSES[chainId];
      const decimals = tokenType === "USDC" ? DEFAULT_DECIMALS : BNM_DECIMALS;
      const balance = await publicClient.readContract({
        address: tokenAddress,
        abi: [
          {
            constant: true,
            inputs: [{ name: "_owner", type: "address" }],
            name: "balanceOf",
            outputs: [{ name: "balance", type: "uint256" }],
            payable: false,
            stateMutability: "view",
            type: "function"
          }
        ],
        functionName: "balanceOf",
        args: [account.address]
      });
      const formattedBalance = formatUnits2(balance, decimals);
      return formattedBalance;
    };
    const approveToken = async (client, sourceChainId, amount, tokenType = "USDC") => {
      setCurrentStep("approving-token");
      addLog(`Approving ${tokenType} transfer...`);
      try {
        const tokenAddress = tokenType === "USDC" ? CCIP_USDC_ADDRESSES[sourceChainId] : CCIP_BNM_ADDRESSES[sourceChainId];
        const spenderAddress = TOKEN_TRANSFEROR_ADDRESSES[sourceChainId];
        const tx = await client.sendTransaction({
          to: tokenAddress,
          data: encodeFunctionData({
            abi: [
              {
                type: "function",
                name: "approve",
                stateMutability: "nonpayable",
                inputs: [
                  { name: "spender", type: "address" },
                  { name: "amount", type: "uint256" }
                ],
                outputs: [{ name: "", type: "bool" }]
              }
            ],
            functionName: "approve",
            args: [spenderAddress, amount]
          })
        });
        addLog(`${tokenType} Approval Tx: ${tx}`);
        return tx;
      } catch (err) {
        setError("Token approval failed");
        throw err;
      }
    };
    const estimateCCIPFees = async (client, sourceChainId, destinationChainId, receiver, amount, tokenType = "USDC") => {
      setCurrentStep("estimating-fees");
      addLog("Estimating CCIP fees...");
      try {
        const destinationSelector = CCIP_CHAIN_SELECTORS[destinationChainId];
        const tokenAddress = tokenType === "USDC" ? CCIP_USDC_ADDRESSES[sourceChainId] : CCIP_BNM_ADDRESSES[sourceChainId];
        const publicClient = getPublicClient(sourceChainId);
        const fees = await publicClient.readContract({
          address: CCIP_ROUTER_ADDRESSES[sourceChainId],
          abi: [
            {
              type: "function",
              name: "getFee",
              stateMutability: "view",
              inputs: [
                { name: "destinationChainSelector", type: "uint64" },
                { name: "message", type: "tuple", components: [
                  { name: "receiver", type: "bytes" },
                  { name: "data", type: "bytes" },
                  { name: "tokenAmounts", type: "tuple[]", components: [
                    { name: "token", type: "address" },
                    { name: "amount", type: "uint256" }
                  ] },
                  { name: "extraArgs", type: "bytes" },
                  { name: "feeToken", type: "address" }
                ] }
              ],
              outputs: [{ name: "fee", type: "uint256" }]
            }
          ],
          functionName: "getFee",
          args: [
            BigInt(destinationSelector),
            {
              receiver: `0x${receiver.slice(2).padStart(64, "0")}`,
              // ABI encode receiver
              data: "0x",
              tokenAmounts: [{
                token: tokenAddress,
                amount
              }],
              extraArgs: "0x97a657c90000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001",
              // Default extraArgs
              feeToken: "0x0000000000000000000000000000000000000000"
              // Native gas
            }
          ]
        });
        addLog(`Estimated CCIP fees: ${formatUnits2(fees, 18)} ETH`);
        return fees;
      } catch (err) {
        setError("Fee estimation failed");
        throw err;
      }
    };
    const transferTokensViaCCIP = async (client, sourceChainId, destinationChainId, receiver, amount, fees, tokenType = "USDC") => {
      setCurrentStep("transferring");
      addLog("Initiating CCIP transfer...");
      try {
        const transferorAddress = TOKEN_TRANSFEROR_ADDRESSES[sourceChainId];
        const destinationSelector = CCIP_CHAIN_SELECTORS[destinationChainId];
        const tokenAddress = tokenType === "USDC" ? CCIP_USDC_ADDRESSES[sourceChainId] : CCIP_BNM_ADDRESSES[sourceChainId];
        const tx = await client.sendTransaction({
          to: transferorAddress,
          value: fees,
          // Pay fees in native gas
          data: encodeFunctionData({
            abi: [
              {
                type: "function",
                name: "transferTokensPayNative",
                stateMutability: "payable",
                inputs: [
                  { name: "_destinationChainSelector", type: "uint64" },
                  { name: "_receiver", type: "address" },
                  { name: "_token", type: "address" },
                  { name: "_amount", type: "uint256" }
                ],
                outputs: [{ name: "messageId", type: "bytes32" }]
              }
            ],
            functionName: "transferTokensPayNative",
            args: [
              BigInt(destinationSelector),
              receiver,
              tokenAddress,
              amount
            ]
          })
        });
        addLog(`CCIP Transfer Tx: ${tx}`);
        return tx;
      } catch (err) {
        setError("CCIP transfer failed");
        throw err;
      }
    };
    const waitForConfirmation = async (txHash, sourceChainId) => {
      setCurrentStep("waiting-confirmation");
      addLog("Waiting for transaction confirmation...");
      try {
        const publicClient = getPublicClient(sourceChainId);
        const receipt = await publicClient.waitForTransactionReceipt({
          hash: txHash
        });
        addLog("Transaction confirmed!");
        if (receipt.logs && receipt.logs.length > 0) {
          const transferEvent = receipt.logs.find(
            (log) => log.topics[0] === "0x17c4de02e47b97f9e8cd5e6c7f8a96baac54e87edfeb1fce426b4d44c4b3f1c5"
            // TokensTransferred event signature
          );
          if (transferEvent && transferEvent.topics[1]) {
            setMessageId(transferEvent.topics[1]);
            addLog(`CCIP Message ID: ${transferEvent.topics[1]}`);
          }
        }
        setCurrentStep("completed");
        return receipt;
      } catch (err) {
        setError("Transaction confirmation failed");
        throw err;
      }
    };
    const executeCCIPTransfer = async (privateKey, sourceChainId, destinationChainId, receiver, amount, tokenType = "USDC") => {
      try {
        setError(null);
        setMessageId(null);
        const decimals = tokenType === "USDC" ? DEFAULT_DECIMALS : BNM_DECIMALS;
        const numericAmount = parseUnits3(amount, decimals);
        const sourceClient = getClients(privateKey, sourceChainId);
        const publicClient = getPublicClient(sourceChainId);
        const nativeBalance = await publicClient.getBalance({
          address: sourceClient.account.address
        });
        const minBalance = parseEther2("0.01");
        if (nativeBalance < minBalance) {
          throw new Error("Insufficient native token for gas fees");
        }
        await approveToken(sourceClient, sourceChainId, numericAmount, tokenType);
        const fees = await estimateCCIPFees(
          sourceClient,
          sourceChainId,
          destinationChainId,
          receiver,
          numericAmount,
          tokenType
        );
        if (nativeBalance < fees) {
          throw new Error(`Insufficient native tokens for CCIP fees. Need ${formatUnits2(fees, 18)} ETH`);
        }
        const txHash = await transferTokensViaCCIP(
          sourceClient,
          sourceChainId,
          destinationChainId,
          receiver,
          numericAmount,
          fees,
          tokenType
        );
        await waitForConfirmation(txHash, sourceChainId);
        addLog("CCIP transfer completed successfully!");
        addLog("Check CCIP Explorer for cross-chain transaction status.");
      } catch (error2) {
        setCurrentStep("error");
        const errorMessage = error2 instanceof Error ? error2.message : "Unknown error";
        setError(errorMessage);
        addLog(`Error: ${errorMessage}`);
      }
    };
    const reset = () => {
      setCurrentStep("idle");
      setLogs([]);
      setError(null);
      setMessageId(null);
    };
    return {
      currentStep,
      logs,
      error,
      messageId,
      executeCCIPTransfer,
      getTokenBalance,
      reset
    };
  }
  var import_react, roninSaigon, chains;
  var init_useCCIPTransfer = __esm({
    "src/hooks/useCCIPTransfer.ts"() {
      "use strict";
      "use client";
      import_react = __toESM(require_react());
      init_esm();
      init_accounts();
      init_chains();
      init_esm();
      init_ccipChains();
      roninSaigon = defineChain({
        id: 2021,
        name: "Ronin Saigon",
        nativeCurrency: {
          decimals: 18,
          name: "RON",
          symbol: "RON"
        },
        rpcUrls: {
          default: {
            http: ["https://saigon-testnet.roninchain.com/rpc"]
          }
        },
        blockExplorers: {
          default: { name: "Ronin Explorer", url: "https://saigon-app.roninchain.com" }
        }
      });
      chains = {
        [11155111 /* ETH_SEPOLIA */]: sepolia,
        [43113 /* AVAX_FUJI */]: avalancheFuji,
        [84532 /* BASE_SEPOLIA */]: baseSepolia,
        [421614 /* ARB_SEPOLIA */]: arbitrumSepolia,
        [80002 /* POLYGON_AMOY */]: polygonAmoy,
        [2021 /* RONIN_SAIGON */]: roninSaigon
      };
    }
  });

  // node_modules/react/cjs/react-jsx-runtime.production.js
  var require_react_jsx_runtime_production = __commonJS({
    "node_modules/react/cjs/react-jsx-runtime.production.js"(exports) {
      "use strict";
      var REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element");
      var REACT_FRAGMENT_TYPE = Symbol.for("react.fragment");
      function jsxProd(type, config, maybeKey) {
        var key = null;
        void 0 !== maybeKey && (key = "" + maybeKey);
        void 0 !== config.key && (key = "" + config.key);
        if ("key" in config) {
          maybeKey = {};
          for (var propName in config)
            "key" !== propName && (maybeKey[propName] = config[propName]);
        } else maybeKey = config;
        config = maybeKey.ref;
        return {
          $$typeof: REACT_ELEMENT_TYPE,
          type,
          key,
          ref: void 0 !== config ? config : null,
          props: maybeKey
        };
      }
      exports.Fragment = REACT_FRAGMENT_TYPE;
      exports.jsx = jsxProd;
      exports.jsxs = jsxProd;
    }
  });

  // node_modules/react/jsx-runtime.js
  var require_jsx_runtime = __commonJS({
    "node_modules/react/jsx-runtime.js"(exports, module) {
      "use strict";
      if (true) {
        module.exports = require_react_jsx_runtime_production();
      } else {
        module.exports = null;
      }
    }
  });

  // src/popup/App.tsx
  var import_react2, import_jsx_runtime, App, App_default;
  var init_App = __esm({
    "src/popup/App.tsx"() {
      "use strict";
      import_react2 = __toESM(require_react());
      init_lib2();
      init_useCCIPTransfer();
      init_ccipChains();
      import_jsx_runtime = __toESM(require_jsx_runtime());
      App = () => {
        const [mnemonic, setMnemonic] = (0, import_react2.useState)("");
        const [walletInfo, setWalletInfo] = (0, import_react2.useState)(null);
        const [pendingTransactions, setPendingTransactions] = (0, import_react2.useState)([]);
        const [isImporting, setIsImporting] = (0, import_react2.useState)(false);
        const [error, setError] = (0, import_react2.useState)("");
        const [addressSpoofing, setAddressSpoofing] = (0, import_react2.useState)(true);
        const [showSessionList, setShowSessionList] = (0, import_react2.useState)(false);
        const [sessionAddresses, setSessionAddresses] = (0, import_react2.useState)([]);
        const [masterBalance, setMasterBalance] = (0, import_react2.useState)("0");
        const [poolBalance, setPoolBalance] = (0, import_react2.useState)("0");
        const [showDepositSuggestion, setShowDepositSuggestion] = (0, import_react2.useState)(false);
        const [showPayUSDC, setShowPayUSDC] = (0, import_react2.useState)(false);
        const [showPaymentOverview, setShowPaymentOverview] = (0, import_react2.useState)(false);
        const [transactionProgress, setTransactionProgress] = (0, import_react2.useState)(null);
        const [paymentForm, setPaymentForm] = (0, import_react2.useState)({
          destinationAddress: "",
          amount: "",
          destinationChain: 11155111 /* ETH_SEPOLIA */,
          tokenType: "USDC"
        });
        const { currentStep, logs, error: transferError, messageId, executeCCIPTransfer, reset } = useCCIPTransfer();
        (0, import_react2.useEffect)(() => {
          loadExistingWallet();
          loadAddressSpoofing();
          loadMasterBalance();
          loadPoolBalance();
          const progressInterval = setInterval(loadTransactionProgress, 1e3);
          return () => clearInterval(progressInterval);
        }, []);
        const loadMasterBalance = async () => {
          try {
            const response = await chrome.runtime.sendMessage({ type: "getMasterBalance" });
            if (response && !response.error) {
              setMasterBalance(response.balance);
            }
          } catch (err) {
            console.error("Error loading master balance:", err);
          }
        };
        const loadPoolBalance = async () => {
          try {
            const response = await chrome.runtime.sendMessage({ type: "getPoolBalance" });
            if (response && !response.error) {
              setPoolBalance(response.balance);
            }
          } catch (err) {
            console.error("Error loading pool balance:", err);
          }
        };
        const loadTransactionProgress = async () => {
          try {
            const response = await chrome.runtime.sendMessage({ type: "getTransactionProgress" });
            if (response && response.progress) {
              setTransactionProgress(response.progress);
            } else {
              setTransactionProgress(null);
            }
          } catch (err) {
            console.error("Error loading transaction progress:", err);
          }
        };
        const depositToPool = async (amount) => {
          try {
            const response = await chrome.runtime.sendMessage({ type: "depositToPool", amount });
            if (response && !response.error) {
              await loadMasterBalance();
              await loadPoolBalance();
              setShowDepositSuggestion(false);
              return response;
            } else {
              throw new Error(response.error || "Deposit failed");
            }
          } catch (err) {
            console.error("Error depositing to pool:", err);
            throw err;
          }
        };
        const loadAddressSpoofing = async () => {
          try {
            const result = await chrome.storage.local.get(["addressSpoofing"]);
            setAddressSpoofing(result.addressSpoofing || true);
          } catch (err) {
            console.error("Error loading address spoofing setting:", err);
          }
        };
        const toggleAddressSpoofing = async () => {
          const newValue = !addressSpoofing;
          setAddressSpoofing(newValue);
          try {
            await chrome.storage.local.set({ addressSpoofing: newValue });
            console.log("Address spoofing set to:", newValue);
          } catch (err) {
            console.error("Error saving address spoofing setting:", err);
          }
        };
        const loadSessionAddresses = async () => {
          try {
            const response = await chrome.runtime.sendMessage({ type: "getAllSessions" });
            if (response && !response.error) {
              setSessionAddresses(response);
            }
          } catch (err) {
            console.error("Error loading session addresses:", err);
          }
        };
        const switchToSession = async (sessionNumber) => {
          try {
            const response = await chrome.runtime.sendMessage({
              type: "switchToSession",
              sessionNumber
            });
            if (response && !response.error) {
              await loadExistingWallet();
              await loadSessionAddresses();
              setShowSessionList(false);
            }
          } catch (err) {
            console.error("Error switching session:", err);
          }
        };
        const openEtherscan = (address) => {
          const etherscanUrl = `https://sepolia.etherscan.io/address/${address}`;
          chrome.tabs.create({ url: etherscanUrl });
        };
        const loadExistingWallet = async () => {
          try {
            const response = await chrome.runtime.sendMessage({ type: "getWalletInfo" });
            if (response && !response.error) {
              setWalletInfo(response);
              loadMasterBalance();
            }
            await loadPendingTransactions();
          } catch (err) {
            console.error("Error loading wallet:", err);
          }
        };
        const loadPendingTransactions = async () => {
          try {
            const response = await chrome.runtime.sendMessage({ type: "getPendingTransactions" });
            if (response && Array.isArray(response)) {
              setPendingTransactions(response);
            }
          } catch (err) {
            console.error("Error loading pending transactions:", err);
          }
        };
        const approveTransaction = async (txId) => {
          try {
            console.log("\u{1F680} Popup: Approving transaction:", txId);
            const response = await chrome.runtime.sendMessage({ type: "approveTransaction", txId });
            console.log("\u{1F4E8} Popup: Response from background:", response);
            await loadPendingTransactions();
          } catch (err) {
            console.error("Error approving transaction:", err);
          }
        };
        const rejectTransaction = async (txId) => {
          try {
            await chrome.runtime.sendMessage({ type: "rejectTransaction", txId });
            await loadPendingTransactions();
          } catch (err) {
            console.error("Error rejecting transaction:", err);
          }
        };
        const importWallet = async () => {
          if (!mnemonic.trim()) {
            setError("Please enter a seed phrase");
            return;
          }
          setIsImporting(true);
          setError("");
          try {
            const response = await chrome.runtime.sendMessage({
              type: "importWallet",
              seedPhrase: mnemonic.trim()
            });
            if (response.error) {
              setError(response.error);
            } else {
              setWalletInfo({
                masterAddress: response.masterAddress,
                currentSessionAddress: null,
                sessionCount: 0
              });
              setMnemonic("");
              setError("");
              const masterBalanceResponse = await chrome.runtime.sendMessage({ type: "getMasterBalance" });
              const poolBalanceResponse = await chrome.runtime.sendMessage({ type: "getPoolBalance" });
              if (masterBalanceResponse && !masterBalanceResponse.error) {
                setMasterBalance(masterBalanceResponse.balance);
              }
              if (poolBalanceResponse && !poolBalanceResponse.error) {
                setPoolBalance(poolBalanceResponse.balance);
              }
              const poolBalanceNum = parseFloat(poolBalanceResponse?.balance || "0");
              const masterBalanceNum = parseFloat(masterBalanceResponse?.balance || "0");
              if (poolBalanceNum === 0 && masterBalanceNum > 0) {
                setShowDepositSuggestion(true);
              }
            }
          } catch (err) {
            setError("Invalid seed phrase");
          } finally {
            setIsImporting(false);
          }
        };
        const clearWallet = async () => {
          try {
            await chrome.storage.local.remove(["seedPhrase", "sessionCounter"]);
            setWalletInfo(null);
            setMnemonic("");
            setError("");
          } catch (err) {
            console.error("Error clearing wallet:", err);
          }
        };
        return /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", { style: {
          padding: "20px",
          width: "350px",
          minHeight: "400px",
          fontFamily: "Arial, sans-serif",
          backgroundColor: "white"
        }, children: [
          /* @__PURE__ */ (0, import_jsx_runtime.jsx)("h2", { style: { margin: "0 0 20px 0", color: "#333", textAlign: "center" }, children: "Welcome to PrivacyLinks" }),
          !walletInfo ? /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", { children: [
            /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", { style: { marginBottom: "15px" }, children: [
              /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("label", { style: { display: "flex", alignItems: "center", gap: "6px", marginBottom: "5px", color: "#666" }, children: [
                "Enter 12-word PrivacyPools secret:",
                /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
                  "span",
                  {
                    title: "For the demo, use a 12-word seed phrase with testnet funds",
                    style: {
                      display: "inline-block",
                      width: "16px",
                      height: "16px",
                      backgroundColor: "#007bff",
                      color: "white",
                      borderRadius: "50%",
                      fontSize: "11px",
                      fontWeight: "bold",
                      textAlign: "center",
                      lineHeight: "16px",
                      cursor: "help",
                      userSelect: "none"
                    },
                    children: "?"
                  }
                )
              ] }),
              /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
                "textarea",
                {
                  rows: 3,
                  value: mnemonic,
                  onChange: (e) => setMnemonic(e.target.value),
                  placeholder: "word1 word2 word3 ...",
                  style: {
                    width: "100%",
                    padding: "8px",
                    border: "1px solid #ddd",
                    borderRadius: "4px",
                    fontSize: "14px",
                    resize: "vertical"
                  }
                }
              )
            ] }),
            error && /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", { style: {
              color: "red",
              fontSize: "12px",
              marginBottom: "10px",
              padding: "8px",
              backgroundColor: "#ffebee",
              border: "1px solid #ffcdd2",
              borderRadius: "4px"
            }, children: error }),
            /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
              "button",
              {
                onClick: importWallet,
                disabled: isImporting || !mnemonic.trim(),
                style: {
                  width: "100%",
                  padding: "10px",
                  backgroundColor: isImporting ? "#ccc" : "#007bff",
                  color: "white",
                  border: "none",
                  borderRadius: "4px",
                  cursor: isImporting ? "not-allowed" : "pointer",
                  fontSize: "14px"
                },
                children: isImporting ? "Importing..." : "Import Secret"
              }
            )
          ] }) : /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", { children: [
            /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", { style: {
              marginBottom: "20px",
              padding: "15px",
              backgroundColor: "#f8f9fa",
              border: "1px solid #e9ecef",
              borderRadius: "4px"
            }, children: [
              /* @__PURE__ */ (0, import_jsx_runtime.jsx)("h3", { style: { margin: "0 0 15px 0", color: "#333" }, children: "PrivacyLinks Wallet" }),
              walletInfo.currentSessionAddress && /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", { style: { marginBottom: "15px" }, children: [
                /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", { style: { display: "flex", alignItems: "center", justifyContent: "space-between", marginBottom: "5px" }, children: [
                  /* @__PURE__ */ (0, import_jsx_runtime.jsx)("strong", { style: { color: "#28a745" }, children: "Current Session Address:" }),
                  /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
                    "span",
                    {
                      onClick: () => {
                        setShowSessionList(!showSessionList);
                        if (!showSessionList) {
                          loadSessionAddresses();
                        }
                      },
                      style: {
                        fontSize: "11px",
                        color: "#6c757d",
                        cursor: "pointer",
                        textDecoration: "underline",
                        opacity: 0.8,
                        transition: "opacity 0.2s, color 0.2s"
                      },
                      onMouseEnter: (e) => {
                        e.currentTarget.style.opacity = "1";
                        e.currentTarget.style.color = "#495057";
                      },
                      onMouseLeave: (e) => {
                        e.currentTarget.style.opacity = "0.8";
                        e.currentTarget.style.color = "#6c757d";
                      },
                      children: showSessionList ? "\u25B3 hide" : "\u25BD show all"
                    }
                  )
                ] }),
                /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
                  "div",
                  {
                    onClick: () => {
                      setShowSessionList(!showSessionList);
                      if (!showSessionList) {
                        loadSessionAddresses();
                      }
                    },
                    style: {
                      marginTop: "5px",
                      wordBreak: "break-all",
                      fontSize: "11px",
                      fontFamily: "monospace",
                      color: "#155724",
                      backgroundColor: "#d4edda",
                      padding: "6px",
                      borderRadius: "3px",
                      cursor: "pointer",
                      transition: "background-color 0.2s",
                      border: "1px solid transparent"
                    },
                    onMouseEnter: (e) => {
                      e.currentTarget.style.backgroundColor = "#c3e6cb";
                      e.currentTarget.style.borderColor = "#b1dfbb";
                    },
                    onMouseLeave: (e) => {
                      e.currentTarget.style.backgroundColor = "#d4edda";
                      e.currentTarget.style.borderColor = "transparent";
                    },
                    title: "Click to toggle session list",
                    children: walletInfo.currentSessionAddress
                  }
                ),
                showSessionList && /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", { style: {
                  marginTop: "10px",
                  maxHeight: "200px",
                  overflowY: "auto",
                  border: "1px solid #dee2e6",
                  borderRadius: "4px",
                  backgroundColor: "#f8f9fa"
                }, children: [
                  /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", { style: {
                    padding: "8px",
                    fontSize: "12px",
                    fontWeight: "bold",
                    borderBottom: "1px solid #dee2e6",
                    backgroundColor: "#e9ecef"
                  }, children: "Previous Sessions" }),
                  sessionAddresses.length > 0 ? sessionAddresses.map((session) => /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(
                    "div",
                    {
                      onClick: () => {
                        if (!session.isCurrent) {
                          switchToSession(session.sessionNumber);
                        }
                      },
                      style: {
                        padding: "8px",
                        borderBottom: "1px solid #dee2e6",
                        backgroundColor: session.isCurrent ? "#d4edda" : "transparent",
                        transition: "background-color 0.2s",
                        cursor: session.isCurrent ? "default" : "pointer"
                      },
                      onMouseEnter: (e) => {
                        if (!session.isCurrent) {
                          e.currentTarget.style.backgroundColor = "#e9ecef";
                        }
                      },
                      onMouseLeave: (e) => {
                        if (!session.isCurrent) {
                          e.currentTarget.style.backgroundColor = "transparent";
                        }
                      },
                      children: [
                        /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", { style: {
                          fontSize: "11px",
                          color: "#6c757d",
                          marginBottom: "2px",
                          display: "flex",
                          justifyContent: "space-between",
                          alignItems: "center"
                        }, children: [
                          /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("span", { children: [
                            "Session #",
                            session.sessionNumber,
                            " ",
                            session.isCurrent && "(Current)"
                          ] }),
                          /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", { style: { display: "flex", gap: "8px" }, children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
                            "span",
                            {
                              onClick: (e) => {
                                e.stopPropagation();
                                openEtherscan(session.address);
                              },
                              style: {
                                cursor: "pointer",
                                color: "#007bff",
                                fontSize: "10px",
                                textDecoration: "underline"
                              },
                              title: "View on Etherscan",
                              children: "\u{1F50E}"
                            }
                          ) })
                        ] }),
                        /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
                          "div",
                          {
                            style: {
                              fontSize: "10px",
                              fontFamily: "monospace",
                              wordBreak: "break-all",
                              color: "#495057",
                              padding: "2px",
                              borderRadius: "2px"
                            },
                            title: session.isCurrent ? "Current session" : "Click to switch to this session",
                            children: session.address
                          }
                        )
                      ]
                    },
                    session.sessionNumber
                  )) : /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", { style: { padding: "12px", fontSize: "11px", color: "#6c757d", textAlign: "center" }, children: "No previous sessions found" })
                ] })
              ] }),
              /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", { style: { fontSize: "12px", color: "#6c757d" }, children: [
                "Sessions Generated: ",
                /* @__PURE__ */ (0, import_jsx_runtime.jsx)("strong", { children: walletInfo.sessionCount })
              ] }),
              /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", { style: { fontSize: "12px", color: "#6c757d", marginTop: "5px" }, children: [
                "Pool Balance: ",
                /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("strong", { style: { color: "#007bff" }, children: [
                  poolBalance,
                  " ETH"
                ] })
              ] })
            ] }),
            showDepositSuggestion && /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", { style: {
              marginBottom: "20px",
              padding: "15px",
              backgroundColor: "#e7f3ff",
              border: "2px solid #007bff",
              borderRadius: "8px"
            }, children: [
              /* @__PURE__ */ (0, import_jsx_runtime.jsx)("h4", { style: { margin: "0 0 10px 0", color: "#0056b3", fontSize: "14px" }, children: "\u{1F4B0} Deposit Suggestion" }),
              /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("p", { style: { fontSize: "12px", color: "#0056b3", margin: "0 0 15px 0" }, children: [
                "To enable secure transactions, consider depositing some of your balance (",
                (parseFloat(masterBalance) * 0.5).toFixed(4),
                " ETH) to the Pool contract."
              ] }),
              /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", { style: { display: "flex", gap: "8px" }, children: [
                /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
                  "button",
                  {
                    onClick: () => setShowDepositSuggestion(false),
                    style: {
                      flex: 1,
                      padding: "8px 12px",
                      backgroundColor: "#6c757d",
                      color: "white",
                      border: "none",
                      borderRadius: "4px",
                      cursor: "pointer",
                      fontSize: "12px"
                    },
                    children: "Maybe Later"
                  }
                ),
                /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(
                  "button",
                  {
                    onClick: async () => {
                      try {
                        const depositAmount = (parseFloat(masterBalance) * 0.5).toFixed(4);
                        await depositToPool(depositAmount);
                      } catch (error2) {
                        console.error("Deposit failed:", error2);
                        setError("Deposit failed. Please try again.");
                      }
                    },
                    style: {
                      flex: 2,
                      padding: "8px 12px",
                      backgroundColor: "#007bff",
                      color: "white",
                      border: "none",
                      borderRadius: "4px",
                      cursor: "pointer",
                      fontSize: "12px",
                      fontWeight: "600"
                    },
                    children: [
                      "Deposit (",
                      (parseFloat(masterBalance) * 0.5).toFixed(4),
                      " ETH)"
                    ]
                  }
                )
              ] })
            ] }),
            /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", { style: {
              marginBottom: "20px",
              textAlign: "center"
            }, children: !showPayUSDC ? /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(
              "button",
              {
                onClick: () => setShowPayUSDC(true),
                style: {
                  padding: "12px 24px",
                  backgroundColor: "#2775ca",
                  color: "white",
                  border: "none",
                  borderRadius: "8px",
                  cursor: "pointer",
                  fontSize: "14px",
                  fontWeight: "600",
                  display: "flex",
                  alignItems: "center",
                  gap: "8px",
                  margin: "0 auto",
                  boxShadow: "0 2px 8px rgba(39, 117, 202, 0.3)",
                  transition: "all 0.2s ease"
                },
                onMouseEnter: (e) => {
                  e.currentTarget.style.backgroundColor = "#1e5a96";
                  e.currentTarget.style.transform = "translateY(-1px)";
                  e.currentTarget.style.boxShadow = "0 4px 12px rgba(39, 117, 202, 0.4)";
                },
                onMouseLeave: (e) => {
                  e.currentTarget.style.backgroundColor = "#2775ca";
                  e.currentTarget.style.transform = "translateY(0px)";
                  e.currentTarget.style.boxShadow = "0 2px 8px rgba(39, 117, 202, 0.3)";
                },
                children: [
                  /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
                    "img",
                    {
                      src: "usdc-logo.png",
                      alt: "USDC",
                      style: {
                        width: "20px",
                        height: "20px",
                        borderRadius: "50%"
                      }
                    }
                  ),
                  "Pay"
                ]
              }
            ) : /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", { style: {
              padding: "20px",
              backgroundColor: "#f8f9fa",
              border: "1px solid #e9ecef",
              borderRadius: "8px",
              textAlign: "left"
            }, children: [
              /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", { style: {
                display: "flex",
                justifyContent: "space-between",
                alignItems: "center",
                marginBottom: "15px"
              }, children: [
                /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("h4", { style: {
                  margin: 0,
                  color: "#333",
                  fontSize: "14px",
                  display: "flex",
                  alignItems: "center",
                  gap: "6px"
                }, children: [
                  /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
                    "img",
                    {
                      src: "usdc-logo.png",
                      alt: "USDC",
                      style: {
                        width: "16px",
                        height: "16px",
                        borderRadius: "50%"
                      }
                    }
                  ),
                  "Pay"
                ] }),
                /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
                  "span",
                  {
                    onClick: () => setShowPayUSDC(false),
                    style: {
                      cursor: "pointer",
                      color: "#6c757d",
                      fontSize: "18px",
                      lineHeight: "1"
                    },
                    children: "\xD7"
                  }
                )
              ] }),
              /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", { style: { marginBottom: "12px" }, children: [
                /* @__PURE__ */ (0, import_jsx_runtime.jsx)("label", { style: {
                  display: "block",
                  marginBottom: "4px",
                  fontSize: "12px",
                  color: "#666",
                  fontWeight: "500"
                }, children: "Token Type" }),
                /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(
                  "select",
                  {
                    value: paymentForm.tokenType,
                    onChange: (e) => setPaymentForm({
                      ...paymentForm,
                      tokenType: e.target.value
                    }),
                    style: {
                      width: "100%",
                      padding: "8px 10px",
                      border: "1px solid #ddd",
                      borderRadius: "4px",
                      fontSize: "12px",
                      backgroundColor: "white",
                      boxSizing: "border-box"
                    },
                    children: [
                      /* @__PURE__ */ (0, import_jsx_runtime.jsx)("option", { value: "USDC", children: "USDC" }),
                      /* @__PURE__ */ (0, import_jsx_runtime.jsx)("option", { value: "CCIP-BnM", children: "CCIP-BnM (Test Token)" })
                    ]
                  }
                )
              ] }),
              /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", { style: { marginBottom: "12px" }, children: [
                /* @__PURE__ */ (0, import_jsx_runtime.jsx)("label", { style: {
                  display: "block",
                  marginBottom: "4px",
                  fontSize: "12px",
                  color: "#666",
                  fontWeight: "500"
                }, children: "Destination Address" }),
                /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
                  "input",
                  {
                    type: "text",
                    value: paymentForm.destinationAddress,
                    onChange: (e) => setPaymentForm({
                      ...paymentForm,
                      destinationAddress: e.target.value
                    }),
                    placeholder: "0x1234...",
                    style: {
                      width: "100%",
                      padding: "8px 10px",
                      border: "1px solid #ddd",
                      borderRadius: "4px",
                      fontSize: "12px",
                      fontFamily: "monospace",
                      boxSizing: "border-box"
                    }
                  }
                )
              ] }),
              /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", { style: { marginBottom: "12px" }, children: [
                /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("label", { style: {
                  display: "block",
                  marginBottom: "4px",
                  fontSize: "12px",
                  color: "#666",
                  fontWeight: "500"
                }, children: [
                  "Amount (",
                  paymentForm.tokenType,
                  ")"
                ] }),
                /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
                  "input",
                  {
                    type: "number",
                    value: paymentForm.amount,
                    onChange: (e) => setPaymentForm({
                      ...paymentForm,
                      amount: e.target.value
                    }),
                    placeholder: "0.00",
                    step: "0.01",
                    min: "0",
                    style: {
                      width: "100%",
                      padding: "8px 10px",
                      border: "1px solid #ddd",
                      borderRadius: "4px",
                      fontSize: "12px",
                      boxSizing: "border-box"
                    }
                  }
                )
              ] }),
              /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", { style: { marginBottom: "15px" }, children: [
                /* @__PURE__ */ (0, import_jsx_runtime.jsx)("label", { style: {
                  display: "block",
                  marginBottom: "4px",
                  fontSize: "12px",
                  color: "#666",
                  fontWeight: "500"
                }, children: "Destination Chain" }),
                /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(
                  "select",
                  {
                    value: paymentForm.destinationChain,
                    onChange: (e) => setPaymentForm({
                      ...paymentForm,
                      destinationChain: parseInt(e.target.value)
                    }),
                    style: {
                      width: "100%",
                      padding: "8px 10px",
                      border: "1px solid #ddd",
                      borderRadius: "4px",
                      fontSize: "12px",
                      backgroundColor: "white",
                      boxSizing: "border-box"
                    },
                    children: [
                      /* @__PURE__ */ (0, import_jsx_runtime.jsx)("option", { value: 11155111 /* ETH_SEPOLIA */, children: "Ethereum Sepolia" }),
                      /* @__PURE__ */ (0, import_jsx_runtime.jsx)("option", { value: 84532 /* BASE_SEPOLIA */, children: "Base Sepolia" }),
                      /* @__PURE__ */ (0, import_jsx_runtime.jsx)("option", { value: 421614 /* ARB_SEPOLIA */, children: "Arbitrum Sepolia" }),
                      /* @__PURE__ */ (0, import_jsx_runtime.jsx)("option", { value: 43113 /* AVAX_FUJI */, children: "Avalanche Fuji" }),
                      /* @__PURE__ */ (0, import_jsx_runtime.jsx)("option", { value: 80002 /* POLYGON_AMOY */, children: "Polygon Amoy" }),
                      /* @__PURE__ */ (0, import_jsx_runtime.jsx)("option", { value: 2021 /* RONIN_SAIGON */, children: "Ronin Saigon" })
                    ]
                  }
                )
              ] }),
              !showPaymentOverview ? /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
                "button",
                {
                  onClick: () => {
                    setShowPaymentOverview(true);
                  },
                  disabled: !paymentForm.destinationAddress || !paymentForm.amount,
                  style: {
                    width: "100%",
                    padding: "10px",
                    backgroundColor: !paymentForm.destinationAddress || !paymentForm.amount ? "#6c757d" : "#007bff",
                    color: "white",
                    border: "none",
                    borderRadius: "4px",
                    cursor: !paymentForm.destinationAddress || !paymentForm.amount ? "not-allowed" : "pointer",
                    fontSize: "13px",
                    fontWeight: "600"
                  },
                  onMouseEnter: (e) => {
                    if (paymentForm.destinationAddress && paymentForm.amount) {
                      e.currentTarget.style.backgroundColor = "#0056b3";
                    }
                  },
                  onMouseLeave: (e) => {
                    if (paymentForm.destinationAddress && paymentForm.amount) {
                      e.currentTarget.style.backgroundColor = "#007bff";
                    }
                  },
                  children: "Overview"
                }
              ) : /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", { children: [
                /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", { style: {
                  backgroundColor: "#e7f3ff",
                  border: "1px solid #bee5eb",
                  borderRadius: "4px",
                  padding: "12px",
                  marginBottom: "12px"
                }, children: [
                  /* @__PURE__ */ (0, import_jsx_runtime.jsx)("h5", { style: { margin: "0 0 8px 0", fontSize: "12px", color: "#0c5460" }, children: "Payment Overview" }),
                  /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", { style: { fontSize: "11px", marginBottom: "4px" }, children: [
                    /* @__PURE__ */ (0, import_jsx_runtime.jsx)("span", { style: { color: "#6c757d" }, children: "To:" }),
                    /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", { style: {
                      fontFamily: "monospace",
                      wordBreak: "break-all",
                      fontSize: "10px",
                      marginTop: "2px"
                    }, children: paymentForm.destinationAddress })
                  ] }),
                  /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", { style: { fontSize: "11px", marginBottom: "4px" }, children: [
                    /* @__PURE__ */ (0, import_jsx_runtime.jsx)("span", { style: { color: "#6c757d" }, children: "Amount:" }),
                    /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("span", { style: { marginLeft: "8px", fontWeight: "600" }, children: [
                      paymentForm.amount,
                      " ",
                      paymentForm.tokenType
                    ] })
                  ] }),
                  /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", { style: { fontSize: "11px", marginBottom: "4px" }, children: [
                    /* @__PURE__ */ (0, import_jsx_runtime.jsx)("span", { style: { color: "#6c757d" }, children: "Chain:" }),
                    /* @__PURE__ */ (0, import_jsx_runtime.jsx)("span", { style: { marginLeft: "8px" }, children: CCIP_CHAIN_ID_TO_NAME[paymentForm.destinationChain] || "Unknown Chain" })
                  ] }),
                  /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", { style: { fontSize: "11px", marginBottom: "0" }, children: [
                    /* @__PURE__ */ (0, import_jsx_runtime.jsx)("span", { style: { color: "#6c757d" }, children: "Estimated Cost:" }),
                    /* @__PURE__ */ (0, import_jsx_runtime.jsx)("span", { style: { marginLeft: "8px", fontWeight: "600", color: "#dc3545" }, children: "~0.0023 ETH" })
                  ] })
                ] }),
                /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", { style: { display: "flex", gap: "8px" }, children: [
                  /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
                    "button",
                    {
                      onClick: () => setShowPaymentOverview(false),
                      style: {
                        flex: 1,
                        padding: "10px",
                        backgroundColor: "#6c757d",
                        color: "white",
                        border: "none",
                        borderRadius: "4px",
                        cursor: "pointer",
                        fontSize: "13px",
                        fontWeight: "600"
                      },
                      onMouseEnter: (e) => {
                        e.currentTarget.style.backgroundColor = "#545b62";
                      },
                      onMouseLeave: (e) => {
                        e.currentTarget.style.backgroundColor = "#6c757d";
                      },
                      children: "Back"
                    }
                  ),
                  /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
                    "button",
                    {
                      onClick: async () => {
                        if (!walletInfo?.currentSessionAddress) {
                          console.error("No session address available");
                          return;
                        }
                        try {
                          const response = await chrome.runtime.sendMessage({ type: "getPrivateKey" });
                          if (response.error) {
                            console.error("Failed to get private key:", response.error);
                            return;
                          }
                          const fundResponse = await chrome.runtime.sendMessage({
                            type: "fundSessionIfNeeded",
                            sessionAddress: walletInfo.currentSessionAddress,
                            requiredAmount: "0.01"
                            // 0.01 ETH
                          });
                          if (fundResponse.error) {
                            console.error("Failed to fund session:", fundResponse.error);
                          }
                          await executeCCIPTransfer(
                            response.privateKey,
                            11155111 /* ETH_SEPOLIA */,
                            // Source chain (assuming current session is on Sepolia)
                            paymentForm.destinationChain,
                            paymentForm.destinationAddress,
                            paymentForm.amount,
                            paymentForm.tokenType
                          );
                        } catch (error2) {
                          console.error("Payment failed:", error2);
                        }
                      },
                      disabled: currentStep !== "idle" && currentStep !== "completed" && currentStep !== "error",
                      style: {
                        flex: 1,
                        padding: "10px",
                        backgroundColor: currentStep !== "idle" && currentStep !== "completed" && currentStep !== "error" ? "#6c757d" : "#28a745",
                        color: "white",
                        border: "none",
                        borderRadius: "4px",
                        cursor: currentStep !== "idle" && currentStep !== "completed" && currentStep !== "error" ? "not-allowed" : "pointer",
                        fontSize: "13px",
                        fontWeight: "600"
                      },
                      onMouseEnter: (e) => {
                        if (currentStep === "idle" || currentStep === "completed" || currentStep === "error") {
                          e.currentTarget.style.backgroundColor = "#218838";
                        }
                      },
                      onMouseLeave: (e) => {
                        if (currentStep === "idle" || currentStep === "completed" || currentStep === "error") {
                          e.currentTarget.style.backgroundColor = "#28a745";
                        }
                      },
                      children: currentStep === "idle" ? "Confirm Payment" : currentStep === "completed" ? "Payment Complete" : currentStep === "error" ? "Retry Payment" : "Processing..."
                    }
                  )
                ] })
              ] }),
              (currentStep !== "idle" || logs.length > 0) && /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", { style: {
                marginTop: "15px",
                padding: "12px",
                backgroundColor: currentStep === "error" ? "#f8d7da" : "#e7f3ff",
                border: `1px solid ${currentStep === "error" ? "#f5c6cb" : "#bee5eb"}`,
                borderRadius: "4px"
              }, children: [
                /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("h5", { style: {
                  margin: "0 0 8px 0",
                  fontSize: "12px",
                  color: currentStep === "error" ? "#721c24" : "#0c5460",
                  display: "flex",
                  justifyContent: "space-between",
                  alignItems: "center"
                }, children: [
                  "Payment Status",
                  (currentStep === "completed" || currentStep === "error") && /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
                    "button",
                    {
                      onClick: () => {
                        reset();
                        setShowPaymentOverview(false);
                      },
                      style: {
                        fontSize: "10px",
                        padding: "2px 6px",
                        backgroundColor: "#6c757d",
                        color: "white",
                        border: "none",
                        borderRadius: "2px",
                        cursor: "pointer"
                      },
                      children: "Clear"
                    }
                  )
                ] }),
                /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", { style: {
                  fontSize: "11px",
                  color: currentStep === "error" ? "#721c24" : "#0c5460",
                  marginBottom: "8px",
                  fontWeight: "600"
                }, children: [
                  "Current Step: ",
                  currentStep === "idle" ? "Ready" : currentStep === "approving-token" ? `Approving ${paymentForm.tokenType}` : currentStep === "estimating-fees" ? "Estimating CCIP Fees" : currentStep === "transferring" ? "Initiating CCIP Transfer" : currentStep === "waiting-confirmation" ? "Waiting for Confirmation" : currentStep === "completed" ? "\u2705 Completed" : currentStep === "error" ? "\u274C Error" : currentStep
                ] }),
                messageId && /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", { style: {
                  fontSize: "10px",
                  color: "#0c5460",
                  backgroundColor: "#e7f3ff",
                  border: "1px solid #bee5eb",
                  padding: "6px",
                  borderRadius: "3px",
                  marginBottom: "8px",
                  wordBreak: "break-all"
                }, children: [
                  /* @__PURE__ */ (0, import_jsx_runtime.jsx)("strong", { children: "CCIP Message ID:" }),
                  /* @__PURE__ */ (0, import_jsx_runtime.jsx)("br", {}),
                  messageId,
                  /* @__PURE__ */ (0, import_jsx_runtime.jsx)("br", {}),
                  /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("small", { children: [
                    "Track on ",
                    /* @__PURE__ */ (0, import_jsx_runtime.jsx)("a", { href: `https://ccip.chain.link/msg/${messageId}`, target: "_blank", rel: "noopener noreferrer", style: { color: "#007bff" }, children: "CCIP Explorer" })
                  ] })
                ] }),
                transferError && /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", { style: {
                  fontSize: "10px",
                  color: "#721c24",
                  backgroundColor: "#f8d7da",
                  border: "1px solid #f5c6cb",
                  padding: "6px",
                  borderRadius: "3px",
                  marginBottom: "8px"
                }, children: [
                  "Error: ",
                  transferError
                ] }),
                logs.length > 0 && /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", { style: {
                  maxHeight: "120px",
                  overflowY: "auto",
                  fontSize: "9px",
                  fontFamily: "monospace",
                  backgroundColor: "rgba(255, 255, 255, 0.7)",
                  padding: "6px",
                  borderRadius: "3px",
                  border: "1px solid rgba(0, 0, 0, 0.1)"
                }, children: logs.map((log, index2) => /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", { style: { marginBottom: "2px", lineHeight: "1.2" }, children: log }, index2)) })
              ] })
            ] }) }),
            transactionProgress && /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", { style: {
              marginBottom: "20px",
              padding: "15px",
              backgroundColor: transactionProgress.status === "error" ? "#f8d7da" : transactionProgress.status === "completed" ? "#d4edda" : "#e7f3ff",
              border: `2px solid ${transactionProgress.status === "error" ? "#dc3545" : transactionProgress.status === "completed" ? "#28a745" : "#007bff"}`,
              borderRadius: "8px"
            }, children: [
              /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("h4", { style: {
                margin: "0 0 10px 0",
                color: transactionProgress.status === "error" ? "#721c24" : transactionProgress.status === "completed" ? "#155724" : "#0056b3",
                fontSize: "14px",
                display: "flex",
                alignItems: "center",
                gap: "8px"
              }, children: [
                transactionProgress.status === "processing" && "\u23F3",
                transactionProgress.status === "completed" && "\u2705",
                transactionProgress.status === "error" && "\u274C",
                "Transaction Progress"
              ] }),
              /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", { style: {
                width: "100%",
                height: "8px",
                backgroundColor: "#e9ecef",
                borderRadius: "4px",
                marginBottom: "10px",
                overflow: "hidden"
              }, children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", { style: {
                width: `${transactionProgress.currentStep / transactionProgress.totalSteps * 100}%`,
                height: "100%",
                backgroundColor: transactionProgress.status === "error" ? "#dc3545" : transactionProgress.status === "completed" ? "#28a745" : "#007bff",
                transition: "width 0.3s ease"
              } }) }),
              /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", { style: { fontSize: "12px", marginBottom: "8px" }, children: [
                /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("strong", { children: [
                  "Step ",
                  transactionProgress.currentStep,
                  "/",
                  transactionProgress.totalSteps,
                  ":"
                ] }),
                " ",
                transactionProgress.stepName
              ] }),
              transactionProgress.txHash && /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", { style: { fontSize: "11px", marginBottom: "8px" }, children: [
                /* @__PURE__ */ (0, import_jsx_runtime.jsx)("strong", { children: "Transaction:" }),
                /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", { style: {
                  fontFamily: "monospace",
                  wordBreak: "break-all",
                  fontSize: "10px",
                  marginTop: "2px"
                }, children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
                  "a",
                  {
                    href: `https://sepolia.etherscan.io/tx/${transactionProgress.txHash}`,
                    target: "_blank",
                    rel: "noopener noreferrer",
                    style: { color: "#007bff", textDecoration: "underline" },
                    children: transactionProgress.txHash
                  }
                ) })
              ] }),
              transactionProgress.error && /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", { style: {
                fontSize: "11px",
                color: "#721c24",
                backgroundColor: "#f8d7da",
                padding: "6px",
                borderRadius: "3px",
                border: "1px solid #f5c6cb"
              }, children: [
                /* @__PURE__ */ (0, import_jsx_runtime.jsx)("strong", { children: "Error:" }),
                " ",
                transactionProgress.error
              ] })
            ] }),
            pendingTransactions.length > 0 && /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", { style: {
              marginBottom: "15px",
              padding: "15px",
              backgroundColor: "#fff3cd",
              border: "2px solid #ff6b35",
              borderRadius: "4px"
            }, children: [
              /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("h4", { style: { margin: "0 0 15px 0", color: "#d63384" }, children: [
                "\u{1F525} Pending Transactions (",
                pendingTransactions.length,
                ")"
              ] }),
              pendingTransactions.map((tx) => /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", { style: {
                marginBottom: "15px",
                padding: "12px",
                backgroundColor: "#ffffff",
                border: "1px solid #dee2e6",
                borderRadius: "4px"
              }, children: [
                /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", { style: { marginBottom: "8px" }, children: [
                  /* @__PURE__ */ (0, import_jsx_runtime.jsx)("strong", { children: "To:" }),
                  /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", { style: { fontSize: "11px", fontFamily: "monospace", wordBreak: "break-all" }, children: tx.txParams.to })
                ] }),
                /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", { style: { marginBottom: "8px" }, children: [
                  /* @__PURE__ */ (0, import_jsx_runtime.jsx)("strong", { children: "Value:" }),
                  " ",
                  tx.txParams.value ? ethers_exports.formatEther(tx.txParams.value) + " ETH" : "0 ETH"
                ] }),
                /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", { style: { marginBottom: "12px", fontSize: "11px", color: "#6c757d" }, children: [
                  "Gas Limit: ",
                  tx.txParams.gasLimit || "Not set"
                ] }),
                /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", { style: { display: "flex", gap: "8px" }, children: [
                  /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
                    "button",
                    {
                      onClick: () => approveTransaction(tx.id),
                      style: {
                        flex: 1,
                        padding: "8px",
                        backgroundColor: "#28a745",
                        color: "white",
                        border: "none",
                        borderRadius: "4px",
                        cursor: "pointer",
                        fontSize: "12px"
                      },
                      children: "\u2705 Approve"
                    }
                  ),
                  /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
                    "button",
                    {
                      onClick: () => rejectTransaction(tx.id),
                      style: {
                        flex: 1,
                        padding: "8px",
                        backgroundColor: "#dc3545",
                        color: "white",
                        border: "none",
                        borderRadius: "4px",
                        cursor: "pointer",
                        fontSize: "12px"
                      },
                      children: "\u274C Reject"
                    }
                  )
                ] })
              ] }, tx.id))
            ] }),
            /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", { style: {
              marginBottom: "15px",
              padding: "12px",
              backgroundColor: "#fff3cd",
              border: "1px solid #ffeaa7",
              borderRadius: "4px"
            }, children: [
              /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("p", { style: { fontSize: "13px", color: "#856404", margin: "0 0 10px 0" }, children: [
                /* @__PURE__ */ (0, import_jsx_runtime.jsx)("strong", { children: "\u{1F504} Fresh Address Mode:" }),
                " Each time you connect to a dApp, a new address will be generated for enhanced privacy."
              ] }),
              /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", { style: { display: "flex", alignItems: "center", gap: "8px" }, children: [
                /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
                  "input",
                  {
                    type: "checkbox",
                    id: "addressSpoofing",
                    checked: addressSpoofing,
                    onChange: toggleAddressSpoofing,
                    style: { cursor: "pointer" }
                  }
                ),
                /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(
                  "label",
                  {
                    htmlFor: "addressSpoofing",
                    style: { fontSize: "12px", color: "#856404", cursor: "pointer" },
                    children: [
                      /* @__PURE__ */ (0, import_jsx_runtime.jsx)("strong", { children: "\u{1F3AD} Address Spoofing:" }),
                      " Show fake rich address to dApps to enable actions."
                    ]
                  }
                )
              ] })
            ] })
          ] }),
          /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", { style: {
            marginTop: "20px",
            padding: "10px",
            backgroundColor: "#e7f3ff",
            border: "1px solid #bee5eb",
            borderRadius: "4px",
            fontSize: "12px",
            color: "#0c5460"
          }, children: [
            /* @__PURE__ */ (0, import_jsx_runtime.jsx)("strong", { children: "Security Notice:" }),
            " This is a Proof of Concept. Do not use with real funds."
          ] }),
          walletInfo && /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", { style: { textAlign: "center", marginTop: "8px" }, children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
            "span",
            {
              onClick: clearWallet,
              style: {
                fontSize: "10px",
                color: "#6c757d",
                cursor: "pointer",
                textDecoration: "underline",
                opacity: 0.7
              },
              onMouseEnter: (e) => {
                e.currentTarget.style.opacity = "1";
                e.currentTarget.style.color = "#dc3545";
              },
              onMouseLeave: (e) => {
                e.currentTarget.style.opacity = "0.7";
                e.currentTarget.style.color = "#6c757d";
              },
              children: "Change secret"
            }
          ) })
        ] });
      };
      App_default = App;
    }
  });

  // src/popup/index.tsx
  var require_popup = __commonJS({
    "src/popup/index.tsx"() {
      var import_client = __toESM(require_client());
      init_App();
      var import_jsx_runtime2 = __toESM(require_jsx_runtime());
      var container = document.getElementById("root");
      if (!container) {
        throw new Error("Root element not found");
      }
      var root = import_client.default.createRoot(container);
      root.render(/* @__PURE__ */ (0, import_jsx_runtime2.jsx)(App_default, {}));
    }
  });
  require_popup();
})();
/*! Bundled license information:

scheduler/cjs/scheduler.production.js:
  (**
   * @license React
   * scheduler.production.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

react/cjs/react.production.js:
  (**
   * @license React
   * react.production.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

react-dom/cjs/react-dom.production.js:
  (**
   * @license React
   * react-dom.production.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

react-dom/cjs/react-dom-client.production.js:
  (**
   * @license React
   * react-dom-client.production.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

@noble/hashes/esm/utils.js:
@noble/hashes/esm/utils.js:
@noble/hashes/esm/utils.js:
  (*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/abstract/utils.js:
@noble/curves/esm/abstract/modular.js:
@noble/curves/esm/abstract/curve.js:
@noble/curves/esm/abstract/weierstrass.js:
@noble/curves/esm/_shortw_utils.js:
@noble/curves/esm/secp256k1.js:
@noble/curves/esm/utils.js:
@noble/curves/esm/abstract/modular.js:
@noble/curves/esm/abstract/curve.js:
@noble/curves/esm/abstract/weierstrass.js:
@noble/curves/esm/_shortw_utils.js:
@noble/curves/esm/secp256k1.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

aes-js/lib.esm/aes.js:
  (*! MIT License. Copyright 2015-2022 Richard Moore <me@ricmoo.com>. See LICENSE.txt. *)

react/cjs/react-jsx-runtime.production.js:
  (**
   * @license React
   * react-jsx-runtime.production.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)
*/
//# sourceMappingURL=popup.js.map
